{"version":3,"sources":["rxjs.js"],"names":["define","require","exports","Object","defineProperty","value","__window","window","__self","self","WorkerGlobalScope","__global","global","_root","root","Error","isFunction","x","isArray","Array","length","isObject","errorObject","e","errorObject_1","tryCatchTarget","tryCatch","fn","apply","this","arguments","tslib_1","UnsubscriptionError","_super","errors","_this","call","err","map","i","toString","join","name","stack","message","__extends","isArray_1","isObject_1","isFunction_1","tryCatch_1","UnsubscriptionError_1","flattenUnsubscriptionErrors","reduce","errs","concat","Subscription","unsubscribe","closed","_parent","_parents","_subscriptions","_unsubscribe","prototype","hasErrors","index","len","remove","trial","sub","push","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","empty","next","error","complete","root_1","Symbol","rxSubscriber","for","$$rxSubscriber","Subscription_1","Observer_1","rxSubscriber_1","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","SafeSubscriber","create","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","Subscriber_1","toSubscriber","nextOrObserver","getSymbolObservable","$$observable","observable","noop","noop_1","pipeFromArray","fns","input","prev","pipe","_i","toSubscriber_1","observable_1","pipe_1","Observable","subscribe","_isScalar","_subscribe","lift","operator","source","sink","_trySubscribe","forEach","PromiseCtor","Rx","config","Promise","resolve","reject","operations","toPromise","ObjectUnsubscribedError","SubjectSubscription","subject","observers","subscriberIndex","Observable_1","ObjectUnsubscribedError_1","SubjectSubscription_1","SubjectSubscriber","Subject","hasError","thrownError","AnonymousSubject","copy","slice","asObservable","Subject_1","AsyncSubject","hasNext","hasCompleted","Action","scheduler","work","schedule","state","delay","Action_1","AsyncAction","pending","id","recycleAsyncId","requestAsyncId","setInterval","flush","clearInterval","undefined","execute","_execute","errored","errorValue","actions","AsyncAction_1","QueueAction","Scheduler","SchedulerAction","now","Date","Scheduler_1","AsyncScheduler","active","scheduled","action","shift","AsyncScheduler_1","QueueScheduler","QueueAction_1","QueueScheduler_1","queue","Notification","kind","hasValue","observe","observer","do","accept","toObservable","of","throw","createNext","undefinedValueNotification","createError","createComplete","completeNotification","Notification_1","observeOn","ObserveOnOperator","ObserveOnSubscriber","dispatch","arg","notification","scheduleMessage","ObserveOnMessage","queue_1","observeOn_1","ReplaySubject","bufferSize","windowTime","Number","POSITIVE_INFINITY","_events","_bufferSize","_windowTime","_getNow","ReplayEvent","_trimBufferThenGetEvents","eventsCount","spliceCount","time","Math","max","BehaviorSubject","_value","get","getValue","enumerable","configurable","refCount","RefCountOperator","connectable","_refCount","refCounter","RefCountSubscriber","connection","connect","sharedConnection","_connection","refCount_1","ConnectableObservable","subjectFactory","_isComplete","getSubject","_subject","ConnectableSubscriber","connectableProto","connectableObservableDescriptor","writable","EmptyError","ArgumentOutOfRangeError","TimeoutError","async","async_1","timeInterval","TimeIntervalOperator","TimeInterval","interval","TimeIntervalSubscriber","lastTime","span","timeInterval_1","project","thisArg","TypeError","MapOperator","MapSubscriber","count","result","map_1","timestamp","Timestamp","SubscriptionLog","subscribedFrame","unsubscribedFrame","SubscriptionLog_1","SubscriptionLoggable","logSubscribedFrame","logUnsubscribedFrame","subscriptionLogs","oldSubscriptionLog","applyMixins","derivedCtor","baseCtors","baseCtor","propertyKeys","getOwnPropertyNames","j","len2","name_1","SubscriptionLoggable_1","applyMixins_1","ColdObservable","messages","scheduleMessages","messagesLength","_a","frame","HotObservable","setup","VirtualTimeScheduler","maxFrames","VirtualAction","frameTimeFactor","sort","sortActions","a","b","ColdObservable_1","HotObservable_1","VirtualTimeScheduler_1","defaultMaxFrame","TestScheduler","assertDeepEqual","hotObservables","coldObservables","flushTests","createTime","marbles","createColdObservable","values","parseMarbles","cold","createHotObservable","materializeInnerObservable","outerFrame","expectObservable","unsubscriptionMarbles","actual","flushTest","ready","unsubscriptionFrame","parseMarblesAsSubscriptions","toBe","expected","expectSubscriptions","actualSubscriptionLogs","marblesArray","readyFlushTests","filter","test","groupStart","subscriptionFrame","c","materializeInnerObservables","testMessages","subIndex","frameOffset","ajaxGet","url","headers","AjaxObservable","method","ajaxPost","body","ajaxDelete","ajaxPut","ajaxPatch","ajaxGetJSON","mapResponse","responseType","parseXhrResponse","xhr","response","JSON","parse","responseText","responseXML","urlOrRequest","request","createXHR","crossDomain","XMLHttpRequest","XDomainRequest","progId","progIds","ActiveXObject","getXMLHttpRequest","withCredentials","timeout","prop","hasOwnProperty","AjaxSubscriber","post","delete","put","patch","getJSON","done","FormData","serializeBody","send","AjaxResponse","_b","user","password","setupEvents","open","setHeaders","contentType","splitIndex","substring","keys","key","encodeURI","stringify","setRequestHeader","xhrTimeout","progressSubscriber","AjaxTimeoutError","xhrReadyStateChange","readyState","status_1","status","AjaxError","ontimeout","upload","xhrProgress_1","onprogress","xhrError_1","onerror","onreadystatechange","abort","originalEvent","ImmediateDefinition","setImmediate","clearImmediate","nextHandle","tasksByHandle","currentlyRunningATask","canUseProcessNextTick","createProcessNextTickSetImmediate","canUsePostMessage","createPostMessageSetImmediate","canUseMessageChannel","createMessageChannelSetImmediate","canUseReadyStateChange","createReadyStateChangeSetImmediate","createSetTimeoutSetImmediate","ci","handle","instance","identify","o","process","Boolean","MessageChannel","document","createElement","postMessage","importScripts","postMessageIsAsynchronous_1","oldOnMessage","onmessage","partiallyApplied","handler","args","Function","addFromSetImmediateArguments","nextTick","runIfPresent","messagePrefix","random","onGlobalMessage","globalMessageHandler","event","data","addEventListener","setTimeout","task","channel","port1","port2","doc","html","documentElement","script","removeChild","appendChild","Immediate","Immediate_1","AsapAction","AsapScheduler","AsapAction_1","AsapScheduler_1","asap","RequestAnimationFrameDefinition","requestAnimationFrame","cancelAnimationFrame","mozRequestAnimationFrame","mozCancelAnimationFrame","webkitRequestAnimationFrame","webkitCancelAnimationFrame","msRequestAnimationFrame","msCancelAnimationFrame","oRequestAnimationFrame","oCancelAnimationFrame","clearTimeout","cb","AnimationFrame","AnimationFrame_1","AnimationFrameAction","AnimationFrameScheduler","AnimationFrameAction_1","AnimationFrameScheduler_1","animationFrame","symbolIteratorPonyfill","iterator","Set_1","Set","Map_1","Map","$$iterator","OuterSubscriber","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","notifyComplete","isArrayLike","isPromise","then","InnerSubscriber","isArrayLike_1","isPromise_1","iterator_1","InnerSubscriber_1","subscribeToResult","outerSubscriber","item","obs","msg","OuterSubscriber_1","subscribeToResult_1","audit","durationSelector","AuditOperator","AuditSubscriber","throttled","duration","innerSubscription","clearThrottle","isNumeric","val","parseFloat","isScheduler","isDate","isNaN","isNumeric_1","isScheduler_1","isDate_1","TimerObservable","dueTime","period","initialDelay","TimerObservable_1","timer","audit_1","timer_1","auditTime","buffer","closingNotifier","BufferOperator","BufferSubscriber","bufferCount","startBufferEvery","BufferCountOperator","subscriberClass","BufferSkipCountSubscriber","BufferCountSubscriber","buffers","dispatchBufferTimeSpanOnly","prevContext","closeContext","openContext","closeAction","bufferTimeSpan","dispatchBufferClose","bufferTime","bufferCreationInterval","maxBufferSize","BufferTimeOperator","BufferTimeSubscriber","Context","contexts","timespanOnly","timeSpanOnlyState","closeState","creationState","filledBufferContext","onBufferFull","bufferToggle","openings","closingSelector","BufferToggleOperator","BufferToggleSubscriber","closeBuffer","openBuffer","trySubscribe","bufferWhen","BufferWhenOperator","BufferWhenSubscriber","subscribing","closingSubscription","catchError","selector","CatchOperator","caught","CatchSubscriber","err2","ScalarObservable","EmptyObservable","ScalarObservable_1","EmptyObservable_1","ArrayObservable","array","pop","ArrayObservable_1","none","combineLatest","observables","CombineLatestOperator","CombineLatestSubscriber","toRespond","unused","oldVal","_tryProject","combineLatest_1","combineAll","dispatchNext","PromiseObservable","promise","IteratorObservable","obj","StringIterator","ArrayIterator","getIterator","return","str","idx","charAt","arr","isFinite","numberIsFinite","valueAsNumber","sign","floor","abs","maxSafeInteger","toLength","pow","ArrayLikeObservable","arrayLike","PromiseObservable_1","IteratorObservable_1","ArrayLikeObservable_1","FromObservable","ish","FromObservable_1","from","mergeMap","resultSelector","concurrent","MergeMapOperator","MergeMapSubscriber","_tryNext","_innerSub","_notifyResultSelector","identity","mergeMap_1","identity_1","mergeAll","mergeAll_1","concatAll","of_1","from_1","concatAll_1","concat_1","concatMap","concatMap_1","concatMapTo","innerObservable","predicate","CountOperator","CountSubscriber","_tryPredicate","debounce","DebounceOperator","DebounceSubscriber","durationSubscription","emitValue","debounceTime","DebounceTimeOperator","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","debouncedNext","defaultIfEmpty","defaultValue","DefaultIfEmptyOperator","DefaultIfEmptySubscriber","isEmpty","delayFor","DelayOperator","DelaySubscriber","delay_1","_schedule","scheduleNotification","DelayMessage","delayWhen","delayDurationSelector","subscriptionDelay","SubscriptionDelayObservable","DelayWhenOperator","DelayWhenSubscriber","completed","delayNotifierSubscriptions","removeSubscription","tryComplete","delayNotifier","tryDelay","subscriptionIdx","notifierSubscription","SubscriptionDelaySubscriber","sourceSubscribed","subscribeToSource","dematerialize","DeMaterializeOperator","DeMaterializeSubscriber","minimalSetImpl","MinimalSet","_values","has","clear","distinct","keySelector","flushes","DistinctOperator","DistinctSubscriber","_useKeySelector","_finalizeNext","distinctUntilChanged","compare","DistinctUntilChangedOperator","DistinctUntilChangedSubscriber","hasKey","y","distinctUntilChanged_1","distinctUntilKeyChanged","ArgumentOutOfRangeError_1","elementAt","ElementAtOperator","ElementAtSubscriber","every","EveryOperator","EverySubscriber","everyValueMatch","exhaust","SwitchFirstOperator","SwitchFirstSubscriber","hasSubscription","exhaustMap","SwitchFirstMapOperator","SwitchFirstMapSubscriber","tryNext","trySelectResult","expand","ExpandOperator","ExpandSubscriber","subscribeToProjection","FilterOperator","FilterSubscriber","finalize","callback","FinallyOperator","FinallySubscriber","find","FindValueOperator","yieldIndex","FindValueSubscriber","find_1","findIndex","EmptyError_1","first","FirstOperator","FirstSubscriber","_emitted","_emit","_tryResultSelector","_emitFinal","MapPolyfill","size","_keys","set","MapPolyfill_1","FastMap","FastMap_1","groupBy","elementSelector","subjectSelector","GroupByOperator","GroupBySubscriber","groups","attemptedToUnsubscribe","_group","element","group","groupedObservable","GroupedObservable","GroupDurationSubscriber","removeGroup","groupSubject","refCountSubscription","InnerRefCountSubscription","ignoreElements","IgnoreElementsOperator","IgnoreElementsSubscriber","IsEmptyOperator","IsEmptySubscriber","last","LastOperator","LastSubscriber","mapTo","MapToOperator","MapToSubscriber","materialize","MaterializeOperator","MaterializeSubscriber","scan","accumulator","seed","hasSeed","ScanOperator","ScanSubscriber","_seed","takeLast","TakeLastOperator","total","TakeLastSubscriber","ring","scan_1","takeLast_1","defaultIfEmpty_1","acc","reduce_1","comparer","mergeStatic","merge","mergeMapTo","MergeMapToOperator","MergeMapToSubscriber","mergeScan","MergeScanOperator","MergeScanSubscriber","min","ConnectableObservable_1","multicast","subjectOrSubjectFactory","MulticastOperator","onErrorResumeNext","nextSources","OnErrorResumeNextOperator","onErrorResumeNextStatic","OnErrorResumeNextSubscriber","subscribeToNextSource","pairwise","PairwiseOperator","PairwiseSubscriber","hasPrev","not","pred","notPred","not_1","filter_1","partition","pluck","properties","props","currentProp","p","plucker","multicast_1","publish","BehaviorSubject_1","publishBehavior","AsyncSubject_1","publishLast","ReplaySubject_1","publishReplay","selectorOrScheduler","race","RaceOperator","RaceSubscriber","hasFirst","race_1","repeat","RepeatOperator","RepeatSubscriber","repeatWhen","notifier","RepeatWhenOperator","RepeatWhenSubscriber","sourceIsBeingSubscribedTo","retries","retriesSubscription","subscribeToRetries","notifications","retry","RetryOperator","RetrySubscriber","retryWhen","RetryWhenOperator","RetryWhenSubscriber","sample","SampleOperator","sampleSubscriber","SampleSubscriber","sampleTime","SampleTimeOperator","SampleTimeSubscriber","sequenceEqual","compareTo","comparor","SequenceEqualOperator","SequenceEqualSubscriber","_oneComplete","SequenceEqualCompareToSubscriber","emit","checkValues","areEqual","nextB","share","shareReplay","isComplete","shareReplayOperator","single","SingleOperator","SingleSubscriber","seenValue","applySingleValue","singleValue","skip","SkipOperator","SkipSubscriber","skipLast","SkipLastOperator","_skipCount","SkipLastSubscriber","_count","_ring","skipCount","currentIndex","oldValue","skipUntil","SkipUntilOperator","SkipUntilSubscriber","isInnerStopped","skipWhile","SkipWhileOperator","SkipWhileSubscriber","skipping","tryCallPredicate","startWith","switchMap","SwitchMapOperator","SwitchMapSubscriber","_tryNotifyNext","switchMap_1","switchAll","switchMapTo","SwitchMapToOperator","SwitchMapToSubscriber","inner","tryResultSelector","take","TakeOperator","TakeSubscriber","takeUntil","TakeUntilOperator","TakeUntilSubscriber","takeWhile","TakeWhileOperator","TakeWhileSubscriber","nextOrComplete","predicateResult","tap","DoOperator","DoSubscriber","safeSubscriber","defaultThrottleConfig","leading","trailing","throttle","ThrottleOperator","ThrottleSubscriber","_leading","_trailing","_hasTrailingValue","_trailingValue","tryDurationSelector","_sendTrailing","throttle_1","throttleTime","ThrottleTimeOperator","ThrottleTimeSubscriber","TimeoutError_1","due","absoluteTimeout","waitFor","TimeoutOperator","errorInstance","TimeoutSubscriber","scheduleTimeout","dispatchTimeout","timeoutWith","withObservable","TimeoutWithOperator","TimeoutWithSubscriber","toArray","windowBoundaries","WindowOperator","windowSubscriber","WindowSubscriber","sourceSubscription","openWindow","prevWindow","newWindow","windowCount","windowSize","startWindowEvery","WindowCountOperator","WindowCountSubscriber","windows","window_1","dispatchWindowClose","closeWindow","windowTimeSpan","windowCreationInterval","maxWindowSize","WindowTimeOperator","WindowTimeSubscriber","CountedSubject","_numberOfNextedValues","timeSpanState","numberOfNextedValues","window_2","windowToggle","WindowToggleOperator","WindowToggleSubscriber","openSubscription","windowWhen","unsubscribeClosingNotification","closingNotification","withLatestFrom","WithLatestFromOperator","WithLatestFromSubscriber","found","zipStatic","ZipOperator","zip","ZipSubscriber","iterators","StaticArrayIterator","StaticIterator","ZipBufferIterator","stillUnsubscribed","notifyInactive","checkIterators","shouldComplete","nextResult","zip_1","zipAll","auditTime_1","buffer_1","bufferCount_1","bufferTime_1","bufferToggle_1","bufferWhen_1","catchError_1","combineAll_1","concatMapTo_1","count_1","debounce_1","debounceTime_1","delayWhen_1","dematerialize_1","distinct_1","distinctUntilKeyChanged_1","elementAt_1","every_1","exhaust_1","exhaustMap_1","expand_1","finalize_1","findIndex_1","first_1","groupBy_1","ignoreElements_1","isEmpty_1","last_1","mapTo_1","materialize_1","max_1","merge_1","mergeMap_2","mergeMapTo_1","mergeScan_1","min_1","onErrorResumeNext_1","pairwise_1","partition_1","pluck_1","publish_1","publishBehavior_1","publishLast_1","publishReplay_1","repeat_1","repeatWhen_1","retry_1","retryWhen_1","sample_1","sampleTime_1","sequenceEqual_1","share_1","shareReplay_1","single_1","skip_1","skipLast_1","skipUntil_1","skipWhile_1","startWith_1","switchAll_1","switchMapTo_1","take_1","takeUntil_1","takeWhile_1","tap_1","throttleTime_1","timeout_1","timeoutWith_1","timestamp_1","toArray_1","windowCount_1","windowTime_1","windowToggle_1","windowWhen_1","withLatestFrom_1","zipAll_1","flatMap","main","BoundCallbackObservable","callbackFunc","func","handlerFn","innerArgs","result_1","result_2","BoundCallbackObservable_1","bindCallback","bindCallback_1","dispatchError","BoundNodeCallbackObservable","BoundNodeCallbackObservable_1","bindNodeCallback","bindNodeCallback_1","DeferObservable","observableFactory","DeferSubscriber","factory","tryDefer","_callFactory","DeferObservable_1","defer","defer_1","empty_1","ForkJoinObservable","sources","ForkJoinSubscriber","haveValues","_hasValue","ForkJoinObservable_1","forkJoin","forkJoin_1","FromEventObservable","sourceObj","eventName","options","target","setupSubscription","isNodeList","isHTMLCollection","removeEventListener","isEventTarget","source_1","on","off","isJQueryStyleEventEmitter","source_2","addListener","removeListener","isNodeStyleEventEmitter","source_3","FromEventObservable_1","fromEvent","fromEvent_1","FromEventPatternObservable","addHandler","removeHandler","_callSelector","retValue","_callAddHandler","errorSubscriber","FromEventPatternObservable_1","fromEventPattern","fromEventPattern_1","fromPromise","fromPromise_1","selfSelector","GenerateObservable","initialState","condition","iterate","initialStateOrOptions","resultSelectorOrObservable","conditionResult","needIterate","GenerateObservable_1","generate","generate_1","IfObservable","thenSource","elseSource","IfSubscriber","tryIf","IfObservable_1","_if","if_1","if","IntervalObservable","IntervalObservable_1","interval_1","merge_2","NeverObservable","NeverObservable_1","never","never_1","PairsObservable","PairsObservable_1","pairs","pairs_1","RangeObservable","start","RangeObservable_1","range","range_1","UsingObservable","resourceFactory","resource","UsingSubscriber","tryUse","UsingObservable_1","using","using_1","ErrorObservable","ErrorObservable_1","_throw","throw_1","AjaxObservable_1","ajax","ajax_1","assignImpl","k","getAssign","assign","assign_1","WebSocketSubject","urlConfigOrSource","WebSocketCtor","WebSocket","_output","sock","_resetState","socket","multiplex","subMsg","unsubMsg","messageFilter","_connectSocket","protocol","binaryType","close","onopen","openObserver","closingObserver","code","reason","onclose","closeObserver","wasClean","WebSocketSubject_1","webSocket","webSocket_1","_catch","catch_1","catch","_do","do_1","_finally","finally_1","finally","letProto","let_1","let","letBind","flatMapTo","race_2","raceStatic","asap_1","SubscribeOnObservable","delayTime","SubscribeOnObservable_1","subscribeOn","SubscribeOnOperator","subscribeOn_1","_switch","switch_1","switch","zipProto","TestScheduler_1","animationFrame_1","_operators","operators"],"mappings":"AAAAA,OAAO,kBAAkB,UAAW,WAAY,SAAUC,EAASC,GAC/D,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItD,IAAIC,EAA6B,oBAAXC,QAA0BA,OAC5CC,EAAyB,oBAATC,MAAqD,oBAAtBC,mBAC/CD,gBAAgBC,mBAAqBD,KACrCE,EAA6B,oBAAXC,QAA0BA,OAC5CC,EAAQP,GAAYK,GAAYH,EACpCN,EAAQY,KAAOD,EAIf,WACI,IAAKA,EACD,MAAM,IAAIE,MAAM,iEAFxB,KAOJf,OAAO,wBAAwB,UAAW,WAAY,SAAUC,EAASC,GACrE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQc,WAHR,SAAoBC,GAChB,MAAoB,mBAANA,KAKtBjB,OAAO,qBAAqB,UAAW,WAAY,SAAUC,EAASC,GAClE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQgB,QAAUC,MAAMD,SAAW,SAAWD,GAAK,OAAOA,GAAyB,iBAAbA,EAAEG,UAG5EpB,OAAO,sBAAsB,UAAW,WAAY,SAAUC,EAASC,GACnE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQmB,SAHR,SAAkBJ,GACd,OAAY,MAALA,GAA0B,iBAANA,KAKnCjB,OAAO,yBAAyB,UAAW,WAAY,SAAUC,EAASC,GACtE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAEtDH,EAAQoB,aAAgBC,QAG5BvB,OAAO,sBAAsB,UAAW,UAAW,iBAAkB,SAAUC,EAASC,EAASsB,GAC7F,aACArB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIoB,EAcJvB,EAAQwB,SAJR,SAAkBC,GAEd,OADAF,EAAiBE,EAVrB,WACI,IACI,OAAOF,EAAeG,MAAMC,KAAMC,WAEtC,MAAOP,GAEH,OADAC,EAAcF,YAAYC,EAAIA,EACvBC,EAAcF,iBAWjCtB,OAAO,iCAAiC,UAAW,UAAW,SAAU,SAAUC,EAASC,EAAS6B,GAChG,aACA5B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAKtD,IAAI2B,EAAqC,SAAUC,GAE/C,SAASD,EAAoBE,GACzB,IAAIC,EAAQF,EAAOG,KAAKP,OAASA,KACjCM,EAAMD,OAASA,EACf,IAAIG,EAAMtB,MAAMqB,KAAKD,EAAOD,EACxBA,EAAOd,OAAS,8CAAgDc,EAAOI,IAAI,SAAUD,EAAKE,GAAK,OAAOA,EAAI,EAAI,KAAOF,EAAIG,aAAeC,KAAK,QAAU,IAI3J,OAHAN,EAAMO,KAAOL,EAAIK,KAAO,sBACxBP,EAAMQ,MAAQN,EAAIM,MAClBR,EAAMS,QAAUP,EAAIO,QACbT,EAEX,OAXAJ,EAAQc,UAAUb,EAAqBC,GAWhCD,EAZ6B,CAatCjB,OACFb,EAAQ8B,oBAAsBA,IAGlChC,OAAO,qBAAqB,UAAW,UAAW,iBAAkB,kBAAmB,oBAAqB,kBAAmB,qBAAsB,8BAA+B,SAAUC,EAASC,EAAS4C,EAAWC,EAAYC,EAAcC,EAAYzB,EAAe0B,GAC5Q,aAwLA,SAASC,EAA4BjB,GACjC,OAAOA,EAAOkB,OAAO,SAAUC,EAAMhB,GAAO,OAAOgB,EAAKC,OAAQjB,aAAea,EAAsBlB,oBAAuBK,EAAIH,OAASG,QAxL7IlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAatD,IAAIkD,EAA8B,WAK9B,SAASA,EAAaC,GAKlB3B,KAAK4B,QAAS,EACd5B,KAAK6B,QAAU,KACf7B,KAAK8B,SAAW,KAChB9B,KAAK+B,eAAiB,KAClBJ,IACA3B,KAAKgC,aAAeL,GAwJ5B,OA/IAD,EAAaO,UAAUN,YAAc,WACjC,IACItB,EADA6B,GAAY,EAEhB,IAAIlC,KAAK4B,OAAT,CAGA,IAAeC,EAAN7B,KAAmB6B,QAASC,EAA5B9B,KAA0C8B,SAAUE,EAApDhC,KAAsEgC,aAAcD,EAApF/B,KAAwG+B,eACjH/B,KAAK4B,QAAS,EACd5B,KAAK6B,QAAU,KACf7B,KAAK8B,SAAW,KAGhB9B,KAAK+B,eAAiB,KAKtB,IAJA,IAAII,GAAS,EACTC,EAAMN,EAAWA,EAASvC,OAAS,EAGhCsC,GACHA,EAAQQ,OAAOrC,MAGf6B,IAAYM,EAAQC,GAAON,EAASK,IAAU,KAElD,GAAIhB,EAAahC,WAAW6C,GAAe,EACnCM,EAAQlB,EAAWvB,SAASmC,GAAczB,KAAKP,SACrCL,EAAcF,cACxByC,GAAY,EACZ7B,EAASA,IAAWV,EAAcF,YAAYC,aAAa2B,EAAsBlB,oBAC7EmB,EAA4B3B,EAAcF,YAAYC,EAAEW,SAAWV,EAAcF,YAAYC,KAGzG,GAAIuB,EAAU5B,QAAQ0C,GAGlB,IAFAI,GAAS,EACTC,EAAML,EAAexC,SACZ4C,EAAQC,GAAK,CAClB,IAAIG,EAAMR,EAAeI,GACzB,GAAIjB,EAAW1B,SAAS+C,GAAM,CAC1B,IAAID,EAAQlB,EAAWvB,SAAS0C,EAAIZ,aAAapB,KAAKgC,GACtD,GAAID,IAAU3C,EAAcF,YAAa,CACrCyC,GAAY,EACZ7B,EAASA,MACT,IAAIG,EAAMb,EAAcF,YAAYC,EAChCc,aAAea,EAAsBlB,oBACrCE,EAASA,EAAOoB,OAAOH,EAA4Bd,EAAIH,SAGvDA,EAAOmC,KAAKhC,KAMhC,GAAI0B,EACA,MAAM,IAAIb,EAAsBlB,oBAAoBE,KAqB5DqB,EAAaO,UAAUQ,IAAM,SAAUC,GACnC,IAAKA,GAAaA,IAAahB,EAAaiB,MACxC,OAAOjB,EAAaiB,MAExB,GAAID,IAAa1C,KACb,OAAOA,KAEX,IAAI4C,EAAeF,EACnB,cAAeA,GACX,IAAK,WACDE,EAAe,IAAIlB,EAAagB,GACpC,IAAK,SACD,GAAIE,EAAahB,QAA8C,mBAA7BgB,EAAajB,YAC3C,OAAOiB,EAEN,GAAI5C,KAAK4B,OAEV,OADAgB,EAAajB,cACNiB,EAEN,GAAuC,mBAA5BA,EAAaC,WAA6C,CACtE,IAAIC,EAAMF,GACVA,EAAe,IAAIlB,GACNK,gBAAkBe,GAEnC,MACJ,QACI,MAAM,IAAI5D,MAAM,yBAA2BwD,EAAW,2BAK9D,OAHoB1C,KAAK+B,iBAAmB/B,KAAK+B,oBACnCS,KAAKI,GACnBA,EAAaC,WAAW7C,MACjB4C,GAQXlB,EAAaO,UAAUI,OAAS,SAAUO,GACtC,IAAIG,EAAgB/C,KAAK+B,eACzB,GAAIgB,EAAe,CACf,IAAIC,EAAoBD,EAAcE,QAAQL,IACnB,IAAvBI,GACAD,EAAcG,OAAOF,EAAmB,KAIpDtB,EAAaO,UAAUY,WAAa,SAAUM,GAC1C,IAAetB,EAAN7B,KAAmB6B,QAASC,EAA5B9B,KAA0C8B,SAC9CD,GAAWA,IAAYsB,EAKlBrB,GAK6B,IAA9BA,EAASmB,QAAQE,IAEtBrB,EAASU,KAAKW,GAJdnD,KAAK8B,UAAYqB,GALjBnD,KAAK6B,QAAUsB,GAYvBzB,EAAaiB,MAAS,SAAUS,GAE5B,OADAA,EAAMxB,QAAS,EACRwB,EAFU,CAGnB,IAAI1B,GACCA,EAvKsB,GAyKjCrD,EAAQqD,aAAeA,IAM3BvD,OAAO,iBAAiB,UAAW,WAAY,SAAUC,EAASC,GAC9D,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ+E,OACJxB,QAAQ,EACRyB,KAAM,SAAU7E,KAChB8E,MAAO,SAAU9C,GAAO,MAAMA,GAC9B+C,SAAU,gBAIlBpF,OAAO,4BAA4B,UAAW,UAAW,gBAAiB,SAAUC,EAASC,EAASmF,GAClG,aACAlF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIiF,EAASD,EAAOvE,KAAKwE,OACzBpF,EAAQqF,aAAkC,mBAAXD,GAA+C,mBAAfA,EAAOE,IAClEF,EAAOE,IAAI,gBAAkB,iBAIjCtF,EAAQuF,eAAiBvF,EAAQqF,eAGrCvF,OAAO,mBAAmB,UAAW,UAAW,QAAS,oBAAqB,iBAAkB,aAAc,yBAA0B,SAAUC,EAASC,EAAS6B,EAASiB,EAAc0C,EAAgBC,EAAYC,GACnN,aACAzF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAWtD,IAAIwF,EAA4B,SAAU5D,GAUtC,SAAS4D,EAAWC,EAAmBX,EAAOC,GAC1C,IAAIjD,EAAQF,EAAOG,KAAKP,OAASA,KAKjC,OAJAM,EAAM4D,eAAiB,KACvB5D,EAAM6D,iBAAkB,EACxB7D,EAAM8D,oBAAqB,EAC3B9D,EAAM+D,WAAY,EACVpE,UAAUV,QACd,KAAK,EACDe,EAAMgE,YAAcR,EAAWV,MAC/B,MACJ,KAAK,EACD,IAAKa,EAAmB,CACpB3D,EAAMgE,YAAcR,EAAWV,MAC/B,MAEJ,GAAiC,iBAAtBa,EAAgC,CACnCA,aAA6BD,GAC7B1D,EAAMgE,YAAcL,EACpB3D,EAAMgE,YAAY7B,IAAInC,KAGtBA,EAAM8D,oBAAqB,EAC3B9D,EAAMgE,YAAc,IAAIC,EAAejE,EAAO2D,IAElD,MAER,QACI3D,EAAM8D,oBAAqB,EAC3B9D,EAAMgE,YAAc,IAAIC,EAAejE,EAAO2D,EAAmBX,EAAOC,GAGhF,OAAOjD,EAqFX,OA7HAJ,EAAQc,UAAUgD,EAAY5D,GA0C9B4D,EAAW/B,UAAU8B,EAAeL,cAAgB,WAAc,OAAO1D,MAYzEgE,EAAWQ,OAAS,SAAUnB,EAAMC,EAAOC,GACvC,IAAIkB,EAAa,IAAIT,EAAWX,EAAMC,EAAOC,GAE7C,OADAkB,EAAWL,oBAAqB,EACzBK,GASXT,EAAW/B,UAAUoB,KAAO,SAAU7E,GAC7BwB,KAAKqE,WACNrE,KAAK0E,MAAMlG,IAUnBwF,EAAW/B,UAAUqB,MAAQ,SAAU9C,GAC9BR,KAAKqE,YACNrE,KAAKqE,WAAY,EACjBrE,KAAK2E,OAAOnE,KASpBwD,EAAW/B,UAAUsB,SAAW,WACvBvD,KAAKqE,YACNrE,KAAKqE,WAAY,EACjBrE,KAAK4E,cAGbZ,EAAW/B,UAAUN,YAAc,WAC3B3B,KAAK4B,SAGT5B,KAAKqE,WAAY,EACjBjE,EAAO6B,UAAUN,YAAYpB,KAAKP,QAEtCgE,EAAW/B,UAAUyC,MAAQ,SAAUlG,GACnCwB,KAAKsE,YAAYjB,KAAK7E,IAE1BwF,EAAW/B,UAAU0C,OAAS,SAAUnE,GACpCR,KAAKsE,YAAYhB,MAAM9C,GACvBR,KAAK2B,eAETqC,EAAW/B,UAAU2C,UAAY,WAC7B5E,KAAKsE,YAAYf,WACjBvD,KAAK2B,eAETqC,EAAW/B,UAAU4C,uBAAyB,WAC1C,IAAehD,EAAN7B,KAAmB6B,QAASC,EAA5B9B,KAA0C8B,SAQnD,OAPA9B,KAAK6B,QAAU,KACf7B,KAAK8B,SAAW,KAChB9B,KAAK2B,cACL3B,KAAK4B,QAAS,EACd5B,KAAKqE,WAAY,EACjBrE,KAAK6B,QAAUA,EACf7B,KAAK8B,SAAWA,EACT9B,MAEJgE,EA9HoB,CA+H7BH,EAAenC,cACjBrD,EAAQ2F,WAAaA,EAMrB,IAAIO,EAAgC,SAAUnE,GAE1C,SAASmE,EAAeO,EAAmBC,EAAgBzB,EAAOC,GAC9D,IAAIjD,EAAQF,EAAOG,KAAKP,OAASA,KACjCM,EAAMwE,kBAAoBA,EAC1B,IAAIzB,EACA2B,EAAU1E,EAoBd,OAnBIa,EAAahC,WAAW4F,GACxB1B,EAAO0B,EAEFA,IACL1B,EAAO0B,EAAe1B,KACtBC,EAAQyB,EAAezB,MACvBC,EAAWwB,EAAexB,SACtBwB,IAAmBjB,EAAWV,QAC9B4B,EAAU1G,OAAOkG,OAAOO,GACpB5D,EAAahC,WAAW6F,EAAQrD,cAChCrB,EAAMmC,IAAIuC,EAAQrD,YAAYsD,KAAKD,IAEvCA,EAAQrD,YAAcrB,EAAMqB,YAAYsD,KAAK3E,KAGrDA,EAAM4E,SAAWF,EACjB1E,EAAMoE,MAAQrB,EACd/C,EAAMqE,OAASrB,EACfhD,EAAMsE,UAAYrB,EACXjD,EAmFX,OA5GAJ,EAAQc,UAAUuD,EAAgBnE,GA2BlCmE,EAAetC,UAAUoB,KAAO,SAAU7E,GACtC,IAAKwB,KAAKqE,WAAarE,KAAK0E,MAAO,CAC/B,IAAII,EAAoB9E,KAAK8E,kBACxBA,EAAkBV,mBAGdpE,KAAKmF,gBAAgBL,EAAmB9E,KAAK0E,MAAOlG,IACzDwB,KAAK2B,cAHL3B,KAAKoF,aAAapF,KAAK0E,MAAOlG,KAO1C+F,EAAetC,UAAUqB,MAAQ,SAAU9C,GACvC,IAAKR,KAAKqE,UAAW,CACjB,IAAIS,EAAoB9E,KAAK8E,kBAC7B,GAAI9E,KAAK2E,OACAG,EAAkBV,oBAKnBpE,KAAKmF,gBAAgBL,EAAmB9E,KAAK2E,OAAQnE,GACrDR,KAAK2B,gBALL3B,KAAKoF,aAAapF,KAAK2E,OAAQnE,GAC/BR,KAAK2B,mBAOR,CAAA,IAAKmD,EAAkBV,mBAExB,MADApE,KAAK2B,cACCnB,EAGNsE,EAAkBZ,eAAiB1D,EACnCsE,EAAkBX,iBAAkB,EACpCnE,KAAK2B,iBAIjB4C,EAAetC,UAAUsB,SAAW,WAChC,IAAIjD,EAAQN,KACZ,IAAKA,KAAKqE,UAAW,CACjB,IAAIS,EAAoB9E,KAAK8E,kBAC7B,GAAI9E,KAAK4E,UAAW,CAChB,IAAIS,EAAkB,WAAc,OAAO/E,EAAMsE,UAAUrE,KAAKD,EAAM4E,WACjEJ,EAAkBV,oBAKnBpE,KAAKmF,gBAAgBL,EAAmBO,GACxCrF,KAAK2B,gBALL3B,KAAKoF,aAAaC,GAClBrF,KAAK2B,oBAQT3B,KAAK2B,gBAIjB4C,EAAetC,UAAUmD,aAAe,SAAUtF,EAAItB,GAClD,IACIsB,EAAGS,KAAKP,KAAKkF,SAAU1G,GAE3B,MAAOgC,GAEH,MADAR,KAAK2B,cACCnB,IAGd+D,EAAetC,UAAUkD,gBAAkB,SAAUhC,EAAQrD,EAAItB,GAC7D,IACIsB,EAAGS,KAAKP,KAAKkF,SAAU1G,GAE3B,MAAOgC,GAGH,OAFA2C,EAAOe,eAAiB1D,EACxB2C,EAAOgB,iBAAkB,GAClB,EAEX,OAAO,GAEXI,EAAetC,UAAUD,aAAe,WACpC,IAAI8C,EAAoB9E,KAAK8E,kBAC7B9E,KAAKkF,SAAW,KAChBlF,KAAK8E,kBAAoB,KACzBA,EAAkBnD,eAEf4C,EA7GwB,CA8GjCP,KAGN7F,OAAO,0BAA0B,UAAW,UAAW,gBAAiB,yBAA0B,eAAgB,SAAUC,EAASC,EAASiH,EAAcvB,EAAgBD,GACxK,aACAxF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAetDH,EAAQkH,aAdR,SAAsBC,EAAgBlC,EAAOC,GACzC,GAAIiC,EAAgB,CAChB,GAAIA,aAA0BF,EAAatB,WACvC,OAAOwB,EAEX,GAAIA,EAAezB,EAAeL,cAC9B,OAAO8B,EAAezB,EAAeL,gBAG7C,OAAK8B,GAAmBlC,GAAUC,EAG3B,IAAI+B,EAAatB,WAAWwB,EAAgBlC,EAAOC,GAF/C,IAAI+B,EAAatB,WAAWF,EAAWV,UAO1DjF,OAAO,0BAA0B,UAAW,UAAW,gBAAiB,SAAUC,EAASC,EAASmF,GAChG,aAEA,SAASiC,EAAoBT,GACzB,IAAIU,EACAjC,EAASuB,EAAQvB,OAarB,MAZsB,mBAAXA,EACHA,EAAOkC,WACPD,EAAejC,EAAOkC,YAGtBD,EAAejC,EAAO,cACtBA,EAAOkC,WAAaD,GAIxBA,EAAe,eAEZA,EAhBXpH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQoH,oBAAsBA,EAC9BpH,EAAQsH,WAAaF,EAAoBjC,EAAOvE,MAIhDZ,EAAQqH,aAAerH,EAAQsH,aAGnCxH,OAAO,kBAAkB,UAAW,WAAY,SAAUC,EAASC,GAC/D,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAGtDH,EAAQuH,KADR,eAIJzH,OAAO,kBAAkB,UAAW,UAAW,UAAW,SAAUC,EAASC,EAASwH,GAClF,aAYA,SAASC,EAAcC,GACnB,OAAKA,EAGc,IAAfA,EAAIxG,OACGwG,EAAI,GAER,SAAeC,GAClB,OAAOD,EAAIxE,OAAO,SAAU0E,EAAMnG,GAAM,OAAOA,EAAGmG,IAAUD,IANrDH,EAAOD,KAbtBtH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAStDH,EAAQ6H,KAPR,WAEI,IAAK,IADDH,KACKI,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCJ,EAAII,GAAMlG,UAAUkG,GAExB,OAAOL,EAAcC,IAezB1H,EAAQyH,cAAgBA,IAG5B3H,OAAO,mBAAmB,UAAW,UAAW,cAAe,sBAAuB,sBAAuB,eAAgB,SAAUC,EAASC,EAASmF,EAAQ4C,EAAgBC,EAAcC,GAC3L,aACAhI,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAOtD,IAAI+H,EAA4B,WAQ5B,SAASA,EAAWC,GAChBxG,KAAKyG,WAAY,EACbD,IACAxG,KAAK0G,WAAaF,GAuR1B,OA7QAD,EAAWtE,UAAU0E,KAAO,SAAUC,GAClC,IAAIjB,EAAa,IAAIY,EAGrB,OAFAZ,EAAWkB,OAAS7G,KACpB2F,EAAWiB,SAAWA,EACfjB,GAoHXY,EAAWtE,UAAUuE,UAAY,SAAUzB,EAAgBzB,EAAOC,GAC9D,IAAIqD,EAAW5G,KAAK4G,SAChBE,EAAOV,EAAeb,aAAaR,EAAgBzB,EAAOC,GAO9D,GANIqD,EACAA,EAASrG,KAAKuG,EAAM9G,KAAK6G,QAGzBC,EAAKrE,IAAIzC,KAAK6G,OAAS7G,KAAK0G,WAAWI,GAAQ9G,KAAK+G,cAAcD,IAElEA,EAAK1C,qBACL0C,EAAK1C,oBAAqB,EACtB0C,EAAK3C,iBACL,MAAM2C,EAAK5C,eAGnB,OAAO4C,GAEXP,EAAWtE,UAAU8E,cAAgB,SAAUD,GAC3C,IACI,OAAO9G,KAAK0G,WAAWI,GAE3B,MAAOtG,GACHsG,EAAK3C,iBAAkB,EACvB2C,EAAK5C,eAAiB1D,EACtBsG,EAAKxD,MAAM9C,KAUnB+F,EAAWtE,UAAU+E,QAAU,SAAU3D,EAAM4D,GAC3C,IAAI3G,EAAQN,KASZ,GARKiH,IACGzD,EAAOvE,KAAKiI,IAAM1D,EAAOvE,KAAKiI,GAAGC,QAAU3D,EAAOvE,KAAKiI,GAAGC,OAAOC,QACjEH,EAAczD,EAAOvE,KAAKiI,GAAGC,OAAOC,QAE/B5D,EAAOvE,KAAKmI,UACjBH,EAAczD,EAAOvE,KAAKmI,WAG7BH,EACD,MAAM,IAAI/H,MAAM,yBAEpB,OAAO,IAAI+H,EAAY,SAAUI,EAASC,GAGtC,IAAI1E,EACJA,EAAetC,EAAMkG,UAAU,SAAUhI,GACrC,GAAIoE,EAKA,IACIS,EAAK7E,GAET,MAAOgC,GACH8G,EAAO9G,GACPoC,EAAajB,mBAUjB0B,EAAK7E,IAEV8I,EAAQD,MAGnBd,EAAWtE,UAAUyE,WAAa,SAAUjC,GACxC,OAAOzE,KAAK6G,OAAOL,UAAU/B,IAOjC8B,EAAWtE,UAAUoE,EAAaV,YAAc,WAC5C,OAAO3F,MAqBXuG,EAAWtE,UAAUiE,KAAO,WAExB,IAAK,IADDqB,KACKpB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCoB,EAAWpB,GAAMlG,UAAUkG,GAE/B,OAA0B,IAAtBoB,EAAWhI,OACJS,KAEJsG,EAAOR,cAAcyB,EAArBjB,CAAiCtG,OAG5CuG,EAAWtE,UAAUuF,UAAY,SAAUP,GACvC,IAAI3G,EAAQN,KASZ,GARKiH,IACGzD,EAAOvE,KAAKiI,IAAM1D,EAAOvE,KAAKiI,GAAGC,QAAU3D,EAAOvE,KAAKiI,GAAGC,OAAOC,QACjEH,EAAczD,EAAOvE,KAAKiI,GAAGC,OAAOC,QAE/B5D,EAAOvE,KAAKmI,UACjBH,EAAczD,EAAOvE,KAAKmI,WAG7BH,EACD,MAAM,IAAI/H,MAAM,yBAEpB,OAAO,IAAI+H,EAAY,SAAUI,EAASC,GACtC,IAAI9I,EACJ8B,EAAMkG,UAAU,SAAUpH,GAAK,OAAOZ,EAAQY,GAAM,SAAUoB,GAAO,OAAO8G,EAAO9G,IAAS,WAAc,OAAO6G,EAAQ7I,QAajI+H,EAAW/B,OAAS,SAAUgC,GAC1B,OAAO,IAAID,EAAWC,IAEnBD,EAlSoB,GAoS/BlI,EAAQkI,WAAaA,IAGzBpI,OAAO,qCAAqC,UAAW,UAAW,SAAU,SAAUC,EAASC,EAAS6B,GACpG,aACA5B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAUtD,IAAIiJ,EAAyC,SAAUrH,GAEnD,SAASqH,IACL,IAAInH,EAAQN,KACRQ,EAAMF,EAAQF,EAAOG,KAAKP,KAAM,wBAA0BA,KAI9D,OAHAM,EAAMO,KAAOL,EAAIK,KAAO,0BACxBP,EAAMQ,MAAQN,EAAIM,MAClBR,EAAMS,QAAUP,EAAIO,QACbT,EAEX,OATAJ,EAAQc,UAAUyG,EAAyBrH,GASpCqH,EAViC,CAW1CvI,OACFb,EAAQoJ,wBAA0BA,IAGtCtJ,OAAO,4BAA4B,UAAW,UAAW,QAAS,kBAAmB,SAAUC,EAASC,EAAS6B,EAAS2D,GACtH,aACAvF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIkJ,EAAqC,SAAUtH,GAE/C,SAASsH,EAAoBC,EAASlD,GAClC,IAAInE,EAAQF,EAAOG,KAAKP,OAASA,KAIjC,OAHAM,EAAMqH,QAAUA,EAChBrH,EAAMmE,WAAaA,EACnBnE,EAAMsB,QAAS,EACRtB,EAkBX,OAxBAJ,EAAQc,UAAU0G,EAAqBtH,GAQvCsH,EAAoBzF,UAAUN,YAAc,WACxC,IAAI3B,KAAK4B,OAAT,CAGA5B,KAAK4B,QAAS,EACd,IAAI+F,EAAU3H,KAAK2H,QACfC,EAAYD,EAAQC,UAExB,GADA5H,KAAK2H,QAAU,KACVC,GAAkC,IAArBA,EAAUrI,SAAgBoI,EAAQtD,YAAasD,EAAQ/F,OAAzE,CAGA,IAAIiG,EAAkBD,EAAU3E,QAAQjD,KAAKyE,aACpB,IAArBoD,GACAD,EAAU1E,OAAO2E,EAAiB,MAGnCH,EAzB6B,CA0BtC7D,EAAenC,cACjBrD,EAAQqJ,oBAAsBA,IAGlCvJ,OAAO,gBAAgB,UAAW,UAAW,QAAS,eAAgB,eAAgB,iBAAkB,iCAAkC,wBAAyB,yBAA0B,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcxC,EAAczB,EAAgBkE,EAA2BC,EAAuBjE,GAC5T,aACAzF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItD,IAAIyJ,EAAmC,SAAU7H,GAE7C,SAAS6H,EAAkB3D,GACvB,IAAIhE,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAE9C,OADAM,EAAMgE,YAAcA,EACbhE,EAEX,OANAJ,EAAQc,UAAUiH,EAAmB7H,GAM9B6H,EAP2B,CAQpC3C,EAAatB,YACf3F,EAAQ4J,kBAAoBA,EAI5B,IAAIC,EAAyB,SAAU9H,GAEnC,SAAS8H,IACL,IAAI5H,EAAQF,EAAOG,KAAKP,OAASA,KAMjC,OALAM,EAAMsH,aACNtH,EAAMsB,QAAS,EACftB,EAAM+D,WAAY,EAClB/D,EAAM6H,UAAW,EACjB7H,EAAM8H,YAAc,KACb9H,EAyFX,OAjGAJ,EAAQc,UAAUkH,EAAS9H,GAU3B8H,EAAQjG,UAAU8B,EAAeL,cAAgB,WAC7C,OAAO,IAAIuE,EAAkBjI,OAEjCkI,EAAQjG,UAAU0E,KAAO,SAAUC,GAC/B,IAAIe,EAAU,IAAIU,EAAiBrI,KAAMA,MAEzC,OADA2H,EAAQf,SAAWA,EACZe,GAEXO,EAAQjG,UAAUoB,KAAO,SAAU7E,GAC/B,GAAIwB,KAAK4B,OACL,MAAM,IAAImG,EAA0BN,wBAExC,IAAKzH,KAAKqE,UAIN,IAAK,IAHDuD,EAAY5H,KAAK4H,UACjBxF,EAAMwF,EAAUrI,OAChB+I,EAAOV,EAAUW,QACZ7H,EAAI,EAAGA,EAAI0B,EAAK1B,IACrB4H,EAAK5H,GAAG2C,KAAK7E,IAIzB0J,EAAQjG,UAAUqB,MAAQ,SAAU9C,GAChC,GAAIR,KAAK4B,OACL,MAAM,IAAImG,EAA0BN,wBAExCzH,KAAKmI,UAAW,EAChBnI,KAAKoI,YAAc5H,EACnBR,KAAKqE,WAAY,EAIjB,IAAK,IAHDuD,EAAY5H,KAAK4H,UACjBxF,EAAMwF,EAAUrI,OAChB+I,EAAOV,EAAUW,QACZ7H,EAAI,EAAGA,EAAI0B,EAAK1B,IACrB4H,EAAK5H,GAAG4C,MAAM9C,GAElBR,KAAK4H,UAAUrI,OAAS,GAE5B2I,EAAQjG,UAAUsB,SAAW,WACzB,GAAIvD,KAAK4B,OACL,MAAM,IAAImG,EAA0BN,wBAExCzH,KAAKqE,WAAY,EAIjB,IAAK,IAHDuD,EAAY5H,KAAK4H,UACjBxF,EAAMwF,EAAUrI,OAChB+I,EAAOV,EAAUW,QACZ7H,EAAI,EAAGA,EAAI0B,EAAK1B,IACrB4H,EAAK5H,GAAG6C,WAEZvD,KAAK4H,UAAUrI,OAAS,GAE5B2I,EAAQjG,UAAUN,YAAc,WAC5B3B,KAAKqE,WAAY,EACjBrE,KAAK4B,QAAS,EACd5B,KAAK4H,UAAY,MAErBM,EAAQjG,UAAU8E,cAAgB,SAAUtC,GACxC,GAAIzE,KAAK4B,OACL,MAAM,IAAImG,EAA0BN,wBAGpC,OAAOrH,EAAO6B,UAAU8E,cAAcxG,KAAKP,KAAMyE,IAGzDyD,EAAQjG,UAAUyE,WAAa,SAAUjC,GACrC,GAAIzE,KAAK4B,OACL,MAAM,IAAImG,EAA0BN,wBAEnC,OAAIzH,KAAKmI,UACV1D,EAAWnB,MAAMtD,KAAKoI,aACfvE,EAAenC,aAAaiB,OAE9B3C,KAAKqE,WACVI,EAAWlB,WACJM,EAAenC,aAAaiB,QAGnC3C,KAAK4H,UAAUpF,KAAKiC,GACb,IAAIuD,EAAsBN,oBAAoB1H,KAAMyE,KAGnEyD,EAAQjG,UAAUuG,aAAe,WAC7B,IAAI7C,EAAa,IAAImC,EAAavB,WAElC,OADAZ,EAAWkB,OAAS7G,KACb2F,GAEXuC,EAAQ1D,OAAS,SAAUF,EAAauC,GACpC,OAAO,IAAIwB,EAAiB/D,EAAauC,IAEtCqB,EAlGiB,CAmG1BJ,EAAavB,YACflI,EAAQ6J,QAAUA,EAIlB,IAAIG,EAAkC,SAAUjI,GAE5C,SAASiI,EAAiB/D,EAAauC,GACnC,IAAIvG,EAAQF,EAAOG,KAAKP,OAASA,KAGjC,OAFAM,EAAMgE,YAAcA,EACpBhE,EAAMuG,OAASA,EACRvG,EA6BX,OAlCAJ,EAAQc,UAAUqH,EAAkBjI,GAOpCiI,EAAiBpG,UAAUoB,KAAO,SAAU7E,GACxC,IAAI8F,EAActE,KAAKsE,YACnBA,GAAeA,EAAYjB,MAC3BiB,EAAYjB,KAAK7E,IAGzB6J,EAAiBpG,UAAUqB,MAAQ,SAAU9C,GACzC,IAAI8D,EAActE,KAAKsE,YACnBA,GAAeA,EAAYhB,OAC3BtD,KAAKsE,YAAYhB,MAAM9C,IAG/B6H,EAAiBpG,UAAUsB,SAAW,WAClC,IAAIe,EAActE,KAAKsE,YACnBA,GAAeA,EAAYf,UAC3BvD,KAAKsE,YAAYf,YAGzB8E,EAAiBpG,UAAUyE,WAAa,SAAUjC,GAE9C,OADazE,KAAK6G,OAEP7G,KAAK6G,OAAOL,UAAU/B,GAGtBZ,EAAenC,aAAaiB,OAGpC0F,EAnC0B,CAoCnCH,GACF7J,EAAQgK,iBAAmBA,IAG/BlK,OAAO,qBAAqB,UAAW,UAAW,QAAS,YAAa,kBAAmB,SAAUC,EAASC,EAAS6B,EAASuI,EAAW5E,GACvI,aACAvF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItD,IAAIkK,EAA8B,SAAUtI,GAExC,SAASsI,IACL,IAAIpI,EAAmB,OAAXF,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAIhE,OAHAM,EAAM9B,MAAQ,KACd8B,EAAMqI,SAAU,EAChBrI,EAAMsI,cAAe,EACdtI,EAgCX,OAtCAJ,EAAQc,UAAU0H,EAActI,GAQhCsI,EAAazG,UAAUyE,WAAa,SAAUjC,GAC1C,OAAIzE,KAAKmI,UACL1D,EAAWnB,MAAMtD,KAAKoI,aACfvE,EAAenC,aAAaiB,OAE9B3C,KAAK4I,cAAgB5I,KAAK2I,SAC/BlE,EAAWpB,KAAKrD,KAAKxB,OACrBiG,EAAWlB,WACJM,EAAenC,aAAaiB,OAEhCvC,EAAO6B,UAAUyE,WAAWnG,KAAKP,KAAMyE,IAElDiE,EAAazG,UAAUoB,KAAO,SAAU7E,GAC/BwB,KAAK4I,eACN5I,KAAKxB,MAAQA,EACbwB,KAAK2I,SAAU,IAGvBD,EAAazG,UAAUqB,MAAQ,SAAUA,GAChCtD,KAAK4I,cACNxI,EAAO6B,UAAUqB,MAAM/C,KAAKP,KAAMsD,IAG1CoF,EAAazG,UAAUsB,SAAW,WAC9BvD,KAAK4I,cAAe,EAChB5I,KAAK2I,SACLvI,EAAO6B,UAAUoB,KAAK9C,KAAKP,KAAMA,KAAKxB,OAE1C4B,EAAO6B,UAAUsB,SAAShD,KAAKP,OAE5B0I,EAvCsB,CAwC/BD,EAAUP,SACZ7J,EAAQqK,aAAeA,IAG3BvK,OAAO,yBAAyB,UAAW,UAAW,QAAS,mBAAoB,SAAUC,EAASC,EAAS6B,EAAS2D,GACpH,aACAvF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAetD,IAAIqK,EAAwB,SAAUzI,GAElC,SAASyI,EAAOC,EAAWC,GACvB,OAAO3I,EAAOG,KAAKP,OAASA,KAgBhC,OAlBAE,EAAQc,UAAU6H,EAAQzI,GAc1ByI,EAAO5G,UAAU+G,SAAW,SAAUC,EAAOC,GAEzC,YADc,IAAVA,IAAoBA,EAAQ,GACzBlJ,MAEJ6I,EAnBgB,CAoBzBhF,EAAenC,cACjBrD,EAAQwK,OAASA,IAGrB1K,OAAO,8BAA8B,UAAW,UAAW,QAAS,eAAgB,YAAa,SAAUC,EAASC,EAAS6B,EAASsD,EAAQ2F,GAC1I,aACA7K,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI4K,EAA6B,SAAUhJ,GAEvC,SAASgJ,EAAYN,EAAWC,GAC5B,IAAIzI,EAAQF,EAAOG,KAAKP,KAAM8I,EAAWC,IAAS/I,KAIlD,OAHAM,EAAMwI,UAAYA,EAClBxI,EAAMyI,KAAOA,EACbzI,EAAM+I,SAAU,EACT/I,EAuHX,OA7HAJ,EAAQc,UAAUoI,EAAahJ,GAQ/BgJ,EAAYnH,UAAU+G,SAAW,SAAUC,EAAOC,GAE9C,QADc,IAAVA,IAAoBA,EAAQ,GAC5BlJ,KAAK4B,OACL,OAAO5B,KAGXA,KAAKiJ,MAAQA,EAGbjJ,KAAKqJ,SAAU,EACf,IAAIC,EAAKtJ,KAAKsJ,GACVR,EAAY9I,KAAK8I,UA4BrB,OANU,MAANQ,IACAtJ,KAAKsJ,GAAKtJ,KAAKuJ,eAAeT,EAAWQ,EAAIJ,IAEjDlJ,KAAKkJ,MAAQA,EAEblJ,KAAKsJ,GAAKtJ,KAAKsJ,IAAMtJ,KAAKwJ,eAAeV,EAAW9I,KAAKsJ,GAAIJ,GACtDlJ,MAEXoJ,EAAYnH,UAAUuH,eAAiB,SAAUV,EAAWQ,EAAIJ,GAE5D,YADc,IAAVA,IAAoBA,EAAQ,GACzB1F,EAAOvE,KAAKwK,YAAYX,EAAUY,MAAMzE,KAAK6D,EAAW9I,MAAOkJ,IAE1EE,EAAYnH,UAAUsH,eAAiB,SAAUT,EAAWQ,EAAIJ,GAG5D,YAFc,IAAVA,IAAoBA,EAAQ,GAElB,OAAVA,GAAkBlJ,KAAKkJ,QAAUA,IAA0B,IAAjBlJ,KAAKqJ,QACxCC,EAIJ9F,EAAOvE,KAAK0K,cAAcL,SAAOM,QAAaA,GAMzDR,EAAYnH,UAAU4H,QAAU,SAAUZ,EAAOC,GAC7C,GAAIlJ,KAAK4B,OACL,OAAO,IAAI1C,MAAM,gCAErBc,KAAKqJ,SAAU,EACf,IAAI/F,EAAQtD,KAAK8J,SAASb,EAAOC,GACjC,GAAI5F,EACA,OAAOA,GAEe,IAAjBtD,KAAKqJ,SAAgC,MAAXrJ,KAAKsJ,KAcpCtJ,KAAKsJ,GAAKtJ,KAAKuJ,eAAevJ,KAAK8I,UAAW9I,KAAKsJ,GAAI,QAG/DF,EAAYnH,UAAU6H,SAAW,SAAUb,EAAOC,GAC9C,IAAIa,GAAU,EACVC,OAAaJ,EACjB,IACI5J,KAAK+I,KAAKE,GAEd,MAAOvJ,GACHqK,GAAU,EACVC,IAAetK,GAAKA,GAAK,IAAIR,MAAMQ,GAEvC,GAAIqK,EAEA,OADA/J,KAAK2B,cACEqI,GAGfZ,EAAYnH,UAAUD,aAAe,WACjC,IAAIsH,EAAKtJ,KAAKsJ,GACVR,EAAY9I,KAAK8I,UACjBmB,EAAUnB,EAAUmB,QACpB9H,EAAQ8H,EAAQhH,QAAQjD,MAC5BA,KAAK+I,KAAO,KACZ/I,KAAKiJ,MAAQ,KACbjJ,KAAKqJ,SAAU,EACfrJ,KAAK8I,UAAY,MACF,IAAX3G,GACA8H,EAAQ/G,OAAOf,EAAO,GAEhB,MAANmH,IACAtJ,KAAKsJ,GAAKtJ,KAAKuJ,eAAeT,EAAWQ,EAAI,OAEjDtJ,KAAKkJ,MAAQ,MAEVE,EA9HqB,CA+H9BD,EAASN,QACXxK,EAAQ+K,YAAcA,IAG1BjL,OAAO,8BAA8B,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASgK,GACvH,aACA5L,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI2L,EAA6B,SAAU/J,GAEvC,SAAS+J,EAAYrB,EAAWC,GAC5B,IAAIzI,EAAQF,EAAOG,KAAKP,KAAM8I,EAAWC,IAAS/I,KAGlD,OAFAM,EAAMwI,UAAYA,EAClBxI,EAAMyI,KAAOA,EACNzI,EA4BX,OAjCAJ,EAAQc,UAAUmJ,EAAa/J,GAO/B+J,EAAYlI,UAAU+G,SAAW,SAAUC,EAAOC,GAE9C,YADc,IAAVA,IAAoBA,EAAQ,GAC5BA,EAAQ,EACD9I,EAAO6B,UAAU+G,SAASzI,KAAKP,KAAMiJ,EAAOC,IAEvDlJ,KAAKkJ,MAAQA,EACblJ,KAAKiJ,MAAQA,EACbjJ,KAAK8I,UAAUY,MAAM1J,MACdA,OAEXmK,EAAYlI,UAAU4H,QAAU,SAAUZ,EAAOC,GAC7C,OAAQA,EAAQ,GAAKlJ,KAAK4B,OACtBxB,EAAO6B,UAAU4H,QAAQtJ,KAAKP,KAAMiJ,EAAOC,GAC3ClJ,KAAK8J,SAASb,EAAOC,IAE7BiB,EAAYlI,UAAUuH,eAAiB,SAAUV,EAAWQ,EAAIJ,GAK5D,YAJc,IAAVA,IAAoBA,EAAQ,GAIjB,OAAVA,GAAkBA,EAAQ,GAAiB,OAAVA,GAAkBlJ,KAAKkJ,MAAQ,EAC1D9I,EAAO6B,UAAUuH,eAAejJ,KAAKP,KAAM8I,EAAWQ,EAAIJ,GAG9DJ,EAAUY,MAAM1J,OAEpBmK,EAlCqB,CAmC9BD,EAAcd,aAChB/K,EAAQ8L,YAAcA,IAG1BhM,OAAO,kBAAkB,UAAW,WAAY,SAAUC,EAASC,GAC/D,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiBtD,IAAI4L,EAA2B,WAC3B,SAASA,EAAUC,EAAiBC,QACpB,IAARA,IAAkBA,EAAMF,EAAUE,KACtCtK,KAAKqK,gBAAkBA,EACvBrK,KAAKsK,IAAMA,EAwBf,OALAF,EAAUnI,UAAU+G,SAAW,SAAUD,EAAMG,EAAOD,GAElD,YADc,IAAVC,IAAoBA,EAAQ,GACzB,IAAIlJ,KAAKqK,gBAAgBrK,KAAM+I,GAAMC,SAASC,EAAOC,IAEhEkB,EAAUE,IAAMC,KAAKD,IAAMC,KAAKD,IAAM,WAAc,OAAQ,IAAIC,MACzDH,EA5BmB,GA8B9B/L,EAAQ+L,UAAYA,IAGxBjM,OAAO,iCAAiC,UAAW,UAAW,QAAS,gBAAiB,SAAUC,EAASC,EAAS6B,EAASsK,GACzH,aACAlM,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIiM,EAAgC,SAAUrK,GAE1C,SAASqK,IACL,IAAInK,EAAmB,OAAXF,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAehE,OAdAM,EAAM2J,WAMN3J,EAAMoK,QAAS,EAOfpK,EAAMqK,eAAYf,EACXtJ,EAuBX,OAxCAJ,EAAQc,UAAUyJ,EAAgBrK,GAmBlCqK,EAAexI,UAAUyH,MAAQ,SAAUkB,GACvC,IAAIX,EAAUjK,KAAKiK,QACnB,GAAIjK,KAAK0K,OACLT,EAAQzH,KAAKoI,OADjB,CAIA,IAAItH,EACJtD,KAAK0K,QAAS,EACd,GACI,GAAIpH,EAAQsH,EAAOf,QAAQe,EAAO3B,MAAO2B,EAAO1B,OAC5C,YAEC0B,EAASX,EAAQY,SAE1B,GADA7K,KAAK0K,QAAS,EACVpH,EAAO,CACP,KAAOsH,EAASX,EAAQY,SACpBD,EAAOjJ,cAEX,MAAM2B,KAGPmH,EAzCwB,CA0CjCD,EAAYJ,WACd/L,EAAQoM,eAAiBA,IAG7BtM,OAAO,iCAAiC,UAAW,UAAW,QAAS,oBAAqB,SAAUC,EAASC,EAAS6B,EAAS4K,GAC7H,aACAxM,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIuM,EAAgC,SAAU3K,GAE1C,SAAS2K,IACL,OAAkB,OAAX3K,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAE/D,OAJAE,EAAQc,UAAU+J,EAAgB3K,GAI3B2K,EALwB,CAMjCD,EAAiBL,gBACnBpM,EAAQ0M,eAAiBA,IAG7B5M,OAAO,wBAAwB,UAAW,UAAW,gBAAiB,oBAAqB,SAAUC,EAASC,EAAS2M,EAAeC,GAClI,aACA3M,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8DtDH,EAAQ6M,MAAQ,IAAID,EAAiBF,eAAeC,EAAcb,eAGtEhM,OAAO,qBAAqB,UAAW,UAAW,gBAAiB,SAAUC,EAASC,EAASyJ,GAC3F,aACAxJ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAetD,IAAI2M,EAA8B,WAC9B,SAASA,EAAaC,EAAM5M,EAAO8E,GAC/BtD,KAAKoL,KAAOA,EACZpL,KAAKxB,MAAQA,EACbwB,KAAKsD,MAAQA,EACbtD,KAAKqL,SAAoB,MAATD,EAsGpB,OA/FAD,EAAalJ,UAAUqJ,QAAU,SAAUC,GACvC,OAAQvL,KAAKoL,MACT,IAAK,IACD,OAAOG,EAASlI,MAAQkI,EAASlI,KAAKrD,KAAKxB,OAC/C,IAAK,IACD,OAAO+M,EAASjI,OAASiI,EAASjI,MAAMtD,KAAKsD,OACjD,IAAK,IACD,OAAOiI,EAAShI,UAAYgI,EAAShI,aAWjD4H,EAAalJ,UAAUuJ,GAAK,SAAUnI,EAAMC,EAAOC,GAE/C,OADWvD,KAAKoL,MAEZ,IAAK,IACD,OAAO/H,GAAQA,EAAKrD,KAAKxB,OAC7B,IAAK,IACD,OAAO8E,GAASA,EAAMtD,KAAKsD,OAC/B,IAAK,IACD,OAAOC,GAAYA,MAY/B4H,EAAalJ,UAAUwJ,OAAS,SAAUjG,EAAgBlC,EAAOC,GAC7D,OAAIiC,GAAiD,mBAAxBA,EAAenC,KACjCrD,KAAKsL,QAAQ9F,GAGbxF,KAAKwL,GAAGhG,EAAgBlC,EAAOC,IAQ9C4H,EAAalJ,UAAUyJ,aAAe,WAElC,OADW1L,KAAKoL,MAEZ,IAAK,IACD,OAAOtD,EAAavB,WAAWoF,GAAG3L,KAAKxB,OAC3C,IAAK,IACD,OAAOsJ,EAAavB,WAAWqF,MAAM5L,KAAKsD,OAC9C,IAAK,IACD,OAAOwE,EAAavB,WAAWnD,QAEvC,MAAM,IAAIlE,MAAM,uCASpBiM,EAAaU,WAAa,SAAUrN,GAChC,YAAqB,IAAVA,EACA,IAAI2M,EAAa,IAAK3M,GAE1B2M,EAAaW,4BASxBX,EAAaY,YAAc,SAAUvL,GACjC,OAAO,IAAI2K,EAAa,SAAKvB,EAAWpJ,IAM5C2K,EAAaa,eAAiB,WAC1B,OAAOb,EAAac,sBAExBd,EAAac,qBAAuB,IAAId,EAAa,KACrDA,EAAaW,2BAA6B,IAAIX,EAAa,SAAKvB,GACzDuB,EA3GsB,GA6GjC9M,EAAQ8M,aAAeA,IAG3BhN,OAAO,4BAA4B,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,SAAUC,EAASC,EAAS6B,EAASoF,EAAc4G,GACtJ,aACA5N,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQ8N,UANR,SAAmBrD,EAAWI,GAE1B,YADc,IAAVA,IAAoBA,EAAQ,GACzB,SAAmCrC,GACtC,OAAOA,EAAOF,KAAK,IAAIyF,EAAkBtD,EAAWI,MAI5D,IAAIkD,EAAmC,WACnC,SAASA,EAAkBtD,EAAWI,QACpB,IAAVA,IAAoBA,EAAQ,GAChClJ,KAAK8I,UAAYA,EACjB9I,KAAKkJ,MAAQA,EAKjB,OAHAkD,EAAkBnK,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAI6F,EAAoB5H,EAAYzE,KAAK8I,UAAW9I,KAAKkJ,SAE9EkD,EAT2B,GAWtC/N,EAAQ+N,kBAAoBA,EAM5B,IAAIC,EAAqC,SAAUjM,GAE/C,SAASiM,EAAoB/H,EAAawE,EAAWI,QACnC,IAAVA,IAAoBA,EAAQ,GAChC,IAAI5I,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMwI,UAAYA,EAClBxI,EAAM4I,MAAQA,EACP5I,EAmBX,OAzBAJ,EAAQc,UAAUqL,EAAqBjM,GAQvCiM,EAAoBC,SAAW,SAAUC,GACrC,IAAIC,EAAeD,EAAIC,aAAclI,EAAciI,EAAIjI,YACvDkI,EAAalB,QAAQhH,GACrBtE,KAAK2B,eAET0K,EAAoBpK,UAAUwK,gBAAkB,SAAUD,GACtDxM,KAAKyC,IAAIzC,KAAK8I,UAAUE,SAASqD,EAAoBC,SAAUtM,KAAKkJ,MAAO,IAAIwD,EAAiBF,EAAcxM,KAAKsE,gBAEvH+H,EAAoBpK,UAAUyC,MAAQ,SAAUlG,GAC5CwB,KAAKyM,gBAAgBP,EAAef,aAAaU,WAAWrN,KAEhE6N,EAAoBpK,UAAU0C,OAAS,SAAUnE,GAC7CR,KAAKyM,gBAAgBP,EAAef,aAAaY,YAAYvL,KAEjE6L,EAAoBpK,UAAU2C,UAAY,WACtC5E,KAAKyM,gBAAgBP,EAAef,aAAaa,mBAE9CK,EA1B6B,CA2BtC/G,EAAatB,YACf3F,EAAQgO,oBAAsBA,EAC9B,IAAIK,EAAkC,WAKlC,OAJA,SAA0BF,EAAclI,GACpCtE,KAAKwM,aAAeA,EACpBxM,KAAKsE,YAAcA,GAHU,GAOrCjG,EAAQqO,iBAAmBA,IAG/BvO,OAAO,sBAAsB,UAAW,UAAW,QAAS,YAAa,oBAAqB,iBAAkB,wBAAyB,iCAAkC,yBAA0B,SAAUC,EAASC,EAAS6B,EAASuI,EAAWkE,EAAS9I,EAAgB+I,EAAa7E,EAA2BC,GAClT,aACA1J,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItD,IAAIqO,EAA+B,SAAUzM,GAEzC,SAASyM,EAAcC,EAAYC,EAAYjE,QACxB,IAAfgE,IAAyBA,EAAaE,OAAOC,wBAC9B,IAAfF,IAAyBA,EAAaC,OAAOC,mBACjD,IAAI3M,EAAQF,EAAOG,KAAKP,OAASA,KAKjC,OAJAM,EAAMwI,UAAYA,EAClBxI,EAAM4M,WACN5M,EAAM6M,YAAcL,EAAa,EAAI,EAAIA,EACzCxM,EAAM8M,YAAcL,EAAa,EAAI,EAAIA,EAClCzM,EAmEX,OA5EAJ,EAAQc,UAAU6L,EAAezM,GAWjCyM,EAAc5K,UAAUoB,KAAO,SAAU7E,GACrC,IAAI8L,EAAMtK,KAAKqN,UACfrN,KAAKkN,QAAQ1K,KAAK,IAAI8K,EAAYhD,EAAK9L,IACvCwB,KAAKuN,2BACLnN,EAAO6B,UAAUoB,KAAK9C,KAAKP,KAAMxB,IAErCqO,EAAc5K,UAAUyE,WAAa,SAAUjC,GAC3C,IAEI7B,EAFAsK,EAAUlN,KAAKuN,2BACfzE,EAAY9I,KAAK8I,UAErB,GAAI9I,KAAK4B,OACL,MAAM,IAAImG,EAA0BN,wBAE/BzH,KAAKmI,SACVvF,EAAeiB,EAAenC,aAAaiB,MAEtC3C,KAAKqE,UACVzB,EAAeiB,EAAenC,aAAaiB,OAG3C3C,KAAK4H,UAAUpF,KAAKiC,GACpB7B,EAAe,IAAIoF,EAAsBN,oBAAoB1H,KAAMyE,IAEnEqE,GACArE,EAAWhC,IAAIgC,EAAa,IAAImI,EAAYP,oBAAoB5H,EAAYqE,IAGhF,IAAK,IADD1G,EAAM8K,EAAQ3N,OACTmB,EAAI,EAAGA,EAAI0B,IAAQqC,EAAW7C,OAAQlB,IAC3C+D,EAAWpB,KAAK6J,EAAQxM,GAAGlC,OAQ/B,OANIwB,KAAKmI,SACL1D,EAAWnB,MAAMtD,KAAKoI,aAEjBpI,KAAKqE,WACVI,EAAWlB,WAERX,GAEXiK,EAAc5K,UAAUoL,QAAU,WAC9B,OAAQrN,KAAK8I,WAAa6D,EAAQzB,OAAOZ,OAE7CuC,EAAc5K,UAAUsL,yBAA2B,WAU/C,IATA,IAAIjD,EAAMtK,KAAKqN,UACXF,EAAcnN,KAAKmN,YACnBC,EAAcpN,KAAKoN,YACnBF,EAAUlN,KAAKkN,QACfM,EAAcN,EAAQ3N,OACtBkO,EAAc,EAIXA,EAAcD,KACZlD,EAAM4C,EAAQO,GAAaC,KAAQN,IAGxCK,IAQJ,OANID,EAAcL,IACdM,EAAcE,KAAKC,IAAIH,EAAaD,EAAcL,IAElDM,EAAc,GACdP,EAAQhK,OAAO,EAAGuK,GAEfP,GAEJL,EA7EuB,CA8EhCpE,EAAUP,SACZ7J,EAAQwO,cAAgBA,EACxB,IAAIS,EAA6B,WAK7B,OAJA,SAAqBI,EAAMlP,GACvBwB,KAAK0N,KAAOA,EACZ1N,KAAKxB,MAAQA,GAHW,KASpCL,OAAO,wBAAwB,UAAW,UAAW,QAAS,YAAa,kCAAmC,SAAUC,EAASC,EAAS6B,EAASuI,EAAWV,GAC1J,aACAzJ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItD,IAAIqP,EAAiC,SAAUzN,GAE3C,SAASyN,EAAgBC,GACrB,IAAIxN,EAAQF,EAAOG,KAAKP,OAASA,KAEjC,OADAM,EAAMwN,OAASA,EACRxN,EA8BX,OAlCAJ,EAAQc,UAAU6M,EAAiBzN,GAMnC9B,OAAOC,eAAesP,EAAgB5L,UAAW,SAC7C8L,IAAK,WACD,OAAO/N,KAAKgO,YAEhBC,YAAY,EACZC,cAAc,IAElBL,EAAgB5L,UAAUyE,WAAa,SAAUjC,GAC7C,IAAI7B,EAAexC,EAAO6B,UAAUyE,WAAWnG,KAAKP,KAAMyE,GAI1D,OAHI7B,IAAiBA,EAAahB,QAC9B6C,EAAWpB,KAAKrD,KAAK8N,QAElBlL,GAEXiL,EAAgB5L,UAAU+L,SAAW,WACjC,GAAIhO,KAAKmI,SACL,MAAMnI,KAAKoI,YAEV,GAAIpI,KAAK4B,OACV,MAAM,IAAImG,EAA0BN,wBAGpC,OAAOzH,KAAK8N,QAGpBD,EAAgB5L,UAAUoB,KAAO,SAAU7E,GACvC4B,EAAO6B,UAAUoB,KAAK9C,KAAKP,KAAMA,KAAK8N,OAAStP,IAE5CqP,EAnCyB,CAoClCpF,EAAUP,SACZ7J,EAAQwP,gBAAkBA,IAG9B1P,OAAO,2BAA2B,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACpH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtDH,EAAQ8P,SALR,WACI,OAAO,SAAkCtH,GACrC,OAAOA,EAAOF,KAAK,IAAIyH,EAAiBvH,MAIhD,IAAIuH,EAAkC,WAClC,SAASA,EAAiBC,GACtBrO,KAAKqO,YAAcA,EAYvB,OAVAD,EAAiBnM,UAAU1B,KAAO,SAAUkE,EAAYoC,GACpD,IAAIwH,EAAcrO,KAAKqO,YACvBA,EAAYC,YACZ,IAAIC,EAAa,IAAIC,EAAmB/J,EAAY4J,GAChDzL,EAAeiE,EAAOL,UAAU+H,GAIpC,OAHKA,EAAW3M,SACZ2M,EAAWE,WAAaJ,EAAYK,WAEjC9L,GAEJwL,EAd0B,GAgBjCI,EAAoC,SAAUpO,GAE9C,SAASoO,EAAmBlK,EAAa+J,GACrC,IAAI/N,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAE9C,OADAM,EAAM+N,YAAcA,EACb/N,EAiDX,OArDAJ,EAAQc,UAAUwN,EAAoBpO,GAMtCoO,EAAmBvM,UAAUD,aAAe,WACxC,IAAIqM,EAAcrO,KAAKqO,YACvB,GAAKA,EAAL,CAIArO,KAAKqO,YAAc,KACnB,IAAIF,EAAWE,EAAYC,UAC3B,GAAIH,GAAY,EACZnO,KAAKyO,WAAa,UAItB,GADAJ,EAAYC,UAAYH,EAAW,EAC/BA,EAAW,EACXnO,KAAKyO,WAAa,SADtB,CA2BA,IAAIA,EAAazO,KAAKyO,WAClBE,EAAmBN,EAAYO,YACnC5O,KAAKyO,WAAa,MACdE,GAAsBF,GAAcE,IAAqBF,GACzDE,EAAiBhN,oBAzCjB3B,KAAKyO,WAAa,MA4CnBD,EAtD4B,CAuDrClJ,EAAatB,cAGnB7F,OAAO,yCAAyC,UAAW,UAAW,QAAS,aAAc,gBAAiB,gBAAiB,kBAAmB,yBAA0B,SAAUC,EAASC,EAAS6B,EAASuI,EAAWX,EAAcxC,EAAczB,EAAgBgL,GACpQ,aACAvQ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItD,IAAIsQ,EAAuC,SAAU1O,GAEjD,SAAS0O,EAAsBjI,EAAQkI,GACnC,IAAIzO,EAAQF,EAAOG,KAAKP,OAASA,KAKjC,OAJAM,EAAMuG,OAASA,EACfvG,EAAMyO,eAAiBA,EACvBzO,EAAMgO,UAAY,EAClBhO,EAAM0O,aAAc,EACb1O,EAgCX,OAvCAJ,EAAQc,UAAU8N,EAAuB1O,GASzC0O,EAAsB7M,UAAUyE,WAAa,SAAUjC,GACnD,OAAOzE,KAAKiP,aAAazI,UAAU/B,IAEvCqK,EAAsB7M,UAAUgN,WAAa,WACzC,IAAItH,EAAU3H,KAAKkP,SAInB,OAHKvH,IAAWA,EAAQtD,YACpBrE,KAAKkP,SAAWlP,KAAK+O,kBAElB/O,KAAKkP,UAEhBJ,EAAsB7M,UAAUyM,QAAU,WACtC,IAAID,EAAazO,KAAK4O,YActB,OAbKH,IACDzO,KAAKgP,aAAc,GACnBP,EAAazO,KAAK4O,YAAc,IAAI/K,EAAenC,cACxCe,IAAIzC,KAAK6G,OACfL,UAAU,IAAI2I,EAAsBnP,KAAKiP,aAAcjP,QACxDyO,EAAW7M,QACX5B,KAAK4O,YAAc,KACnBH,EAAa5K,EAAenC,aAAaiB,OAGzC3C,KAAK4O,YAAcH,GAGpBA,GAEXK,EAAsB7M,UAAUkM,SAAW,WACvC,OAAOU,EAAWV,UAAXU,CAAsB7O,OAE1B8O,EAxC+B,CAyCxChH,EAAavB,YACflI,EAAQyQ,sBAAwBA,EAChC,IAAIM,EAAmBN,EAAsB7M,UAC7C5D,EAAQgR,iCACJzI,UAAYpI,MAAO,MACnB8P,WAAa9P,MAAO,EAAG8Q,UAAU,GACjCJ,UAAY1Q,MAAO,KAAM8Q,UAAU,GACnCV,aAAepQ,MAAO,KAAM8Q,UAAU,GACtC5I,YAAclI,MAAO4Q,EAAiB1I,YACtCsI,aAAexQ,MAAO4Q,EAAiBJ,YAAaM,UAAU,GAC9DL,YAAczQ,MAAO4Q,EAAiBH,YACtCP,SAAWlQ,MAAO4Q,EAAiBV,SACnCP,UAAY3P,MAAO4Q,EAAiBjB,WAExC,IAAIgB,EAAuC,SAAU/O,GAEjD,SAAS+O,EAAsB7K,EAAa+J,GACxC,IAAI/N,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAE9C,OADAM,EAAM+N,YAAcA,EACb/N,EAwBX,OA5BAJ,EAAQc,UAAUmO,EAAuB/O,GAMzC+O,EAAsBlN,UAAU0C,OAAS,SAAUnE,GAC/CR,KAAKgC,eACL5B,EAAO6B,UAAU0C,OAAOpE,KAAKP,KAAMQ,IAEvC2O,EAAsBlN,UAAU2C,UAAY,WACxC5E,KAAKqO,YAAYW,aAAc,EAC/BhP,KAAKgC,eACL5B,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAEpCmP,EAAsBlN,UAAUD,aAAe,WAC3C,IAAIqM,EAAcrO,KAAKqO,YACvB,GAAIA,EAAa,CACbrO,KAAKqO,YAAc,KACnB,IAAII,EAAaJ,EAAYO,YAC7BP,EAAYC,UAAY,EACxBD,EAAYa,SAAW,KACvBb,EAAYO,YAAc,KACtBH,GACAA,EAAW9M,gBAIhBwN,EA7B+B,CA8BxC1G,EAAUR,mBAiBRuG,GAhBkC,WAClC,SAASJ,EAAiBC,GACtBrO,KAAKqO,YAAcA,EAEvBD,EAAiBnM,UAAU1B,KAAO,SAAUkE,EAAYoC,GACpD,IAAIwH,EAAcrO,KAAKqO,YACvBA,EAAYC,YACZ,IAAIC,EAAa,IAAIC,EAAmB/J,EAAY4J,GAChDzL,EAAeiE,EAAOL,UAAU+H,GAIpC,OAHKA,EAAW3M,SACZ2M,EAAWE,WAAaJ,EAAYK,WAEjC9L,GAZsB,GAgBG,SAAUxC,GAE9C,SAASoO,EAAmBlK,EAAa+J,GACrC,IAAI/N,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAE9C,OADAM,EAAM+N,YAAcA,EACb/N,EAiDX,OArDAJ,EAAQc,UAAUwN,EAAoBpO,GAMtCoO,EAAmBvM,UAAUD,aAAe,WACxC,IAAIqM,EAAcrO,KAAKqO,YACvB,GAAKA,EAAL,CAIArO,KAAKqO,YAAc,KACnB,IAAIF,EAAWE,EAAYC,UAC3B,GAAIH,GAAY,EACZnO,KAAKyO,WAAa,UAItB,GADAJ,EAAYC,UAAYH,EAAW,EAC/BA,EAAW,EACXnO,KAAKyO,WAAa,SADtB,CA2BA,IAAIA,EAAazO,KAAKyO,WAClBE,EAAmBN,EAAYO,YACnC5O,KAAKyO,WAAa,MACdE,GAAsBF,GAAcE,IAAqBF,GACzDE,EAAiBhN,oBAzCjB3B,KAAKyO,WAAa,MA4CnBD,EAtD4B,CAuDrClJ,EAAatB,eAGnB7F,OAAO,wBAAwB,UAAW,UAAW,SAAU,SAAUC,EAASC,EAAS6B,GACvF,aACA5B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAWtD,IAAI+Q,EAA4B,SAAUnP,GAEtC,SAASmP,IACL,IAAIjP,EAAQN,KACRQ,EAAMF,EAAQF,EAAOG,KAAKP,KAAM,4BAA8BA,KAIlE,OAHAM,EAAMO,KAAOL,EAAIK,KAAO,aACxBP,EAAMQ,MAAQN,EAAIM,MAClBR,EAAMS,QAAUP,EAAIO,QACbT,EAEX,OATAJ,EAAQc,UAAUuO,EAAYnP,GASvBmP,EAVoB,CAW7BrQ,OACFb,EAAQkR,WAAaA,IAGzBpR,OAAO,qCAAqC,UAAW,UAAW,SAAU,SAAUC,EAASC,EAAS6B,GACpG,aACA5B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAWtD,IAAIgR,EAAyC,SAAUpP,GAEnD,SAASoP,IACL,IAAIlP,EAAQN,KACRQ,EAAMF,EAAQF,EAAOG,KAAKP,KAAM,0BAA4BA,KAIhE,OAHAM,EAAMO,KAAOL,EAAIK,KAAO,0BACxBP,EAAMQ,MAAQN,EAAIM,MAClBR,EAAMS,QAAUP,EAAIO,QACbT,EAEX,OATAJ,EAAQc,UAAUwO,EAAyBpP,GASpCoP,EAViC,CAW1CtQ,OACFb,EAAQmR,wBAA0BA,IAGtCrR,OAAO,0BAA0B,UAAW,UAAW,SAAU,SAAUC,EAASC,EAAS6B,GACzF,aACA5B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAQtD,IAAIiR,EAA8B,SAAUrP,GAExC,SAASqP,IACL,IAAInP,EAAQN,KACRQ,EAAMF,EAAQF,EAAOG,KAAKP,KAAM,yBAA2BA,KAI/D,OAHAM,EAAMO,KAAOL,EAAIK,KAAO,eACxBP,EAAMQ,MAAQN,EAAIM,MAClBR,EAAMS,QAAUP,EAAIO,QACbT,EAEX,OATAJ,EAAQc,UAAUyO,EAAcrP,GASzBqP,EAVsB,CAW/BvQ,OACFb,EAAQoR,aAAeA,IAG3BtR,OAAO,wBAAwB,UAAW,UAAW,gBAAiB,oBAAqB,SAAUC,EAASC,EAAS6L,EAAeY,GAClI,aACAxM,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA2CtDH,EAAQqR,MAAQ,IAAI5E,EAAiBL,eAAeP,EAAcd,eAGtEjL,OAAO,+BAA+B,UAAW,UAAW,QAAS,gBAAiB,sBAAuB,SAAUC,EAASC,EAAS6B,EAASoF,EAAcqK,GAC5J,aACArR,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAKtDH,EAAQuR,aAJR,SAAsB9G,GAElB,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzC,SAAU7I,GAAU,OAAOA,EAAOF,KAAK,IAAIkJ,EAAqB/G,MAG3E,IAAIgH,EAA8B,WAK9B,OAJA,SAAsBtR,EAAOuR,GACzB/P,KAAKxB,MAAQA,EACbwB,KAAK+P,SAAWA,GAHS,GAOjC1R,EAAQyR,aAAeA,EAEvB,IAAID,EAAsC,WACtC,SAASA,EAAqB/G,GAC1B9I,KAAK8I,UAAYA,EAKrB,OAHA+G,EAAqB5N,UAAU1B,KAAO,SAAUgL,EAAU1E,GACtD,OAAOA,EAAOL,UAAU,IAAIwJ,EAAuBzE,EAAUvL,KAAK8I,aAE/D+G,EAP8B,GAcrCG,EAAwC,SAAU5P,GAElD,SAAS4P,EAAuB1L,EAAawE,GACzC,IAAIxI,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAMwI,UAAYA,EAClBxI,EAAM2P,SAAW,EACjB3P,EAAM2P,SAAWnH,EAAUwB,MACpBhK,EAQX,OAdAJ,EAAQc,UAAUgP,EAAwB5P,GAQ1C4P,EAAuB/N,UAAUyC,MAAQ,SAAUlG,GAC/C,IAAI8L,EAAMtK,KAAK8I,UAAUwB,MACrB4F,EAAO5F,EAAMtK,KAAKiQ,SACtBjQ,KAAKiQ,SAAW3F,EAChBtK,KAAKsE,YAAYjB,KAAK,IAAIyM,EAAatR,EAAO0R,KAE3CF,EAfgC,CAgBzC1K,EAAatB,cAGnB7F,OAAO,8BAA8B,UAAW,UAAW,qBAAsB,6BAA8B,SAAUC,EAASC,EAASsR,EAASQ,GAChJ,aACA7R,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQyR,aAAeK,EAAeL,aAWtCzR,EAAQuR,aAJR,SAAsB9G,GAElB,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzCS,EAAeP,aAAa9G,EAA5BqH,CAAuCnQ,SAKtD7B,OAAO,sBAAsB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GAC/G,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA0CtDH,EAAQoC,IARR,SAAa2P,EAASC,GAClB,OAAO,SAAsBxJ,GACzB,GAAuB,mBAAZuJ,EACP,MAAM,IAAIE,UAAU,8DAExB,OAAOzJ,EAAOF,KAAK,IAAI4J,EAAYH,EAASC,MAIpD,IAAIE,EAA6B,WAC7B,SAASA,EAAYH,EAASC,GAC1BrQ,KAAKoQ,QAAUA,EACfpQ,KAAKqQ,QAAUA,EAKnB,OAHAE,EAAYtO,UAAU1B,KAAO,SAAUkE,EAAYoC,GAC/C,OAAOA,EAAOL,UAAU,IAAIgK,EAAc/L,EAAYzE,KAAKoQ,QAASpQ,KAAKqQ,WAEtEE,EARqB,GAUhClS,EAAQkS,YAAcA,EAMtB,IAAIC,EAA+B,SAAUpQ,GAEzC,SAASoQ,EAAclM,EAAa8L,EAASC,GACzC,IAAI/P,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAM8P,QAAUA,EAChB9P,EAAMmQ,MAAQ,EACdnQ,EAAM+P,QAAUA,GAAW/P,EACpBA,EAeX,OArBAJ,EAAQc,UAAUwP,EAAepQ,GAUjCoQ,EAAcvO,UAAUyC,MAAQ,SAAUlG,GACtC,IAAIkS,EACJ,IACIA,EAAS1Q,KAAKoQ,QAAQ7P,KAAKP,KAAKqQ,QAAS7R,EAAOwB,KAAKyQ,SAEzD,MAAOjQ,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAKsE,YAAYjB,KAAKqN,IAEnBF,EAtBuB,CAuBhClL,EAAatB,cAGnB7F,OAAO,4BAA4B,UAAW,UAAW,qBAAsB,SAAU,SAAUC,EAASC,EAASsR,EAASgB,GAC1H,aACArS,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAYtDH,EAAQuS,UALR,SAAmB9H,GAEf,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzCiB,EAAMlQ,IAAI,SAAUjC,GAAS,OAAO,IAAIqS,EAAUrS,EAAOsK,EAAUwB,UAI9E,IAAIuG,EAA2B,WAK3B,OAJA,SAAmBrS,EAAOoS,GACtB5Q,KAAKxB,MAAQA,EACbwB,KAAK4Q,UAAYA,GAHK,GAO9BvS,EAAQwS,UAAYA,IAIxB1S,OAAO,gCAAgC,UAAW,WAAY,SAAUC,EAASC,GAC7E,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIsS,EAAiC,WAMjC,OALA,SAAyBC,EAAiBC,QACZ,IAAtBA,IAAgCA,EAAoBhE,OAAOC,mBAC/DjN,KAAK+Q,gBAAkBA,EACvB/Q,KAAKgR,kBAAoBA,GAJG,GAQpC3S,EAAQyS,gBAAkBA,IAG9B3S,OAAO,qCAAqC,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAAS4S,GAChH,aACA3S,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAI0S,EAAsC,WACtC,SAASA,IACLlR,KAAK+C,iBAWT,OATAmO,EAAqBjP,UAAUkP,mBAAqB,WAEhD,OADAnR,KAAK+C,cAAcP,KAAK,IAAIyO,EAAkBH,gBAAgB9Q,KAAK8I,UAAUwB,QACtEtK,KAAK+C,cAAcxD,OAAS,GAEvC2R,EAAqBjP,UAAUmP,qBAAuB,SAAUjP,GAC5D,IAAIkP,EAAmBrR,KAAK+C,cACxBuO,EAAqBD,EAAiBlP,GAC1CkP,EAAiBlP,GAAS,IAAI8O,EAAkBH,gBAAgBQ,EAAmBP,gBAAiB/Q,KAAK8I,UAAUwB,QAEhH4G,EAb8B,GAezC7S,EAAQ6S,qBAAuBA,IAGnC/S,OAAO,yBAAyB,UAAW,WAAY,SAAUC,EAASC,GACtE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAWtDH,EAAQkT,YAVR,SAAqBC,EAAaC,GAC9B,IAAK,IAAI/Q,EAAI,EAAG0B,EAAMqP,EAAUlS,OAAQmB,EAAI0B,EAAK1B,IAG7C,IAAK,IAFDgR,EAAWD,EAAU/Q,GACrBiR,EAAerT,OAAOsT,oBAAoBF,EAASzP,WAC9C4P,EAAI,EAAGC,EAAOH,EAAapS,OAAQsS,EAAIC,EAAMD,IAAK,CACvD,IAAIE,EAASJ,EAAaE,GAC1BL,EAAYvP,UAAU8P,GAAUL,EAASzP,UAAU8P,OAOnE5T,OAAO,+BAA+B,UAAW,UAAW,QAAS,gBAAiB,kBAAmB,yBAA0B,uBAAwB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcjE,EAAgBmO,EAAwBC,GAClP,aACA3T,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI0T,EAAgC,SAAU9R,GAE1C,SAAS8R,EAAeC,EAAUrJ,GAC9B,IAAIxI,EAAQF,EAAOG,KAAKP,KAAM,SAAUyE,GACpC,IAAIkB,EAAa3F,KACbmC,EAAQwD,EAAWwL,qBAKvB,OAJA1M,EAAWhC,IAAI,IAAIoB,EAAenC,aAAa,WAC3CiE,EAAWyL,qBAAqBjP,MAEpCwD,EAAWyM,iBAAiB3N,GACrBA,KACLzE,KAIN,OAHAM,EAAM6R,SAAWA,EACjB7R,EAAMyC,iBACNzC,EAAMwI,UAAYA,EACXxI,EAYX,OA1BAJ,EAAQc,UAAUkR,EAAgB9R,GAgBlC8R,EAAejQ,UAAUmQ,iBAAmB,SAAU3N,GAElD,IAAK,IADD4N,EAAiBrS,KAAKmS,SAAS5S,OAC1BmB,EAAI,EAAGA,EAAI2R,EAAgB3R,IAAK,CACrC,IAAIK,EAAUf,KAAKmS,SAASzR,GAC5B+D,EAAWhC,IAAIzC,KAAK8I,UAAUE,SAAS,SAAUsJ,GAC7C,IAAIvR,EAAUuR,EAAGvR,QAAS0D,EAAa6N,EAAG7N,WAC1C1D,EAAQyL,aAAalB,QAAQ7G,IAC9B1D,EAAQwR,OAASxR,QAASA,EAAS0D,WAAYA,OAGnDyN,EA3BwB,CA4BjCpK,EAAavB,YACflI,EAAQ6T,eAAiBA,EACzBD,EAAcV,YAAYW,GAAiBF,EAAuBd,yBAGtE/S,OAAO,8BAA8B,UAAW,UAAW,QAAS,aAAc,kBAAmB,yBAA0B,uBAAwB,SAAUC,EAASC,EAAS6B,EAASuI,EAAW5E,EAAgBmO,EAAwBC,GAC3O,aACA3T,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIgU,EAA+B,SAAUpS,GAEzC,SAASoS,EAAcL,EAAUrJ,GAC7B,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAIjC,OAHAM,EAAM6R,SAAWA,EACjB7R,EAAMyC,iBACNzC,EAAMwI,UAAYA,EACXxI,EAsBX,OA5BAJ,EAAQc,UAAUwR,EAAepS,GAQjCoS,EAAcvQ,UAAUyE,WAAa,SAAUjC,GAC3C,IAAIkD,EAAU3H,KACVmC,EAAQwF,EAAQwJ,qBAIpB,OAHA1M,EAAWhC,IAAI,IAAIoB,EAAenC,aAAa,WAC3CiG,EAAQyJ,qBAAqBjP,MAE1B/B,EAAO6B,UAAUyE,WAAWnG,KAAKP,KAAMyE,IAElD+N,EAAcvQ,UAAUwQ,MAAQ,WAI5B,IAAK,IAHD9K,EAAU3H,KACVqS,EAAiB1K,EAAQwK,SAAS5S,OAE7BmB,EAAI,EAAGA,EAAI2R,EAAgB3R,KAChC,WACI,IAAIK,EAAU4G,EAAQwK,SAASzR,GAE/BiH,EAAQmB,UAAUE,SAAS,WAAcjI,EAAQyL,aAAalB,QAAQ3D,IAAa5G,EAAQwR,OAH/F,IAODC,EA7BuB,CA8BhC/J,EAAUP,SACZ7J,EAAQmU,cAAgBA,EACxBP,EAAcV,YAAYiB,GAAgBR,EAAuBd,yBAGrE/S,OAAO,uCAAuC,UAAW,UAAW,QAAS,gBAAiB,oBAAqB,SAAUC,EAASC,EAAS6B,EAASgK,EAAeY,GACnK,aACAxM,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIkU,EAAsC,SAAUtS,GAEhD,SAASsS,EAAqBrI,EAAiBsI,QACnB,IAApBtI,IAA8BA,EAAkBuI,QAClC,IAAdD,IAAwBA,EAAY3F,OAAOC,mBAC/C,IAAI3M,EAAQF,EAAOG,KAAKP,KAAMqK,EAAiB,WAAc,OAAO/J,EAAMiS,SAAavS,KAIvF,OAHAM,EAAMqS,UAAYA,EAClBrS,EAAMiS,MAAQ,EACdjS,EAAM6B,OAAS,EACR7B,EAuBX,OA/BAJ,EAAQc,UAAU0R,EAAsBtS,GAexCsS,EAAqBzQ,UAAUyH,MAAQ,WAGnC,IAFA,IACIpG,EAAOsH,EADIX,EAANjK,KAAmBiK,QAAS0I,EAA5B3S,KAA2C2S,WAE5C/H,EAASX,EAAQY,WAAa7K,KAAKuS,MAAQ3H,EAAO1B,QAAUyJ,KAC5DrP,EAAQsH,EAAOf,QAAQe,EAAO3B,MAAO2B,EAAO1B,UAIpD,GAAI5F,EAAO,CACP,KAAOsH,EAASX,EAAQY,SACpBD,EAAOjJ,cAEX,MAAM2B,IAGdoP,EAAqBG,gBAAkB,GAChCH,EAhC8B,CAiCvC5H,EAAiBL,gBACnBpM,EAAQqU,qBAAuBA,EAM/B,IAAIE,EAA+B,SAAUxS,GAEzC,SAASwS,EAAc9J,EAAWC,EAAM5G,QACtB,IAAVA,IAAoBA,EAAQ2G,EAAU3G,OAAS,GACnD,IAAI7B,EAAQF,EAAOG,KAAKP,KAAM8I,EAAWC,IAAS/I,KAMlD,OALAM,EAAMwI,UAAYA,EAClBxI,EAAMyI,KAAOA,EACbzI,EAAM6B,MAAQA,EACd7B,EAAMoK,QAAS,EACfpK,EAAM6B,MAAQ2G,EAAU3G,MAAQA,EACzB7B,EAoDX,OA7DAJ,EAAQc,UAAU4R,EAAexS,GAWjCwS,EAAc3Q,UAAU+G,SAAW,SAAUC,EAAOC,GAEhD,QADc,IAAVA,IAAoBA,EAAQ,IAC3BlJ,KAAKsJ,GACN,OAAOlJ,EAAO6B,UAAU+G,SAASzI,KAAKP,KAAMiJ,EAAOC,GAEvDlJ,KAAK0K,QAAS,EAKd,IAAIE,EAAS,IAAIgI,EAAc5S,KAAK8I,UAAW9I,KAAK+I,MAEpD,OADA/I,KAAKyC,IAAImI,GACFA,EAAO5B,SAASC,EAAOC,IAElC0J,EAAc3Q,UAAUuH,eAAiB,SAAUV,EAAWQ,EAAIJ,QAChD,IAAVA,IAAoBA,EAAQ,GAChClJ,KAAKkJ,MAAQJ,EAAUyJ,MAAQrJ,EAC/B,IAAIe,EAAUnB,EAAUmB,QAGxB,OAFAA,EAAQzH,KAAKxC,MACbiK,EAAQ6I,KAAKF,EAAcG,cACpB,GAEXH,EAAc3Q,UAAUsH,eAAiB,SAAUT,EAAWQ,EAAIJ,QAChD,IAAVA,IAAoBA,EAAQ,IAGpC0J,EAAc3Q,UAAU6H,SAAW,SAAUb,EAAOC,GAChD,IAAoB,IAAhBlJ,KAAK0K,OACL,OAAOtK,EAAO6B,UAAU6H,SAASvJ,KAAKP,KAAMiJ,EAAOC,IAG3D0J,EAAcG,YAAc,SAAUC,EAAGC,GACrC,OAAID,EAAE9J,QAAU+J,EAAE/J,MACV8J,EAAE7Q,QAAU8Q,EAAE9Q,MACP,EAEF6Q,EAAE7Q,MAAQ8Q,EAAE9Q,MACV,GAGC,EAGP6Q,EAAE9J,MAAQ+J,EAAE/J,MACV,GAGC,GAGT0J,EA9DuB,CA+DhC1I,EAAcd,aAChB/K,EAAQuU,cAAgBA,IAG5BzU,OAAO,8BAA8B,UAAW,UAAW,QAAS,gBAAiB,kBAAmB,mBAAoB,kBAAmB,oBAAqB,qCAAsC,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcoE,EAAgBgH,EAAkBC,EAAiBlC,EAAmBmC,GAC/T,aACA9U,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAI6U,EAAkB,IAClBC,EAA+B,SAAUlT,GAEzC,SAASkT,EAAcC,GACnB,IAAIjT,EAAQF,EAAOG,KAAKP,KAAMoT,EAAuBR,cAAeS,IAAoBrT,KAKxF,OAJAM,EAAMiT,gBAAkBA,EACxBjT,EAAMkT,kBACNlT,EAAMmT,mBACNnT,EAAMoT,cACCpT,EAuMX,OA9MAJ,EAAQc,UAAUsS,EAAelT,GASjCkT,EAAcrR,UAAU0R,WAAa,SAAUC,GAC3C,IAAI3Q,EAAU2Q,EAAQ3Q,QAAQ,KAC9B,IAAiB,IAAbA,EACA,MAAM,IAAI/D,MAAM,+DAEpB,OAAO+D,EAAUqQ,EAAcT,iBAEnCS,EAAcrR,UAAU4R,qBAAuB,SAAUD,EAASE,EAAQxQ,GACtE,IAA8B,IAA1BsQ,EAAQ3Q,QAAQ,KAChB,MAAM,IAAI/D,MAAM,uDAEpB,IAA8B,IAA1B0U,EAAQ3Q,QAAQ,KAChB,MAAM,IAAI/D,MAAM,yDAEpB,IAAIiT,EAAWmB,EAAcS,aAAaH,EAASE,EAAQxQ,GACvD0Q,EAAO,IAAId,EAAiBhB,eAAeC,EAAUnS,MAEzD,OADAA,KAAKyT,gBAAgBjR,KAAKwR,GACnBA,GAEXV,EAAcrR,UAAUgS,oBAAsB,SAAUL,EAASE,EAAQxQ,GACrE,IAA8B,IAA1BsQ,EAAQ3Q,QAAQ,KAChB,MAAM,IAAI/D,MAAM,wDAEpB,IAAIiT,EAAWmB,EAAcS,aAAaH,EAASE,EAAQxQ,GACvDqE,EAAU,IAAIwL,EAAgBX,cAAcL,EAAUnS,MAE1D,OADAA,KAAKwT,eAAehR,KAAKmF,GAClBA,GAEX2L,EAAcrR,UAAUiS,2BAA6B,SAAUvO,EAAYwO,GACvE,IAAI7T,EAAQN,KACRmS,KAQJ,OAPAxM,EAAWa,UAAU,SAAUhI,GAC3B2T,EAAS3P,MAAO+P,MAAOjS,EAAMiS,MAAQ4B,EAAY3H,aAAcN,EAAef,aAAaU,WAAWrN,MACvG,SAAUgC,GACT2R,EAAS3P,MAAO+P,MAAOjS,EAAMiS,MAAQ4B,EAAY3H,aAAcN,EAAef,aAAaY,YAAYvL,MACxG,WACC2R,EAAS3P,MAAO+P,MAAOjS,EAAMiS,MAAQ4B,EAAY3H,aAAcN,EAAef,aAAaa,qBAExFmG,GAEXmB,EAAcrR,UAAUmS,iBAAmB,SAAUzO,EAAY0O,GAC7D,IAAI/T,EAAQN,UACkB,IAA1BqU,IAAoCA,EAAwB,MAChE,IAIIzR,EAJA0R,KACAC,GAAcD,OAAQA,EAAQE,OAAO,GACrCC,EAAsBnB,EACrBoB,4BAA4BL,GAAuBrD,kBAoBxD,OAlBAhR,KAAKgJ,SAAS,WACVpG,EAAe+C,EAAWa,UAAU,SAAUpH,GAC1C,IAAIZ,EAAQY,EAERA,aAAa0I,EAAavB,aAC1B/H,EAAQ8B,EAAM4T,2BAA2B1V,EAAO8B,EAAMiS,QAE1D+B,EAAO9R,MAAO+P,MAAOjS,EAAMiS,MAAO/F,aAAcN,EAAef,aAAaU,WAAWrN,MACxF,SAAUgC,GACT8T,EAAO9R,MAAO+P,MAAOjS,EAAMiS,MAAO/F,aAAcN,EAAef,aAAaY,YAAYvL,MACzF,WACC8T,EAAO9R,MAAO+P,MAAOjS,EAAMiS,MAAO/F,aAAcN,EAAef,aAAaa,sBAEjF,GACCyI,IAAwBzH,OAAOC,mBAC/BjN,KAAKgJ,SAAS,WAAc,OAAOpG,EAAajB,eAAkB8S,GAEtEzU,KAAK0T,WAAWlR,KAAK+R,IAEjBI,KAAM,SAAUf,EAASE,EAAQ9J,GAC7BuK,EAAUC,OAAQ,EAClBD,EAAUK,SAAWtB,EAAcS,aAAaH,EAASE,EAAQ9J,GAAY,MAIzFsJ,EAAcrR,UAAU4S,oBAAsB,SAAUC,GACpD,IAAIP,GAAcD,OAAQQ,EAAwBN,OAAO,GAEzD,OADAxU,KAAK0T,WAAWlR,KAAK+R,IAEjBI,KAAM,SAAUf,GACZ,IAAImB,EAAmC,iBAAZnB,GAAyBA,GAAWA,EAC/DW,EAAUC,OAAQ,EAClBD,EAAUK,SAAWG,EAAatU,IAAI,SAAUmT,GAC5C,OAAON,EAAcoB,4BAA4Bd,QAKjEN,EAAcrR,UAAUyH,MAAQ,WAE5B,IADA,IAAI8J,EAAiBxT,KAAKwT,eACnBA,EAAejU,OAAS,GAC3BiU,EAAe3I,QAAQ4H,QAE3BrS,EAAO6B,UAAUyH,MAAMnJ,KAAKP,MAE5B,IADA,IAAIgV,EAAkBhV,KAAK0T,WAAWuB,OAAO,SAAUC,GAAQ,OAAOA,EAAKV,QACpEQ,EAAgBzV,OAAS,GAAG,CAC/B,IAAI2V,EAAOF,EAAgBnK,QAC3B7K,KAAKuT,gBAAgB2B,EAAKZ,OAAQY,EAAKN,YAG/CtB,EAAcoB,4BAA8B,SAAUd,GAClD,GAAuB,iBAAZA,EACP,OAAO,IAAI3C,EAAkBH,gBAAgB9D,OAAOC,mBAMxD,IAAK,IAJD7K,EAAMwR,EAAQrU,OACd4V,GAAc,EACdC,EAAoBpI,OAAOC,kBAC3BwH,EAAsBzH,OAAOC,kBACxBvM,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAI6R,EAAQ7R,EAAIV,KAAK6S,gBACjBwC,EAAIzB,EAAQlT,GAChB,OAAQ2U,GACJ,IAAK,IACL,IAAK,IACD,MACJ,IAAK,IACDF,EAAa5C,EACb,MACJ,IAAK,IACD4C,GAAc,EACd,MACJ,IAAK,IACD,GAAIC,IAAsBpI,OAAOC,kBAC7B,MAAM,IAAI/N,MAAM,kGAGpBkW,EAAoBD,GAAc,EAAIA,EAAa5C,EACnD,MACJ,IAAK,IACD,GAAIkC,IAAwBzH,OAAOC,kBAC/B,MAAM,IAAI/N,MAAM,kGAGpBuV,EAAsBU,GAAc,EAAIA,EAAa5C,EACrD,MACJ,QACI,MAAM,IAAIrT,MAAM,0FACsCmW,EAAI,OAGtE,OAAIZ,EAAsB,EACf,IAAIxD,EAAkBH,gBAAgBsE,GAGtC,IAAInE,EAAkBH,gBAAgBsE,EAAmBX,IAGxEnB,EAAcS,aAAe,SAAUH,EAASE,EAAQ9J,EAAYsL,GAEhE,QADoC,IAAhCA,IAA0CA,GAA8B,IAC9C,IAA1B1B,EAAQ3Q,QAAQ,KAChB,MAAM,IAAI/D,MAAM,0EAiBpB,IAAK,IAdDkD,EAAMwR,EAAQrU,OACdgW,KACAC,EAAW5B,EAAQ3Q,QAAQ,KAC3BwS,GAA4B,IAAdD,EAAkB,EAAKA,GAAYxV,KAAK6S,gBACtD7E,EAA6B,iBAAX8F,EAClB,SAAU1U,GAAK,OAAOA,GACtB,SAAUA,GAEN,OAAIkW,GAA+BxB,EAAO1U,aAAc8T,EAAiBhB,eAC9D4B,EAAO1U,GAAG+S,SAEd2B,EAAO1U,IAElB+V,GAAc,EACTzU,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAI6R,EAAQ7R,EAAIV,KAAK6S,gBAAkB4C,EACnCjJ,OAAe,EACf6I,EAAIzB,EAAQlT,GAChB,OAAQ2U,GACJ,IAAK,IACL,IAAK,IACD,MACJ,IAAK,IACDF,EAAa5C,EACb,MACJ,IAAK,IACD4C,GAAc,EACd,MACJ,IAAK,IACD3I,EAAeN,EAAef,aAAaa,iBAC3C,MACJ,IAAK,IACD,MACJ,IAAK,IACDQ,EAAeN,EAAef,aAAaY,YAAY/B,GAAc,SACrE,MACJ,QACIwC,EAAeN,EAAef,aAAaU,WAAWmC,EAASqH,IAGnE7I,GACA+I,EAAa/S,MAAO+P,MAAO4C,GAAc,EAAIA,EAAa5C,EAAO/F,aAAcA,IAGvF,OAAO+I,GAEJjC,EA/MuB,CAgNhCF,EAAuBV,sBACzBrU,EAAQiV,cAAgBA,IAG5BnV,OAAO,sCAAsC,UAAW,UAAW,QAAS,kBAAmB,sBAAuB,yBAA0B,mBAAoB,mBAAoB,uBAAwB,SAAUC,EAASC,EAAS6B,EAASsD,EAAQpC,EAAYzB,EAAemI,EAAcxC,EAAcqL,GAChT,aAuCA,SAAS+E,EAAQC,EAAKC,GAElB,YADgB,IAAZA,IAAsBA,EAAU,MAC7B,IAAIC,GAAiBC,OAAQ,MAAOH,IAAKA,EAAKC,QAASA,IAIlE,SAASG,EAASJ,EAAKK,EAAMJ,GACzB,OAAO,IAAIC,GAAiBC,OAAQ,OAAQH,IAAKA,EAAKK,KAAMA,EAAMJ,QAASA,IAI/E,SAASK,EAAWN,EAAKC,GACrB,OAAO,IAAIC,GAAiBC,OAAQ,SAAUH,IAAKA,EAAKC,QAASA,IAIrE,SAASM,EAAQP,EAAKK,EAAMJ,GACxB,OAAO,IAAIC,GAAiBC,OAAQ,MAAOH,IAAKA,EAAKK,KAAMA,EAAMJ,QAASA,IAI9E,SAASO,EAAUR,EAAKK,EAAMJ,GAC1B,OAAO,IAAIC,GAAiBC,OAAQ,QAASH,IAAKA,EAAKK,KAAMA,EAAMJ,QAASA,IAKhF,SAASQ,EAAYT,EAAKC,GACtB,OAAOS,EAAY,IAAIR,GACnBC,OAAQ,MACRH,IAAKA,EACLW,aAAc,OACdV,QAASA,KA0TjB,SAASW,EAAiBD,EAAcE,GACpC,OAAQF,GACJ,IAAK,OACD,MAAI,aAAcE,EAEPA,EAAIF,aAAeE,EAAIC,SAAWC,KAAKC,MAAMH,EAAIC,UAAYD,EAAII,cAAgB,QAGjFF,KAAKC,MAAMH,EAAII,cAAgB,QAE9C,IAAK,MACD,OAAOJ,EAAIK,YACf,IAAK,OACL,QACI,MAAQ,aAAcL,EAAOA,EAAIC,SAAWD,EAAII,cA9Y5DtY,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA0CtDH,EAAQqX,QAAUA,EAKlBrX,EAAQ0X,SAAWA,EAKnB1X,EAAQ4X,WAAaA,EAKrB5X,EAAQ6X,QAAUA,EAKlB7X,EAAQ8X,UAAYA,EAEpB,IAAIE,EAAc1F,EAAMlQ,IAAI,SAAUrB,EAAG+C,GAAS,OAAO/C,EAAEqX,WAS3DpY,EAAQ+X,YAAcA,EAOtB,IAAIP,EAAgC,SAAUzV,GAE1C,SAASyV,EAAeiB,GACpB,IAAIxW,EAAQF,EAAOG,KAAKP,OAASA,KAC7B+W,GACArH,OAAO,EACPsH,UAAW,WACP,OAAOhX,KAAKiX,YAtF5B,WACI,GAAIzT,EAAOvE,KAAKiY,eACZ,OAAO,IAAI1T,EAAOvE,KAAKiY,eAEtB,GAAM1T,EAAOvE,KAAKkY,eACnB,OAAO,IAAI3T,EAAOvE,KAAKkY,eAGvB,MAAM,IAAIjY,MAAM,0CA8EiCqB,KAAKP,MA3E9D,WACI,GAAIwD,EAAOvE,KAAKiY,eACZ,OAAO,IAAI1T,EAAOvE,KAAKiY,eAGvB,IAAIE,OAAS,EACb,IAEI,IAAK,IADDC,GAAW,iBAAkB,oBAAqB,sBAC7C3W,EAAI,EAAGA,EAAI,EAAGA,IACnB,IAEI,GADA0W,EAASC,EAAQ3W,GACb,IAAI8C,EAAOvE,KAAKqY,cAAcF,GAC9B,MAGR,MAAO1X,IAIX,OAAO,IAAI8D,EAAOvE,KAAKqY,cAAcF,GAEzC,MAAO1X,GACH,MAAM,IAAIR,MAAM,oDAqD0CqY,IAE1DN,aAAa,EACbO,iBAAiB,EACjB5B,WACAE,OAAQ,MACRQ,aAAc,OACdmB,QAAS,GAEb,GAA4B,iBAAjBX,EACPC,EAAQpB,IAAMmB,OAGd,IAAK,IAAIY,KAAQZ,EACTA,EAAaa,eAAeD,KAC5BX,EAAQW,GAAQZ,EAAaY,IAKzC,OADApX,EAAMyW,QAAUA,EACTzW,EA2CX,OArEAJ,EAAQc,UAAU6U,EAAgBzV,GA4BlCyV,EAAe5T,UAAUyE,WAAa,SAAUjC,GAC5C,OAAO,IAAImT,EAAenT,EAAYzE,KAAK+W,UA4B/ClB,EAAerR,OAAS,WACpB,IAAIA,EAAS,SAAUsS,GACnB,OAAO,IAAIjB,EAAeiB,IAQ9B,OANAtS,EAAOuJ,IAAM2H,EACblR,EAAOqT,KAAO9B,EACdvR,EAAOsT,OAAS7B,EAChBzR,EAAOuT,IAAM7B,EACb1R,EAAOwT,MAAQ7B,EACf3R,EAAOyT,QAAU7B,EACV5R,EAVa,GAYjBqR,EAtEwB,CAuEjC/N,EAAavB,YACflI,EAAQwX,eAAiBA,EAMzB,IAAI+B,EAAgC,SAAUxX,GAE1C,SAASwX,EAAetT,EAAayS,GACjC,IAAIzW,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAC9CM,EAAMyW,QAAUA,EAChBzW,EAAM4X,MAAO,EACb,IAAItC,EAAUmB,EAAQnB,QAAUmB,EAAQnB,YAYxC,OAVKmB,EAAQE,aAAgBrB,EAAQ,sBACjCA,EAAQ,oBAAsB,kBAG5B,iBAAkBA,GAAcpS,EAAOvE,KAAKkZ,UAAYpB,EAAQf,gBAAgBxS,EAAOvE,KAAKkZ,eAAqC,IAAjBpB,EAAQf,OAC1HJ,EAAQ,gBAAkB,oDAG9BmB,EAAQf,KAAO1V,EAAM8X,cAAcrB,EAAQf,KAAMe,EAAQnB,QAAQ,iBACjEtV,EAAM+X,OACC/X,EAoKX,OArLAJ,EAAQc,UAAU4W,EAAgBxX,GAmBlCwX,EAAe3V,UAAUoB,KAAO,SAAU3D,GACtCM,KAAKkY,MAAO,EACZ,IAAe1B,EAANxW,KAAewW,IAAKO,EAApB/W,KAAiC+W,QAASzS,EAA1CtE,KAA2DsE,YAChEmS,EAAW,IAAI6B,EAAa5Y,EAAG8W,EAAKO,GACxCzS,EAAYjB,KAAKoT,IAErBmB,EAAe3V,UAAUoW,KAAO,WAC5B,IAAetB,EAAN/W,KAAmB+W,QAASwB,EAA5BvY,KAAoC+W,QAASyB,EAAOD,EAAGC,KAAM1C,EAASyC,EAAGzC,OAAQH,EAAM4C,EAAG5C,IAAKjG,EAAQ6I,EAAG7I,MAAO+I,EAAWF,EAAGE,SAAU7C,EAAU2C,EAAG3C,QAASI,EAAOuC,EAAGvC,KAC9KgB,EAAYD,EAAQC,UACpBR,EAAMpV,EAAWvB,SAASmX,GAAWzW,KAAKwW,GAC9C,GAAIP,IAAQ7W,EAAcF,YACtBO,KAAKsD,MAAM3D,EAAcF,YAAYC,OAEpC,CACDM,KAAKwW,IAAMA,EAKXxW,KAAK0Y,YAAYlC,EAAKO,GAStB,IANIyB,EACSpX,EAAWvB,SAAS2W,EAAImC,MAAMpY,KAAKiW,EAAKV,EAAQH,EAAKjG,EAAO8I,EAAMC,GAGlErX,EAAWvB,SAAS2W,EAAImC,MAAMpY,KAAKiW,EAAKV,EAAQH,EAAKjG,MAEnD/P,EAAcF,YAEzB,OADAO,KAAKsD,MAAM3D,EAAcF,YAAYC,GAC9B,KAcX,GAXIgQ,IACA8G,EAAIiB,QAAUV,EAAQU,QACtBjB,EAAIF,aAAeS,EAAQT,cAE3B,oBAAqBE,IACrBA,EAAIgB,kBAAoBT,EAAQS,iBAGpCxX,KAAK4Y,WAAWpC,EAAKZ,IAEZI,EAAO5U,EAAWvB,SAAS2W,EAAI6B,MAAM9X,KAAKiW,EAAKR,GAAQ5U,EAAWvB,SAAS2W,EAAI6B,MAAM9X,KAAKiW,MACpF7W,EAAcF,YAEzB,OADAO,KAAKsD,MAAM3D,EAAcF,YAAYC,GAC9B,KAGf,OAAO8W,GAEXoB,EAAe3V,UAAUmW,cAAgB,SAAUpC,EAAM6C,GACrD,IAAK7C,GAAwB,iBAATA,EAChB,OAAOA,EAEN,GAAIxS,EAAOvE,KAAKkZ,UAAYnC,aAAgBxS,EAAOvE,KAAKkZ,SACzD,OAAOnC,EAEX,GAAI6C,EAAa,CACb,IAAIC,EAAaD,EAAY5V,QAAQ,MACjB,IAAhB6V,IACAD,EAAcA,EAAYE,UAAU,EAAGD,IAG/C,OAAQD,GACJ,IAAK,oCACD,OAAOva,OAAO0a,KAAKhD,GAAMvV,IAAI,SAAUwY,GAAO,OAAOC,UAAUD,GAAO,IAAMC,UAAUlD,EAAKiD,MAAUrY,KAAK,KAC9G,IAAK,mBACD,OAAO8V,KAAKyC,UAAUnD,GAC1B,QACI,OAAOA,IAGnB4B,EAAe3V,UAAU2W,WAAa,SAAUpC,EAAKZ,GACjD,IAAK,IAAIqD,KAAOrD,EACRA,EAAQ+B,eAAesB,IACvBzC,EAAI4C,iBAAiBH,EAAKrD,EAAQqD,KAI9CrB,EAAe3V,UAAUyW,YAAc,SAAUlC,EAAKO,GAElD,SAASsC,EAAW3Z,GAChB,IAAI4S,EAAK+G,EAAY5U,EAAa6N,EAAG7N,WAAY6U,EAAqBhH,EAAGgH,mBAAoBvC,EAAUzE,EAAGyE,QACtGuC,GACAA,EAAmBhW,MAAM5D,GAE7B+E,EAAWnB,MAAM,IAAIiW,EAAiBvZ,KAAM+W,IAmChD,SAASyC,EAAoB9Z,GACzB,IAAI4S,EAAKkH,EAAqB/U,EAAa6N,EAAG7N,WAAY6U,EAAqBhH,EAAGgH,mBAAoBvC,EAAUzE,EAAGyE,QACnH,GAAwB,IAApB/W,KAAKyZ,WAAkB,CAEvB,IAAIC,EAA2B,OAAhB1Z,KAAK2Z,OAAkB,IAAM3Z,KAAK2Z,OAC7ClD,EAAkC,SAAtBzW,KAAKsW,aAA2BtW,KAAKyW,UAAYzW,KAAK4W,aAAgB5W,KAAKyW,SAI1E,IAAbiD,IACAA,EAAWjD,EAAW,IAAM,GAE5B,KAAOiD,GAAYA,EAAW,KAC1BJ,GACAA,EAAmB/V,WAEvBkB,EAAWpB,KAAK3D,GAChB+E,EAAWlB,aAGP+V,GACAA,EAAmBhW,MAAM5D,GAE7B+E,EAAWnB,MAAM,IAAIsW,EAAU,cAAgBF,EAAU1Z,KAAM+W,MAhE3E,IAAIuC,EAAqBvC,EAAQuC,mBAajC,GAJA9C,EAAIqD,UAAYR,EAChBA,EAAWtC,QAAUA,EACrBsC,EAAW5U,WAAazE,KACxBqZ,EAAWC,mBAAqBA,EAC5B9C,EAAIsD,QAAU,oBAAqBtD,EAAK,CACxC,GAAI8C,EAAoB,CACpB,IAAIS,EACJA,EAAgB,SAAUra,GACGqa,EAAcT,mBACpBjW,KAAK3D,IAExB8D,EAAOvE,KAAKkY,eACZX,EAAIwD,WAAaD,EAGjBvD,EAAIsD,OAAOE,WAAaD,EAE5BA,EAAcT,mBAAqBA,EAEvC,IAAIW,EACJA,EAAa,SAAUva,GACnB,IAAI4S,EAAK2H,EAAYX,EAAqBhH,EAAGgH,mBAAoB7U,EAAa6N,EAAG7N,WAAYsS,EAAUzE,EAAGyE,QACtGuC,GACAA,EAAmBhW,MAAM5D,GAE7B+E,EAAWnB,MAAM,IAAIsW,EAAU,aAAc5Z,KAAM+W,KAEvDP,EAAI0D,QAAUD,EACdA,EAAWlD,QAAUA,EACrBkD,EAAWxV,WAAazE,KACxBia,EAAWX,mBAAqBA,EA8BpC9C,EAAI2D,mBAAqBX,EACzBA,EAAoB/U,WAAazE,KACjCwZ,EAAoBF,mBAAqBA,EACzCE,EAAoBzC,QAAUA,GAElCa,EAAe3V,UAAUN,YAAc,WACnC,IAAeuW,EAANlY,KAAgBkY,KAAM1B,EAAtBxW,KAA+BwW,KACnC0B,GAAQ1B,GAA0B,IAAnBA,EAAIiD,YAAyC,mBAAdjD,EAAI4D,OACnD5D,EAAI4D,QAERha,EAAO6B,UAAUN,YAAYpB,KAAKP,OAE/B4X,EAtLwB,CAuLjCtS,EAAatB,YACf3F,EAAQuZ,eAAiBA,EAQzB,IAAIU,EAA8B,WAS9B,OARA,SAAsB+B,EAAe7D,EAAKO,GACtC/W,KAAKqa,cAAgBA,EACrBra,KAAKwW,IAAMA,EACXxW,KAAK+W,QAAUA,EACf/W,KAAK2Z,OAASnD,EAAImD,OAClB3Z,KAAKsW,aAAeE,EAAIF,cAAgBS,EAAQT,aAChDtW,KAAKyW,SAAWF,EAAiBvW,KAAKsW,aAAcE,IAP3B,GAWjCnY,EAAQia,aAAeA,EAQvB,IAAIsB,EAA2B,SAAUxZ,GAErC,SAASwZ,EAAU7Y,EAASyV,EAAKO,GAC7B,IAAIzW,EAAQF,EAAOG,KAAKP,KAAMe,IAAYf,KAO1C,OANAM,EAAMS,QAAUA,EAChBT,EAAMkW,IAAMA,EACZlW,EAAMyW,QAAUA,EAChBzW,EAAMqZ,OAASnD,EAAImD,OACnBrZ,EAAMgW,aAAeE,EAAIF,cAAgBS,EAAQT,aACjDhW,EAAMmW,SAAWF,EAAiBjW,EAAMgW,aAAcE,GAC/ClW,EAEX,OAXAJ,EAAQc,UAAU4Y,EAAWxZ,GAWtBwZ,EAZmB,CAa5B1a,OACFb,EAAQub,UAAYA,EAuBpB,IAAIL,EAAkC,SAAUnZ,GAE5C,SAASmZ,EAAiB/C,EAAKO,GAC3B,OAAO3W,EAAOG,KAAKP,KAAM,eAAgBwW,EAAKO,IAAY/W,KAE9D,OAJAE,EAAQc,UAAUuY,EAAkBnZ,GAI7BmZ,EAL0B,CAMnCK,GACFvb,EAAQkb,iBAAmBA,IAM/Bpb,OAAO,uBAAuB,UAAW,UAAW,UAAW,SAAUC,EAASC,EAASmF,GACvF,aACAlF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAI8b,EAAqC,WACrC,SAASA,EAAoBrb,GAEzB,GADAe,KAAKf,KAAOA,EACRA,EAAKsb,cAA6C,mBAAtBtb,EAAKsb,aACjCva,KAAKua,aAAetb,EAAKsb,aAAatV,KAAKhG,GAC3Ce,KAAKwa,eAAiBvb,EAAKub,eAAevV,KAAKhG,OAE9C,CACDe,KAAKya,WAAa,EAClBza,KAAK0a,iBACL1a,KAAK2a,uBAAwB,EAEzB3a,KAAK4a,wBAEL5a,KAAKua,aAAeva,KAAK6a,oCAEpB7a,KAAK8a,oBAEV9a,KAAKua,aAAeva,KAAK+a,gCAEpB/a,KAAKgb,uBAEVhb,KAAKua,aAAeva,KAAKib,mCAEpBjb,KAAKkb,yBAEVlb,KAAKua,aAAeva,KAAKmb,qCAIzBnb,KAAKua,aAAeva,KAAKob,+BAE7B,IAAIC,EAAK,SAASb,EAAec,UACtBd,EAAee,SAASb,cAAcY,IAEjDD,EAAGE,SAAWvb,KACdA,KAAKwa,eAAiBa,GAmK9B,OAhKAf,EAAoBrY,UAAUuZ,SAAW,SAAUC,GAC/C,OAAOzb,KAAKf,KAAKX,OAAO2D,UAAUtB,SAASJ,KAAKkb,IAEpDnB,EAAoBrY,UAAU2Y,sBAAwB,WAClD,MAA4C,qBAArC5a,KAAKwb,SAASxb,KAAKf,KAAKyc,UAEnCpB,EAAoBrY,UAAU+Y,qBAAuB,WACjD,OAAOW,QAAQ3b,KAAKf,KAAK2c,iBAE7BtB,EAAoBrY,UAAUiZ,uBAAyB,WACnD,IAAIW,EAAW7b,KAAKf,KAAK4c,SACzB,OAAOF,QAAQE,GAAY,uBAAwBA,EAASC,cAAc,YAE9ExB,EAAoBrY,UAAU6Y,kBAAoB,WAC9C,IAAI7b,EAAOe,KAAKf,KAGhB,GAAIA,EAAK8c,cAAgB9c,EAAK+c,cAAe,CACzC,IAAIC,GAA8B,EAC9BC,EAAejd,EAAKkd,UAMxB,OALAld,EAAKkd,UAAY,WACbF,GAA8B,GAElChd,EAAK8c,YAAY,GAAI,KACrB9c,EAAKkd,UAAYD,EACVD,EAEX,OAAO,GAIX3B,EAAoBrY,UAAUma,iBAAmB,SAAUC,GAEvD,IAAK,IADDC,KACKnW,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCmW,EAAKnW,EAAK,GAAKlG,UAAUkG,GAE7B,IAAIrG,EAAK,SAAS4Q,IACd,IAAI4B,EAAK5B,EAAQ2L,EAAU/J,EAAG+J,QAASC,EAAOhK,EAAGgK,KAC1B,mBAAZD,EACPA,EAAQtc,WAAM6J,EAAW0S,GAGzB,IAAKC,SAAS,GAAKF,EAAnB,IAKR,OAFAvc,EAAGuc,QAAUA,EACbvc,EAAGwc,KAAOA,EACHxc,GAEXwa,EAAoBrY,UAAUua,6BAA+B,SAAUF,GAEnE,OADAtc,KAAK0a,cAAc1a,KAAKya,YAAcza,KAAKoc,iBAAiBrc,WAAM6J,EAAW0S,GACtEtc,KAAKya,cAEhBH,EAAoBrY,UAAU4Y,kCAAoC,WAC9D,IAAI/a,EAAK,SAASya,IACd,IAAIgB,EAAWhB,EAAagB,SACxBD,EAASC,EAASiB,6BAA6Bvc,WAEnD,OADAsb,EAAStc,KAAKyc,QAAQe,SAASlB,EAASa,iBAAiBb,EAASmB,aAAcpB,IACzEA,GAGX,OADAxb,EAAGyb,SAAWvb,KACPF,GAEXwa,EAAoBrY,UAAU8Y,8BAAgC,WAI1D,IAAI9b,EAAOe,KAAKf,KACZ0d,EAAgB,gBAAkB1d,EAAK0O,KAAKiP,SAAW,IACvDC,EAAkB,SAASC,EAAqBC,GAChD,IAAIxB,EAAWuB,EAAqBvB,SAChCwB,EAAMlW,SAAW5H,GACK,iBAAf8d,EAAMC,MACyB,IAAtCD,EAAMC,KAAK/Z,QAAQ0Z,IACnBpB,EAASmB,cAAcK,EAAMC,KAAKzU,MAAMoU,EAAcpd,UAG9Dsd,EAAgBtB,SAAWvb,KAC3Bf,EAAKge,iBAAiB,UAAWJ,GAAiB,GAClD,IAAI/c,EAAK,SAASya,IACd,IAAIjI,EAAKiI,EAAcoC,EAAgBrK,EAAGqK,cAAepB,EAAWjJ,EAAGiJ,SACnED,EAASC,EAASiB,6BAA6Bvc,WAEnD,OADAsb,EAAStc,KAAK8c,YAAYY,EAAgBrB,EAAQ,KAC3CA,GAIX,OAFAxb,EAAGyb,SAAWvb,KACdF,EAAG6c,cAAgBA,EACZ7c,GAEXwa,EAAoBrY,UAAUya,aAAe,SAAUpB,GAGnD,GAAItb,KAAK2a,sBAGL3a,KAAKf,KAAKie,WAAWld,KAAKoc,iBAAiBpc,KAAK0c,aAAcpB,GAAS,OAEtE,CACD,IAAI6B,EAAOnd,KAAK0a,cAAcY,GAC9B,GAAI6B,EAAM,CACNnd,KAAK2a,uBAAwB,EAC7B,IACIwC,IAEJ,QACInd,KAAKwa,eAAec,GACpBtb,KAAK2a,uBAAwB,MAK7CL,EAAoBrY,UAAUgZ,iCAAmC,WAC7D,IAAI3a,EAAQN,KACRod,EAAU,IAAIpd,KAAKf,KAAK2c,eAC5BwB,EAAQC,MAAMlB,UAAY,SAAUY,GAChC,IAAIzB,EAASyB,EAAMC,KACnB1c,EAAMoc,aAAapB,IAEvB,IAAIxb,EAAK,SAASya,IACd,IAAIjI,EAAKiI,EAAc6C,EAAU9K,EAAG8K,QAChC9B,EADoDhJ,EAAGiJ,SACrCiB,6BAA6Bvc,WAEnD,OADAmd,EAAQE,MAAMvB,YAAYT,GACnBA,GAIX,OAFAxb,EAAGsd,QAAUA,EACbtd,EAAGyb,SAAWvb,KACPF,GAEXwa,EAAoBrY,UAAUkZ,mCAAqC,WAC/D,IAAIrb,EAAK,SAASya,IACd,IAAIgB,EAAWhB,EAAagB,SAExBgC,EADOhC,EAAStc,KACL4c,SACX2B,EAAOD,EAAIE,gBACXnC,EAASC,EAASiB,6BAA6Bvc,WAG/Cyd,EAASH,EAAIzB,cAAc,UAQ/B,OAPA4B,EAAOvD,mBAAqB,WACxBoB,EAASmB,aAAapB,GACtBoC,EAAOvD,mBAAqB,KAC5BqD,EAAKG,YAAYD,GACjBA,EAAS,MAEbF,EAAKI,YAAYF,GACVpC,GAGX,OADAxb,EAAGyb,SAAWvb,KACPF,GAEXwa,EAAoBrY,UAAUmZ,6BAA+B,WACzD,IAAItb,EAAK,SAASya,IACd,IAAIgB,EAAWhB,EAAagB,SACxBD,EAASC,EAASiB,6BAA6Bvc,WAEnD,OADAsb,EAAStc,KAAKie,WAAW3B,EAASa,iBAAiBb,EAASmB,aAAcpB,GAAS,GAC5EA,GAGX,OADAxb,EAAGyb,SAAWvb,KACPF,GAEJwa,EAvM6B,GAyMxCjc,EAAQic,oBAAsBA,EAC9Bjc,EAAQwf,UAAY,IAAIvD,EAAoB9W,EAAOvE,QAGvDd,OAAO,6BAA6B,UAAW,UAAW,QAAS,oBAAqB,iBAAkB,SAAUC,EAASC,EAAS6B,EAAS4d,EAAa5T,GACxJ,aACA5L,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIuf,EAA4B,SAAU3d,GAEtC,SAAS2d,EAAWjV,EAAWC,GAC3B,IAAIzI,EAAQF,EAAOG,KAAKP,KAAM8I,EAAWC,IAAS/I,KAGlD,OAFAM,EAAMwI,UAAYA,EAClBxI,EAAMyI,KAAOA,EACNzI,EAiCX,OAtCAJ,EAAQc,UAAU+c,EAAY3d,GAO9B2d,EAAW9b,UAAUuH,eAAiB,SAAUV,EAAWQ,EAAIJ,GAG3D,YAFc,IAAVA,IAAoBA,EAAQ,GAElB,OAAVA,GAAkBA,EAAQ,EACnB9I,EAAO6B,UAAUuH,eAAejJ,KAAKP,KAAM8I,EAAWQ,EAAIJ,IAGrEJ,EAAUmB,QAAQzH,KAAKxC,MAIhB8I,EAAU6B,YAAc7B,EAAU6B,UAAYmT,EAAYD,UAAUtD,aAAazR,EAAUY,MAAMzE,KAAK6D,EAAW,UAE5HiV,EAAW9b,UAAUsH,eAAiB,SAAUT,EAAWQ,EAAIJ,GAK3D,QAJc,IAAVA,IAAoBA,EAAQ,GAIjB,OAAVA,GAAkBA,EAAQ,GAAiB,OAAVA,GAAkBlJ,KAAKkJ,MAAQ,EACjE,OAAO9I,EAAO6B,UAAUsH,eAAehJ,KAAKP,KAAM8I,EAAWQ,EAAIJ,GAKpC,IAA7BJ,EAAUmB,QAAQ1K,SAClBue,EAAYD,UAAUrD,eAAelR,GACrCR,EAAU6B,eAAYf,IAKvBmU,EAvCoB,CAwC7B7T,EAAcd,aAChB/K,EAAQ0f,WAAaA,IAGzB5f,OAAO,gCAAgC,UAAW,UAAW,QAAS,oBAAqB,SAAUC,EAASC,EAAS6B,EAAS4K,GAC5H,aACAxM,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIwf,EAA+B,SAAU5d,GAEzC,SAAS4d,IACL,OAAkB,OAAX5d,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAuB/D,OAzBAE,EAAQc,UAAUgd,EAAe5d,GAIjC4d,EAAc/b,UAAUyH,MAAQ,SAAUkB,GACtC5K,KAAK0K,QAAS,EACd1K,KAAK2K,eAAYf,EACjB,IACItG,EADA2G,EAAUjK,KAAKiK,QAEf9H,GAAS,EACTsO,EAAQxG,EAAQ1K,OACpBqL,EAASA,GAAUX,EAAQY,QAC3B,GACI,GAAIvH,EAAQsH,EAAOf,QAAQe,EAAO3B,MAAO2B,EAAO1B,OAC5C,cAEG/G,EAAQsO,IAAU7F,EAASX,EAAQY,UAE9C,GADA7K,KAAK0K,QAAS,EACVpH,EAAO,CACP,OAASnB,EAAQsO,IAAU7F,EAASX,EAAQY,UACxCD,EAAOjJ,cAEX,MAAM2B,IAGP0a,EA1BuB,CA2BhClT,EAAiBL,gBACnBpM,EAAQ2f,cAAgBA,IAG5B7f,OAAO,uBAAuB,UAAW,UAAW,eAAgB,mBAAoB,SAAUC,EAASC,EAAS4f,EAAcC,GAC9H,aACA5f,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAmCtDH,EAAQ8f,KAAO,IAAID,EAAgBF,cAAcC,EAAaF,cAGlE5f,OAAO,4BAA4B,UAAW,UAAW,UAAW,SAAUC,EAASC,EAASmF,GAC5F,aACAlF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAI4f,EAAiD,WA2BjD,OA1BA,SAAyCnf,GACjCA,EAAKof,uBACLre,KAAKse,qBAAuBrf,EAAKqf,qBAAqBrZ,KAAKhG,GAC3De,KAAKqe,sBAAwBpf,EAAKof,sBAAsBpZ,KAAKhG,IAExDA,EAAKsf,0BACVve,KAAKse,qBAAuBrf,EAAKuf,wBAAwBvZ,KAAKhG,GAC9De,KAAKqe,sBAAwBpf,EAAKsf,yBAAyBtZ,KAAKhG,IAE3DA,EAAKwf,6BACVze,KAAKse,qBAAuBrf,EAAKyf,2BAA2BzZ,KAAKhG,GACjEe,KAAKqe,sBAAwBpf,EAAKwf,4BAA4BxZ,KAAKhG,IAE9DA,EAAK0f,yBACV3e,KAAKse,qBAAuBrf,EAAK2f,uBAAuB3Z,KAAKhG,GAC7De,KAAKqe,sBAAwBpf,EAAK0f,wBAAwB1Z,KAAKhG,IAE1DA,EAAK4f,wBACV7e,KAAKse,qBAAuBrf,EAAK6f,sBAAsB7Z,KAAKhG,GAC5De,KAAKqe,sBAAwBpf,EAAK4f,uBAAuB5Z,KAAKhG,KAG9De,KAAKse,qBAAuBrf,EAAK8f,aAAa9Z,KAAKhG,GACnDe,KAAKqe,sBAAwB,SAAUW,GAAM,OAAO/f,EAAKie,WAAW8B,EAAI,IAAO,OAxBvC,GA6BpD3gB,EAAQ+f,gCAAkCA,EAC1C/f,EAAQ4gB,eAAiB,IAAIb,EAAgC5a,EAAOvE,QAGxEd,OAAO,uCAAuC,UAAW,UAAW,QAAS,gBAAiB,0BAA2B,SAAUC,EAASC,EAAS6B,EAASgK,EAAegV,GACzK,aACA5gB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI2gB,EAAsC,SAAU/e,GAEhD,SAAS+e,EAAqBrW,EAAWC,GACrC,IAAIzI,EAAQF,EAAOG,KAAKP,KAAM8I,EAAWC,IAAS/I,KAGlD,OAFAM,EAAMwI,UAAYA,EAClBxI,EAAMyI,KAAOA,EACNzI,EAiCX,OAtCAJ,EAAQc,UAAUme,EAAsB/e,GAOxC+e,EAAqBld,UAAUuH,eAAiB,SAAUV,EAAWQ,EAAIJ,GAGrE,YAFc,IAAVA,IAAoBA,EAAQ,GAElB,OAAVA,GAAkBA,EAAQ,EACnB9I,EAAO6B,UAAUuH,eAAejJ,KAAKP,KAAM8I,EAAWQ,EAAIJ,IAGrEJ,EAAUmB,QAAQzH,KAAKxC,MAIhB8I,EAAU6B,YAAc7B,EAAU6B,UAAYuU,EAAiBD,eAAeZ,sBAAsBvV,EAAUY,MAAMzE,KAAK6D,EAAW,UAE/IqW,EAAqBld,UAAUsH,eAAiB,SAAUT,EAAWQ,EAAIJ,GAKrE,QAJc,IAAVA,IAAoBA,EAAQ,GAIjB,OAAVA,GAAkBA,EAAQ,GAAiB,OAAVA,GAAkBlJ,KAAKkJ,MAAQ,EACjE,OAAO9I,EAAO6B,UAAUsH,eAAehJ,KAAKP,KAAM8I,EAAWQ,EAAIJ,GAKpC,IAA7BJ,EAAUmB,QAAQ1K,SAClB2f,EAAiBD,eAAeX,qBAAqBhV,GACrDR,EAAU6B,eAAYf,IAKvBuV,EAvC8B,CAwCvCjV,EAAcd,aAChB/K,EAAQ8gB,qBAAuBA,IAGnChhB,OAAO,0CAA0C,UAAW,UAAW,QAAS,oBAAqB,SAAUC,EAASC,EAAS6B,EAAS4K,GACtI,aACAxM,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAI4gB,EAAyC,SAAUhf,GAEnD,SAASgf,IACL,OAAkB,OAAXhf,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAuB/D,OAzBAE,EAAQc,UAAUoe,EAAyBhf,GAI3Cgf,EAAwBnd,UAAUyH,MAAQ,SAAUkB,GAChD5K,KAAK0K,QAAS,EACd1K,KAAK2K,eAAYf,EACjB,IACItG,EADA2G,EAAUjK,KAAKiK,QAEf9H,GAAS,EACTsO,EAAQxG,EAAQ1K,OACpBqL,EAASA,GAAUX,EAAQY,QAC3B,GACI,GAAIvH,EAAQsH,EAAOf,QAAQe,EAAO3B,MAAO2B,EAAO1B,OAC5C,cAEG/G,EAAQsO,IAAU7F,EAASX,EAAQY,UAE9C,GADA7K,KAAK0K,QAAS,EACVpH,EAAO,CACP,OAASnB,EAAQsO,IAAU7F,EAASX,EAAQY,UACxCD,EAAOjJ,cAEX,MAAM2B,IAGP8b,EA1BiC,CA2B1CtU,EAAiBL,gBACnBpM,EAAQ+gB,wBAA0BA,IAGtCjhB,OAAO,iCAAiC,UAAW,UAAW,yBAA0B,6BAA8B,SAAUC,EAASC,EAASghB,EAAwBC,GACtK,aACAhhB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+BtDH,EAAQkhB,eAAiB,IAAID,EAA0BF,wBAAwBC,EAAuBF,wBAG1GhhB,OAAO,wBAAwB,UAAW,UAAW,gBAAiB,SAAUC,EAASC,EAASmF,GAC9F,aAEA,SAASgc,EAAuBvgB,GAC5B,IAAIwE,EAASxE,EAAKwE,OAClB,GAAsB,mBAAXA,EAIP,OAHKA,EAAOgc,WACRhc,EAAOgc,SAAWhc,EAAO,sBAEtBA,EAAOgc,SAId,IAAIC,EAAQzgB,EAAK0gB,IACjB,GAAID,GAA8C,mBAA9B,IAAIA,GAAQ,cAC5B,MAAO,aAEX,IAAIE,EAAQ3gB,EAAK4gB,IAEjB,GAAID,EAEA,IAAK,IADD5G,EAAO1a,OAAOsT,oBAAoBgO,EAAM3d,WACnCvB,EAAI,EAAGA,EAAIsY,EAAKzZ,SAAUmB,EAAG,CAClC,IAAIuY,EAAMD,EAAKtY,GAEf,GAAY,YAARuY,GAA6B,SAARA,GAAkB2G,EAAM3d,UAAUgX,KAAS2G,EAAM3d,UAAmB,QACzF,OAAOgX,EAInB,MAAO,aA3Bf3a,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8BtDH,EAAQmhB,uBAAyBA,EACjCnhB,EAAQohB,SAAWD,EAAuBhc,EAAOvE,MAIjDZ,EAAQyhB,WAAazhB,EAAQohB,WAGjCthB,OAAO,wBAAwB,UAAW,UAAW,QAAS,gBAAiB,SAAUC,EAASC,EAAS6B,EAASoF,GAChH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIuhB,EAAiC,SAAU3f,GAE3C,SAAS2f,IACL,OAAkB,OAAX3f,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAW/D,OAbAE,EAAQc,UAAU+e,EAAiB3f,GAInC2f,EAAgB9d,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC7FrgB,KAAKsE,YAAYjB,KAAK6c,IAE1BH,EAAgB9d,UAAUqe,YAAc,SAAUhd,EAAO+c,GACrDrgB,KAAKsE,YAAYhB,MAAMA,IAE3Byc,EAAgB9d,UAAUse,eAAiB,SAAUF,GACjDrgB,KAAKsE,YAAYf,YAEdwc,EAdyB,CAelCza,EAAatB,YACf3F,EAAQ0hB,gBAAkBA,IAG9B5hB,OAAO,yBAAyB,UAAW,WAAY,SAAUC,EAASC,GACtE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQmiB,YAAc,SAAWphB,GAAK,OAAOA,GAAyB,iBAAbA,EAAEG,UAG/DpB,OAAO,uBAAuB,UAAW,WAAY,SAAUC,EAASC,GACpE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQoiB,UAHR,SAAmBjiB,GACf,OAAOA,GAAoC,mBAApBA,EAAMgI,WAAkD,mBAAfhI,EAAMkiB,QAK9EviB,OAAO,wBAAwB,UAAW,UAAW,QAAS,gBAAiB,SAAUC,EAASC,EAAS6B,EAASoF,GAChH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAImiB,EAAiC,SAAUvgB,GAE3C,SAASugB,EAAgBxd,EAAQ8c,EAAYE,GACzC,IAAI7f,EAAQF,EAAOG,KAAKP,OAASA,KAKjC,OAJAM,EAAM6C,OAASA,EACf7C,EAAM2f,WAAaA,EACnB3f,EAAM6f,WAAaA,EACnB7f,EAAM6B,MAAQ,EACP7B,EAaX,OApBAJ,EAAQc,UAAU2f,EAAiBvgB,GASnCugB,EAAgB1e,UAAUyC,MAAQ,SAAUlG,GACxCwB,KAAKmD,OAAO6c,WAAWhgB,KAAKigB,WAAYzhB,EAAOwB,KAAKmgB,WAAYngB,KAAKmC,QAASnC,OAElF2gB,EAAgB1e,UAAU0C,OAAS,SAAUrB,GACzCtD,KAAKmD,OAAOmd,YAAYhd,EAAOtD,MAC/BA,KAAK2B,eAETgf,EAAgB1e,UAAU2C,UAAY,WAClC5E,KAAKmD,OAAOod,eAAevgB,MAC3BA,KAAK2B,eAEFgf,EArByB,CAsBlCrb,EAAatB,YACf3F,EAAQsiB,gBAAkBA,IAG9BxiB,OAAO,+BAA+B,UAAW,UAAW,SAAU,gBAAiB,cAAe,aAAc,gBAAiB,qBAAsB,qBAAsB,wBAAyB,SAAUC,EAASC,EAASmF,EAAQod,EAAeC,EAAa3f,EAAY4G,EAAcgZ,EAAYC,EAAmB1a,GAC/T,aACA/H,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqEtDH,EAAQ2iB,kBApER,SAA2BC,EAAiBvQ,EAAQuP,EAAYE,GAC5D,IAAI7b,EAAc,IAAIyc,EAAkBJ,gBAAgBM,EAAiBhB,EAAYE,GACrF,GAAI7b,EAAY1C,OACZ,OAAO,KAEX,GAAI8O,aAAkB5I,EAAavB,WAC/B,OAAImK,EAAOjK,WACPnC,EAAYjB,KAAKqN,EAAOlS,OACxB8F,EAAYf,WACL,OAGPe,EAAYF,oBAAqB,EAC1BsM,EAAOlK,UAAUlC,IAG3B,GAAIsc,EAAcJ,YAAY9P,GAAS,CACxC,IAAK,IAAIhQ,EAAI,EAAG0B,EAAMsO,EAAOnR,OAAQmB,EAAI0B,IAAQkC,EAAY1C,OAAQlB,IACjE4D,EAAYjB,KAAKqN,EAAOhQ,IAEvB4D,EAAY1C,QACb0C,EAAYf,eAGf,CAAA,GAAIsd,EAAYJ,UAAU/P,GAW3B,OAVAA,EAAOgQ,KAAK,SAAUliB,GACb8F,EAAY1C,SACb0C,EAAYjB,KAAK7E,GACjB8F,EAAYf,aAEjB,SAAU/C,GAAO,OAAO8D,EAAYhB,MAAM9C,KACxCkgB,KAAK,KAAM,SAAUlgB,GAEtBgD,EAAOvE,KAAKie,WAAW,WAAc,MAAM1c,MAExC8D,EAEN,GAAIoM,GAAiD,mBAAhCA,EAAOoQ,EAAWrB,UAExC,IADA,IAAIA,EAAW/O,EAAOoQ,EAAWrB,cAC9B,CACC,IAAIyB,EAAOzB,EAASpc,OACpB,GAAI6d,EAAKhJ,KAAM,CACX5T,EAAYf,WACZ,MAGJ,GADAe,EAAYjB,KAAK6d,EAAK1iB,OAClB8F,EAAY1C,OACZ,WAIP,GAAI8O,GAAqD,mBAApCA,EAAOrK,EAAaV,YAA4B,CACtE,IAAIwb,EAAMzQ,EAAOrK,EAAaV,cAC9B,GAA6B,mBAAlBwb,EAAI3a,UAIX,OAAO2a,EAAI3a,UAAU,IAAIua,EAAkBJ,gBAAgBM,EAAiBhB,EAAYE,IAHxF7b,EAAYhB,MAAM,IAAIgN,UAAU,uEAMnC,CACD,IACI8Q,EAAM,iBADElgB,EAAW1B,SAASkR,GAAU,oBAAsB,IAAMA,EAAS,KAC3C,4FAEpCpM,EAAYhB,MAAM,IAAIgN,UAAU8Q,KAEpC,OAAO,QAKfjjB,OAAO,wBAAwB,UAAW,UAAW,QAAS,mBAAoB,sBAAuB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASkB,EAAYzB,EAAe0hB,EAAmBC,GAC5O,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQkjB,MALR,SAAeC,GACX,OAAO,SAA+B3a,GAClC,OAAOA,EAAOF,KAAK,IAAI8a,EAAcD,MAI7C,IAAIC,EAA+B,WAC/B,SAASA,EAAcD,GACnBxhB,KAAKwhB,iBAAmBA,EAK5B,OAHAC,EAAcxf,UAAU1B,KAAO,SAAUkE,EAAYoC,GACjD,OAAOA,EAAOL,UAAU,IAAIkb,EAAgBjd,EAAYzE,KAAKwhB,oBAE1DC,EAPuB,GAc9BC,EAAiC,SAAUthB,GAE3C,SAASshB,EAAgBpd,EAAakd,GAClC,IAAIlhB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMkhB,iBAAmBA,EACzBlhB,EAAM+K,UAAW,EACV/K,EAwCX,OA7CAJ,EAAQc,UAAU0gB,EAAiBthB,GAOnCshB,EAAgBzf,UAAUyC,MAAQ,SAAUlG,GAGxC,GAFAwB,KAAKxB,MAAQA,EACbwB,KAAKqL,UAAW,GACXrL,KAAK2hB,UAAW,CACjB,IAAIC,EAAWxgB,EAAWvB,SAASG,KAAKwhB,iBAAzBpgB,CAA2C5C,GAC1D,GAAIojB,IAAajiB,EAAcF,YAC3BO,KAAKsE,YAAYhB,MAAM3D,EAAcF,YAAYC,OAEhD,CACD,IAAImiB,EAAoBP,EAAoBN,kBAAkBhhB,KAAM4hB,GAChEC,EAAkBjgB,OAClB5B,KAAK8hB,gBAGL9hB,KAAKyC,IAAIzC,KAAK2hB,UAAYE,MAK1CH,EAAgBzf,UAAU6f,cAAgB,WACtC,IAAetjB,EAANwB,KAAiBxB,MAAO6M,EAAxBrL,KAAsCqL,SAAUsW,EAAhD3hB,KAA+D2hB,UACpEA,IACA3hB,KAAKqC,OAAOsf,GACZ3hB,KAAK2hB,UAAY,KACjBA,EAAUhgB,eAEV0J,IACArL,KAAKxB,MAAQ,KACbwB,KAAKqL,UAAW,EAChBrL,KAAKsE,YAAYjB,KAAK7E,KAG9BkjB,EAAgBzf,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,GACjFpgB,KAAK8hB,iBAETJ,EAAgBzf,UAAUse,eAAiB,WACvCvgB,KAAK8hB,iBAEFJ,EA9CyB,CA+ClCL,EAAkBtB,mBAGxB5hB,OAAO,uBAAuB,UAAW,UAAW,mBAAoB,SAAUC,EAASC,EAAS4C,GAChG,aACA3C,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAQtDH,EAAQ0jB,UAPR,SAAmBC,GAKf,OAAQ/gB,EAAU5B,QAAQ2iB,IAASA,EAAMC,WAAWD,GAAO,GAAM,KAMzE7jB,OAAO,yBAAyB,UAAW,WAAY,SAAUC,EAASC,GACtE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQ6jB,YAHR,SAAqB1jB,GACjB,OAAOA,GAAmC,mBAAnBA,EAAMwK,YAKrC7K,OAAO,oBAAoB,UAAW,WAAY,SAAUC,EAASC,GACjE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQ8jB,OAHR,SAAgB3jB,GACZ,OAAOA,aAAiB+L,OAAS6X,OAAO5jB,MAKhDL,OAAO,mCAAmC,UAAW,UAAW,QAAS,oBAAqB,gBAAiB,qBAAsB,sBAAuB,kBAAmB,SAAUC,EAASC,EAAS6B,EAASmiB,EAAava,EAAc6H,EAAS2S,EAAeC,GACnQ,aACAjkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIgkB,EAAiC,SAAUpiB,GAE3C,SAASoiB,EAAgBC,EAASC,EAAQ5Z,QACtB,IAAZ2Z,IAAsBA,EAAU,GACpC,IAAIniB,EAAQF,EAAOG,KAAKP,OAASA,KAgBjC,OAfAM,EAAMoiB,QAAU,EAChBpiB,EAAMmiB,QAAU,EACZJ,EAAYN,UAAUW,GACtBpiB,EAAMoiB,OAAS1V,OAAO0V,GAAU,GAAK,GAAK1V,OAAO0V,GAE5CJ,EAAcJ,YAAYQ,KAC/B5Z,EAAY4Z,GAEXJ,EAAcJ,YAAYpZ,KAC3BA,EAAY6G,EAAQD,OAExBpP,EAAMwI,UAAYA,EAClBxI,EAAMmiB,QAAUF,EAASJ,OAAOM,IAC1BA,EAAUniB,EAAMwI,UAAUwB,MAC5BmY,EACGniB,EAoEX,OAvFAJ,EAAQc,UAAUwhB,EAAiBpiB,GA+DnCoiB,EAAgBhe,OAAS,SAAUme,EAAcD,EAAQ5Z,GAErD,YADqB,IAAjB6Z,IAA2BA,EAAe,GACvC,IAAIH,EAAgBG,EAAcD,EAAQ5Z,IAErD0Z,EAAgBlW,SAAW,SAAUrD,GACjC,IAAI9G,EAAQ8G,EAAM9G,MAAOugB,EAASzZ,EAAMyZ,OAAQje,EAAawE,EAAMxE,WAGnE,GADAA,EAAWpB,KAAKlB,IACZsC,EAAW7C,OAAf,CAGK,IAAgB,IAAZ8gB,EACL,OAAOje,EAAWlB,WAEtB0F,EAAM9G,MAAQA,EAAQ,EARTnC,KASNgJ,SAASC,EAAOyZ,KAE3BF,EAAgBvgB,UAAUyE,WAAa,SAAUjC,GAC7C,IACeie,EAAN1iB,KAAkB0iB,OAAQD,EAA1BziB,KAAuCyiB,QAChD,OADSziB,KAA+D8I,UACvDE,SAASwZ,EAAgBlW,SAAUmW,GAChDtgB,MAHQ,EAGMugB,OAAQA,EAAQje,WAAYA,KAG3C+d,EAxFyB,CAyFlC1a,EAAavB,YACflI,EAAQmkB,gBAAkBA,IAG9BrkB,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASukB,GACpG,aACAtkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQwkB,MAAQD,EAAkBJ,gBAAgBhe,SAGtDrG,OAAO,4BAA4B,UAAW,UAAW,qBAAsB,UAAW,uBAAwB,SAAUC,EAASC,EAASsR,EAASmT,EAASC,GAC5J,aACAzkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+CtDH,EAAQ2kB,UAJR,SAAmBpB,EAAU9Y,GAEzB,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzCoT,EAAQvB,MAAM,WAAc,OAAOwB,EAAQF,MAAMjB,EAAU9Y,QAK1E3K,OAAO,yBAAyB,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GACvK,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQ4kB,OALR,SAAgBC,GACZ,OAAO,SAAgCrc,GACnC,OAAOA,EAAOF,KAAK,IAAIwc,EAAeD,MAI9C,IAAIC,EAAgC,WAChC,SAASA,EAAeD,GACpBljB,KAAKkjB,gBAAkBA,EAK3B,OAHAC,EAAelhB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAClD,OAAOA,EAAOL,UAAU,IAAI4c,EAAiB3e,EAAYzE,KAAKkjB,mBAE3DC,EAPwB,GAc/BC,EAAkC,SAAUhjB,GAE5C,SAASgjB,EAAiB9e,EAAa4e,GACnC,IAAI5iB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAM2iB,UACN3iB,EAAMmC,IAAI6e,EAAoBN,kBAAkB1gB,EAAO4iB,IAChD5iB,EAUX,OAfAJ,EAAQc,UAAUoiB,EAAkBhjB,GAOpCgjB,EAAiBnhB,UAAUyC,MAAQ,SAAUlG,GACzCwB,KAAKijB,OAAOzgB,KAAKhE,IAErB4kB,EAAiBnhB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC9F,IAAI4C,EAASjjB,KAAKijB,OAClBjjB,KAAKijB,UACLjjB,KAAKsE,YAAYjB,KAAK4f,IAEnBG,EAhB0B,CAiBnC/B,EAAkBtB,mBAGxB5hB,OAAO,8BAA8B,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACvH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgDtDH,EAAQglB,YANR,SAAqBvW,EAAYwW,GAE7B,YADyB,IAArBA,IAA+BA,EAAmB,MAC/C,SAAqCzc,GACxC,OAAOA,EAAOF,KAAK,IAAI4c,EAAoBzW,EAAYwW,MAI/D,IAAIC,EAAqC,WACrC,SAASA,EAAoBzW,EAAYwW,GACrCtjB,KAAK8M,WAAaA,EAClB9M,KAAKsjB,iBAAmBA,EAKpBtjB,KAAKwjB,gBAJJF,GAAoBxW,IAAewW,EAIbG,EAHAC,EAS/B,OAHAH,EAAoBthB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACvD,OAAOA,EAAOL,UAAU,IAAIxG,KAAKwjB,gBAAgB/e,EAAYzE,KAAK8M,WAAY9M,KAAKsjB,oBAEhFC,EAd6B,GAqBpCG,EAAuC,SAAUtjB,GAEjD,SAASsjB,EAAsBpf,EAAawI,GACxC,IAAIxM,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMwM,WAAaA,EACnBxM,EAAM2iB,UACC3iB,EAiBX,OAtBAJ,EAAQc,UAAU0iB,EAAuBtjB,GAOzCsjB,EAAsBzhB,UAAUyC,MAAQ,SAAUlG,GAC9C,IAAIykB,EAASjjB,KAAKijB,OAClBA,EAAOzgB,KAAKhE,GACRykB,EAAO1jB,QAAUS,KAAK8M,aACtB9M,KAAKsE,YAAYjB,KAAK4f,GACtBjjB,KAAKijB,YAGbS,EAAsBzhB,UAAU2C,UAAY,WACxC,IAAIqe,EAASjjB,KAAKijB,OACdA,EAAO1jB,OAAS,GAChBS,KAAKsE,YAAYjB,KAAK4f,GAE1B7iB,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAE7B0jB,EAvB+B,CAwBxCpe,EAAatB,YAMXyf,EAA2C,SAAUrjB,GAErD,SAASqjB,EAA0Bnf,EAAawI,EAAYwW,GACxD,IAAIhjB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMwM,WAAaA,EACnBxM,EAAMgjB,iBAAmBA,EACzBhjB,EAAMqjB,WACNrjB,EAAMmQ,MAAQ,EACPnQ,EA2BX,OAlCAJ,EAAQc,UAAUyiB,EAA2BrjB,GAS7CqjB,EAA0BxhB,UAAUyC,MAAQ,SAAUlG,GAClD,IAAesO,EAAN9M,KAAsB8M,WAAYwW,EAAlCtjB,KAAwDsjB,iBAAkBK,EAA1E3jB,KAAuF2jB,QAASlT,EAAhGzQ,KAA2GyQ,MACpHzQ,KAAKyQ,QACDA,EAAQ6S,GAAqB,GAC7BK,EAAQnhB,SAEZ,IAAK,IAAI9B,EAAIijB,EAAQpkB,OAAQmB,KAAM,CAC/B,IAAIuiB,EAASU,EAAQjjB,GACrBuiB,EAAOzgB,KAAKhE,GACRykB,EAAO1jB,SAAWuN,IAClB6W,EAAQzgB,OAAOxC,EAAG,GAClBV,KAAKsE,YAAYjB,KAAK4f,MAIlCQ,EAA0BxhB,UAAU2C,UAAY,WAE5C,IADA,IAAe+e,EAAN3jB,KAAmB2jB,QAASrf,EAA5BtE,KAA6CsE,YAC/Cqf,EAAQpkB,OAAS,GAAG,CACvB,IAAI0jB,EAASU,EAAQ9Y,QACjBoY,EAAO1jB,OAAS,GAChB+E,EAAYjB,KAAK4f,GAGzB7iB,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAE7ByjB,EAnCmC,CAoC5Cne,EAAatB,cAGnB7F,OAAO,6BAA6B,UAAW,UAAW,QAAS,qBAAsB,gBAAiB,uBAAwB,SAAUC,EAASC,EAAS6B,EAASyP,EAASrK,EAAcgd,GAC1L,aA0KA,SAASsB,EAA2B3a,GAChC,IAAIxE,EAAawE,EAAMxE,WACnBof,EAAc5a,EAAMjE,QACpB6e,GACApf,EAAWqf,aAAaD,GAEvBpf,EAAW7C,SACZqH,EAAMjE,QAAUP,EAAWsf,cAC3B9a,EAAMjE,QAAQgf,YAAchkB,KAAKgJ,SAASC,EAAOA,EAAMgb,iBAY/D,SAASC,EAAoB3X,GACzB,IAAI9H,EAAa8H,EAAI9H,WAAYO,EAAUuH,EAAIvH,QAC/CP,EAAWqf,aAAa9e,GA/L5B1G,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgEtDH,EAAQ8lB,WAnBR,SAAoBF,GAChB,IAAI1kB,EAASU,UAAUV,OACnBuJ,EAAY6G,EAAQD,MACpB4S,EAAcJ,YAAYjiB,UAAUA,UAAUV,OAAS,MACvDuJ,EAAY7I,UAAUA,UAAUV,OAAS,GACzCA,KAEJ,IAAI6kB,EAAyB,KACzB7kB,GAAU,IACV6kB,EAAyBnkB,UAAU,IAEvC,IAAIokB,EAAgBrX,OAAOC,kBAI3B,OAHI1N,GAAU,IACV8kB,EAAgBpkB,UAAU,IAEvB,SAAoC4G,GACvC,OAAOA,EAAOF,KAAK,IAAI2d,EAAmBL,EAAgBG,EAAwBC,EAAevb,MAIzG,IAAIwb,EAAoC,WACpC,SAASA,EAAmBL,EAAgBG,EAAwBC,EAAevb,GAC/E9I,KAAKikB,eAAiBA,EACtBjkB,KAAKokB,uBAAyBA,EAC9BpkB,KAAKqkB,cAAgBA,EACrBrkB,KAAK8I,UAAYA,EAKrB,OAHAwb,EAAmBriB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACtD,OAAOA,EAAOL,UAAU,IAAI+d,EAAqB9f,EAAYzE,KAAKikB,eAAgBjkB,KAAKokB,uBAAwBpkB,KAAKqkB,cAAerkB,KAAK8I,aAErIwb,EAV4B,GAYnCE,EAAyB,WAIzB,OAHA,WACIxkB,KAAKijB,WAFe,GAWxBsB,EAAsC,SAAUnkB,GAEhD,SAASmkB,EAAqBjgB,EAAa2f,EAAgBG,EAAwBC,EAAevb,GAC9F,IAAIxI,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAC9CM,EAAM2jB,eAAiBA,EACvB3jB,EAAM8jB,uBAAyBA,EAC/B9jB,EAAM+jB,cAAgBA,EACtB/jB,EAAMwI,UAAYA,EAClBxI,EAAMmkB,YACN,IAAIzf,EAAU1E,EAAMyjB,cAEpB,GADAzjB,EAAMokB,aAAyC,MAA1BN,GAAkCA,EAAyB,EAC5E9jB,EAAMokB,aAAc,CACpB,IAAIC,GAAsBlgB,WAAYnE,EAAO0E,QAASA,EAASif,eAAgBA,GAC/E3jB,EAAMmC,IAAIuC,EAAQgf,YAAclb,EAAUE,SAAS4a,EAA4BK,EAAgBU,QAE9F,CACD,IAAIC,GAAengB,WAAYnE,EAAO0E,QAASA,GAC3C6f,GAAkBZ,eAAgBA,EAAgBG,uBAAwBA,EAAwB3f,WAAYnE,EAAOwI,UAAWA,GACpIxI,EAAMmC,IAAIuC,EAAQgf,YAAclb,EAAUE,SAASkb,EAAqBD,EAAgBW,IACxFtkB,EAAMmC,IAAIqG,EAAUE,SAyEhC,SAAgCC,GAC5B,IAAImb,EAAyBnb,EAAMmb,uBAAwBH,EAAiBhb,EAAMgb,eAAgBxf,EAAawE,EAAMxE,WAAYqE,EAAYG,EAAMH,UAC/I9D,EAAUP,EAAWsf,cAEpBtf,EAAW7C,SACZ6C,EAAWhC,IAAIuC,EAAQgf,YAAclb,EAAUE,SAASkb,EAAqBD,GAAkBxf,WAAYA,EAAYO,QAASA,KAFvHhF,KAGFgJ,SAASC,EAAOmb,KA/EkCA,EAAwBS,IAEjF,OAAOvkB,EA0DX,OA9EAJ,EAAQc,UAAUujB,EAAsBnkB,GAsBxCmkB,EAAqBtiB,UAAUyC,MAAQ,SAAUlG,GAI7C,IAAK,IADDsmB,EAFAL,EAAWzkB,KAAKykB,SAChBriB,EAAMqiB,EAASllB,OAEVmB,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAIsE,EAAUyf,EAAS/jB,GACnBuiB,EAASje,EAAQie,OACrBA,EAAOzgB,KAAKhE,GACRykB,EAAO1jB,QAAUS,KAAKqkB,gBACtBS,EAAsB9f,GAG1B8f,GACA9kB,KAAK+kB,aAAaD,IAG1BP,EAAqBtiB,UAAU0C,OAAS,SAAUnE,GAC9CR,KAAKykB,SAASllB,OAAS,EACvBa,EAAO6B,UAAU0C,OAAOpE,KAAKP,KAAMQ,IAEvC+jB,EAAqBtiB,UAAU2C,UAAY,WAEvC,IADA,IAAe6f,EAANzkB,KAAoBykB,SAAUngB,EAA9BtE,KAA+CsE,YACjDmgB,EAASllB,OAAS,GAAG,CACxB,IAAIyF,EAAUyf,EAAS5Z,QACvBvG,EAAYjB,KAAK2B,EAAQie,QAE7B7iB,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAEpCukB,EAAqBtiB,UAAUD,aAAe,WAC1ChC,KAAKykB,SAAW,MAEpBF,EAAqBtiB,UAAU8iB,aAAe,SAAU/f,GACpDhF,KAAK8jB,aAAa9e,GAClB,IAAIgf,EAAchf,EAAQgf,YAG1B,GAFAA,EAAYriB,cACZ3B,KAAKqC,OAAO2hB,IACPhkB,KAAK4B,QAAU5B,KAAK0kB,aAAc,CACnC1f,EAAUhF,KAAK+jB,cACf,IAAIE,EAAiBjkB,KAAKikB,eACtBU,GAAsBlgB,WAAYzE,KAAMgF,QAASA,EAASif,eAAgBA,GAC9EjkB,KAAKyC,IAAIuC,EAAQgf,YAAchkB,KAAK8I,UAAUE,SAAS4a,EAA4BK,EAAgBU,MAG3GJ,EAAqBtiB,UAAU8hB,YAAc,WACzC,IAAI/e,EAAU,IAAIwf,EAElB,OADAxkB,KAAKykB,SAASjiB,KAAKwC,GACZA,GAEXuf,EAAqBtiB,UAAU6hB,aAAe,SAAU9e,GACpDhF,KAAKsE,YAAYjB,KAAK2B,EAAQie,QAC9B,IAAIwB,EAAWzkB,KAAKykB,UACFA,EAAWA,EAASxhB,QAAQ+B,IAAY,IACvC,GACfyf,EAASvhB,OAAOuhB,EAASxhB,QAAQ+B,GAAU,IAG5Cuf,EA/E8B,CAgFvCjf,EAAatB,cA2BnB7F,OAAO,+BAA+B,UAAW,UAAW,QAAS,kBAAmB,4BAA6B,sBAAuB,SAAUC,EAASC,EAAS6B,EAAS2D,EAAgByd,EAAqBD,GAClN,aACA/iB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQ2mB,aALR,SAAsBC,EAAUC,GAC5B,OAAO,SAAsCre,GACzC,OAAOA,EAAOF,KAAK,IAAIwe,EAAqBF,EAAUC,MAI9D,IAAIC,EAAsC,WACtC,SAASA,EAAqBF,EAAUC,GACpCllB,KAAKilB,SAAWA,EAChBjlB,KAAKklB,gBAAkBA,EAK3B,OAHAC,EAAqBljB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACxD,OAAOA,EAAOL,UAAU,IAAI4e,EAAuB3gB,EAAYzE,KAAKilB,SAAUjlB,KAAKklB,mBAEhFC,EAR8B,GAerCC,EAAwC,SAAUhlB,GAElD,SAASglB,EAAuB9gB,EAAa2gB,EAAUC,GACnD,IAAI5kB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAM2kB,SAAWA,EACjB3kB,EAAM4kB,gBAAkBA,EACxB5kB,EAAMmkB,YACNnkB,EAAMmC,IAAI6e,EAAoBN,kBAAkB1gB,EAAO2kB,IAChD3kB,EA4EX,OAnFAJ,EAAQc,UAAUokB,EAAwBhlB,GAS1CglB,EAAuBnjB,UAAUyC,MAAQ,SAAUlG,GAG/C,IAAK,IAFDimB,EAAWzkB,KAAKykB,SAChBriB,EAAMqiB,EAASllB,OACVmB,EAAI,EAAGA,EAAI0B,EAAK1B,IACrB+jB,EAAS/jB,GAAGuiB,OAAOzgB,KAAKhE,IAGhC4mB,EAAuBnjB,UAAU0C,OAAS,SAAUnE,GAEhD,IADA,IAAIikB,EAAWzkB,KAAKykB,SACbA,EAASllB,OAAS,GAAG,CACxB,IAAIyF,EAAUyf,EAAS5Z,QACvB7F,EAAQpC,aAAajB,cACrBqD,EAAQie,OAAS,KACjBje,EAAQpC,aAAe,KAE3B5C,KAAKykB,SAAW,KAChBrkB,EAAO6B,UAAU0C,OAAOpE,KAAKP,KAAMQ,IAEvC4kB,EAAuBnjB,UAAU2C,UAAY,WAEzC,IADA,IAAI6f,EAAWzkB,KAAKykB,SACbA,EAASllB,OAAS,GAAG,CACxB,IAAIyF,EAAUyf,EAAS5Z,QACvB7K,KAAKsE,YAAYjB,KAAK2B,EAAQie,QAC9Bje,EAAQpC,aAAajB,cACrBqD,EAAQie,OAAS,KACjBje,EAAQpC,aAAe,KAE3B5C,KAAKykB,SAAW,KAChBrkB,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAEpColB,EAAuBnjB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACpGJ,EAAajgB,KAAKqlB,YAAYpF,GAAcjgB,KAAKslB,WAAWpF,IAEhEkF,EAAuBnjB,UAAUse,eAAiB,SAAUF,GACxDrgB,KAAKqlB,YAAYhF,EAASrb,UAE9BogB,EAAuBnjB,UAAUqjB,WAAa,SAAU9mB,GACpD,IACI,IACI0kB,EADkBljB,KAAKklB,gBACW3kB,KAAKP,KAAMxB,GAC7C0kB,GACAljB,KAAKulB,aAAarC,GAG1B,MAAO1iB,GACHR,KAAK2E,OAAOnE,KAGpB4kB,EAAuBnjB,UAAUojB,YAAc,SAAUrgB,GACrD,IAAIyf,EAAWzkB,KAAKykB,SACpB,GAAIA,GAAYzf,EAAS,CACrB,IAAIie,EAASje,EAAQie,OAAQrgB,EAAeoC,EAAQpC,aACpD5C,KAAKsE,YAAYjB,KAAK4f,GACtBwB,EAASvhB,OAAOuhB,EAASxhB,QAAQ+B,GAAU,GAC3ChF,KAAKqC,OAAOO,GACZA,EAAajB,gBAGrByjB,EAAuBnjB,UAAUsjB,aAAe,SAAUrC,GACtD,IAAIuB,EAAWzkB,KAAKykB,SAEhB7hB,EAAe,IAAIiB,EAAenC,aAClCsD,GAAYie,UAAgBrgB,aAAcA,GAC9C6hB,EAASjiB,KAAKwC,GACd,IAAI6c,EAAoBP,EAAoBN,kBAAkBhhB,KAAMkjB,EAAiBle,IAChF6c,GAAqBA,EAAkBjgB,OACxC5B,KAAKqlB,YAAYrgB,IAGjB6c,EAAkB7c,QAAUA,EAC5BhF,KAAKyC,IAAIof,GACTjf,EAAaH,IAAIof,KAGlBuD,EApFgC,CAqFzC/D,EAAkBtB,mBAGxB5hB,OAAO,6BAA6B,UAAW,UAAW,QAAS,kBAAmB,mBAAoB,sBAAuB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAAS2D,EAAgBzC,EAAYzB,EAAe0hB,EAAmBC,GACpR,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAuCtDH,EAAQmnB,WALR,SAAoBN,GAChB,OAAO,SAAUre,GACb,OAAOA,EAAOF,KAAK,IAAI8e,EAAmBP,MAIlD,IAAIO,EAAoC,WACpC,SAASA,EAAmBP,GACxBllB,KAAKklB,gBAAkBA,EAK3B,OAHAO,EAAmBxjB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACtD,OAAOA,EAAOL,UAAU,IAAIkf,EAAqBjhB,EAAYzE,KAAKklB,mBAE/DO,EAP4B,GAcnCC,EAAsC,SAAUtlB,GAEhD,SAASslB,EAAqBphB,EAAa4gB,GACvC,IAAI5kB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAM4kB,gBAAkBA,EACxB5kB,EAAMqlB,aAAc,EACpBrlB,EAAMglB,aACChlB,EAmDX,OAzDAJ,EAAQc,UAAU0kB,EAAsBtlB,GAQxCslB,EAAqBzjB,UAAUyC,MAAQ,SAAUlG,GAC7CwB,KAAKijB,OAAOzgB,KAAKhE,IAErBknB,EAAqBzjB,UAAU2C,UAAY,WACvC,IAAIqe,EAASjjB,KAAKijB,OACdA,GACAjjB,KAAKsE,YAAYjB,KAAK4f,GAE1B7iB,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAEpC0lB,EAAqBzjB,UAAUD,aAAe,WAC1ChC,KAAKijB,OAAS,KACdjjB,KAAK2lB,aAAc,GAEvBD,EAAqBzjB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAClGrgB,KAAKslB,cAETI,EAAqBzjB,UAAUse,eAAiB,WACxCvgB,KAAK2lB,YACL3lB,KAAKuD,WAGLvD,KAAKslB,cAGbI,EAAqBzjB,UAAUqjB,WAAa,WACxC,IAAIM,EAAsB5lB,KAAK4lB,oBAC3BA,IACA5lB,KAAKqC,OAAOujB,GACZA,EAAoBjkB,eAExB,IAAIshB,EAASjjB,KAAKijB,OACdjjB,KAAKijB,QACLjjB,KAAKsE,YAAYjB,KAAK4f,GAE1BjjB,KAAKijB,UACL,IAAIC,EAAkB9hB,EAAWvB,SAASG,KAAKklB,gBAAzB9jB,GAClB8hB,IAAoBvjB,EAAcF,YAClCO,KAAKsD,MAAM3D,EAAcF,YAAYC,IAGrCkmB,EAAsB,IAAI/hB,EAAenC,aACzC1B,KAAK4lB,oBAAsBA,EAC3B5lB,KAAKyC,IAAImjB,GACT5lB,KAAK2lB,aAAc,EACnBC,EAAoBnjB,IAAI6e,EAAoBN,kBAAkBhhB,KAAMkjB,IACpEljB,KAAK2lB,aAAc,IAGpBD,EA1D8B,CA2DvCrE,EAAkBtB,mBAGxB5hB,OAAO,6BAA6B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GAC3K,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiEtDH,EAAQwnB,WAPR,SAAoBC,GAChB,OAAO,SAAoCjf,GACvC,IAAID,EAAW,IAAImf,EAAcD,GAC7BE,EAASnf,EAAOF,KAAKC,GACzB,OAAQA,EAASof,OAASA,IAIlC,IAAID,EAA+B,WAC/B,SAASA,EAAcD,GACnB9lB,KAAK8lB,SAAWA,EAKpB,OAHAC,EAAc9jB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACjD,OAAOA,EAAOL,UAAU,IAAIyf,EAAgBxhB,EAAYzE,KAAK8lB,SAAU9lB,KAAKgmB,UAEzED,EAPuB,GAc9BE,EAAiC,SAAU7lB,GAE3C,SAAS6lB,EAAgB3hB,EAAawhB,EAAUE,GAC5C,IAAI1lB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMwlB,SAAWA,EACjBxlB,EAAM0lB,OAASA,EACR1lB,EAqBX,OA1BAJ,EAAQc,UAAUilB,EAAiB7lB,GAYnC6lB,EAAgBhkB,UAAUqB,MAAQ,SAAU9C,GACxC,IAAKR,KAAKqE,UAAW,CACjB,IAAIqM,OAAS,EACb,IACIA,EAAS1Q,KAAK8lB,SAAStlB,EAAKR,KAAKgmB,QAErC,MAAOE,GAEH,YADA9lB,EAAO6B,UAAUqB,MAAM/C,KAAKP,KAAMkmB,GAGtClmB,KAAK6E,yBACL7E,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAM0Q,MAGtDuV,EA3ByB,CA4BlC5E,EAAkBtB,mBAGxB5hB,OAAO,oCAAoC,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAAS4H,GAC7H,aACAxJ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI2nB,EAAkC,SAAU/lB,GAE5C,SAAS+lB,EAAiB3nB,EAAOsK,GAC7B,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAOjC,OANAM,EAAM9B,MAAQA,EACd8B,EAAMwI,UAAYA,EAClBxI,EAAMmG,WAAY,EACdqC,IACAxI,EAAMmG,WAAY,GAEfnG,EAiCX,OA1CAJ,EAAQc,UAAUmlB,EAAkB/lB,GAWpC+lB,EAAiB3hB,OAAS,SAAUhG,EAAOsK,GACvC,OAAO,IAAIqd,EAAiB3nB,EAAOsK,IAEvCqd,EAAiB7Z,SAAW,SAAUrD,GAClC,IAAIiP,EAAOjP,EAAMiP,KAAM1Z,EAAQyK,EAAMzK,MAAOiG,EAAawE,EAAMxE,WAC3DyT,EACAzT,EAAWlB,YAGfkB,EAAWpB,KAAK7E,GACZiG,EAAW7C,SAGfqH,EAAMiP,MAAO,EACblY,KAAKgJ,SAASC,MAElBkd,EAAiBlkB,UAAUyE,WAAa,SAAUjC,GAC9C,IAAIjG,EAAQwB,KAAKxB,MACbsK,EAAY9I,KAAK8I,UACrB,GAAIA,EACA,OAAOA,EAAUE,SAASmd,EAAiB7Z,SAAU,GACjD4L,MAAM,EAAO1Z,MAAOA,EAAOiG,WAAYA,IAI3CA,EAAWpB,KAAK7E,GACXiG,EAAW7C,QACZ6C,EAAWlB,YAIhB4iB,EA3C0B,CA4CnCre,EAAavB,YACflI,EAAQ8nB,iBAAmBA,IAG/BhoB,OAAO,mCAAmC,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAAS4H,GAC5H,aACAxJ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI4nB,EAAiC,SAAUhmB,GAE3C,SAASgmB,EAAgBtd,GACrB,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAEjC,OADAM,EAAMwI,UAAYA,EACXxI,EA6DX,OAjEAJ,EAAQc,UAAUolB,EAAiBhmB,GAiDnCgmB,EAAgB5hB,OAAS,SAAUsE,GAC/B,OAAO,IAAIsd,EAAgBtd,IAE/Bsd,EAAgB9Z,SAAW,SAAUC,GAChBA,EAAI9H,WACVlB,YAEf6iB,EAAgBnkB,UAAUyE,WAAa,SAAUjC,GAC7C,IAAIqE,EAAY9I,KAAK8I,UACrB,GAAIA,EACA,OAAOA,EAAUE,SAASod,EAAgB9Z,SAAU,GAAK7H,WAAYA,IAGrEA,EAAWlB,YAGZ6iB,EAlEyB,CAmElCte,EAAavB,YACflI,EAAQ+nB,gBAAkBA,IAG9BjoB,OAAO,mCAAmC,UAAW,UAAW,QAAS,gBAAiB,qBAAsB,oBAAqB,uBAAwB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcue,EAAoBC,EAAmBhE,GACnP,aACAhkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI+nB,EAAiC,SAAUnmB,GAE3C,SAASmmB,EAAgBC,EAAO1d,GAC5B,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAOjC,OANAM,EAAMkmB,MAAQA,EACdlmB,EAAMwI,UAAYA,EACbA,GAA8B,IAAjB0d,EAAMjnB,SACpBe,EAAMmG,WAAY,EAClBnG,EAAM9B,MAAQgoB,EAAM,IAEjBlmB,EA8FX,OAvGAJ,EAAQc,UAAUulB,EAAiBnmB,GAWnCmmB,EAAgB/hB,OAAS,SAAUgiB,EAAO1d,GACtC,OAAO,IAAIyd,EAAgBC,EAAO1d,IAsCtCyd,EAAgB5a,GAAK,WAEjB,IAAK,IADD6a,KACKrgB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCqgB,EAAMrgB,GAAMlG,UAAUkG,GAE1B,IAAI2C,EAAY0d,EAAMA,EAAMjnB,OAAS,GACjC+iB,EAAcJ,YAAYpZ,GAC1B0d,EAAMC,MAGN3d,EAAY,KAEhB,IAAI1G,EAAMokB,EAAMjnB,OAChB,OAAI6C,EAAM,EACC,IAAImkB,EAAgBC,EAAO1d,GAErB,IAAR1G,EACE,IAAIikB,EAAmBF,iBAAiBK,EAAM,GAAI1d,GAGlD,IAAIwd,EAAkBF,gBAAgBtd,IAGrDyd,EAAgBja,SAAW,SAAUrD,GACjC,IAAIud,EAAQvd,EAAMud,MAAOrkB,EAAQ8G,EAAM9G,MAAOsO,EAAQxH,EAAMwH,MAAOhM,EAAawE,EAAMxE,WAClFtC,GAASsO,EACThM,EAAWlB,YAGfkB,EAAWpB,KAAKmjB,EAAMrkB,IAClBsC,EAAW7C,SAGfqH,EAAM9G,MAAQA,EAAQ,EACtBnC,KAAKgJ,SAASC,MAElBsd,EAAgBtkB,UAAUyE,WAAa,SAAUjC,GAC7C,IACI+hB,EAAQxmB,KAAKwmB,MACb/V,EAAQ+V,EAAMjnB,OACduJ,EAAY9I,KAAK8I,UACrB,GAAIA,EACA,OAAOA,EAAUE,SAASud,EAAgBja,SAAU,GAChDka,MAAOA,EAAOrkB,MANV,EAMwBsO,MAAOA,EAAOhM,WAAYA,IAI1D,IAAK,IAAI/D,EAAI,EAAGA,EAAI+P,IAAUhM,EAAW7C,OAAQlB,IAC7C+D,EAAWpB,KAAKmjB,EAAM9lB,IAE1B+D,EAAWlB,YAGZgjB,EAxGyB,CAyGlCze,EAAavB,YACflI,EAAQkoB,gBAAkBA,IAG9BpoB,OAAO,gCAAgC,UAAW,UAAW,QAAS,gCAAiC,kBAAmB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASwmB,EAAmBzlB,EAAWogB,EAAmBC,GAChQ,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAImoB,KA6DJtoB,EAAQuoB,cAhBR,WAEI,IAAK,IADDC,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,IAAIiK,EAAU,KASd,MARmD,mBAAxCyW,EAAYA,EAAYtnB,OAAS,KACxC6Q,EAAUyW,EAAYJ,OAIC,IAAvBI,EAAYtnB,QAAgB0B,EAAU5B,QAAQwnB,EAAY,MAC1DA,EAAcA,EAAY,GAAGte,SAE1B,SAAU1B,GAAU,OAAOA,EAAOF,KAAKpG,KAAK,IAAImmB,EAAkBH,iBAAiB1f,GAAQpF,OAAOolB,IAAe,IAAIC,EAAsB1W,MAGtJ,IAAI0W,EAAuC,WACvC,SAASA,EAAsB1W,GAC3BpQ,KAAKoQ,QAAUA,EAKnB,OAHA0W,EAAsB7kB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACzD,OAAOA,EAAOL,UAAU,IAAIugB,EAAwBtiB,EAAYzE,KAAKoQ,WAElE0W,EAP+B,GAS1CzoB,EAAQyoB,sBAAwBA,EAMhC,IAAIC,EAAyC,SAAU3mB,GAEnD,SAAS2mB,EAAwBziB,EAAa8L,GAC1C,IAAI9P,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAM8P,QAAUA,EAChB9P,EAAMoK,OAAS,EACfpK,EAAMwT,UACNxT,EAAMumB,eACCvmB,EAqDX,OA5DAJ,EAAQc,UAAU+lB,EAAyB3mB,GAS3C2mB,EAAwB9kB,UAAUyC,MAAQ,SAAUiB,GAChD3F,KAAK8T,OAAOtR,KAAKmkB,GACjB3mB,KAAK6mB,YAAYrkB,KAAKmD,IAE1BohB,EAAwB9kB,UAAU2C,UAAY,WAC1C,IAAIiiB,EAAc7mB,KAAK6mB,YACnBzkB,EAAMykB,EAAYtnB,OACtB,GAAY,IAAR6C,EACApC,KAAKsE,YAAYf,eAEhB,CACDvD,KAAK0K,OAAStI,EACdpC,KAAKgnB,UAAY5kB,EACjB,IAAK,IAAI1B,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAIiF,EAAakhB,EAAYnmB,GAC7BV,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAM2F,EAAYA,EAAYjF,OAIzFqmB,EAAwB9kB,UAAUse,eAAiB,SAAU0G,GAC9B,IAAtBjnB,KAAK0K,QAAU,IAChB1K,KAAKsE,YAAYf,YAGzBwjB,EAAwB9kB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACrG,IAAIvM,EAAS9T,KAAK8T,OACdoT,EAASpT,EAAOqM,GAChB6G,EAAahnB,KAAKgnB,UAEhBE,IAAWP,IAAS3mB,KAAKgnB,UAAYhnB,KAAKgnB,UAD1C,EAENlT,EAAOqM,GAAcD,EACH,IAAd8G,IACIhnB,KAAKoQ,QACLpQ,KAAKmnB,YAAYrT,GAGjB9T,KAAKsE,YAAYjB,KAAKyQ,EAAOvL,WAIzCwe,EAAwB9kB,UAAUklB,YAAc,SAAUrT,GACtD,IAAIpD,EACJ,IACIA,EAAS1Q,KAAKoQ,QAAQrQ,MAAMC,KAAM8T,GAEtC,MAAOtT,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAKsE,YAAYjB,KAAKqN,IAEnBqW,EA7DiC,CA8D1C1F,EAAkBtB,iBACpB1hB,EAAQ0oB,wBAA0BA,IAGtC5oB,OAAO,6BAA6B,UAAW,UAAW,8BAA+B,SAAUC,EAASC,EAAS+oB,GACjH,aACA9oB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQgpB,WAHR,SAAoBjX,GAChB,OAAO,SAAUvJ,GAAU,OAAOA,EAAOF,KAAK,IAAIygB,EAAgBN,sBAAsB1W,QAKhGjS,OAAO,sBAAsB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASqoB,GACjG,aACApoB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQsN,GAAK+a,EAAkBH,gBAAgB5a,KAGnDxN,OAAO,qCAAqC,UAAW,UAAW,QAAS,eAAgB,iBAAkB,SAAUC,EAASC,EAAS6B,EAASsD,EAAQsE,GACtJ,aAsGA,SAASwf,EAAa/a,GAClB,IAAI/N,EAAQ+N,EAAI/N,MAAOiG,EAAa8H,EAAI9H,WACnCA,EAAW7C,SACZ6C,EAAWpB,KAAK7E,GAChBiG,EAAWlB,YAzGnBjF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI+oB,EAAmC,SAAUnnB,GAE7C,SAASmnB,EAAkBC,EAAS1e,GAChC,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAGjC,OAFAM,EAAMknB,QAAUA,EAChBlnB,EAAMwI,UAAYA,EACXxI,EAsFX,OA3FAJ,EAAQc,UAAUumB,EAAmBnnB,GAiCrCmnB,EAAkB/iB,OAAS,SAAUgjB,EAAS1e,GAC1C,OAAO,IAAIye,EAAkBC,EAAS1e,IAE1Cye,EAAkBtlB,UAAUyE,WAAa,SAAUjC,GAC/C,IAAInE,EAAQN,KACRwnB,EAAUxnB,KAAKwnB,QACf1e,EAAY9I,KAAK8I,UACrB,GAAiB,MAAbA,EACI9I,KAAKyG,UACAhC,EAAW7C,SACZ6C,EAAWpB,KAAKrD,KAAKxB,OACrBiG,EAAWlB,YAIfikB,EAAQ9G,KAAK,SAAUliB,GACnB8B,EAAM9B,MAAQA,EACd8B,EAAMmG,WAAY,EACbhC,EAAW7C,SACZ6C,EAAWpB,KAAK7E,GAChBiG,EAAWlB,aAEhB,SAAU/C,GACJiE,EAAW7C,QACZ6C,EAAWnB,MAAM9C,KAGpBkgB,KAAK,KAAM,SAAUlgB,GAEtBgD,EAAOvE,KAAKie,WAAW,WAAc,MAAM1c,WAKnD,GAAIR,KAAKyG,WACL,IAAKhC,EAAW7C,OACZ,OAAOkH,EAAUE,SAASse,EAAc,GAAK9oB,MAAOwB,KAAKxB,MAAOiG,WAAYA,SAIhF+iB,EAAQ9G,KAAK,SAAUliB,GACnB8B,EAAM9B,MAAQA,EACd8B,EAAMmG,WAAY,EACbhC,EAAW7C,QACZ6C,EAAWhC,IAAIqG,EAAUE,SAASse,EAAc,GAAK9oB,MAAOA,EAAOiG,WAAYA,MAEpF,SAAUjE,GACJiE,EAAW7C,QACZ6C,EAAWhC,IAAIqG,EAAUE,SAoBjD,SAAuBuD,GACnB,IAAI/L,EAAM+L,EAAI/L,IAAKiE,EAAa8H,EAAI9H,WAC/BA,EAAW7C,QACZ6C,EAAWnB,MAAM9C,IAvBgD,GAAKA,IAAKA,EAAKiE,WAAYA,OAG/Eic,KAAK,KAAM,SAAUlgB,GAEtBgD,EAAOvE,KAAKie,WAAW,WAAc,MAAM1c,OAKpD+mB,EA5F2B,CA6FpCzf,EAAavB,YACflI,EAAQkpB,kBAAoBA,IAgBhCppB,OAAO,sCAAsC,UAAW,UAAW,QAAS,eAAgB,gBAAiB,sBAAuB,SAAUC,EAASC,EAAS6B,EAASsD,EAAQsE,EAAcgZ,GAC3L,aACAxiB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIipB,EAAoC,SAAUrnB,GAE9C,SAASqnB,EAAmBhI,EAAU3W,GAClC,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAEjC,GADAM,EAAMwI,UAAYA,EACF,MAAZ2W,EACA,MAAM,IAAIvgB,MAAM,4BAGpB,OADAoB,EAAMmf,SAiGd,SAAqBiI,GACjB,IAAIhnB,EAAIgnB,EAAI5G,EAAWrB,UACvB,IAAK/e,GAAoB,iBAARgnB,EACb,OAAO,IAAIC,EAAeD,GAE9B,IAAKhnB,QAAoBkJ,IAAf8d,EAAInoB,OACV,OAAO,IAAIqoB,EAAcF,GAE7B,IAAKhnB,EACD,MAAM,IAAI4P,UAAU,0BAExB,OAAOoX,EAAI5G,EAAWrB,YA5GDoI,CAAYpI,GACtBnf,EAqDX,OA7DAJ,EAAQc,UAAUymB,EAAoBrnB,GAUtCqnB,EAAmBjjB,OAAS,SAAUib,EAAU3W,GAC5C,OAAO,IAAI2e,EAAmBhI,EAAU3W,IAE5C2e,EAAmBnb,SAAW,SAAUrD,GACpC,IAAI9G,EAAQ8G,EAAM9G,MAAOgG,EAAWc,EAAMd,SAAUsX,EAAWxW,EAAMwW,SAAUhb,EAAawE,EAAMxE,WAClG,GAAI0D,EACA1D,EAAWnB,MAAM2F,EAAM3F,WAD3B,CAIA,IAAIoN,EAAS+O,EAASpc,OAClBqN,EAAOwH,KACPzT,EAAWlB,YAGfkB,EAAWpB,KAAKqN,EAAOlS,OACvByK,EAAM9G,MAAQA,EAAQ,EAClBsC,EAAW7C,OACoB,mBAApB6d,EAASqI,QAChBrI,EAASqI,SAIjB9nB,KAAKgJ,SAASC,MAElBwe,EAAmBxlB,UAAUyE,WAAa,SAAUjC,GAChD,IACegb,EAANzf,KAAoByf,SAAU3W,EAA9B9I,KAA6C8I,UACtD,GAAIA,EACA,OAAOA,EAAUE,SAASye,EAAmBnb,SAAU,GACnDnK,MAJI,EAIUsd,SAAUA,EAAUhb,WAAYA,IAIlD,OAAG,CACC,IAAIiM,EAAS+O,EAASpc,OACtB,GAAIqN,EAAOwH,KAAM,CACbzT,EAAWlB,WACX,MAKJ,GAFIkB,EAAWpB,KAAKqN,EAAOlS,OAEvBiG,EAAW7C,OAAQ,CACY,mBAApB6d,EAASqI,QAChBrI,EAASqI,SAEb,SAKTL,EA9D4B,CA+DrC3f,EAAavB,YACflI,EAAQopB,mBAAqBA,EAC7B,IAAIE,EAAgC,WAChC,SAASA,EAAeI,EAAKC,EAAK5lB,QAClB,IAAR4lB,IAAkBA,EAAM,QAChB,IAAR5lB,IAAkBA,EAAM2lB,EAAIxoB,QAChCS,KAAK+nB,IAAMA,EACX/nB,KAAKgoB,IAAMA,EACXhoB,KAAKoC,IAAMA,EAYf,OAVAulB,EAAe1lB,UAAU6e,EAAWrB,UAAY,WAAc,OAAO,MACrEkI,EAAe1lB,UAAUoB,KAAO,WAC5B,OAAOrD,KAAKgoB,IAAMhoB,KAAKoC,KACnB8V,MAAM,EACN1Z,MAAOwB,KAAK+nB,IAAIE,OAAOjoB,KAAKgoB,SAE5B9P,MAAM,EACN1Z,WAAOoL,IAGR+d,EAlBwB,GAoB/BC,EAA+B,WAC/B,SAASA,EAAcM,EAAKF,EAAK5lB,QACjB,IAAR4lB,IAAkBA,EAAM,QAChB,IAAR5lB,IAAkBA,EA+B9B,SAAkBqZ,GACd,IAAIrZ,GAAOqZ,EAAElc,OACb,OAAI6iB,MAAMhgB,GACC,EAEC,IAARA,GAYR,SAAwB5D,GACpB,MAAwB,iBAAVA,GAAsBgF,EAAOvE,KAAKkpB,SAAS3pB,GAbvC4pB,CAAehmB,IAGjCA,EAYJ,SAAc5D,GACV,IAAI6pB,GAbOjmB,EAcX,OAAsB,IAAlBimB,EACOA,EAEPjG,MAAMiG,GACCA,EAEJA,EAAgB,GAAK,EAAI,EApB1BC,GAAY3a,KAAK4a,MAAM5a,KAAK6a,IAAIpmB,MAC3B,EACA,EAEPA,EAAMqmB,EACCA,EAEJrmB,EATIA,EArCqBsmB,CAASR,IACrCloB,KAAKkoB,IAAMA,EACXloB,KAAKgoB,IAAMA,EACXhoB,KAAKoC,IAAMA,EAYf,OAVAwlB,EAAc3lB,UAAU6e,EAAWrB,UAAY,WAAc,OAAOzf,MACpE4nB,EAAc3lB,UAAUoB,KAAO,WAC3B,OAAOrD,KAAKgoB,IAAMhoB,KAAKoC,KACnB8V,MAAM,EACN1Z,MAAOwB,KAAKkoB,IAAIloB,KAAKgoB,SAErB9P,MAAM,EACN1Z,WAAOoL,IAGRge,EAlBuB,GAiC9Ba,EAAiB9a,KAAKgb,IAAI,EAAG,IAAM,IAiC3CxqB,OAAO,uCAAuC,UAAW,UAAW,QAAS,gBAAiB,qBAAsB,qBAAsB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcue,EAAoBC,GAC7M,aACAhoB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIoqB,EAAqC,SAAUxoB,GAE/C,SAASwoB,EAAoBC,EAAW/f,GACpC,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAOjC,OANAM,EAAMuoB,UAAYA,EAClBvoB,EAAMwI,UAAYA,EACbA,GAAkC,IAArB+f,EAAUtpB,SACxBe,EAAMmG,WAAY,EAClBnG,EAAM9B,MAAQqqB,EAAU,IAErBvoB,EA2CX,OApDAJ,EAAQc,UAAU4nB,EAAqBxoB,GAWvCwoB,EAAoBpkB,OAAS,SAAUqkB,EAAW/f,GAC9C,IAAIvJ,EAASspB,EAAUtpB,OACvB,OAAe,IAAXA,EACO,IAAI+mB,EAAkBF,gBAEb,IAAX7mB,EACE,IAAI8mB,EAAmBF,iBAAiB0C,EAAU,GAAI/f,GAGtD,IAAI8f,EAAoBC,EAAW/f,IAGlD8f,EAAoBtc,SAAW,SAAUrD,GACrC,IAAI4f,EAAY5f,EAAM4f,UAAW1mB,EAAQ8G,EAAM9G,MAAO5C,EAAS0J,EAAM1J,OAAQkF,EAAawE,EAAMxE,WAC5FA,EAAW7C,SAGXO,GAAS5C,EACTkF,EAAWlB,YAGfkB,EAAWpB,KAAKwlB,EAAU1mB,IAC1B8G,EAAM9G,MAAQA,EAAQ,EACtBnC,KAAKgJ,SAASC,MAElB2f,EAAoB3mB,UAAUyE,WAAa,SAAUjC,GACjD,IACeokB,EAAN7oB,KAAqB6oB,UAAW/f,EAAhC9I,KAA+C8I,UACpDvJ,EAASspB,EAAUtpB,OACvB,GAAIuJ,EACA,OAAOA,EAAUE,SAAS4f,EAAoBtc,SAAU,GACpDuc,UAAWA,EAAW1mB,MALlB,EAKgC5C,OAAQA,EAAQkF,WAAYA,IAIpE,IAAK,IAAI/D,EAAI,EAAGA,EAAInB,IAAWkF,EAAW7C,OAAQlB,IAC9C+D,EAAWpB,KAAKwlB,EAAUnoB,IAE9B+D,EAAWlB,YAGZqlB,EArD6B,CAsDtC9gB,EAAavB,YACflI,EAAQuqB,oBAAsBA,IAGlCzqB,OAAO,kCAAkC,UAAW,UAAW,QAAS,kBAAmB,sBAAuB,oBAAqB,sBAAuB,uBAAwB,oBAAqB,wBAAyB,qBAAsB,gBAAiB,yBAA0B,wBAAyB,SAAUC,EAASC,EAAS6B,EAASe,EAAW2f,EAAeC,EAAaiI,EAAqBC,EAAsBrC,EAAmBsC,EAAuBlI,EAAYhZ,EAAc8E,EAAavG,GAClgB,aACA/H,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIyqB,EAAgC,SAAU7oB,GAE1C,SAAS6oB,EAAeC,EAAKpgB,GACzB,IAAIxI,EAAQF,EAAOG,KAAKP,KAAM,OAASA,KAGvC,OAFAM,EAAM4oB,IAAMA,EACZ5oB,EAAMwI,UAAYA,EACXxI,EA2FX,OAhGAJ,EAAQc,UAAUioB,EAAgB7oB,GA+DlC6oB,EAAezkB,OAAS,SAAU0kB,EAAKpgB,GACnC,GAAW,MAAPogB,EAAa,CACb,GAA4C,mBAAjCA,EAAI7iB,EAAaV,YACxB,OAAIujB,aAAephB,EAAavB,aAAeuC,EACpCogB,EAEJ,IAAID,EAAeC,EAAKpgB,GAE9B,GAAI7H,EAAU5B,QAAQ6pB,GACvB,OAAO,IAAIxC,EAAkBH,gBAAgB2C,EAAKpgB,GAEjD,GAAI+X,EAAYJ,UAAUyI,GAC3B,OAAO,IAAIJ,EAAoBvB,kBAAkB2B,EAAKpgB,GAErD,GAAwC,mBAA7BogB,EAAIpI,EAAWrB,WAA2C,iBAARyJ,EAC9D,OAAO,IAAIH,EAAqBtB,mBAAmByB,EAAKpgB,GAEvD,GAAI8X,EAAcJ,YAAY0I,GAC/B,OAAO,IAAIF,EAAsBJ,oBAAoBM,EAAKpgB,GAGlE,MAAM,IAAIwH,WAAmB,OAAR4Y,UAAuBA,GAAOA,GAAO,uBAE9DD,EAAehnB,UAAUyE,WAAa,SAAUjC,GAC5C,IAAIykB,EAAMlpB,KAAKkpB,IACXpgB,EAAY9I,KAAK8I,UACrB,OAAiB,MAAbA,EACOogB,EAAI7iB,EAAaV,cAAca,UAAU/B,GAGzCykB,EAAI7iB,EAAaV,cAAca,UAAU,IAAIoG,EAAYP,oBAAoB5H,EAAYqE,EAAW,KAG5GmgB,EAjGwB,CAkGjCnhB,EAAavB,YACflI,EAAQ4qB,eAAiBA,IAG7B9qB,OAAO,wBAAwB,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAAS8qB,GAClG,aACA7qB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ+qB,KAAOD,EAAiBF,eAAezkB,SAGnDrG,OAAO,2BAA2B,UAAW,UAAW,QAAS,4BAA6B,sBAAuB,SAAUC,EAASC,EAAS6B,EAASohB,EAAqBD,GAC3K,aACA/iB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsEtDH,EAAQgrB,SAVR,SAAkBjZ,EAASkZ,EAAgBC,GAEvC,YADmB,IAAfA,IAAyBA,EAAavc,OAAOC,mBAC1C,SAAkCpG,GAKrC,MAJ8B,iBAAnByiB,IACPC,EAAaD,EACbA,EAAiB,MAEdziB,EAAOF,KAAK,IAAI6iB,EAAiBpZ,EAASkZ,EAAgBC,MAIzE,IAAIC,EAAkC,WAClC,SAASA,EAAiBpZ,EAASkZ,EAAgBC,QAC5B,IAAfA,IAAyBA,EAAavc,OAAOC,mBACjDjN,KAAKoQ,QAAUA,EACfpQ,KAAKspB,eAAiBA,EACtBtpB,KAAKupB,WAAaA,EAKtB,OAHAC,EAAiBvnB,UAAU1B,KAAO,SAAUgL,EAAU1E,GAClD,OAAOA,EAAOL,UAAU,IAAIijB,EAAmBle,EAAUvL,KAAKoQ,QAASpQ,KAAKspB,eAAgBtpB,KAAKupB,cAE9FC,EAV0B,GAYrCnrB,EAAQmrB,iBAAmBA,EAM3B,IAAIC,EAAoC,SAAUrpB,GAE9C,SAASqpB,EAAmBnlB,EAAa8L,EAASkZ,EAAgBC,QAC3C,IAAfA,IAAyBA,EAAavc,OAAOC,mBACjD,IAAI3M,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAQ9C,OAPAM,EAAM8P,QAAUA,EAChB9P,EAAMgpB,eAAiBA,EACvBhpB,EAAMipB,WAAaA,EACnBjpB,EAAMsI,cAAe,EACrBtI,EAAM2iB,UACN3iB,EAAMoK,OAAS,EACfpK,EAAM6B,MAAQ,EACP7B,EA8DX,OAzEAJ,EAAQc,UAAUyoB,EAAoBrpB,GAatCqpB,EAAmBxnB,UAAUyC,MAAQ,SAAUlG,GACvCwB,KAAK0K,OAAS1K,KAAKupB,WACnBvpB,KAAK0pB,SAASlrB,GAGdwB,KAAKijB,OAAOzgB,KAAKhE,IAGzBirB,EAAmBxnB,UAAUynB,SAAW,SAAUlrB,GAC9C,IAAIkS,EACAvO,EAAQnC,KAAKmC,QACjB,IACIuO,EAAS1Q,KAAKoQ,QAAQ5R,EAAO2D,GAEjC,MAAO3B,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAK0K,SACL1K,KAAK2pB,UAAUjZ,EAAQlS,EAAO2D,IAElCsnB,EAAmBxnB,UAAU0nB,UAAY,SAAUT,EAAK1qB,EAAO2D,GAC3DnC,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAMkpB,EAAK1qB,EAAO2D,KAErEsnB,EAAmBxnB,UAAU2C,UAAY,WACrC5E,KAAK4I,cAAe,EACA,IAAhB5I,KAAK0K,QAAuC,IAAvB1K,KAAKijB,OAAO1jB,QACjCS,KAAKsE,YAAYf,YAGzBkmB,EAAmBxnB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC5FrgB,KAAKspB,eACLtpB,KAAK4pB,sBAAsB3J,EAAYC,EAAYC,EAAYC,GAG/DpgB,KAAKsE,YAAYjB,KAAK6c,IAG9BuJ,EAAmBxnB,UAAU2nB,sBAAwB,SAAU3J,EAAYC,EAAYC,EAAYC,GAC/F,IAAI1P,EACJ,IACIA,EAAS1Q,KAAKspB,eAAerJ,EAAYC,EAAYC,EAAYC,GAErE,MAAO5f,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAKsE,YAAYjB,KAAKqN,IAE1B+Y,EAAmBxnB,UAAUse,eAAiB,SAAUF,GACpD,IAAI4C,EAASjjB,KAAKijB,OAClBjjB,KAAKqC,OAAOge,GACZrgB,KAAK0K,SACDuY,EAAO1jB,OAAS,EAChBS,KAAK0E,MAAMue,EAAOpY,SAEG,IAAhB7K,KAAK0K,QAAgB1K,KAAK4I,cAC/B5I,KAAKsE,YAAYf,YAGlBkmB,EA1E4B,CA2ErCpI,EAAkBtB,iBACpB1hB,EAAQorB,mBAAqBA,IAGjCtrB,OAAO,sBAAsB,UAAW,WAAY,SAAUC,EAASC,GACnE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQwrB,SAHR,SAAkBzqB,GACd,OAAOA,KAKfjB,OAAO,2BAA2B,UAAW,UAAW,aAAc,oBAAqB,SAAUC,EAASC,EAASyrB,EAAYC,GAC/H,aACAzrB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiDtDH,EAAQ2rB,SAJR,SAAkBT,GAEd,YADmB,IAAfA,IAAyBA,EAAavc,OAAOC,mBAC1C6c,EAAWT,SAASU,EAAWF,SAAU,KAAMN,MAK9DprB,OAAO,4BAA4B,UAAW,UAAW,cAAe,SAAUC,EAASC,EAAS4rB,GAChG,aACA3rB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoDtDH,EAAQ6rB,UAHR,WACI,OAAOD,EAAWD,SAAS,MAKnC7rB,OAAO,0BAA0B,UAAW,UAAW,sBAAuB,OAAQ,SAAU,0BAA2B,SAAUC,EAASC,EAASikB,EAAe6H,EAAMC,EAAQC,GAChL,aACA/rB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAyGtDH,EAAQoD,OAVR,WAEI,IAAK,IADDolB,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAA2B,IAAvB0gB,EAAYtnB,QAAwC,IAAvBsnB,EAAYtnB,QAAgB+iB,EAAcJ,YAAY2E,EAAY,IACxFuD,EAAOhB,KAAKvC,EAAY,IAE5BwD,EAAYH,WAAZG,CAAwBF,EAAKxe,GAAG5L,WAAM,EAAQ8mB,OAK7D1oB,OAAO,yBAAyB,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAASisB,GACvG,aACAhsB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA0DtDH,EAAQoD,OAPR,WAEI,IAAK,IADDolB,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAO,SAAUU,GAAU,OAAOA,EAAOF,KAAKpG,KAAK+pB,EAAS7oB,OAAO1B,WAAM,GAAS8G,GAAQpF,OAAOolB,SAKzG1oB,OAAO,4BAA4B,UAAW,UAAW,cAAe,SAAUC,EAASC,EAASyrB,GAChG,aACAxrB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgEtDH,EAAQksB,UAHR,SAAmBna,EAASkZ,GACxB,OAAOQ,EAAWT,SAASjZ,EAASkZ,EAAgB,MAK5DnrB,OAAO,8BAA8B,UAAW,UAAW,eAAgB,SAAUC,EAASC,EAASmsB,GACnG,aACAlsB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6DtDH,EAAQosB,YAHR,SAAqBC,EAAiBpB,GAClC,OAAOkB,EAAYD,UAAU,WAAc,OAAOG,GAAoBpB,MAK9EnrB,OAAO,wBAAwB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACjH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoDtDH,EAAQoS,MAHR,SAAeka,GACX,OAAO,SAAU9jB,GAAU,OAAOA,EAAOF,KAAK,IAAIikB,EAAcD,EAAW9jB,MAG/E,IAAI+jB,EAA+B,WAC/B,SAASA,EAAcD,EAAW9jB,GAC9B7G,KAAK2qB,UAAYA,EACjB3qB,KAAK6G,OAASA,EAKlB,OAHA+jB,EAAc3oB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACjD,OAAOA,EAAOL,UAAU,IAAIqkB,EAAgBpmB,EAAYzE,KAAK2qB,UAAW3qB,KAAK6G,UAE1E+jB,EARuB,GAe9BC,EAAiC,SAAUzqB,GAE3C,SAASyqB,EAAgBvmB,EAAaqmB,EAAW9jB,GAC7C,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMqqB,UAAYA,EAClBrqB,EAAMuG,OAASA,EACfvG,EAAMmQ,MAAQ,EACdnQ,EAAM6B,MAAQ,EACP7B,EA2BX,OAlCAJ,EAAQc,UAAU6pB,EAAiBzqB,GASnCyqB,EAAgB5oB,UAAUyC,MAAQ,SAAUlG,GACpCwB,KAAK2qB,UACL3qB,KAAK8qB,cAActsB,GAGnBwB,KAAKyQ,SAGboa,EAAgB5oB,UAAU6oB,cAAgB,SAAUtsB,GAChD,IAAIkS,EACJ,IACIA,EAAS1Q,KAAK2qB,UAAUnsB,EAAOwB,KAAKmC,QAASnC,KAAK6G,QAEtD,MAAOrG,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAGvBkQ,GACA1Q,KAAKyQ,SAGboa,EAAgB5oB,UAAU2C,UAAY,WAClC5E,KAAKsE,YAAYjB,KAAKrD,KAAKyQ,OAC3BzQ,KAAKsE,YAAYf,YAEdsnB,EAnCyB,CAoClCvlB,EAAatB,cAGnB7F,OAAO,2BAA2B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GACzK,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQ0sB,SAHR,SAAkBvJ,GACd,OAAO,SAAU3a,GAAU,OAAOA,EAAOF,KAAK,IAAIqkB,EAAiBxJ,MAGvE,IAAIwJ,EAAkC,WAClC,SAASA,EAAiBxJ,GACtBxhB,KAAKwhB,iBAAmBA,EAK5B,OAHAwJ,EAAiB/oB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACpD,OAAOA,EAAOL,UAAU,IAAIykB,EAAmBxmB,EAAYzE,KAAKwhB,oBAE7DwJ,EAP0B,GAcjCC,EAAoC,SAAU7qB,GAE9C,SAAS6qB,EAAmB3mB,EAAakd,GACrC,IAAIlhB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAMkhB,iBAAmBA,EACzBlhB,EAAM+K,UAAW,EACjB/K,EAAM4qB,qBAAuB,KACtB5qB,EAkDX,OAxDAJ,EAAQc,UAAUiqB,EAAoB7qB,GAQtC6qB,EAAmBhpB,UAAUyC,MAAQ,SAAUlG,GAC3C,IACI,IAAIkS,EAAS1Q,KAAKwhB,iBAAiBjhB,KAAKP,KAAMxB,GAC1CkS,GACA1Q,KAAK0pB,SAASlrB,EAAOkS,GAG7B,MAAOlQ,GACHR,KAAKsE,YAAYhB,MAAM9C,KAG/ByqB,EAAmBhpB,UAAU2C,UAAY,WACrC5E,KAAKmrB,YACLnrB,KAAKsE,YAAYf,YAErB0nB,EAAmBhpB,UAAUynB,SAAW,SAAUlrB,EAAOojB,GACrD,IAAIhf,EAAe5C,KAAKkrB,qBACxBlrB,KAAKxB,MAAQA,EACbwB,KAAKqL,UAAW,EACZzI,IACAA,EAAajB,cACb3B,KAAKqC,OAAOO,KAEhBA,EAAe0e,EAAoBN,kBAAkBhhB,KAAM4hB,IACzChgB,QACd5B,KAAKyC,IAAIzC,KAAKkrB,qBAAuBtoB,IAG7CqoB,EAAmBhpB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAChGrgB,KAAKmrB,aAETF,EAAmBhpB,UAAUse,eAAiB,WAC1CvgB,KAAKmrB,aAETF,EAAmBhpB,UAAUkpB,UAAY,WACrC,GAAInrB,KAAKqL,SAAU,CACf,IAAI7M,EAAQwB,KAAKxB,MACboE,EAAe5C,KAAKkrB,qBACpBtoB,IACA5C,KAAKkrB,qBAAuB,KAC5BtoB,EAAajB,cACb3B,KAAKqC,OAAOO,IAEhB5C,KAAKxB,MAAQ,KACbwB,KAAKqL,UAAW,EAChBjL,EAAO6B,UAAUyC,MAAMnE,KAAKP,KAAMxB,KAGnCysB,EAzD4B,CA0DrC5J,EAAkBtB,mBAGxB5hB,OAAO,+BAA+B,UAAW,UAAW,QAAS,gBAAiB,sBAAuB,SAAUC,EAASC,EAAS6B,EAASoF,EAAcqK,GAC5J,aACArR,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAmDtDH,EAAQ+sB,aAJR,SAAsB3I,EAAS3Z,GAE3B,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzC,SAAU7I,GAAU,OAAOA,EAAOF,KAAK,IAAI0kB,EAAqB5I,EAAS3Z,MAGpF,IAAIuiB,EAAsC,WACtC,SAASA,EAAqB5I,EAAS3Z,GACnC9I,KAAKyiB,QAAUA,EACfziB,KAAK8I,UAAYA,EAKrB,OAHAuiB,EAAqBppB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACxD,OAAOA,EAAOL,UAAU,IAAI8kB,EAAuB7mB,EAAYzE,KAAKyiB,QAASziB,KAAK8I,aAE/EuiB,EAR8B,GAerCC,EAAwC,SAAUlrB,GAElD,SAASkrB,EAAuBhnB,EAAame,EAAS3Z,GAClD,IAAIxI,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAMmiB,QAAUA,EAChBniB,EAAMwI,UAAYA,EAClBxI,EAAMirB,sBAAwB,KAC9BjrB,EAAMkrB,UAAY,KAClBlrB,EAAM+K,UAAW,EACV/K,EA4BX,OApCAJ,EAAQc,UAAUsqB,EAAwBlrB,GAU1CkrB,EAAuBrpB,UAAUyC,MAAQ,SAAUlG,GAC/CwB,KAAKyrB,gBACLzrB,KAAKwrB,UAAYhtB,EACjBwB,KAAKqL,UAAW,EAChBrL,KAAKyC,IAAIzC,KAAKurB,sBAAwBvrB,KAAK8I,UAAUE,SAwB7D,SAAsBvE,GAClBA,EAAWinB,iBAzBqE1rB,KAAKyiB,QAASziB,QAE9FsrB,EAAuBrpB,UAAU2C,UAAY,WACzC5E,KAAK0rB,gBACL1rB,KAAKsE,YAAYf,YAErB+nB,EAAuBrpB,UAAUypB,cAAgB,WAC7C1rB,KAAKyrB,gBACDzrB,KAAKqL,WACLrL,KAAKsE,YAAYjB,KAAKrD,KAAKwrB,WAC3BxrB,KAAKwrB,UAAY,KACjBxrB,KAAKqL,UAAW,IAGxBigB,EAAuBrpB,UAAUwpB,cAAgB,WAC7C,IAAIF,EAAwBvrB,KAAKurB,sBACH,OAA1BA,IACAvrB,KAAKqC,OAAOkpB,GACZA,EAAsB5pB,cACtB3B,KAAKurB,sBAAwB,OAG9BD,EArCgC,CAsCzChmB,EAAatB,cAMnB7F,OAAO,iCAAiC,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GAC1H,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoCtDH,EAAQstB,eAJR,SAAwBC,GAEpB,YADqB,IAAjBA,IAA2BA,EAAe,MACvC,SAAU/kB,GAAU,OAAOA,EAAOF,KAAK,IAAIklB,EAAuBD,MAG7E,IAAIC,EAAwC,WACxC,SAASA,EAAuBD,GAC5B5rB,KAAK4rB,aAAeA,EAKxB,OAHAC,EAAuB5pB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAC1D,OAAOA,EAAOL,UAAU,IAAIslB,EAAyBrnB,EAAYzE,KAAK4rB,gBAEnEC,EAPgC,GAcvCC,EAA0C,SAAU1rB,GAEpD,SAAS0rB,EAAyBxnB,EAAasnB,GAC3C,IAAItrB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMsrB,aAAeA,EACrBtrB,EAAMyrB,SAAU,EACTzrB,EAYX,OAjBAJ,EAAQc,UAAU8qB,EAA0B1rB,GAO5C0rB,EAAyB7pB,UAAUyC,MAAQ,SAAUlG,GACjDwB,KAAK+rB,SAAU,EACf/rB,KAAKsE,YAAYjB,KAAK7E,IAE1BstB,EAAyB7pB,UAAU2C,UAAY,WACvC5E,KAAK+rB,SACL/rB,KAAKsE,YAAYjB,KAAKrD,KAAK4rB,cAE/B5rB,KAAKsE,YAAYf,YAEduoB,EAlBkC,CAmB3CxmB,EAAatB,cAGnB7F,OAAO,wBAAwB,UAAW,UAAW,QAAS,qBAAsB,iBAAkB,gBAAiB,mBAAoB,SAAUC,EAASC,EAAS6B,EAASyP,EAAS4S,EAAUjd,EAAc4G,GAC7M,aACA5N,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQ6K,MANR,SAAeA,EAAOJ,QACA,IAAdA,IAAwBA,EAAY6G,EAAQD,OAChD,IACIsc,EADgBzJ,EAASJ,OAAOjZ,IACHA,EAAQJ,EAAUwB,MAASqD,KAAK6a,IAAItf,GACrE,OAAO,SAAUrC,GAAU,OAAOA,EAAOF,KAAK,IAAIslB,EAAcD,EAAUljB,MAG9E,IAAImjB,EAA+B,WAC/B,SAASA,EAAc/iB,EAAOJ,GAC1B9I,KAAKkJ,MAAQA,EACblJ,KAAK8I,UAAYA,EAKrB,OAHAmjB,EAAchqB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACjD,OAAOA,EAAOL,UAAU,IAAI0lB,EAAgBznB,EAAYzE,KAAKkJ,MAAOlJ,KAAK8I,aAEtEmjB,EARuB,GAe9BC,EAAiC,SAAU9rB,GAE3C,SAAS8rB,EAAgB5nB,EAAa4E,EAAOJ,GACzC,IAAIxI,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAM4I,MAAQA,EACd5I,EAAMwI,UAAYA,EAClBxI,EAAM4K,SACN5K,EAAMoK,QAAS,EACfpK,EAAMyJ,SAAU,EACTzJ,EA8CX,OAtDAJ,EAAQc,UAAUkrB,EAAiB9rB,GAUnC8rB,EAAgB5f,SAAW,SAAUrD,GAKjC,IAJA,IAAIpC,EAASoC,EAAMpC,OACfqE,EAAQrE,EAAOqE,MACfpC,EAAYG,EAAMH,UAClBxE,EAAc2E,EAAM3E,YACjB4G,EAAM3L,OAAS,GAAM2L,EAAM,GAAGwC,KAAO5E,EAAUwB,OAAU,GAC5DY,EAAML,QAAQ2B,aAAalB,QAAQhH,GAEvC,GAAI4G,EAAM3L,OAAS,EAAG,CAClB,IAAI4sB,EAAUxe,KAAKC,IAAI,EAAG1C,EAAM,GAAGwC,KAAO5E,EAAUwB,OACpDtK,KAAKgJ,SAASC,EAAOkjB,QAGrBtlB,EAAO6D,QAAS,GAGxBwhB,EAAgBjqB,UAAUmqB,UAAY,SAAUtjB,GAC5C9I,KAAK0K,QAAS,EACd1K,KAAKyC,IAAIqG,EAAUE,SAASkjB,EAAgB5f,SAAUtM,KAAKkJ,OACvDrC,OAAQ7G,KAAMsE,YAAatE,KAAKsE,YAAawE,UAAWA,MAGhEojB,EAAgBjqB,UAAUoqB,qBAAuB,SAAU7f,GACvD,IAAqB,IAAjBxM,KAAK+J,QAAT,CAGA,IAAIjB,EAAY9I,KAAK8I,UACjB/H,EAAU,IAAIurB,EAAaxjB,EAAUwB,MAAQtK,KAAKkJ,MAAOsD,GAC7DxM,KAAKkL,MAAM1I,KAAKzB,IACI,IAAhBf,KAAK0K,QACL1K,KAAKosB,UAAUtjB,KAGvBojB,EAAgBjqB,UAAUyC,MAAQ,SAAUlG,GACxCwB,KAAKqsB,qBAAqBngB,EAAef,aAAaU,WAAWrN,KAErE0tB,EAAgBjqB,UAAU0C,OAAS,SAAUnE,GACzCR,KAAK+J,SAAU,EACf/J,KAAKkL,SACLlL,KAAKsE,YAAYhB,MAAM9C,IAE3B0rB,EAAgBjqB,UAAU2C,UAAY,WAClC5E,KAAKqsB,qBAAqBngB,EAAef,aAAaa,mBAEnDkgB,EAvDyB,CAwDlC5mB,EAAatB,YACXsoB,EAA8B,WAK9B,OAJA,SAAsB5e,EAAMlB,GACxBxM,KAAK0N,KAAOA,EACZ1N,KAAKwM,aAAeA,GAHK,KASrCrO,OAAO,4BAA4B,UAAW,UAAW,QAAS,gBAAiB,gBAAiB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASoF,EAAcwC,EAAcuZ,EAAmBC,GACxO,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAuDtDH,EAAQkuB,UATR,SAAmBC,EAAuBC,GACtC,OAAIA,EACO,SAAU5lB,GACb,OAAO,IAAI6lB,EAA4B7lB,EAAQ4lB,GAC1C9lB,KAAK,IAAIgmB,EAAkBH,KAGjC,SAAU3lB,GAAU,OAAOA,EAAOF,KAAK,IAAIgmB,EAAkBH,MAGxE,IAAIG,EAAmC,WACnC,SAASA,EAAkBH,GACvBxsB,KAAKwsB,sBAAwBA,EAKjC,OAHAG,EAAkB1qB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAIomB,EAAoBnoB,EAAYzE,KAAKwsB,yBAE9DG,EAP2B,GAclCC,EAAqC,SAAUxsB,GAE/C,SAASwsB,EAAoBtoB,EAAakoB,GACtC,IAAIlsB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMksB,sBAAwBA,EAC9BlsB,EAAMusB,WAAY,EAClBvsB,EAAMwsB,8BACNxsB,EAAMwT,UACCxT,EAwDX,OA/DAJ,EAAQc,UAAU4rB,EAAqBxsB,GASvCwsB,EAAoB3qB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACjGrgB,KAAKsE,YAAYjB,KAAK4c,GACtBjgB,KAAK+sB,mBAAmB1M,GACxBrgB,KAAKgtB,eAETJ,EAAoB3qB,UAAUqe,YAAc,SAAUhd,EAAO+c,GACzDrgB,KAAK2E,OAAOrB,IAEhBspB,EAAoB3qB,UAAUse,eAAiB,SAAUF,GACrD,IAAI7hB,EAAQwB,KAAK+sB,mBAAmB1M,GAChC7hB,GACAwB,KAAKsE,YAAYjB,KAAK7E,GAE1BwB,KAAKgtB,eAETJ,EAAoB3qB,UAAUyC,MAAQ,SAAUlG,GAC5C,IACI,IAAIyuB,EAAgBjtB,KAAKwsB,sBAAsBhuB,GAC3CyuB,GACAjtB,KAAKktB,SAASD,EAAezuB,GAGrC,MAAOgC,GACHR,KAAKsE,YAAYhB,MAAM9C,KAG/BosB,EAAoB3qB,UAAU2C,UAAY,WACtC5E,KAAK6sB,WAAY,EACjB7sB,KAAKgtB,eAETJ,EAAoB3qB,UAAU8qB,mBAAqB,SAAUnqB,GACzDA,EAAajB,cACb,IAAIwrB,EAAkBntB,KAAK8sB,2BAA2B7pB,QAAQL,GAC1DpE,EAAQ,KAMZ,OALyB,IAArB2uB,IACA3uB,EAAQwB,KAAK8T,OAAOqZ,GACpBntB,KAAK8sB,2BAA2B5pB,OAAOiqB,EAAiB,GACxDntB,KAAK8T,OAAO5Q,OAAOiqB,EAAiB,IAEjC3uB,GAEXouB,EAAoB3qB,UAAUirB,SAAW,SAAUD,EAAezuB,GAC9D,IAAI4uB,EAAuB9L,EAAoBN,kBAAkBhhB,KAAMitB,EAAezuB,GAClF4uB,IAAyBA,EAAqBxrB,SAC9C5B,KAAKyC,IAAI2qB,GACTptB,KAAK8sB,2BAA2BtqB,KAAK4qB,IAEzCptB,KAAK8T,OAAOtR,KAAKhE,IAErBouB,EAAoB3qB,UAAU+qB,YAAc,WACpChtB,KAAK6sB,WAAwD,IAA3C7sB,KAAK8sB,2BAA2BvtB,QAClDS,KAAKsE,YAAYf,YAGlBqpB,EAhE6B,CAiEtCvL,EAAkBtB,iBAMhB2M,EAA6C,SAAUtsB,GAEvD,SAASssB,EAA4B7lB,EAAQ4lB,GACzC,IAAInsB,EAAQF,EAAOG,KAAKP,OAASA,KAGjC,OAFAM,EAAMuG,OAASA,EACfvG,EAAMmsB,kBAAoBA,EACnBnsB,EAKX,OAVAJ,EAAQc,UAAU0rB,EAA6BtsB,GAO/CssB,EAA4BzqB,UAAUyE,WAAa,SAAUjC,GACzDzE,KAAKysB,kBAAkBjmB,UAAU,IAAI6mB,EAA4B5oB,EAAYzE,KAAK6G,UAE/E6lB,EAXqC,CAY9C5kB,EAAavB,YAMX8mB,EAA6C,SAAUjtB,GAEvD,SAASitB,EAA4BlqB,EAAQ0D,GACzC,IAAIvG,EAAQF,EAAOG,KAAKP,OAASA,KAIjC,OAHAM,EAAM6C,OAASA,EACf7C,EAAMuG,OAASA,EACfvG,EAAMgtB,kBAAmB,EAClBhtB,EAmBX,OAzBAJ,EAAQc,UAAUqsB,EAA6BjtB,GAQ/CitB,EAA4BprB,UAAUyC,MAAQ,SAAUuiB,GACpDjnB,KAAKutB,qBAETF,EAA4BprB,UAAU0C,OAAS,SAAUnE,GACrDR,KAAK2B,cACL3B,KAAKmD,OAAOG,MAAM9C,IAEtB6sB,EAA4BprB,UAAU2C,UAAY,WAC9C5E,KAAKutB,qBAETF,EAA4BprB,UAAUsrB,kBAAoB,WACjDvtB,KAAKstB,mBACNttB,KAAKstB,kBAAmB,EACxBttB,KAAK2B,cACL3B,KAAK6G,OAAOL,UAAUxG,KAAKmD,UAG5BkqB,EA1BqC,CA2B9C/nB,EAAatB,cAGnB7F,OAAO,gCAAgC,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACzH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQmvB,cALR,WACI,OAAO,SAAuC3mB,GAC1C,OAAOA,EAAOF,KAAK,IAAI8mB,KAI/B,IAAIA,EAAuC,WACvC,SAASA,KAKT,OAHAA,EAAsBxrB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACzD,OAAOA,EAAOL,UAAU,IAAIknB,EAAwBjpB,KAEjDgpB,EAN+B,GAatCC,EAAyC,SAAUttB,GAEnD,SAASstB,EAAwBppB,GAC7B,OAAOlE,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK7C,OAPAE,EAAQc,UAAU0sB,EAAyBttB,GAI3CstB,EAAwBzrB,UAAUyC,MAAQ,SAAUlG,GAChDA,EAAM8M,QAAQtL,KAAKsE,cAEhBopB,EARiC,CAS1CpoB,EAAatB,cAGnB7F,OAAO,iBAAiB,UAAW,UAAW,UAAW,SAAUC,EAASC,EAASmF,GACjF,aAEA,SAASmqB,IAGL,OAAsB,WAClB,SAASC,IACL5tB,KAAK6tB,WAoBT,OAlBAD,EAAW3rB,UAAUQ,IAAM,SAAUjE,GAC5BwB,KAAK8tB,IAAItvB,IACVwB,KAAK6tB,QAAQrrB,KAAKhE,IAG1BovB,EAAW3rB,UAAU6rB,IAAM,SAAUtvB,GACjC,OAAwC,IAAjCwB,KAAK6tB,QAAQ5qB,QAAQzE,IAEhCF,OAAOC,eAAeqvB,EAAW3rB,UAAW,QACxC8L,IAAK,WACD,OAAO/N,KAAK6tB,QAAQtuB,QAExB0O,YAAY,EACZC,cAAc,IAElB0f,EAAW3rB,UAAU8rB,MAAQ,WACzB/tB,KAAK6tB,QAAQtuB,OAAS,GAEnBquB,EAtBU,GAJzBtvB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6BtDH,EAAQsvB,eAAiBA,EACzBtvB,EAAQshB,IAAMnc,EAAOvE,KAAK0gB,KAAOgO,MAGrCxvB,OAAO,2BAA2B,UAAW,UAAW,QAAS,qBAAsB,4BAA6B,eAAgB,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,EAAqB5B,GAC7M,aACAphB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiDtDH,EAAQ2vB,SAHR,SAAkBC,EAAaC,GAC3B,OAAO,SAAUrnB,GAAU,OAAOA,EAAOF,KAAK,IAAIwnB,EAAiBF,EAAaC,MAGpF,IAAIC,EAAkC,WAClC,SAASA,EAAiBF,EAAaC,GACnCluB,KAAKiuB,YAAcA,EACnBjuB,KAAKkuB,QAAUA,EAKnB,OAHAC,EAAiBlsB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACpD,OAAOA,EAAOL,UAAU,IAAI4nB,EAAmB3pB,EAAYzE,KAAKiuB,YAAajuB,KAAKkuB,WAE/EC,EAR0B,GAejCC,EAAoC,SAAUhuB,GAE9C,SAASguB,EAAmB9pB,EAAa2pB,EAAaC,GAClD,IAAI5tB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAM2tB,YAAcA,EACpB3tB,EAAMwT,OAAS,IAAI4L,EAAMC,IACrBuO,GACA5tB,EAAMmC,IAAI6e,EAAoBN,kBAAkB1gB,EAAO4tB,IAEpD5tB,EAmCX,OA3CAJ,EAAQc,UAAUotB,EAAoBhuB,GAUtCguB,EAAmBnsB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAChGrgB,KAAK8T,OAAOia,SAEhBK,EAAmBnsB,UAAUqe,YAAc,SAAUhd,EAAO+c,GACxDrgB,KAAK2E,OAAOrB,IAEhB8qB,EAAmBnsB,UAAUyC,MAAQ,SAAUlG,GACvCwB,KAAKiuB,YACLjuB,KAAKquB,gBAAgB7vB,GAGrBwB,KAAKsuB,cAAc9vB,EAAOA,IAGlC4vB,EAAmBnsB,UAAUosB,gBAAkB,SAAU7vB,GACrD,IAAIya,EACA3U,EAActE,KAAKsE,YACvB,IACI2U,EAAMjZ,KAAKiuB,YAAYzvB,GAE3B,MAAOgC,GAEH,YADA8D,EAAYhB,MAAM9C,GAGtBR,KAAKsuB,cAAcrV,EAAKza,IAE5B4vB,EAAmBnsB,UAAUqsB,cAAgB,SAAUrV,EAAKza,GACxD,IAAIsV,EAAS9T,KAAK8T,OACbA,EAAOga,IAAI7U,KACZnF,EAAOrR,IAAIwW,GACXjZ,KAAKsE,YAAYjB,KAAK7E,KAGvB4vB,EA5C4B,CA6CrC/M,EAAkBtB,iBACpB1hB,EAAQ+vB,mBAAqBA,IAGjCjwB,OAAO,uCAAuC,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,uBAAwB,SAAUC,EAASC,EAAS6B,EAASoF,EAAclE,EAAYzB,GACrM,aACArB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQkwB,qBAHR,SAA8BC,EAASP,GACnC,OAAO,SAAUpnB,GAAU,OAAOA,EAAOF,KAAK,IAAI8nB,EAA6BD,EAASP,MAG5F,IAAIQ,EAA8C,WAC9C,SAASA,EAA6BD,EAASP,GAC3CjuB,KAAKwuB,QAAUA,EACfxuB,KAAKiuB,YAAcA,EAKvB,OAHAQ,EAA6BxsB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAChE,OAAOA,EAAOL,UAAU,IAAIkoB,EAA+BjqB,EAAYzE,KAAKwuB,QAASxuB,KAAKiuB,eAEvFQ,EARsC,GAe7CC,EAAgD,SAAUtuB,GAE1D,SAASsuB,EAA+BpqB,EAAakqB,EAASP,GAC1D,IAAI3tB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAM2tB,YAAcA,EACpB3tB,EAAMquB,QAAS,EACQ,mBAAZH,IACPluB,EAAMkuB,QAAUA,GAEbluB,EA6BX,OArCAJ,EAAQc,UAAU0tB,EAAgCtuB,GAUlDsuB,EAA+BzsB,UAAUusB,QAAU,SAAUpvB,EAAGwvB,GAC5D,OAAOxvB,IAAMwvB,GAEjBF,EAA+BzsB,UAAUyC,MAAQ,SAAUlG,GACvD,IACIya,EAAMza,EACV,GAFkBwB,KAAKiuB,cAGnBhV,EAAM7X,EAAWvB,SAASG,KAAKiuB,YAAzB7sB,CAAsC5C,MAChCmB,EAAcF,YACtB,OAAOO,KAAKsE,YAAYhB,MAAM3D,EAAcF,YAAYC,GAGhE,IAAIgR,GAAS,EACb,GAAI1Q,KAAK2uB,QAEL,IADAje,EAAStP,EAAWvB,SAASG,KAAKwuB,QAAzBptB,CAAkCpB,KAAKiZ,IAAKA,MACtCtZ,EAAcF,YACzB,OAAOO,KAAKsE,YAAYhB,MAAM3D,EAAcF,YAAYC,QAI5DM,KAAK2uB,QAAS,GAEM,IAApBhT,QAAQjL,KACR1Q,KAAKiZ,IAAMA,EACXjZ,KAAKsE,YAAYjB,KAAK7E,KAGvBkwB,EAtCwC,CAuCjDppB,EAAatB,cAGnB7F,OAAO,0CAA0C,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASwwB,GAC1H,aACAvwB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8DtDH,EAAQywB,wBAHR,SAAiC7V,EAAKuV,GAClC,OAAOK,EAAuBN,qBAAqB,SAAUnvB,EAAGwvB,GAAK,OAAOJ,EAAUA,EAAQpvB,EAAE6Z,GAAM2V,EAAE3V,IAAQ7Z,EAAE6Z,KAAS2V,EAAE3V,QAKrI9a,OAAO,4BAA4B,UAAW,UAAW,QAAS,gBAAiB,mCAAoC,SAAUC,EAASC,EAAS6B,EAASoF,EAAcypB,GACtK,aACAzwB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQ2wB,UAHR,SAAmB7sB,EAAOypB,GACtB,OAAO,SAAU/kB,GAAU,OAAOA,EAAOF,KAAK,IAAIsoB,EAAkB9sB,EAAOypB,MAG/E,IAAIqD,EAAmC,WACnC,SAASA,EAAkB9sB,EAAOypB,GAG9B,GAFA5rB,KAAKmC,MAAQA,EACbnC,KAAK4rB,aAAeA,EAChBzpB,EAAQ,EACR,MAAM,IAAI4sB,EAA0Bvf,wBAM5C,OAHAyf,EAAkBhtB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAI0oB,EAAoBzqB,EAAYzE,KAAKmC,MAAOnC,KAAK4rB,gBAE1EqD,EAX2B,GAkBlCC,EAAqC,SAAU9uB,GAE/C,SAAS8uB,EAAoB5qB,EAAanC,EAAOypB,GAC7C,IAAItrB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAM6B,MAAQA,EACd7B,EAAMsrB,aAAeA,EACdtrB,EAoBX,OAzBAJ,EAAQc,UAAUkuB,EAAqB9uB,GAOvC8uB,EAAoBjtB,UAAUyC,MAAQ,SAAUtF,GACvB,GAAjBY,KAAKmC,UACLnC,KAAKsE,YAAYjB,KAAKjE,GACtBY,KAAKsE,YAAYf,aAGzB2rB,EAAoBjtB,UAAU2C,UAAY,WACtC,IAAIN,EAActE,KAAKsE,YACnBtE,KAAKmC,OAAS,SACmB,IAAtBnC,KAAK4rB,aACZtnB,EAAYjB,KAAKrD,KAAK4rB,cAGtBtnB,EAAYhB,MAAM,IAAIyrB,EAA0Bvf,0BAGxDlL,EAAYf,YAET2rB,EA1B6B,CA2BtC5pB,EAAatB,cAGnB7F,OAAO,wBAAwB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACjH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQ8wB,MAHR,SAAexE,EAAWta,GACtB,OAAO,SAAUxJ,GAAU,OAAOA,EAAOF,KAAK,IAAIyoB,EAAczE,EAAWta,EAASxJ,MAGxF,IAAIuoB,EAA+B,WAC/B,SAASA,EAAczE,EAAWta,EAASxJ,GACvC7G,KAAK2qB,UAAYA,EACjB3qB,KAAKqQ,QAAUA,EACfrQ,KAAK6G,OAASA,EAKlB,OAHAuoB,EAAcntB,UAAU1B,KAAO,SAAUgL,EAAU1E,GAC/C,OAAOA,EAAOL,UAAU,IAAI6oB,EAAgB9jB,EAAUvL,KAAK2qB,UAAW3qB,KAAKqQ,QAASrQ,KAAK6G,UAEtFuoB,EATuB,GAgB9BC,EAAiC,SAAUjvB,GAE3C,SAASivB,EAAgB/qB,EAAaqmB,EAAWta,EAASxJ,GACtD,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAMqqB,UAAYA,EAClBrqB,EAAM+P,QAAUA,EAChB/P,EAAMuG,OAASA,EACfvG,EAAM6B,MAAQ,EACd7B,EAAM+P,QAAUA,GAAW/P,EACpBA,EAsBX,OA9BAJ,EAAQc,UAAUquB,EAAiBjvB,GAUnCivB,EAAgBptB,UAAUse,eAAiB,SAAU+O,GACjDtvB,KAAKsE,YAAYjB,KAAKisB,GACtBtvB,KAAKsE,YAAYf,YAErB8rB,EAAgBptB,UAAUyC,MAAQ,SAAUlG,GACxC,IAAIkS,GAAS,EACb,IACIA,EAAS1Q,KAAK2qB,UAAUpqB,KAAKP,KAAKqQ,QAAS7R,EAAOwB,KAAKmC,QAASnC,KAAK6G,QAEzE,MAAOrG,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAGtBkQ,GACD1Q,KAAKugB,gBAAe,IAG5B8O,EAAgBptB,UAAU2C,UAAY,WAClC5E,KAAKugB,gBAAe,IAEjB8O,EA/ByB,CAgClC/pB,EAAatB,cAGnB7F,OAAO,0BAA0B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GACxK,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAuCtDH,EAAQkxB,QAHR,WACI,OAAO,SAAU1oB,GAAU,OAAOA,EAAOF,KAAK,IAAI6oB,KAGtD,IAAIA,EAAqC,WACrC,SAASA,KAKT,OAHAA,EAAoBvtB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACvD,OAAOA,EAAOL,UAAU,IAAIipB,EAAsBhrB,KAE/C+qB,EAN6B,GAapCC,EAAuC,SAAUrvB,GAEjD,SAASqvB,EAAsBnrB,GAC3B,IAAIhE,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMsI,cAAe,EACrBtI,EAAMovB,iBAAkB,EACjBpvB,EAqBX,OA1BAJ,EAAQc,UAAUyuB,EAAuBrvB,GAOzCqvB,EAAsBxtB,UAAUyC,MAAQ,SAAUlG,GACzCwB,KAAK0vB,kBACN1vB,KAAK0vB,iBAAkB,EACvB1vB,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAMxB,MAG7DixB,EAAsBxtB,UAAU2C,UAAY,WACxC5E,KAAK4I,cAAe,EACf5I,KAAK0vB,iBACN1vB,KAAKsE,YAAYf,YAGzBksB,EAAsBxtB,UAAUse,eAAiB,SAAUF,GACvDrgB,KAAKqC,OAAOge,GACZrgB,KAAK0vB,iBAAkB,EACnB1vB,KAAK4I,cACL5I,KAAKsE,YAAYf,YAGlBksB,EA3B+B,CA4BxCpO,EAAkBtB,mBAGxB5hB,OAAO,6BAA6B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GAC3K,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkDtDH,EAAQsxB,WAHR,SAAoBvf,EAASkZ,GACzB,OAAO,SAAUziB,GAAU,OAAOA,EAAOF,KAAK,IAAIipB,EAAuBxf,EAASkZ,MAGtF,IAAIsG,EAAwC,WACxC,SAASA,EAAuBxf,EAASkZ,GACrCtpB,KAAKoQ,QAAUA,EACfpQ,KAAKspB,eAAiBA,EAK1B,OAHAsG,EAAuB3tB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAC1D,OAAOA,EAAOL,UAAU,IAAIqpB,EAAyBprB,EAAYzE,KAAKoQ,QAASpQ,KAAKspB,kBAEjFsG,EARgC,GAevCC,EAA0C,SAAUzvB,GAEpD,SAASyvB,EAAyBvrB,EAAa8L,EAASkZ,GACpD,IAAIhpB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAM8P,QAAUA,EAChB9P,EAAMgpB,eAAiBA,EACvBhpB,EAAMovB,iBAAkB,EACxBpvB,EAAMsI,cAAe,EACrBtI,EAAM6B,MAAQ,EACP7B,EAsDX,OA9DAJ,EAAQc,UAAU6uB,EAA0BzvB,GAU5CyvB,EAAyB5tB,UAAUyC,MAAQ,SAAUlG,GAC5CwB,KAAK0vB,iBACN1vB,KAAK8vB,QAAQtxB,IAGrBqxB,EAAyB5tB,UAAU6tB,QAAU,SAAUtxB,GACnD,IAAI2D,EAAQnC,KAAKmC,QACbmC,EAActE,KAAKsE,YACvB,IACI,IAAIoM,EAAS1Q,KAAKoQ,QAAQ5R,EAAO2D,GACjCnC,KAAK0vB,iBAAkB,EACvB1vB,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAM0Q,EAAQlS,EAAO2D,IAExE,MAAO3B,GACH8D,EAAYhB,MAAM9C,KAG1BqvB,EAAyB5tB,UAAU2C,UAAY,WAC3C5E,KAAK4I,cAAe,EACf5I,KAAK0vB,iBACN1vB,KAAKsE,YAAYf,YAGzBssB,EAAyB5tB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACtG,IAAeiJ,EAANtpB,KAA0BspB,eAAgBhlB,EAA1CtE,KAA2DsE,YAChEglB,EACAtpB,KAAK+vB,gBAAgB9P,EAAYC,EAAYC,EAAYC,GAGzD9b,EAAYjB,KAAK6c,IAGzB2P,EAAyB5tB,UAAU8tB,gBAAkB,SAAU9P,EAAYC,EAAYC,EAAYC,GAC/F,IAAekJ,EAANtpB,KAA0BspB,eAAgBhlB,EAA1CtE,KAA2DsE,YACpE,IACI,IAAIoM,EAAS4Y,EAAerJ,EAAYC,EAAYC,EAAYC,GAChE9b,EAAYjB,KAAKqN,GAErB,MAAOlQ,GACH8D,EAAYhB,MAAM9C,KAG1BqvB,EAAyB5tB,UAAUqe,YAAc,SAAU9f,GACvDR,KAAKsE,YAAYhB,MAAM9C,IAE3BqvB,EAAyB5tB,UAAUse,eAAiB,SAAUF,GAC1DrgB,KAAKqC,OAAOge,GACZrgB,KAAK0vB,iBAAkB,EACnB1vB,KAAK4I,cACL5I,KAAKsE,YAAYf,YAGlBssB,EA/DkC,CAgE3CxO,EAAkBtB,mBAGxB5hB,OAAO,yBAAyB,UAAW,UAAW,QAAS,mBAAoB,sBAAuB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASkB,EAAYzB,EAAe0hB,EAAmBC,GAC7O,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQ2xB,OANR,SAAgB5f,EAASmZ,EAAYzgB,GAIjC,YAHmB,IAAfygB,IAAyBA,EAAavc,OAAOC,wBAC/B,IAAdnE,IAAwBA,OAAYc,GACxC2f,GAAcA,GAAc,GAAK,EAAIvc,OAAOC,kBAAoBsc,EACzD,SAAU1iB,GAAU,OAAOA,EAAOF,KAAK,IAAIspB,EAAe7f,EAASmZ,EAAYzgB,MAG1F,IAAImnB,EAAgC,WAChC,SAASA,EAAe7f,EAASmZ,EAAYzgB,GACzC9I,KAAKoQ,QAAUA,EACfpQ,KAAKupB,WAAaA,EAClBvpB,KAAK8I,UAAYA,EAKrB,OAHAmnB,EAAehuB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAClD,OAAOA,EAAOL,UAAU,IAAI0pB,EAAiBzrB,EAAYzE,KAAKoQ,QAASpQ,KAAKupB,WAAYvpB,KAAK8I,aAE1FmnB,EATwB,GAWnC5xB,EAAQ4xB,eAAiBA,EAMzB,IAAIC,EAAkC,SAAU9vB,GAE5C,SAAS8vB,EAAiB5rB,EAAa8L,EAASmZ,EAAYzgB,GACxD,IAAIxI,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAU9C,OATAM,EAAM8P,QAAUA,EAChB9P,EAAMipB,WAAaA,EACnBjpB,EAAMwI,UAAYA,EAClBxI,EAAM6B,MAAQ,EACd7B,EAAMoK,OAAS,EACfpK,EAAMsI,cAAe,EACjB2gB,EAAavc,OAAOC,oBACpB3M,EAAM2iB,WAEH3iB,EAuDX,OAnEAJ,EAAQc,UAAUkvB,EAAkB9vB,GAcpC8vB,EAAiB5jB,SAAW,SAAUC,GAClC,IAAI9H,EAAa8H,EAAI9H,WAAYiM,EAASnE,EAAImE,OAAQlS,EAAQ+N,EAAI/N,MAAO2D,EAAQoK,EAAIpK,MACrFsC,EAAW0rB,sBAAsBzf,EAAQlS,EAAO2D,IAEpD+tB,EAAiBjuB,UAAUyC,MAAQ,SAAUlG,GACzC,IAAI8F,EAActE,KAAKsE,YACvB,GAAIA,EAAY1C,OACZ5B,KAAK4E,gBADT,CAIA,IAAIzC,EAAQnC,KAAKmC,QACjB,GAAInC,KAAK0K,OAAS1K,KAAKupB,WAAY,CAC/BjlB,EAAYjB,KAAK7E,GACjB,IAAIkS,EAAStP,EAAWvB,SAASG,KAAKoQ,QAAzBhP,CAAkC5C,EAAO2D,GACtD,GAAIuO,IAAW/Q,EAAcF,YACzB6E,EAAYhB,MAAM3D,EAAcF,YAAYC,QAE3C,GAAKM,KAAK8I,UAGV,CACD,IAAIG,GAAUxE,WAAYzE,KAAM0Q,OAAQA,EAAQlS,MAAOA,EAAO2D,MAAOA,GACrEnC,KAAKyC,IAAIzC,KAAK8I,UAAUE,SAASknB,EAAiB5jB,SAAU,EAAGrD,SAJ/DjJ,KAAKmwB,sBAAsBzf,EAAQlS,EAAO2D,QAQ9CnC,KAAKijB,OAAOzgB,KAAKhE,KAGzB0xB,EAAiBjuB,UAAUkuB,sBAAwB,SAAUzf,EAAQlS,EAAO2D,GACxEnC,KAAK0K,SACL1K,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAM0Q,EAAQlS,EAAO2D,KAExE+tB,EAAiBjuB,UAAU2C,UAAY,WACnC5E,KAAK4I,cAAe,EAChB5I,KAAK4I,cAAgC,IAAhB5I,KAAK0K,QAC1B1K,KAAKsE,YAAYf,YAGzB2sB,EAAiBjuB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC9FrgB,KAAK0E,MAAMwb,IAEfgQ,EAAiBjuB,UAAUse,eAAiB,SAAUF,GAClD,IAAI4C,EAASjjB,KAAKijB,OAClBjjB,KAAKqC,OAAOge,GACZrgB,KAAK0K,SACDuY,GAAUA,EAAO1jB,OAAS,GAC1BS,KAAK0E,MAAMue,EAAOpY,SAElB7K,KAAK4I,cAAgC,IAAhB5I,KAAK0K,QAC1B1K,KAAKsE,YAAYf,YAGlB2sB,EApE0B,CAqEnC7O,EAAkBtB,iBACpB1hB,EAAQ6xB,iBAAmBA,IAG/B/xB,OAAO,yBAAyB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GAClH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQ4W,OALR,SAAgB0V,EAAWta,GACvB,OAAO,SAAgCxJ,GACnC,OAAOA,EAAOF,KAAK,IAAIypB,EAAezF,EAAWta,MAIzD,IAAI+f,EAAgC,WAChC,SAASA,EAAezF,EAAWta,GAC/BrQ,KAAK2qB,UAAYA,EACjB3qB,KAAKqQ,QAAUA,EAKnB,OAHA+f,EAAenuB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAClD,OAAOA,EAAOL,UAAU,IAAI6pB,EAAiB5rB,EAAYzE,KAAK2qB,UAAW3qB,KAAKqQ,WAE3E+f,EARwB,GAe/BC,EAAkC,SAAUjwB,GAE5C,SAASiwB,EAAiB/rB,EAAaqmB,EAAWta,GAC9C,IAAI/P,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAMqqB,UAAYA,EAClBrqB,EAAM+P,QAAUA,EAChB/P,EAAMmQ,MAAQ,EACPnQ,EAiBX,OAvBAJ,EAAQc,UAAUqvB,EAAkBjwB,GAUpCiwB,EAAiBpuB,UAAUyC,MAAQ,SAAUlG,GACzC,IAAIkS,EACJ,IACIA,EAAS1Q,KAAK2qB,UAAUpqB,KAAKP,KAAKqQ,QAAS7R,EAAOwB,KAAKyQ,SAE3D,MAAOjQ,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAGvBkQ,GACA1Q,KAAKsE,YAAYjB,KAAK7E,IAGvB6xB,EAxB0B,CAyBnC/qB,EAAatB,cAGnB7F,OAAO,2BAA2B,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,SAAUC,EAASC,EAAS6B,EAASoF,EAAczB,GACrJ,aACAvF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAYtDH,EAAQiyB,SAHR,SAAkBC,GACd,OAAO,SAAU1pB,GAAU,OAAOA,EAAOF,KAAK,IAAI6pB,EAAgBD,MAGtE,IAAIC,EAAiC,WACjC,SAASA,EAAgBD,GACrBvwB,KAAKuwB,SAAWA,EAKpB,OAHAC,EAAgBvuB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACnD,OAAOA,EAAOL,UAAU,IAAIiqB,EAAkBhsB,EAAYzE,KAAKuwB,YAE5DC,EAPyB,GAchCC,EAAmC,SAAUrwB,GAE7C,SAASqwB,EAAkBnsB,EAAaisB,GACpC,IAAIjwB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAE9C,OADAM,EAAMmC,IAAI,IAAIoB,EAAenC,aAAa6uB,IACnCjwB,EAEX,OANAJ,EAAQc,UAAUyvB,EAAmBrwB,GAM9BqwB,EAP2B,CAQpCnrB,EAAatB,cAGnB7F,OAAO,uBAAuB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GAChH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwCtDH,EAAQqyB,KANR,SAAc/F,EAAWta,GACrB,GAAyB,mBAAdsa,EACP,MAAM,IAAIra,UAAU,+BAExB,OAAO,SAAUzJ,GAAU,OAAOA,EAAOF,KAAK,IAAIgqB,EAAkBhG,EAAW9jB,GAAQ,EAAOwJ,MAGlG,IAAIsgB,EAAmC,WACnC,SAASA,EAAkBhG,EAAW9jB,EAAQ+pB,EAAYvgB,GACtDrQ,KAAK2qB,UAAYA,EACjB3qB,KAAK6G,OAASA,EACd7G,KAAK4wB,WAAaA,EAClB5wB,KAAKqQ,QAAUA,EAKnB,OAHAsgB,EAAkB1uB,UAAU1B,KAAO,SAAUgL,EAAU1E,GACnD,OAAOA,EAAOL,UAAU,IAAIqqB,EAAoBtlB,EAAUvL,KAAK2qB,UAAW3qB,KAAK6G,OAAQ7G,KAAK4wB,WAAY5wB,KAAKqQ,WAE1GsgB,EAV2B,GAYtCtyB,EAAQsyB,kBAAoBA,EAM5B,IAAIE,EAAqC,SAAUzwB,GAE/C,SAASywB,EAAoBvsB,EAAaqmB,EAAW9jB,EAAQ+pB,EAAYvgB,GACrE,IAAI/P,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAMqqB,UAAYA,EAClBrqB,EAAMuG,OAASA,EACfvG,EAAMswB,WAAaA,EACnBtwB,EAAM+P,QAAUA,EAChB/P,EAAM6B,MAAQ,EACP7B,EAuBX,OA/BAJ,EAAQc,UAAU6vB,EAAqBzwB,GAUvCywB,EAAoB5uB,UAAUse,eAAiB,SAAU/hB,GACrD,IAAI8F,EAActE,KAAKsE,YACvBA,EAAYjB,KAAK7E,GACjB8F,EAAYf,YAEhBstB,EAAoB5uB,UAAUyC,MAAQ,SAAUlG,GAC5C,IAAemsB,EAAN3qB,KAAqB2qB,UAAWta,EAAhCrQ,KAA6CqQ,QAClDlO,EAAQnC,KAAKmC,QACjB,IACiBwoB,EAAUpqB,KAAK8P,GAAWrQ,KAAMxB,EAAO2D,EAAOnC,KAAK6G,SAE5D7G,KAAKugB,eAAevgB,KAAK4wB,WAAazuB,EAAQ3D,GAGtD,MAAOgC,GACHR,KAAKsE,YAAYhB,MAAM9C,KAG/BqwB,EAAoB5uB,UAAU2C,UAAY,WACtC5E,KAAKugB,eAAevgB,KAAK4wB,YAAc,OAAIhnB,IAExCinB,EAhC6B,CAiCtCvrB,EAAatB,YACf3F,EAAQwyB,oBAAsBA,IAGlC1yB,OAAO,4BAA4B,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASyyB,GACvG,aACAxyB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQ0yB,UAHR,SAAmBpG,EAAWta,GAC1B,OAAO,SAAUxJ,GAAU,OAAOA,EAAOF,KAAK,IAAImqB,EAAOH,kBAAkBhG,EAAW9jB,GAAQ,EAAMwJ,QAK5GlS,OAAO,wBAAwB,UAAW,UAAW,QAAS,gBAAiB,sBAAuB,SAAUC,EAASC,EAAS6B,EAASoF,EAAc0rB,GACrJ,aACA1yB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQ4yB,MAHR,SAAetG,EAAWrB,EAAgBsC,GACtC,OAAO,SAAU/kB,GAAU,OAAOA,EAAOF,KAAK,IAAIuqB,EAAcvG,EAAWrB,EAAgBsC,EAAc/kB,MAG7G,IAAIqqB,EAA+B,WAC/B,SAASA,EAAcvG,EAAWrB,EAAgBsC,EAAc/kB,GAC5D7G,KAAK2qB,UAAYA,EACjB3qB,KAAKspB,eAAiBA,EACtBtpB,KAAK4rB,aAAeA,EACpB5rB,KAAK6G,OAASA,EAKlB,OAHAqqB,EAAcjvB,UAAU1B,KAAO,SAAUgL,EAAU1E,GAC/C,OAAOA,EAAOL,UAAU,IAAI2qB,EAAgB5lB,EAAUvL,KAAK2qB,UAAW3qB,KAAKspB,eAAgBtpB,KAAK4rB,aAAc5rB,KAAK6G,UAEhHqqB,EAVuB,GAiB9BC,EAAiC,SAAU/wB,GAE3C,SAAS+wB,EAAgB7sB,EAAaqmB,EAAWrB,EAAgBsC,EAAc/kB,GAC3E,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAQ9C,OAPAM,EAAMqqB,UAAYA,EAClBrqB,EAAMgpB,eAAiBA,EACvBhpB,EAAMsrB,aAAeA,EACrBtrB,EAAMuG,OAASA,EACfvG,EAAM6B,MAAQ,EACd7B,EAAMsI,cAAe,EACrBtI,EAAM8wB,UAAW,EACV9wB,EA6DX,OAvEAJ,EAAQc,UAAUmwB,EAAiB/wB,GAYnC+wB,EAAgBlvB,UAAUyC,MAAQ,SAAUlG,GACxC,IAAI2D,EAAQnC,KAAKmC,QACbnC,KAAK2qB,UACL3qB,KAAK8qB,cAActsB,EAAO2D,GAG1BnC,KAAKqxB,MAAM7yB,EAAO2D,IAG1BgvB,EAAgBlvB,UAAU6oB,cAAgB,SAAUtsB,EAAO2D,GACvD,IAAIuO,EACJ,IACIA,EAAS1Q,KAAK2qB,UAAUnsB,EAAO2D,EAAOnC,KAAK6G,QAE/C,MAAOrG,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAGvBkQ,GACA1Q,KAAKqxB,MAAM7yB,EAAO2D,IAG1BgvB,EAAgBlvB,UAAUovB,MAAQ,SAAU7yB,EAAO2D,GAC3CnC,KAAKspB,eACLtpB,KAAKsxB,mBAAmB9yB,EAAO2D,GAGnCnC,KAAKuxB,WAAW/yB,IAEpB2yB,EAAgBlvB,UAAUqvB,mBAAqB,SAAU9yB,EAAO2D,GAC5D,IAAIuO,EACJ,IACIA,EAAS1Q,KAAKspB,eAAe9qB,EAAO2D,GAExC,MAAO3B,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAKuxB,WAAW7gB,IAEpBygB,EAAgBlvB,UAAUsvB,WAAa,SAAU/yB,GAC7C,IAAI8F,EAActE,KAAKsE,YAClBtE,KAAKoxB,WACNpxB,KAAKoxB,UAAW,EAChB9sB,EAAYjB,KAAK7E,GACjB8F,EAAYf,WACZvD,KAAK4I,cAAe,IAG5BuoB,EAAgBlvB,UAAU2C,UAAY,WAClC,IAAIN,EAActE,KAAKsE,YAClBtE,KAAK4I,mBAA6C,IAAtB5I,KAAK4rB,aAI5B5rB,KAAK4I,cACXtE,EAAYhB,MAAM,IAAI0tB,EAAazhB,aAJnCjL,EAAYjB,KAAKrD,KAAK4rB,cACtBtnB,EAAYf,aAMb4tB,EAxEyB,CAyElC7rB,EAAatB,cAGnB7F,OAAO,yBAAyB,UAAW,WAAY,SAAUC,EAASC,GACtE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIgzB,EAA6B,WAC7B,SAASA,IACLxxB,KAAKyxB,KAAO,EACZzxB,KAAK6tB,WACL7tB,KAAK0xB,SAsCT,OApCAF,EAAYvvB,UAAU8L,IAAM,SAAUkL,GAClC,IAAIvY,EAAIV,KAAK0xB,MAAMzuB,QAAQgW,GAC3B,OAAc,IAAPvY,OAAWkJ,EAAY5J,KAAK6tB,QAAQntB,IAE/C8wB,EAAYvvB,UAAU0vB,IAAM,SAAU1Y,EAAKza,GACvC,IAAIkC,EAAIV,KAAK0xB,MAAMzuB,QAAQgW,GAS3B,OARW,IAAPvY,GACAV,KAAK0xB,MAAMlvB,KAAKyW,GAChBjZ,KAAK6tB,QAAQrrB,KAAKhE,GAClBwB,KAAKyxB,QAGLzxB,KAAK6tB,QAAQntB,GAAKlC,EAEfwB,MAEXwxB,EAAYvvB,UAAU6V,OAAS,SAAUmB,GACrC,IAAIvY,EAAIV,KAAK0xB,MAAMzuB,QAAQgW,GAC3B,OAAW,IAAPvY,IAGJV,KAAK6tB,QAAQ3qB,OAAOxC,EAAG,GACvBV,KAAK0xB,MAAMxuB,OAAOxC,EAAG,GACrBV,KAAKyxB,QACE,IAEXD,EAAYvvB,UAAU8rB,MAAQ,WAC1B/tB,KAAK0xB,MAAMnyB,OAAS,EACpBS,KAAK6tB,QAAQtuB,OAAS,EACtBS,KAAKyxB,KAAO,GAEhBD,EAAYvvB,UAAU+E,QAAU,SAAUgY,EAAI3O,GAC1C,IAAK,IAAI3P,EAAI,EAAGA,EAAIV,KAAKyxB,KAAM/wB,IAC3Bse,EAAGze,KAAK8P,EAASrQ,KAAK6tB,QAAQntB,GAAIV,KAAK0xB,MAAMhxB,KAG9C8wB,EA1CqB,GA4ChCnzB,EAAQmzB,YAAcA,IAG1BrzB,OAAO,iBAAiB,UAAW,UAAW,SAAU,iBAAkB,SAAUC,EAASC,EAASmF,EAAQouB,GAC1G,aACAtzB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQwhB,IAAMrc,EAAOvE,KAAK4gB,KAA6B+R,EAAcJ,cAGzErzB,OAAO,qBAAqB,UAAW,WAAY,SAAUC,EAASC,GAClE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAIqzB,EAAyB,WACzB,SAASA,IACL7xB,KAAK8T,UAwBT,OAtBA+d,EAAQ5vB,UAAU6V,OAAS,SAAUmB,GAEjC,OADAjZ,KAAK8T,OAAOmF,GAAO,MACZ,GAEX4Y,EAAQ5vB,UAAU0vB,IAAM,SAAU1Y,EAAKza,GAEnC,OADAwB,KAAK8T,OAAOmF,GAAOza,EACZwB,MAEX6xB,EAAQ5vB,UAAU8L,IAAM,SAAUkL,GAC9B,OAAOjZ,KAAK8T,OAAOmF,IAEvB4Y,EAAQ5vB,UAAU+E,QAAU,SAAUgY,EAAI3O,GACtC,IAAIyD,EAAS9T,KAAK8T,OAClB,IAAK,IAAImF,KAAOnF,EACRA,EAAO6D,eAAesB,IAAwB,OAAhBnF,EAAOmF,IACrC+F,EAAGze,KAAK8P,EAASyD,EAAOmF,GAAMA,IAI1C4Y,EAAQ5vB,UAAU8rB,MAAQ,WACtB/tB,KAAK8T,WAEF+d,EA1BiB,GA4B5BxzB,EAAQwzB,QAAUA,IAGtB1zB,OAAO,0BAA0B,UAAW,UAAW,QAAS,gBAAiB,kBAAmB,gBAAiB,aAAc,cAAe,mBAAoB,SAAUC,EAASC,EAAS6B,EAASoF,EAAczB,EAAgBiE,EAAcW,EAAWmX,EAAOkS,GACrQ,aACAxzB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA0EtDH,EAAQ0zB,QALR,SAAiB9D,EAAa+D,EAAiBxQ,EAAkByQ,GAC7D,OAAO,SAAUprB,GACb,OAAOA,EAAOF,KAAK,IAAIurB,EAAgBjE,EAAa+D,EAAiBxQ,EAAkByQ,MAI/F,IAAIC,EAAiC,WACjC,SAASA,EAAgBjE,EAAa+D,EAAiBxQ,EAAkByQ,GACrEjyB,KAAKiuB,YAAcA,EACnBjuB,KAAKgyB,gBAAkBA,EACvBhyB,KAAKwhB,iBAAmBA,EACxBxhB,KAAKiyB,gBAAkBA,EAK3B,OAHAC,EAAgBjwB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACnD,OAAOA,EAAOL,UAAU,IAAI2rB,EAAkB1tB,EAAYzE,KAAKiuB,YAAajuB,KAAKgyB,gBAAiBhyB,KAAKwhB,iBAAkBxhB,KAAKiyB,mBAE3HC,EAVyB,GAiBhCC,EAAmC,SAAU/xB,GAE7C,SAAS+xB,EAAkB7tB,EAAa2pB,EAAa+D,EAAiBxQ,EAAkByQ,GACpF,IAAI3xB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAQ9C,OAPAM,EAAM2tB,YAAcA,EACpB3tB,EAAM0xB,gBAAkBA,EACxB1xB,EAAMkhB,iBAAmBA,EACzBlhB,EAAM2xB,gBAAkBA,EACxB3xB,EAAM8xB,OAAS,KACf9xB,EAAM+xB,wBAAyB,EAC/B/xB,EAAMmQ,MAAQ,EACPnQ,EAmFX,OA7FAJ,EAAQc,UAAUmxB,EAAmB/xB,GAYrC+xB,EAAkBlwB,UAAUyC,MAAQ,SAAUlG,GAC1C,IAAIya,EACJ,IACIA,EAAMjZ,KAAKiuB,YAAYzvB,GAE3B,MAAOgC,GAEH,YADAR,KAAKsD,MAAM9C,GAGfR,KAAKsyB,OAAO9zB,EAAOya,IAEvBkZ,EAAkBlwB,UAAUqwB,OAAS,SAAU9zB,EAAOya,GAClD,IAAImZ,EAASpyB,KAAKoyB,OACbA,IACDA,EAASpyB,KAAKoyB,OAAwB,iBAARnZ,EAAmB,IAAI6Y,EAAUD,QAAY,IAAIjS,EAAMC,KAEzF,IACI0S,EADAC,EAAQJ,EAAOrkB,IAAIkL,GAEvB,GAAIjZ,KAAKgyB,gBACL,IACIO,EAAUvyB,KAAKgyB,gBAAgBxzB,GAEnC,MAAOgC,GACHR,KAAKsD,MAAM9C,QAIf+xB,EAAU/zB,EAEd,IAAKg0B,EAAO,CACRA,EAAQxyB,KAAKiyB,gBAAkBjyB,KAAKiyB,kBAAoB,IAAIxpB,EAAUP,QACtEkqB,EAAOT,IAAI1Y,EAAKuZ,GAChB,IAAIC,EAAoB,IAAIC,EAAkBzZ,EAAKuZ,EAAOxyB,MAE1D,GADAA,KAAKsE,YAAYjB,KAAKovB,GAClBzyB,KAAKwhB,iBAAkB,CACvB,IAAII,OAAW,EACf,IACIA,EAAW5hB,KAAKwhB,iBAAiB,IAAIkR,EAAkBzZ,EAAKuZ,IAEhE,MAAOhyB,GAEH,YADAR,KAAKsD,MAAM9C,GAGfR,KAAKyC,IAAImf,EAASpb,UAAU,IAAImsB,EAAwB1Z,EAAKuZ,EAAOxyB,SAGvEwyB,EAAM5wB,QACP4wB,EAAMnvB,KAAKkvB,IAGnBJ,EAAkBlwB,UAAU0C,OAAS,SAAUnE,GAC3C,IAAI4xB,EAASpyB,KAAKoyB,OACdA,IACAA,EAAOprB,QAAQ,SAAUwrB,EAAOvZ,GAC5BuZ,EAAMlvB,MAAM9C,KAEhB4xB,EAAOrE,SAEX/tB,KAAKsE,YAAYhB,MAAM9C,IAE3B2xB,EAAkBlwB,UAAU2C,UAAY,WACpC,IAAIwtB,EAASpyB,KAAKoyB,OACdA,IACAA,EAAOprB,QAAQ,SAAUwrB,EAAOvZ,GAC5BuZ,EAAMjvB,aAEV6uB,EAAOrE,SAEX/tB,KAAKsE,YAAYf,YAErB4uB,EAAkBlwB,UAAU2wB,YAAc,SAAU3Z,GAChDjZ,KAAKoyB,OAAOta,OAAOmB,IAEvBkZ,EAAkBlwB,UAAUN,YAAc,WACjC3B,KAAK4B,SACN5B,KAAKqyB,wBAAyB,EACX,IAAfryB,KAAKyQ,OACLrQ,EAAO6B,UAAUN,YAAYpB,KAAKP,QAIvCmyB,EA9F2B,CA+FpC7sB,EAAatB,YAMX2uB,EAAyC,SAAUvyB,GAEnD,SAASuyB,EAAwB1Z,EAAKuZ,EAAOrvB,GACzC,IAAI7C,EAAQF,EAAOG,KAAKP,KAAMwyB,IAAUxyB,KAIxC,OAHAM,EAAM2Y,IAAMA,EACZ3Y,EAAMkyB,MAAQA,EACdlyB,EAAM6C,OAASA,EACR7C,EAYX,OAlBAJ,EAAQc,UAAU2xB,EAAyBvyB,GAQ3CuyB,EAAwB1wB,UAAUyC,MAAQ,SAAUlG,GAChDwB,KAAKuD,YAETovB,EAAwB1wB,UAAUD,aAAe,WAC7C,IAAemB,EAANnD,KAAkBmD,OAAQ8V,EAA1BjZ,KAAmCiZ,IAC5CjZ,KAAKiZ,IAAMjZ,KAAKmD,OAAS,KACrBA,GACAA,EAAOyvB,YAAY3Z,IAGpB0Z,EAnBiC,CAoB1CrtB,EAAatB,YASX0uB,EAAmC,SAAUtyB,GAE7C,SAASsyB,EAAkBzZ,EAAK4Z,EAAcC,GAC1C,IAAIxyB,EAAQF,EAAOG,KAAKP,OAASA,KAIjC,OAHAM,EAAM2Y,IAAMA,EACZ3Y,EAAMuyB,aAAeA,EACrBvyB,EAAMwyB,qBAAuBA,EACtBxyB,EAWX,OAjBAJ,EAAQc,UAAU0xB,EAAmBtyB,GAQrCsyB,EAAkBzwB,UAAUyE,WAAa,SAAUjC,GAC/C,IAAI7B,EAAe,IAAIiB,EAAenC,aACvBoxB,EAAN9yB,KAAgC8yB,qBAAsBD,EAAtD7yB,KAAwE6yB,aAKjF,OAJIC,IAAyBA,EAAqBlxB,QAC9CgB,EAAaH,IAAI,IAAIswB,EAA0BD,IAEnDlwB,EAAaH,IAAIowB,EAAarsB,UAAU/B,IACjC7B,GAEJ8vB,EAlB2B,CAmBpC5qB,EAAavB,YACflI,EAAQq0B,kBAAoBA,EAM5B,IAAIK,EAA2C,SAAU3yB,GAErD,SAAS2yB,EAA0B5vB,GAC/B,IAAI7C,EAAQF,EAAOG,KAAKP,OAASA,KAGjC,OAFAM,EAAM6C,OAASA,EACfA,EAAOsN,QACAnQ,EAYX,OAjBAJ,EAAQc,UAAU+xB,EAA2B3yB,GAO7C2yB,EAA0B9wB,UAAUN,YAAc,WAC9C,IAAIwB,EAASnD,KAAKmD,OACbA,EAAOvB,QAAW5B,KAAK4B,SACxBxB,EAAO6B,UAAUN,YAAYpB,KAAKP,MAClCmD,EAAOsN,OAAS,EACK,IAAjBtN,EAAOsN,OAAetN,EAAOkvB,wBAC7BlvB,EAAOxB,gBAIZoxB,EAlBmC,CAmB5ClvB,EAAenC,gBAGrBvD,OAAO,iCAAiC,UAAW,UAAW,QAAS,gBAAiB,gBAAiB,SAAUC,EAASC,EAAS6B,EAASoF,EAAcO,GACxJ,aACAvH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgBtDH,EAAQ20B,eALR,WACI,OAAO,SAAwCnsB,GAC3C,OAAOA,EAAOF,KAAK,IAAIssB,KAI/B,IAAIA,EAAwC,WACxC,SAASA,KAKT,OAHAA,EAAuBhxB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAC1D,OAAOA,EAAOL,UAAU,IAAI0sB,EAAyBzuB,KAElDwuB,EANgC,GAavCC,EAA0C,SAAU9yB,GAEpD,SAAS8yB,IACL,OAAkB,OAAX9yB,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAK/D,OAPAE,EAAQc,UAAUkyB,EAA0B9yB,GAI5C8yB,EAAyBjxB,UAAUyC,MAAQ,SAAUuiB,GACjDphB,EAAOD,QAEJstB,EARkC,CAS3C5tB,EAAatB,cAGnB7F,OAAO,0BAA0B,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACnH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQ0tB,QAHR,WACI,OAAO,SAAUllB,GAAU,OAAOA,EAAOF,KAAK,IAAIwsB,KAGtD,IAAIA,EAAiC,WACjC,SAASA,KAKT,OAHAA,EAAgBlxB,UAAU1B,KAAO,SAAUgL,EAAU1E,GACjD,OAAOA,EAAOL,UAAU,IAAI4sB,EAAkB7nB,KAE3C4nB,EANyB,GAahCC,EAAmC,SAAUhzB,GAE7C,SAASgzB,EAAkB9uB,GACvB,OAAOlE,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAa7C,OAfAE,EAAQc,UAAUoyB,EAAmBhzB,GAIrCgzB,EAAkBnxB,UAAUse,eAAiB,SAAUwL,GACnD,IAAIznB,EAActE,KAAKsE,YACvBA,EAAYjB,KAAK0oB,GACjBznB,EAAYf,YAEhB6vB,EAAkBnxB,UAAUyC,MAAQ,SAAUlG,GAC1CwB,KAAKugB,gBAAe,IAExB6S,EAAkBnxB,UAAU2C,UAAY,WACpC5E,KAAKugB,gBAAe,IAEjB6S,EAhB2B,CAiBpC9tB,EAAatB,cAGnB7F,OAAO,uBAAuB,UAAW,UAAW,QAAS,gBAAiB,sBAAuB,SAAUC,EAASC,EAAS6B,EAASoF,EAAc0rB,GACpJ,aACA1yB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsBtDH,EAAQg1B,KAHR,SAAc1I,EAAWrB,EAAgBsC,GACrC,OAAO,SAAU/kB,GAAU,OAAOA,EAAOF,KAAK,IAAI2sB,EAAa3I,EAAWrB,EAAgBsC,EAAc/kB,MAG5G,IAAIysB,EAA8B,WAC9B,SAASA,EAAa3I,EAAWrB,EAAgBsC,EAAc/kB,GAC3D7G,KAAK2qB,UAAYA,EACjB3qB,KAAKspB,eAAiBA,EACtBtpB,KAAK4rB,aAAeA,EACpB5rB,KAAK6G,OAASA,EAKlB,OAHAysB,EAAarxB,UAAU1B,KAAO,SAAUgL,EAAU1E,GAC9C,OAAOA,EAAOL,UAAU,IAAI+sB,EAAehoB,EAAUvL,KAAK2qB,UAAW3qB,KAAKspB,eAAgBtpB,KAAK4rB,aAAc5rB,KAAK6G,UAE/GysB,EAVsB,GAiB7BC,EAAgC,SAAUnzB,GAE1C,SAASmzB,EAAejvB,EAAaqmB,EAAWrB,EAAgBsC,EAAc/kB,GAC1E,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAW9C,OAVAM,EAAMqqB,UAAYA,EAClBrqB,EAAMgpB,eAAiBA,EACvBhpB,EAAMsrB,aAAeA,EACrBtrB,EAAMuG,OAASA,EACfvG,EAAM+K,UAAW,EACjB/K,EAAM6B,MAAQ,OACc,IAAjBypB,IACPtrB,EAAMkrB,UAAYI,EAClBtrB,EAAM+K,UAAW,GAEd/K,EAwDX,OArEAJ,EAAQc,UAAUuyB,EAAgBnzB,GAelCmzB,EAAetxB,UAAUyC,MAAQ,SAAUlG,GACvC,IAAI2D,EAAQnC,KAAKmC,QACjB,GAAInC,KAAK2qB,UACL3qB,KAAK8qB,cAActsB,EAAO2D,OAEzB,CACD,GAAInC,KAAKspB,eAEL,YADAtpB,KAAKsxB,mBAAmB9yB,EAAO2D,GAGnCnC,KAAKwrB,UAAYhtB,EACjBwB,KAAKqL,UAAW,IAGxBkoB,EAAetxB,UAAU6oB,cAAgB,SAAUtsB,EAAO2D,GACtD,IAAIuO,EACJ,IACIA,EAAS1Q,KAAK2qB,UAAUnsB,EAAO2D,EAAOnC,KAAK6G,QAE/C,MAAOrG,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3B,GAAIkQ,EAAQ,CACR,GAAI1Q,KAAKspB,eAEL,YADAtpB,KAAKsxB,mBAAmB9yB,EAAO2D,GAGnCnC,KAAKwrB,UAAYhtB,EACjBwB,KAAKqL,UAAW,IAGxBkoB,EAAetxB,UAAUqvB,mBAAqB,SAAU9yB,EAAO2D,GAC3D,IAAIuO,EACJ,IACIA,EAAS1Q,KAAKspB,eAAe9qB,EAAO2D,GAExC,MAAO3B,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAKwrB,UAAY9a,EACjB1Q,KAAKqL,UAAW,GAEpBkoB,EAAetxB,UAAU2C,UAAY,WACjC,IAAIN,EAActE,KAAKsE,YACnBtE,KAAKqL,UACL/G,EAAYjB,KAAKrD,KAAKwrB,WACtBlnB,EAAYf,YAGZe,EAAYhB,MAAM,IAAI0tB,EAAazhB,aAGpCgkB,EAtEwB,CAuEjCjuB,EAAatB,cAGnB7F,OAAO,wBAAwB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACjH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8BtDH,EAAQm1B,MAHR,SAAeh1B,GACX,OAAO,SAAUqI,GAAU,OAAOA,EAAOF,KAAK,IAAI8sB,EAAcj1B,MAGpE,IAAIi1B,EAA+B,WAC/B,SAASA,EAAcj1B,GACnBwB,KAAKxB,MAAQA,EAKjB,OAHAi1B,EAAcxxB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACjD,OAAOA,EAAOL,UAAU,IAAIktB,EAAgBjvB,EAAYzE,KAAKxB,SAE1Di1B,EAPuB,GAc9BC,EAAiC,SAAUtzB,GAE3C,SAASszB,EAAgBpvB,EAAa9F,GAClC,IAAI8B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAE9C,OADAM,EAAM9B,MAAQA,EACP8B,EAKX,OATAJ,EAAQc,UAAU0yB,EAAiBtzB,GAMnCszB,EAAgBzxB,UAAUyC,MAAQ,SAAUtF,GACxCY,KAAKsE,YAAYjB,KAAKrD,KAAKxB,QAExBk1B,EAVyB,CAWlCpuB,EAAatB,cAGnB7F,OAAO,8BAA8B,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,SAAUC,EAASC,EAAS6B,EAASoF,EAAc4G,GACxJ,aACA5N,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkDtDH,EAAQs1B,YALR,WACI,OAAO,SAAqC9sB,GACxC,OAAOA,EAAOF,KAAK,IAAIitB,KAI/B,IAAIA,EAAqC,WACrC,SAASA,KAKT,OAHAA,EAAoB3xB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACvD,OAAOA,EAAOL,UAAU,IAAIqtB,EAAsBpvB,KAE/CmvB,EAN6B,GAapCC,EAAuC,SAAUzzB,GAEjD,SAASyzB,EAAsBvvB,GAC3B,OAAOlE,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAe7C,OAjBAE,EAAQc,UAAU6yB,EAAuBzzB,GAIzCyzB,EAAsB5xB,UAAUyC,MAAQ,SAAUlG,GAC9CwB,KAAKsE,YAAYjB,KAAK6I,EAAef,aAAaU,WAAWrN,KAEjEq1B,EAAsB5xB,UAAU0C,OAAS,SAAUnE,GAC/C,IAAI8D,EAActE,KAAKsE,YACvBA,EAAYjB,KAAK6I,EAAef,aAAaY,YAAYvL,IACzD8D,EAAYf,YAEhBswB,EAAsB5xB,UAAU2C,UAAY,WACxC,IAAIN,EAActE,KAAKsE,YACvBA,EAAYjB,KAAK6I,EAAef,aAAaa,kBAC7C1H,EAAYf,YAETswB,EAlB+B,CAmBxCvuB,EAAatB,cAGnB7F,OAAO,uBAAuB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GAChH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQy1B,KAdR,SAAcC,EAAaC,GACvB,IAAIC,GAAU,EASd,OAHIh0B,UAAUV,QAAU,IACpB00B,GAAU,GAEP,SAA8BptB,GACjC,OAAOA,EAAOF,KAAK,IAAIutB,EAAaH,EAAaC,EAAMC,MAI/D,IAAIC,EAA8B,WAC9B,SAASA,EAAaH,EAAaC,EAAMC,QACrB,IAAZA,IAAsBA,GAAU,GACpCj0B,KAAK+zB,YAAcA,EACnB/zB,KAAKg0B,KAAOA,EACZh0B,KAAKi0B,QAAUA,EAKnB,OAHAC,EAAajyB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAChD,OAAOA,EAAOL,UAAU,IAAI2tB,EAAe1vB,EAAYzE,KAAK+zB,YAAa/zB,KAAKg0B,KAAMh0B,KAAKi0B,WAEtFC,EAVsB,GAiB7BC,EAAgC,SAAU/zB,GAE1C,SAAS+zB,EAAe7vB,EAAayvB,EAAaK,EAAOH,GACrD,IAAI3zB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMyzB,YAAcA,EACpBzzB,EAAM8zB,MAAQA,EACd9zB,EAAM2zB,QAAUA,EAChB3zB,EAAM6B,MAAQ,EACP7B,EAkCX,OAzCAJ,EAAQc,UAAUmzB,EAAgB/zB,GASlC9B,OAAOC,eAAe41B,EAAelyB,UAAW,QAC5C8L,IAAK,WACD,OAAO/N,KAAKo0B,OAEhBzC,IAAK,SAAUnzB,GACXwB,KAAKi0B,SAAU,EACfj0B,KAAKo0B,MAAQ51B,GAEjByP,YAAY,EACZC,cAAc,IAElBimB,EAAelyB,UAAUyC,MAAQ,SAAUlG,GACvC,GAAKwB,KAAKi0B,QAKN,OAAOj0B,KAAK0pB,SAASlrB,GAJrBwB,KAAKg0B,KAAOx1B,EACZwB,KAAKsE,YAAYjB,KAAK7E,IAM9B21B,EAAelyB,UAAUynB,SAAW,SAAUlrB,GAC1C,IACIkS,EADAvO,EAAQnC,KAAKmC,QAEjB,IACIuO,EAAS1Q,KAAK+zB,YAAY/zB,KAAKg0B,KAAMx1B,EAAO2D,GAEhD,MAAO3B,GACHR,KAAKsE,YAAYhB,MAAM9C,GAE3BR,KAAKg0B,KAAOtjB,EACZ1Q,KAAKsE,YAAYjB,KAAKqN,IAEnByjB,EA1CwB,CA2CjC7uB,EAAatB,cAGnB7F,OAAO,2BAA2B,UAAW,UAAW,QAAS,gBAAiB,kCAAmC,iCAAkC,SAAUC,EAASC,EAAS6B,EAASoF,EAAcypB,EAA2BzI,GACjO,aACAhoB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+CtDH,EAAQg2B,SAVR,SAAkB5jB,GACd,OAAO,SAAkC5J,GACrC,OAAc,IAAV4J,EACO,IAAI6V,EAAkBF,gBAGtBvf,EAAOF,KAAK,IAAI2tB,EAAiB7jB,MAKpD,IAAI6jB,EAAkC,WAClC,SAASA,EAAiBC,GAEtB,GADAv0B,KAAKu0B,MAAQA,EACTv0B,KAAKu0B,MAAQ,EACb,MAAM,IAAIxF,EAA0Bvf,wBAM5C,OAHA8kB,EAAiBryB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACpD,OAAOA,EAAOL,UAAU,IAAIguB,EAAmB/vB,EAAYzE,KAAKu0B,SAE7DD,EAV0B,GAiBjCE,EAAoC,SAAUp0B,GAE9C,SAASo0B,EAAmBlwB,EAAaiwB,GACrC,IAAIj0B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAMi0B,MAAQA,EACdj0B,EAAMm0B,KAAO,IAAIn1B,MACjBgB,EAAMmQ,MAAQ,EACPnQ,EA2BX,OAjCAJ,EAAQc,UAAUwzB,EAAoBp0B,GAQtCo0B,EAAmBvyB,UAAUyC,MAAQ,SAAUlG,GAC3C,IAAIi2B,EAAOz0B,KAAKy0B,KACZF,EAAQv0B,KAAKu0B,MACb9jB,EAAQzQ,KAAKyQ,QACjB,GAAIgkB,EAAKl1B,OAASg1B,EACdE,EAAKjyB,KAAKhE,OAET,CAEDi2B,EADYhkB,EAAQ8jB,GACN/1B,IAGtBg2B,EAAmBvyB,UAAU2C,UAAY,WACrC,IAAIN,EAActE,KAAKsE,YACnBmM,EAAQzQ,KAAKyQ,MACjB,GAAIA,EAAQ,EAGR,IAAK,IAFD8jB,EAAQv0B,KAAKyQ,OAASzQ,KAAKu0B,MAAQv0B,KAAKu0B,MAAQv0B,KAAKyQ,MACrDgkB,EAAOz0B,KAAKy0B,KACP/zB,EAAI,EAAGA,EAAI6zB,EAAO7zB,IAAK,CAC5B,IAAIsnB,EAAOvX,IAAW8jB,EACtBjwB,EAAYjB,KAAKoxB,EAAKzM,IAG9B1jB,EAAYf,YAETixB,EAlC4B,CAmCrClvB,EAAatB,cAGnB7F,OAAO,yBAAyB,UAAW,UAAW,SAAU,aAAc,mBAAoB,gBAAiB,SAAUC,EAASC,EAASq2B,EAAQC,EAAYC,EAAkBtuB,GACjL,aACAhI,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+DtDH,EAAQkD,OAjBR,SAAgBwyB,EAAaC,GAMzB,OAAI/zB,UAAUV,QAAU,EACb,SAAwCsH,GAC3C,OAAOP,EAAOJ,KAAKwuB,EAAOZ,KAAKC,EAAaC,GAAOW,EAAWN,SAAS,GAAIO,EAAiBjJ,eAAeqI,GAApG1tB,CAA2GO,IAGnH,SAAgCA,GACnC,OAAOP,EAAOJ,KAAKwuB,EAAOZ,KAAK,SAAUe,EAAKr2B,EAAO2D,GACjD,OAAO4xB,EAAYc,EAAKr2B,EAAO2D,EAAQ,KACvCwyB,EAAWN,SAAS,GAFjB/tB,CAEqBO,OAMxC1I,OAAO,sBAAsB,UAAW,UAAW,YAAa,SAAUC,EAASC,EAASy2B,GACxF,aACAx2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQuP,IANR,SAAamnB,GACT,IAAInnB,EAA2B,mBAAbmnB,EACZ,SAAU31B,EAAGwvB,GAAK,OAAOmG,EAAS31B,EAAGwvB,GAAK,EAAIxvB,EAAIwvB,GAClD,SAAUxvB,EAAGwvB,GAAK,OAAOxvB,EAAIwvB,EAAIxvB,EAAIwvB,GAC3C,OAAOkG,EAASvzB,OAAOqM,MAK/BzP,OAAO,wBAAwB,UAAW,UAAW,gBAAiB,gCAAiC,aAAc,uBAAwB,SAAUC,EAASC,EAASyJ,EAAc4e,EAAmBuD,EAAY3H,GAClN,aAwEA,SAAS0S,IAEL,IAAK,IADDnO,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,IAAIojB,EAAavc,OAAOC,kBACpBnE,EAAY,KACZuqB,EAAOxM,EAAYA,EAAYtnB,OAAS,GAU5C,OATI+iB,EAAcJ,YAAYmR,IAC1BvqB,EAAY+d,EAAYJ,MACpBI,EAAYtnB,OAAS,GAAoD,iBAAxCsnB,EAAYA,EAAYtnB,OAAS,KAClEgqB,EAAa1C,EAAYJ,QAGR,iBAAT4M,IACZ9J,EAAa1C,EAAYJ,OAEX,OAAd3d,GAA6C,IAAvB+d,EAAYtnB,QAAgBsnB,EAAY,aAAc/e,EAAavB,WAClFsgB,EAAY,GAEhBoD,EAAWD,SAAST,EAApBU,CAAgC,IAAIvD,EAAkBH,gBAAgBM,EAAa/d,IA3F9FxK,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAStDH,EAAQ42B,MAPR,WAEI,IAAK,IADDpO,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAO,SAAUU,GAAU,OAAOA,EAAOF,KAAKpG,KAAKy0B,EAAYj1B,WAAM,GAAS8G,GAAQpF,OAAOolB,OAsFjGxoB,EAAQ22B,YAAcA,IAG1B72B,OAAO,6BAA6B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GAC3K,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQ62B,WARR,SAAoBxK,EAAiBpB,EAAgBC,GAMjD,YALmB,IAAfA,IAAyBA,EAAavc,OAAOC,mBACnB,iBAAnBqc,IACPC,EAAaD,EACbA,EAAiB,MAEd,SAAUziB,GAAU,OAAOA,EAAOF,KAAK,IAAIwuB,EAAmBzK,EAAiBpB,EAAgBC,MAK1G,IAAI4L,EAAoC,WACpC,SAASA,EAAmBjM,EAAKI,EAAgBC,QAC1B,IAAfA,IAAyBA,EAAavc,OAAOC,mBACjDjN,KAAKkpB,IAAMA,EACXlpB,KAAKspB,eAAiBA,EACtBtpB,KAAKupB,WAAaA,EAKtB,OAHA4L,EAAmBlzB,UAAU1B,KAAO,SAAUgL,EAAU1E,GACpD,OAAOA,EAAOL,UAAU,IAAI4uB,EAAqB7pB,EAAUvL,KAAKkpB,IAAKlpB,KAAKspB,eAAgBtpB,KAAKupB,cAE5F4L,EAV4B,GAYvC92B,EAAQ82B,mBAAqBA,EAM7B,IAAIC,EAAsC,SAAUh1B,GAEhD,SAASg1B,EAAqB9wB,EAAa4kB,EAAKI,EAAgBC,QACzC,IAAfA,IAAyBA,EAAavc,OAAOC,mBACjD,IAAI3M,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAQ9C,OAPAM,EAAM4oB,IAAMA,EACZ5oB,EAAMgpB,eAAiBA,EACvBhpB,EAAMipB,WAAaA,EACnBjpB,EAAMsI,cAAe,EACrBtI,EAAM2iB,UACN3iB,EAAMoK,OAAS,EACfpK,EAAM6B,MAAQ,EACP7B,EA2DX,OAtEAJ,EAAQc,UAAUo0B,EAAsBh1B,GAaxCg1B,EAAqBnzB,UAAUyC,MAAQ,SAAUlG,GAC7C,GAAIwB,KAAK0K,OAAS1K,KAAKupB,WAAY,CAC/B,IAAID,EAAiBtpB,KAAKspB,eACtBnnB,EAAQnC,KAAKmC,QACb+mB,EAAMlpB,KAAKkpB,IACX5kB,EAActE,KAAKsE,YACvBtE,KAAK0K,SACL1K,KAAK2pB,UAAUT,EAAK5kB,EAAaglB,EAAgB9qB,EAAO2D,QAGxDnC,KAAKijB,OAAOzgB,KAAKhE,IAGzB42B,EAAqBnzB,UAAU0nB,UAAY,SAAUT,EAAK5kB,EAAaglB,EAAgB9qB,EAAO2D,GAC1FnC,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAMkpB,EAAK1qB,EAAO2D,KAErEizB,EAAqBnzB,UAAU2C,UAAY,WACvC5E,KAAK4I,cAAe,EACA,IAAhB5I,KAAK0K,QAAuC,IAAvB1K,KAAKijB,OAAO1jB,QACjCS,KAAKsE,YAAYf,YAGzB6xB,EAAqBnzB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAClG,IAAeiJ,EAANtpB,KAA0BspB,eAAgBhlB,EAA1CtE,KAA2DsE,YAChEglB,EACAtpB,KAAK+vB,gBAAgB9P,EAAYC,EAAYC,EAAYC,GAGzD9b,EAAYjB,KAAK6c,IAGzBkV,EAAqBnzB,UAAU8tB,gBAAkB,SAAU9P,EAAYC,EAAYC,EAAYC,GAC3F,IACI1P,EADW4Y,EAANtpB,KAA0BspB,eAAgBhlB,EAA1CtE,KAA2DsE,YAEpE,IACIoM,EAAS4Y,EAAerJ,EAAYC,EAAYC,EAAYC,GAEhE,MAAO5f,GAEH,YADA8D,EAAYhB,MAAM9C,GAGtB8D,EAAYjB,KAAKqN,IAErB0kB,EAAqBnzB,UAAUqe,YAAc,SAAU9f,GACnDR,KAAKsE,YAAYhB,MAAM9C,IAE3B40B,EAAqBnzB,UAAUse,eAAiB,SAAUF,GACtD,IAAI4C,EAASjjB,KAAKijB,OAClBjjB,KAAKqC,OAAOge,GACZrgB,KAAK0K,SACDuY,EAAO1jB,OAAS,EAChBS,KAAK0E,MAAMue,EAAOpY,SAEG,IAAhB7K,KAAK0K,QAAgB1K,KAAK4I,cAC/B5I,KAAKsE,YAAYf,YAGlB6xB,EAvE8B,CAwEvC/T,EAAkBtB,iBACpB1hB,EAAQ+2B,qBAAuBA,IAGnCj3B,OAAO,4BAA4B,UAAW,UAAW,QAAS,mBAAoB,sBAAuB,4BAA6B,sBAAuB,SAAUC,EAASC,EAAS6B,EAASkB,EAAYzB,EAAe2hB,EAAqBD,GAClP,aACA/iB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoCtDH,EAAQg3B,UAJR,SAAmBtB,EAAaC,EAAMzK,GAElC,YADmB,IAAfA,IAAyBA,EAAavc,OAAOC,mBAC1C,SAAUpG,GAAU,OAAOA,EAAOF,KAAK,IAAI2uB,EAAkBvB,EAAaC,EAAMzK,MAG3F,IAAI+L,EAAmC,WACnC,SAASA,EAAkBvB,EAAaC,EAAMzK,GAC1CvpB,KAAK+zB,YAAcA,EACnB/zB,KAAKg0B,KAAOA,EACZh0B,KAAKupB,WAAaA,EAKtB,OAHA+L,EAAkBrzB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAI+uB,EAAoB9wB,EAAYzE,KAAK+zB,YAAa/zB,KAAKg0B,KAAMh0B,KAAKupB,cAE3F+L,EAT2B,GAWtCj3B,EAAQi3B,kBAAoBA,EAM5B,IAAIC,EAAqC,SAAUn1B,GAE/C,SAASm1B,EAAoBjxB,EAAayvB,EAAac,EAAKtL,GACxD,IAAIjpB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAS9C,OARAM,EAAMyzB,YAAcA,EACpBzzB,EAAMu0B,IAAMA,EACZv0B,EAAMipB,WAAaA,EACnBjpB,EAAM+K,UAAW,EACjB/K,EAAMsI,cAAe,EACrBtI,EAAM2iB,UACN3iB,EAAMoK,OAAS,EACfpK,EAAM6B,MAAQ,EACP7B,EAmDX,OA9DAJ,EAAQc,UAAUu0B,EAAqBn1B,GAavCm1B,EAAoBtzB,UAAUyC,MAAQ,SAAUlG,GAC5C,GAAIwB,KAAK0K,OAAS1K,KAAKupB,WAAY,CAC/B,IAAIpnB,EAAQnC,KAAKmC,QACb+mB,EAAM9nB,EAAWvB,SAASG,KAAK+zB,YAAzB3yB,CAAsCpB,KAAK60B,IAAKr2B,GACtD8F,EAActE,KAAKsE,YACnB4kB,IAAQvpB,EAAcF,YACtB6E,EAAYhB,MAAM3D,EAAcF,YAAYC,IAG5CM,KAAK0K,SACL1K,KAAK2pB,UAAUT,EAAK1qB,EAAO2D,SAI/BnC,KAAKijB,OAAOzgB,KAAKhE,IAGzB+2B,EAAoBtzB,UAAU0nB,UAAY,SAAUT,EAAK1qB,EAAO2D,GAC5DnC,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAMkpB,EAAK1qB,EAAO2D,KAErEozB,EAAoBtzB,UAAU2C,UAAY,WACtC5E,KAAK4I,cAAe,EACA,IAAhB5I,KAAK0K,QAAuC,IAAvB1K,KAAKijB,OAAO1jB,UACX,IAAlBS,KAAKqL,UACLrL,KAAKsE,YAAYjB,KAAKrD,KAAK60B,KAE/B70B,KAAKsE,YAAYf,aAGzBgyB,EAAoBtzB,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACjG,IAAI/b,EAActE,KAAKsE,YACvBtE,KAAK60B,IAAM3U,EACXlgB,KAAKqL,UAAW,EAChB/G,EAAYjB,KAAK6c,IAErBqV,EAAoBtzB,UAAUse,eAAiB,SAAUF,GACrD,IAAI4C,EAASjjB,KAAKijB,OAClBjjB,KAAKqC,OAAOge,GACZrgB,KAAK0K,SACDuY,EAAO1jB,OAAS,EAChBS,KAAK0E,MAAMue,EAAOpY,SAEG,IAAhB7K,KAAK0K,QAAgB1K,KAAK4I,gBACT,IAAlB5I,KAAKqL,UACLrL,KAAKsE,YAAYjB,KAAKrD,KAAK60B,KAE/B70B,KAAKsE,YAAYf,aAGlBgyB,EA/D6B,CAgEtClU,EAAkBtB,iBACpB1hB,EAAQk3B,oBAAsBA,IAGlCp3B,OAAO,sBAAsB,UAAW,UAAW,YAAa,SAAUC,EAASC,EAASy2B,GACxF,aACAx2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQm3B,IANR,SAAaT,GACT,IAAIS,EAA2B,mBAAbT,EACZ,SAAU31B,EAAGwvB,GAAK,OAAOmG,EAAS31B,EAAGwvB,GAAK,EAAIxvB,EAAIwvB,GAClD,SAAUxvB,EAAGwvB,GAAK,OAAOxvB,EAAIwvB,EAAIxvB,EAAIwvB,GAC3C,OAAOkG,EAASvzB,OAAOi0B,MAK/Br3B,OAAO,4BAA4B,UAAW,UAAW,uCAAwC,SAAUC,EAASC,EAASo3B,GACzH,aACAn3B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAyCtDH,EAAQq3B,UApBR,SAAmBC,EAAyB7P,GACxC,OAAO,SAAmCjf,GACtC,IAAIkI,EASJ,GAPIA,EADmC,mBAA5B4mB,EACUA,EAGA,WACb,OAAOA,GAGS,mBAAb7P,EACP,OAAOjf,EAAOF,KAAK,IAAIivB,EAAkB7mB,EAAgB+W,IAE7D,IAAIzX,EAAc/P,OAAOkG,OAAOqC,EAAQ4uB,EAAwBpmB,iCAGhE,OAFAhB,EAAYxH,OAASA,EACrBwH,EAAYU,eAAiBA,EACtBV,IAIf,IAAIunB,EAAmC,WACnC,SAASA,EAAkB7mB,EAAgB+W,GACvC9lB,KAAK+O,eAAiBA,EACtB/O,KAAK8lB,SAAWA,EASpB,OAPA8P,EAAkB3zB,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,IAAIif,EAAW9lB,KAAK8lB,SAChBne,EAAU3H,KAAK+O,iBACfnM,EAAekjB,EAASne,GAASnB,UAAU/B,GAE/C,OADA7B,EAAaH,IAAIoE,EAAOL,UAAUmB,IAC3B/E,GAEJgzB,EAZ2B,GActCv3B,EAAQu3B,kBAAoBA,IAGhCz3B,OAAO,oCAAoC,UAAW,UAAW,QAAS,+BAAgC,kBAAmB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASipB,EAAkBloB,EAAWogB,EAAmBC,GAClQ,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAyEtDH,EAAQw3B,kBAVR,WAEI,IAAK,IADDC,KACK3vB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC2vB,EAAY3vB,GAAMlG,UAAUkG,GAKhC,OAH2B,IAAvB2vB,EAAYv2B,QAAgB0B,EAAU5B,QAAQy2B,EAAY,MAC1DA,EAAcA,EAAY,IAEvB,SAAUjvB,GAAU,OAAOA,EAAOF,KAAK,IAAIovB,EAA0BD,MAgBhFz3B,EAAQ23B,wBAZR,WAEI,IAAK,IADDF,KACK3vB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC2vB,EAAY3vB,GAAMlG,UAAUkG,GAEhC,IAAIU,EAAS,KAKb,OAJ2B,IAAvBivB,EAAYv2B,QAAgB0B,EAAU5B,QAAQy2B,EAAY,MAC1DA,EAAcA,EAAY,IAE9BjvB,EAASivB,EAAYjrB,QACd,IAAIse,EAAiBF,eAAepiB,EAAQ,MAAMF,KAAK,IAAIovB,EAA0BD,KAGhG,IAAIC,EAA2C,WAC3C,SAASA,EAA0BD,GAC/B91B,KAAK81B,YAAcA,EAKvB,OAHAC,EAA0B9zB,UAAU1B,KAAO,SAAUkE,EAAYoC,GAC7D,OAAOA,EAAOL,UAAU,IAAIyvB,EAA4BxxB,EAAYzE,KAAK81B,eAEtEC,EAPmC,GAS1CE,EAA6C,SAAU71B,GAEvD,SAAS61B,EAA4B3xB,EAAawxB,GAC9C,IAAIx1B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMgE,YAAcA,EACpBhE,EAAMw1B,YAAcA,EACbx1B,EAuBX,OA5BAJ,EAAQc,UAAUi1B,EAA6B71B,GAO/C61B,EAA4Bh0B,UAAUqe,YAAc,SAAUhd,EAAO+c,GACjErgB,KAAKk2B,yBAETD,EAA4Bh0B,UAAUse,eAAiB,SAAUF,GAC7DrgB,KAAKk2B,yBAETD,EAA4Bh0B,UAAU0C,OAAS,SAAUnE,GACrDR,KAAKk2B,yBAETD,EAA4Bh0B,UAAU2C,UAAY,WAC9C5E,KAAKk2B,yBAETD,EAA4Bh0B,UAAUi0B,sBAAwB,WAC1D,IAAI7yB,EAAOrD,KAAK81B,YAAYjrB,QACxBxH,EACArD,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAMqD,IAGrDrD,KAAKsE,YAAYf,YAGlB0yB,EA7BqC,CA8B9C5U,EAAkBtB,mBAGxB5hB,OAAO,2BAA2B,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACpH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAuCtDH,EAAQ83B,SAHR,WACI,OAAO,SAAUtvB,GAAU,OAAOA,EAAOF,KAAK,IAAIyvB,KAGtD,IAAIA,EAAkC,WAClC,SAASA,KAKT,OAHAA,EAAiBn0B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACpD,OAAOA,EAAOL,UAAU,IAAI6vB,EAAmB5xB,KAE5C2xB,EAN0B,GAajCC,EAAoC,SAAUj2B,GAE9C,SAASi2B,EAAmB/xB,GACxB,IAAIhE,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAE9C,OADAM,EAAMg2B,SAAU,EACTh2B,EAWX,OAfAJ,EAAQc,UAAUq1B,EAAoBj2B,GAMtCi2B,EAAmBp0B,UAAUyC,MAAQ,SAAUlG,GACvCwB,KAAKs2B,QACLt2B,KAAKsE,YAAYjB,MAAMrD,KAAKiG,KAAMzH,IAGlCwB,KAAKs2B,SAAU,EAEnBt2B,KAAKiG,KAAOzH,GAET63B,EAhB4B,CAiBrC/wB,EAAatB,cAGnB7F,OAAO,iBAAiB,UAAW,WAAY,SAAUC,EAASC,GAC9D,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAStDH,EAAQk4B,IARR,SAAaC,EAAMnmB,GACf,SAASomB,IACL,OAASA,EAAQD,KAAKz2B,MAAM02B,EAAQpmB,QAASpQ,WAIjD,OAFAw2B,EAAQD,KAAOA,EACfC,EAAQpmB,QAAUA,EACXomB,KAKft4B,OAAO,4BAA4B,UAAW,UAAW,cAAe,YAAa,SAAUC,EAASC,EAASq4B,EAAOC,GACpH,aACAr4B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgDtDH,EAAQu4B,UANR,SAAmBjM,EAAWta,GAC1B,OAAO,SAAUxJ,GAAU,OACvB8vB,EAAS1hB,OAAO0V,EAAWta,EAA3BsmB,CAAoC9vB,GACpC8vB,EAAS1hB,OAAOyhB,EAAMH,IAAI5L,EAAWta,GAArCsmB,CAA+C9vB,QAM3D1I,OAAO,wBAAwB,UAAW,UAAW,SAAU,SAAUC,EAASC,EAASsS,GACvF,aACArS,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQw4B,MAXR,WAEI,IAAK,IADDC,KACK3wB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC2wB,EAAW3wB,GAAMlG,UAAUkG,GAE/B,IAAI5G,EAASu3B,EAAWv3B,OACxB,GAAe,IAAXA,EACA,MAAM,IAAIL,MAAM,uCAEpB,OAAO,SAAU2H,GAAU,OAAO8J,EAAMlQ,IAG5C,SAAiBs2B,EAAOx3B,GAcpB,OAba,SAAUH,GAEnB,IAAK,IADD43B,EAAc53B,EACTsB,EAAI,EAAGA,EAAInB,EAAQmB,IAAK,CAC7B,IAAIu2B,EAAID,EAAYD,EAAMr2B,IAC1B,QAAiB,IAANu2B,EAIP,OAHAD,EAAcC,EAMtB,OAAOD,GAfiCE,CAAQJ,EAAYv3B,GAA9BoR,CAAuC9J,OAqBjF1I,OAAO,0BAA0B,UAAW,UAAW,aAAc,eAAgB,SAAUC,EAASC,EAASoK,EAAW0uB,GACxH,aACA74B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoBtDH,EAAQ+4B,QALR,SAAiBtR,GACb,OAAOA,EACHqR,EAAYzB,UAAU,WAAc,OAAO,IAAIjtB,EAAUP,SAAc4d,GACvEqR,EAAYzB,UAAU,IAAIjtB,EAAUP,YAKhD/J,OAAO,kCAAkC,UAAW,UAAW,qBAAsB,eAAgB,SAAUC,EAASC,EAASg5B,EAAmBF,GAChJ,aACA74B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAUtDH,EAAQi5B,gBAHR,SAAyB94B,GACrB,OAAO,SAAUqI,GAAU,OAAOswB,EAAYzB,UAAU,IAAI2B,EAAkBxpB,gBAAgBrP,GAA5D24B,CAAoEtwB,OAK9G1I,OAAO,8BAA8B,UAAW,UAAW,kBAAmB,eAAgB,SAAUC,EAASC,EAASk5B,EAAgBJ,GACtI,aACA74B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQm5B,YAHR,WACI,OAAO,SAAU3wB,GAAU,OAAOswB,EAAYzB,UAAU,IAAI6B,EAAe7uB,aAAzCyuB,CAAyDtwB,OAKnG1I,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,eAAgB,SAAUC,EAASC,EAASo5B,EAAiBN,GAC1I,aACA74B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAUtDH,EAAQq5B,cARR,SAAuB5qB,EAAYC,EAAY4qB,EAAqB7uB,GAC5D6uB,GAAsD,mBAAxBA,IAC9B7uB,EAAY6uB,GAEhB,IAAI7R,EAA0C,mBAAxB6R,EAAqCA,OAAsB/tB,EAC7EjC,EAAU,IAAI8vB,EAAgB5qB,cAAcC,EAAYC,EAAYjE,GACxE,OAAO,SAAUjC,GAAU,OAAOswB,EAAYzB,UAAU,WAAc,OAAO/tB,GAAYme,EAAvDqR,CAAiEtwB,OAK3G1I,OAAO,wBAAwB,UAAW,UAAW,QAAS,kBAAmB,gCAAiC,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASe,EAAWylB,EAAmBrF,EAAmBC,GACxP,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQu5B,KAjBR,WAEI,IAAK,IADD/Q,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAIhC,GAA2B,IAAvB0gB,EAAYtnB,OAAc,CAC1B,IAAI0B,EAAU5B,QAAQwnB,EAAY,IAI9B,OAAOA,EAAY,GAHnBA,EAAcA,EAAY,GAMlC,OAAO,IAAIH,EAAkBH,gBAAgBM,GAAalgB,KAAK,IAAIkxB,IAGvE,IAAIA,EAA8B,WAC9B,SAASA,KAKT,OAHAA,EAAa51B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAChD,OAAOA,EAAOL,UAAU,IAAIsxB,EAAerzB,KAExCozB,EANsB,GAQjCx5B,EAAQw5B,aAAeA,EAMvB,IAAIC,EAAgC,SAAU13B,GAE1C,SAAS03B,EAAexzB,GACpB,IAAIhE,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAMy3B,UAAW,EACjBz3B,EAAMumB,eACNvmB,EAAMyC,iBACCzC,EAqCX,OA3CAJ,EAAQc,UAAU82B,EAAgB13B,GAQlC03B,EAAe71B,UAAUyC,MAAQ,SAAUiB,GACvC3F,KAAK6mB,YAAYrkB,KAAKmD,IAE1BmyB,EAAe71B,UAAU2C,UAAY,WACjC,IAAIiiB,EAAc7mB,KAAK6mB,YACnBzkB,EAAMykB,EAAYtnB,OACtB,GAAY,IAAR6C,EACApC,KAAKsE,YAAYf,eAEhB,CACD,IAAK,IAAI7C,EAAI,EAAGA,EAAI0B,IAAQpC,KAAK+3B,SAAUr3B,IAAK,CAC5C,IAAIiF,EAAakhB,EAAYnmB,GACzBkC,EAAe0e,EAAoBN,kBAAkBhhB,KAAM2F,EAAYA,EAAYjF,GACnFV,KAAK+C,eACL/C,KAAK+C,cAAcP,KAAKI,GAE5B5C,KAAKyC,IAAIG,GAEb5C,KAAK6mB,YAAc,OAG3BiR,EAAe71B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC5F,IAAKrgB,KAAK+3B,SAAU,CAChB/3B,KAAK+3B,UAAW,EAChB,IAAK,IAAIr3B,EAAI,EAAGA,EAAIV,KAAK+C,cAAcxD,OAAQmB,IAC3C,GAAIA,IAAMyf,EAAY,CAClB,IAAIvd,EAAe5C,KAAK+C,cAAcrC,GACtCkC,EAAajB,cACb3B,KAAKqC,OAAOO,GAGpB5C,KAAK+C,cAAgB,KAEzB/C,KAAKsE,YAAYjB,KAAK6c,IAEnB4X,EA5CwB,CA6CjCzW,EAAkBtB,iBACpB1hB,EAAQy5B,eAAiBA,IAG7B35B,OAAO,uBAAuB,UAAW,UAAW,kBAAmB,sBAAuB,SAAUC,EAASC,EAAS4C,EAAW+2B,GACjI,aACA15B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwBtDH,EAAQu5B,KAdR,WAEI,IAAK,IADD/Q,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAO,SAA8BU,GAMjC,OAH2B,IAAvBggB,EAAYtnB,QAAgB0B,EAAU5B,QAAQwnB,EAAY,MAC1DA,EAAcA,EAAY,IAEvBhgB,EAAOF,KAAKpG,KAAKy3B,EAAOJ,KAAK73B,WAAM,GAAS8G,GAAQpF,OAAOolB,SAM9E1oB,OAAO,yBAAyB,UAAW,UAAW,QAAS,gBAAiB,iCAAkC,SAAUC,EAASC,EAAS6B,EAASoF,EAAcghB,GACjK,aACAhoB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA2BtDH,EAAQ45B,OAdR,SAAgBxnB,GAEZ,YADc,IAAVA,IAAoBA,GAAS,GAC1B,SAAU5J,GACb,OAAc,IAAV4J,EACO,IAAI6V,EAAkBF,gBAExB3V,EAAQ,EACN5J,EAAOF,KAAK,IAAIuxB,GAAgB,EAAGrxB,IAGnCA,EAAOF,KAAK,IAAIuxB,EAAeznB,EAAQ,EAAG5J,MAK7D,IAAIqxB,EAAgC,WAChC,SAASA,EAAeznB,EAAO5J,GAC3B7G,KAAKyQ,MAAQA,EACbzQ,KAAK6G,OAASA,EAKlB,OAHAqxB,EAAej2B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAClD,OAAOA,EAAOL,UAAU,IAAI2xB,EAAiB1zB,EAAYzE,KAAKyQ,MAAOzQ,KAAK6G,UAEvEqxB,EARwB,GAe/BC,EAAkC,SAAU/3B,GAE5C,SAAS+3B,EAAiB7zB,EAAamM,EAAO5J,GAC1C,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMmQ,MAAQA,EACdnQ,EAAMuG,OAASA,EACRvG,EAcX,OAnBAJ,EAAQc,UAAUm3B,EAAkB/3B,GAOpC+3B,EAAiBl2B,UAAUsB,SAAW,WAClC,IAAKvD,KAAKqE,UAAW,CACjB,IAAewC,EAAN7G,KAAkB6G,OAAQ4J,EAA1BzQ,KAAqCyQ,MAC9C,GAAc,IAAVA,EACA,OAAOrQ,EAAO6B,UAAUsB,SAAShD,KAAKP,MAEjCyQ,GAAS,IACdzQ,KAAKyQ,MAAQA,EAAQ,GAEzB5J,EAAOL,UAAUxG,KAAK6E,4BAGvBszB,EApB0B,CAqBnC7yB,EAAatB,cAGnB7F,OAAO,6BAA6B,UAAW,UAAW,QAAS,aAAc,mBAAoB,sBAAuB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASuI,EAAWrH,EAAYzB,EAAe0hB,EAAmBC,GAC1Q,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQ+5B,WAHR,SAAoBC,GAChB,OAAO,SAAUxxB,GAAU,OAAOA,EAAOF,KAAK,IAAI2xB,EAAmBD,MAGzE,IAAIC,EAAoC,WACpC,SAASA,EAAmBD,GACxBr4B,KAAKq4B,SAAWA,EAKpB,OAHAC,EAAmBr2B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACtD,OAAOA,EAAOL,UAAU,IAAI+xB,EAAqB9zB,EAAYzE,KAAKq4B,SAAUxxB,KAEzEyxB,EAP4B,GAcnCC,EAAsC,SAAUn4B,GAEhD,SAASm4B,EAAqBj0B,EAAa+zB,EAAUxxB,GACjD,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAM+3B,SAAWA,EACjB/3B,EAAMuG,OAASA,EACfvG,EAAMk4B,2BAA4B,EAC3Bl4B,EAwDX,OA9DAJ,EAAQc,UAAUu3B,EAAsBn4B,GAQxCm4B,EAAqBt2B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAClGrgB,KAAKw4B,2BAA4B,EACjCx4B,KAAK6G,OAAOL,UAAUxG,OAE1Bu4B,EAAqBt2B,UAAUse,eAAiB,SAAUF,GACtD,IAAuC,IAAnCrgB,KAAKw4B,0BACL,OAAOp4B,EAAO6B,UAAUsB,SAAShD,KAAKP,OAG9Cu4B,EAAqBt2B,UAAUsB,SAAW,WAEtC,GADAvD,KAAKw4B,2BAA4B,GAC5Bx4B,KAAKqE,UAAW,CACjB,GAAKrE,KAAKy4B,SAGL,GAAIz4B,KAAK04B,oBAAoB92B,OAC9B,OAAOxB,EAAO6B,UAAUsB,SAAShD,KAAKP,WAHtCA,KAAK24B,qBAKT34B,KAAK6E,yBACL7E,KAAK44B,cAAcv1B,SAG3Bk1B,EAAqBt2B,UAAUD,aAAe,WAC1C,IAAe42B,EAAN54B,KAAyB44B,cAAeF,EAAxC14B,KAAiE04B,oBACtEE,IACAA,EAAcj3B,cACd3B,KAAK44B,cAAgB,MAErBF,IACAA,EAAoB/2B,cACpB3B,KAAK04B,oBAAsB,MAE/B14B,KAAKy4B,QAAU,MAEnBF,EAAqBt2B,UAAU4C,uBAAyB,WACpD,IAAe+zB,EAAN54B,KAAyB44B,cAAeH,EAAxCz4B,KAAqDy4B,QAASC,EAA9D14B,KAAuF04B,oBAQhG,OAPA14B,KAAK44B,cAAgB,KACrB54B,KAAKy4B,QAAU,KACfz4B,KAAK04B,oBAAsB,KAC3Bt4B,EAAO6B,UAAU4C,uBAAuBtE,KAAKP,MAC7CA,KAAK44B,cAAgBA,EACrB54B,KAAKy4B,QAAUA,EACfz4B,KAAK04B,oBAAsBA,EACpB14B,MAEXu4B,EAAqBt2B,UAAU02B,mBAAqB,WAChD34B,KAAK44B,cAAgB,IAAInwB,EAAUP,QACnC,IAAIuwB,EAAUr3B,EAAWvB,SAASG,KAAKq4B,SAAzBj3B,CAAmCpB,KAAK44B,eACtD,GAAIH,IAAY94B,EAAcF,YAC1B,OAAOW,EAAO6B,UAAUsB,SAAShD,KAAKP,MAE1CA,KAAKy4B,QAAUA,EACfz4B,KAAK04B,oBAAsBpX,EAAoBN,kBAAkBhhB,KAAMy4B,IAEpEF,EA/D8B,CAgEvClX,EAAkBtB,mBAGxB5hB,OAAO,wBAAwB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACjH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqBtDH,EAAQw6B,MAJR,SAAepoB,GAEX,YADc,IAAVA,IAAoBA,GAAS,GAC1B,SAAU5J,GAAU,OAAOA,EAAOF,KAAK,IAAImyB,EAAcroB,EAAO5J,MAG3E,IAAIiyB,EAA+B,WAC/B,SAASA,EAAcroB,EAAO5J,GAC1B7G,KAAKyQ,MAAQA,EACbzQ,KAAK6G,OAASA,EAKlB,OAHAiyB,EAAc72B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACjD,OAAOA,EAAOL,UAAU,IAAIuyB,EAAgBt0B,EAAYzE,KAAKyQ,MAAOzQ,KAAK6G,UAEtEiyB,EARuB,GAe9BC,EAAiC,SAAU34B,GAE3C,SAAS24B,EAAgBz0B,EAAamM,EAAO5J,GACzC,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMmQ,MAAQA,EACdnQ,EAAMuG,OAASA,EACRvG,EAcX,OAnBAJ,EAAQc,UAAU+3B,EAAiB34B,GAOnC24B,EAAgB92B,UAAUqB,MAAQ,SAAU9C,GACxC,IAAKR,KAAKqE,UAAW,CACjB,IAAewC,EAAN7G,KAAkB6G,OAAQ4J,EAA1BzQ,KAAqCyQ,MAC9C,GAAc,IAAVA,EACA,OAAOrQ,EAAO6B,UAAUqB,MAAM/C,KAAKP,KAAMQ,GAEpCiQ,GAAS,IACdzQ,KAAKyQ,MAAQA,EAAQ,GAEzB5J,EAAOL,UAAUxG,KAAK6E,4BAGvBk0B,EApByB,CAqBlCzzB,EAAatB,cAGnB7F,OAAO,4BAA4B,UAAW,UAAW,QAAS,aAAc,mBAAoB,sBAAuB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASuI,EAAWrH,EAAYzB,EAAe0hB,EAAmBC,GACzQ,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQ26B,UAHR,SAAmBX,GACf,OAAO,SAAUxxB,GAAU,OAAOA,EAAOF,KAAK,IAAIsyB,EAAkBZ,EAAUxxB,MAGlF,IAAIoyB,EAAmC,WACnC,SAASA,EAAkBZ,EAAUxxB,GACjC7G,KAAKq4B,SAAWA,EAChBr4B,KAAK6G,OAASA,EAKlB,OAHAoyB,EAAkBh3B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAI0yB,EAAoBz0B,EAAYzE,KAAKq4B,SAAUr4B,KAAK6G,UAE7EoyB,EAR2B,GAelCC,EAAqC,SAAU94B,GAE/C,SAAS84B,EAAoB50B,EAAa+zB,EAAUxxB,GAChD,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAM+3B,SAAWA,EACjB/3B,EAAMuG,OAASA,EACRvG,EAiDX,OAtDAJ,EAAQc,UAAUk4B,EAAqB94B,GAOvC84B,EAAoBj3B,UAAUqB,MAAQ,SAAU9C,GAC5C,IAAKR,KAAKqE,UAAW,CACjB,IAAIhE,EAASL,KAAKK,OACdo4B,EAAUz4B,KAAKy4B,QACfC,EAAsB14B,KAAK04B,oBAC/B,GAAKD,EASDz4B,KAAKK,OAAS,KACdL,KAAK04B,oBAAsB,SAVjB,CAGV,GAFAr4B,EAAS,IAAIoI,EAAUP,SACvBuwB,EAAUr3B,EAAWvB,SAASG,KAAKq4B,SAAzBj3B,CAAmCf,MAC7BV,EAAcF,YAC1B,OAAOW,EAAO6B,UAAUqB,MAAM/C,KAAKP,KAAML,EAAcF,YAAYC,GAEvEg5B,EAAsBpX,EAAoBN,kBAAkBhhB,KAAMy4B,GAMtEz4B,KAAK6E,yBACL7E,KAAKK,OAASA,EACdL,KAAKy4B,QAAUA,EACfz4B,KAAK04B,oBAAsBA,EAC3Br4B,EAAOgD,KAAK7C,KAGpB04B,EAAoBj3B,UAAUD,aAAe,WACzC,IAAe3B,EAANL,KAAkBK,OAAQq4B,EAA1B14B,KAAmD04B,oBACxDr4B,IACAA,EAAOsB,cACP3B,KAAKK,OAAS,MAEdq4B,IACAA,EAAoB/2B,cACpB3B,KAAK04B,oBAAsB,MAE/B14B,KAAKy4B,QAAU,MAEnBS,EAAoBj3B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACjG,IAAehgB,EAANL,KAAkBK,OAAQo4B,EAA1Bz4B,KAAuCy4B,QAASC,EAAhD14B,KAAyE04B,oBAClF14B,KAAKK,OAAS,KACdL,KAAKy4B,QAAU,KACfz4B,KAAK04B,oBAAsB,KAC3B14B,KAAK6E,yBACL7E,KAAKK,OAASA,EACdL,KAAKy4B,QAAUA,EACfz4B,KAAK04B,oBAAsBA,EAC3B14B,KAAK6G,OAAOL,UAAUxG,OAEnBk5B,EAvD6B,CAwDtC7X,EAAkBtB,mBAGxB5hB,OAAO,yBAAyB,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GACvK,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQ86B,OAHR,SAAgBd,GACZ,OAAO,SAAUxxB,GAAU,OAAOA,EAAOF,KAAK,IAAIyyB,EAAef,MAGrE,IAAIe,EAAgC,WAChC,SAASA,EAAef,GACpBr4B,KAAKq4B,SAAWA,EAQpB,OANAe,EAAen3B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAClD,IAAIwyB,EAAmB,IAAIC,EAAiB70B,GACxC7B,EAAeiE,EAAOL,UAAU6yB,GAEpC,OADAz2B,EAAaH,IAAI6e,EAAoBN,kBAAkBqY,EAAkBr5B,KAAKq4B,WACvEz1B,GAEJw2B,EAVwB,GAiB/BE,EAAkC,SAAUl5B,GAE5C,SAASk5B,IACL,IAAIh5B,EAAmB,OAAXF,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAEhE,OADAM,EAAM+K,UAAW,EACV/K,EAkBX,OAtBAJ,EAAQc,UAAUs4B,EAAkBl5B,GAMpCk5B,EAAiBr3B,UAAUyC,MAAQ,SAAUlG,GACzCwB,KAAKxB,MAAQA,EACbwB,KAAKqL,UAAW,GAEpBiuB,EAAiBr3B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC9FrgB,KAAKmrB,aAETmO,EAAiBr3B,UAAUse,eAAiB,WACxCvgB,KAAKmrB,aAETmO,EAAiBr3B,UAAUkpB,UAAY,WAC/BnrB,KAAKqL,WACLrL,KAAKqL,UAAW,EAChBrL,KAAKsE,YAAYjB,KAAKrD,KAAKxB,SAG5B86B,EAvB0B,CAwBnCjY,EAAkBtB,mBAGxB5hB,OAAO,6BAA6B,UAAW,UAAW,QAAS,gBAAiB,sBAAuB,SAAUC,EAASC,EAAS6B,EAASoF,EAAcqK,GAC1J,aACArR,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAyCtDH,EAAQk7B,WAJR,SAAoB7W,EAAQ5Z,GAExB,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzC,SAAU7I,GAAU,OAAOA,EAAOF,KAAK,IAAI6yB,EAAmB9W,EAAQ5Z,MAGjF,IAAI0wB,EAAoC,WACpC,SAASA,EAAmB9W,EAAQ5Z,GAChC9I,KAAK0iB,OAASA,EACd1iB,KAAK8I,UAAYA,EAKrB,OAHA0wB,EAAmBv3B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACtD,OAAOA,EAAOL,UAAU,IAAIizB,EAAqBh1B,EAAYzE,KAAK0iB,OAAQ1iB,KAAK8I,aAE5E0wB,EAR4B,GAenCC,EAAsC,SAAUr5B,GAEhD,SAASq5B,EAAqBn1B,EAAaoe,EAAQ5Z,GAC/C,IAAIxI,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMoiB,OAASA,EACfpiB,EAAMwI,UAAYA,EAClBxI,EAAM+K,UAAW,EACjB/K,EAAMmC,IAAIqG,EAAUE,SAe5B,SAA8BC,GAC1B,IAAIxE,EAAawE,EAAMxE,WAAYie,EAASzZ,EAAMyZ,OAClDje,EAAWub,aACXhgB,KAAKgJ,SAASC,EAAOyZ,IAlBkCA,GAAUje,WAAYnE,EAAOoiB,OAAQA,KACjFpiB,EAYX,OAnBAJ,EAAQc,UAAUy4B,EAAsBr5B,GASxCq5B,EAAqBx3B,UAAUyC,MAAQ,SAAUlG,GAC7CwB,KAAKwrB,UAAYhtB,EACjBwB,KAAKqL,UAAW,GAEpBouB,EAAqBx3B,UAAU+d,WAAa,WACpChgB,KAAKqL,WACLrL,KAAKqL,UAAW,EAChBrL,KAAKsE,YAAYjB,KAAKrD,KAAKwrB,aAG5BiO,EApB8B,CAqBvCn0B,EAAatB,cAQnB7F,OAAO,gCAAgC,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,uBAAwB,SAAUC,EAASC,EAAS6B,EAASoF,EAAclE,EAAYzB,GAC9L,aACArB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwDtDH,EAAQq7B,cAHR,SAAuBC,EAAWC,GAC9B,OAAO,SAAU/yB,GAAU,OAAOA,EAAOF,KAAK,IAAIkzB,EAAsBF,EAAWC,MAGvF,IAAIC,EAAuC,WACvC,SAASA,EAAsBF,EAAWC,GACtC55B,KAAK25B,UAAYA,EACjB35B,KAAK45B,SAAWA,EAKpB,OAHAC,EAAsB53B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACzD,OAAOA,EAAOL,UAAU,IAAIszB,EAAwBr1B,EAAYzE,KAAK25B,UAAW35B,KAAK45B,YAElFC,EAR+B,GAU1Cx7B,EAAQw7B,sBAAwBA,EAMhC,IAAIC,EAAyC,SAAU15B,GAEnD,SAAS05B,EAAwBx1B,EAAaq1B,EAAWC,GACrD,IAAIt5B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAO9C,OANAM,EAAMq5B,UAAYA,EAClBr5B,EAAMs5B,SAAWA,EACjBt5B,EAAMgS,MACNhS,EAAMiY,MACNjY,EAAMy5B,cAAe,EACrBz5B,EAAMmC,IAAIk3B,EAAUnzB,UAAU,IAAIwzB,EAAiC11B,EAAahE,KACzEA,EAqDX,OA9DAJ,EAAQc,UAAU84B,EAAyB15B,GAW3C05B,EAAwB73B,UAAUyC,MAAQ,SAAUlG,GAC5CwB,KAAK+5B,cAAmC,IAAnB/5B,KAAKuY,GAAGhZ,OAC7BS,KAAKi6B,MAAK,IAGVj6B,KAAKsS,GAAG9P,KAAKhE,GACbwB,KAAKk6B,gBAGbJ,EAAwB73B,UAAU2C,UAAY,WACtC5E,KAAK+5B,aACL/5B,KAAKi6B,KAAwB,IAAnBj6B,KAAKsS,GAAG/S,QAAmC,IAAnBS,KAAKuY,GAAGhZ,QAG1CS,KAAK+5B,cAAe,GAG5BD,EAAwB73B,UAAUi4B,YAAc,WAE5C,IADA,IAAe5nB,EAANtS,KAAcsS,GAAIiG,EAAlBvY,KAA0BuY,GAAIqhB,EAA9B55B,KAA4C45B,SAC9CtnB,EAAG/S,OAAS,GAAKgZ,EAAGhZ,OAAS,GAAG,CACnC,IAAIyT,EAAIV,EAAGzH,QACPoI,EAAIsF,EAAG1N,QACPsvB,GAAW,EACXP,GACAO,EAAW/4B,EAAWvB,SAAS+5B,EAApBx4B,CAA8B4R,EAAGC,MAC3BtT,EAAcF,aAC3BO,KAAKsE,YAAYhB,MAAM3D,EAAcF,YAAYC,GAIrDy6B,EAAWnnB,IAAMC,EAEhBknB,GACDn6B,KAAKi6B,MAAK,KAItBH,EAAwB73B,UAAUg4B,KAAO,SAAUz7B,GAC/C,IAAI8F,EAActE,KAAKsE,YACvBA,EAAYjB,KAAK7E,GACjB8F,EAAYf,YAEhBu2B,EAAwB73B,UAAUm4B,MAAQ,SAAU57B,GAC5CwB,KAAK+5B,cAAmC,IAAnB/5B,KAAKsS,GAAG/S,OAC7BS,KAAKi6B,MAAK,IAGVj6B,KAAKuY,GAAG/V,KAAKhE,GACbwB,KAAKk6B,gBAGNJ,EA/DiC,CAgE1Cx0B,EAAatB,YACf3F,EAAQy7B,wBAA0BA,EAClC,IAAIE,EAAkD,SAAU55B,GAE5D,SAAS45B,EAAiC11B,EAAanB,GACnD,IAAI7C,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAE9C,OADAM,EAAM6C,OAASA,EACR7C,EAWX,OAfAJ,EAAQc,UAAUg5B,EAAkC55B,GAMpD45B,EAAiC/3B,UAAUyC,MAAQ,SAAUlG,GACzDwB,KAAKmD,OAAOi3B,MAAM57B,IAEtBw7B,EAAiC/3B,UAAU0C,OAAS,SAAUnE,GAC1DR,KAAKmD,OAAOG,MAAM9C,IAEtBw5B,EAAiC/3B,UAAU2C,UAAY,WACnD5E,KAAKmD,OAAOyB,aAETo1B,EAhB0C,CAiBnD10B,EAAatB,cAGnB7F,OAAO,wBAAwB,UAAW,UAAW,cAAe,aAAc,cAAe,SAAUC,EAASC,EAAS84B,EAAatoB,EAAYpG,GAClJ,aACAnK,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAmBtDH,EAAQg8B,MAHR,WACI,OAAO,SAAUxzB,GAAU,OAAOgI,EAAWV,UAAXU,CAAsBsoB,EAAYzB,UAhBxE,WACI,OAAO,IAAIjtB,EAAUP,SAemCivB,CAA2CtwB,QAM3G1I,OAAO,8BAA8B,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAASo5B,GACxG,aACAn5B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAQtDH,EAAQi8B,YAHR,SAAqBxtB,EAAYC,EAAYjE,GACzC,OAAO,SAAUjC,GAAU,OAAOA,EAAOF,KAG7C,SAA6BmG,EAAYC,EAAYjE,GACjD,IAAInB,EAEA/E,EADAuL,EAAW,EAEXhG,GAAW,EACXoyB,GAAa,EACjB,OAAO,SAA8B1zB,GACjCsH,IACKxG,IAAWQ,IACZA,GAAW,EACXR,EAAU,IAAI8vB,EAAgB5qB,cAAcC,EAAYC,EAAYjE,GACpElG,EAAeiE,EAAOL,WAClBnD,KAAM,SAAU7E,GAASmJ,EAAQtE,KAAK7E,IACtC8E,MAAO,SAAU9C,GACb2H,GAAW,EACXR,EAAQrE,MAAM9C,IAElB+C,SAAU,WACNg3B,GAAa,EACb5yB,EAAQpE,eAIpB,IAAI8c,EAAW1Y,EAAQnB,UAAUxG,MACjC,OAAO,WACHmO,IACAkS,EAAS1e,cACLiB,GAA6B,IAAbuL,GAAkBosB,GAClC33B,EAAajB,gBA/BqB64B,CAAoB1tB,EAAYC,EAAYjE,QAuClG3K,OAAO,yBAAyB,UAAW,UAAW,QAAS,gBAAiB,sBAAuB,SAAUC,EAASC,EAAS6B,EAASoF,EAAc0rB,GACtJ,aACA1yB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoBtDH,EAAQo8B,OAHR,SAAgB9P,GACZ,OAAO,SAAU9jB,GAAU,OAAOA,EAAOF,KAAK,IAAI+zB,EAAe/P,EAAW9jB,MAGhF,IAAI6zB,EAAgC,WAChC,SAASA,EAAe/P,EAAW9jB,GAC/B7G,KAAK2qB,UAAYA,EACjB3qB,KAAK6G,OAASA,EAKlB,OAHA6zB,EAAez4B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAClD,OAAOA,EAAOL,UAAU,IAAIm0B,EAAiBl2B,EAAYzE,KAAK2qB,UAAW3qB,KAAK6G,UAE3E6zB,EARwB,GAe/BC,EAAkC,SAAUv6B,GAE5C,SAASu6B,EAAiBr2B,EAAaqmB,EAAW9jB,GAC9C,IAAIvG,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMqqB,UAAYA,EAClBrqB,EAAMuG,OAASA,EACfvG,EAAMs6B,WAAY,EAClBt6B,EAAM6B,MAAQ,EACP7B,EAwCX,OA/CAJ,EAAQc,UAAU25B,EAAkBv6B,GASpCu6B,EAAiB14B,UAAU44B,iBAAmB,SAAUr8B,GAChDwB,KAAK46B,UACL56B,KAAKsE,YAAYhB,MAAM,4CAGvBtD,KAAK46B,WAAY,EACjB56B,KAAK86B,YAAct8B,IAG3Bm8B,EAAiB14B,UAAUyC,MAAQ,SAAUlG,GACzC,IAAI2D,EAAQnC,KAAKmC,QACbnC,KAAK2qB,UACL3qB,KAAK8vB,QAAQtxB,EAAO2D,GAGpBnC,KAAK66B,iBAAiBr8B,IAG9Bm8B,EAAiB14B,UAAU6tB,QAAU,SAAUtxB,EAAO2D,GAClD,IACQnC,KAAK2qB,UAAUnsB,EAAO2D,EAAOnC,KAAK6G,SAClC7G,KAAK66B,iBAAiBr8B,GAG9B,MAAOgC,GACHR,KAAKsE,YAAYhB,MAAM9C,KAG/Bm6B,EAAiB14B,UAAU2C,UAAY,WACnC,IAAIN,EAActE,KAAKsE,YACnBtE,KAAKmC,MAAQ,GACbmC,EAAYjB,KAAKrD,KAAK46B,UAAY56B,KAAK86B,iBAAclxB,GACrDtF,EAAYf,YAGZe,EAAYhB,MAAM,IAAI0tB,EAAazhB,aAGpCorB,EAhD0B,CAiDnCr1B,EAAatB,cAGnB7F,OAAO,uBAAuB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GAChH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAetDH,EAAQ08B,KAHR,SAActqB,GACV,OAAO,SAAU5J,GAAU,OAAOA,EAAOF,KAAK,IAAIq0B,EAAavqB,MAGnE,IAAIuqB,EAA8B,WAC9B,SAASA,EAAazG,GAClBv0B,KAAKu0B,MAAQA,EAKjB,OAHAyG,EAAa/4B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAChD,OAAOA,EAAOL,UAAU,IAAIy0B,EAAex2B,EAAYzE,KAAKu0B,SAEzDyG,EAPsB,GAc7BC,EAAgC,SAAU76B,GAE1C,SAAS66B,EAAe32B,EAAaiwB,GACjC,IAAIj0B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMi0B,MAAQA,EACdj0B,EAAMmQ,MAAQ,EACPnQ,EAOX,OAZAJ,EAAQc,UAAUi6B,EAAgB76B,GAOlC66B,EAAeh5B,UAAUyC,MAAQ,SAAUtF,KACjCY,KAAKyQ,MAAQzQ,KAAKu0B,OACpBv0B,KAAKsE,YAAYjB,KAAKjE,IAGvB67B,EAbwB,CAcjC31B,EAAatB,cAGnB7F,OAAO,2BAA2B,UAAW,UAAW,QAAS,gBAAiB,mCAAoC,SAAUC,EAASC,EAAS6B,EAASoF,EAAcypB,GACrK,aACAzwB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoCtDH,EAAQ68B,SAHR,SAAkBzqB,GACd,OAAO,SAAU5J,GAAU,OAAOA,EAAOF,KAAK,IAAIw0B,EAAiB1qB,MAGvE,IAAI0qB,EAAkC,WAClC,SAASA,EAAiBC,GAEtB,GADAp7B,KAAKo7B,WAAaA,EACdp7B,KAAKo7B,WAAa,EAClB,MAAM,IAAIrM,EAA0Bvf,wBAa5C,OAVA2rB,EAAiBl5B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACpD,OAAwB,IAApB7G,KAAKo7B,WAGEv0B,EAAOL,UAAU,IAAIlB,EAAatB,WAAWS,IAG7CoC,EAAOL,UAAU,IAAI60B,EAAmB52B,EAAYzE,KAAKo7B,cAGjED,EAjB0B,GAwBjCE,EAAoC,SAAUj7B,GAE9C,SAASi7B,EAAmB/2B,EAAa82B,GACrC,IAAI96B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAM86B,WAAaA,EACnB96B,EAAMg7B,OAAS,EACfh7B,EAAMi7B,MAAQ,IAAIj8B,MAAM87B,GACjB96B,EAgBX,OAtBAJ,EAAQc,UAAUq6B,EAAoBj7B,GAQtCi7B,EAAmBp5B,UAAUyC,MAAQ,SAAUlG,GAC3C,IAAIg9B,EAAYx7B,KAAKo7B,WACjB3qB,EAAQzQ,KAAKs7B,SACjB,GAAI7qB,EAAQ+qB,EACRx7B,KAAKu7B,MAAM9qB,GAASjS,MAEnB,CACD,IAAIi9B,EAAehrB,EAAQ+qB,EACvB/G,EAAOz0B,KAAKu7B,MACZG,EAAWjH,EAAKgH,GACpBhH,EAAKgH,GAAgBj9B,EACrBwB,KAAKsE,YAAYjB,KAAKq4B,KAGvBL,EAvB4B,CAwBrC/1B,EAAatB,cAGnB7F,OAAO,4BAA4B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GAC1K,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgBtDH,EAAQs9B,UAHR,SAAmBtD,GACf,OAAO,SAAUxxB,GAAU,OAAOA,EAAOF,KAAK,IAAIi1B,EAAkBvD,MAGxE,IAAIuD,EAAmC,WACnC,SAASA,EAAkBvD,GACvBr4B,KAAKq4B,SAAWA,EAKpB,OAHAuD,EAAkB35B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAIq1B,EAAoBp3B,EAAYzE,KAAKq4B,YAE9DuD,EAP2B,GAclCC,EAAqC,SAAUz7B,GAE/C,SAASy7B,EAAoBv3B,EAAa+zB,GACtC,IAAI/3B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAM+K,UAAW,EACjB/K,EAAMw7B,gBAAiB,EACvBx7B,EAAMmC,IAAI6e,EAAoBN,kBAAkB1gB,EAAO+3B,IAChD/3B,EAwBX,OA9BAJ,EAAQc,UAAU66B,EAAqBz7B,GAQvCy7B,EAAoB55B,UAAUyC,MAAQ,SAAUlG,GACxCwB,KAAKqL,UACLjL,EAAO6B,UAAUyC,MAAMnE,KAAKP,KAAMxB,IAG1Cq9B,EAAoB55B,UAAU2C,UAAY,WAClC5E,KAAK87B,eACL17B,EAAO6B,UAAU2C,UAAUrE,KAAKP,MAGhCA,KAAK2B,eAGbk6B,EAAoB55B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACjGrgB,KAAKqL,UAAW,GAEpBwwB,EAAoB55B,UAAUse,eAAiB,WAC3CvgB,KAAK87B,gBAAiB,EAClB97B,KAAKqE,WACLjE,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAGjC67B,EA/B6B,CAgCtCxa,EAAkBtB,mBAGxB5hB,OAAO,4BAA4B,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACrH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgBtDH,EAAQ09B,UAHR,SAAmBpR,GACf,OAAO,SAAU9jB,GAAU,OAAOA,EAAOF,KAAK,IAAIq1B,EAAkBrR,MAGxE,IAAIqR,EAAmC,WACnC,SAASA,EAAkBrR,GACvB3qB,KAAK2qB,UAAYA,EAKrB,OAHAqR,EAAkB/5B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAIy1B,EAAoBx3B,EAAYzE,KAAK2qB,aAE9DqR,EAP2B,GAclCC,EAAqC,SAAU77B,GAE/C,SAAS67B,EAAoB33B,EAAaqmB,GACtC,IAAIrqB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAMqqB,UAAYA,EAClBrqB,EAAM47B,UAAW,EACjB57B,EAAM6B,MAAQ,EACP7B,EAoBX,OA1BAJ,EAAQc,UAAUi7B,EAAqB77B,GAQvC67B,EAAoBh6B,UAAUyC,MAAQ,SAAUlG,GAC5C,IAAI8F,EAActE,KAAKsE,YACnBtE,KAAKk8B,UACLl8B,KAAKm8B,iBAAiB39B,GAErBwB,KAAKk8B,UACN53B,EAAYjB,KAAK7E,IAGzBy9B,EAAoBh6B,UAAUk6B,iBAAmB,SAAU39B,GACvD,IACI,IAAIkS,EAAS1Q,KAAK2qB,UAAUnsB,EAAOwB,KAAKmC,SACxCnC,KAAKk8B,SAAWvgB,QAAQjL,GAE5B,MAAOlQ,GACHR,KAAKsE,YAAYhB,MAAM9C,KAGxBy7B,EA3B6B,CA4BtC32B,EAAatB,cAGnB7F,OAAO,4BAA4B,UAAW,UAAW,gCAAiC,iCAAkC,gCAAiC,uBAAwB,uBAAwB,SAAUC,EAASC,EAASqoB,EAAmBL,EAAoBC,EAAmBgE,EAAUhI,GACzS,aACAhkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAyCtDH,EAAQ+9B,UAzBR,WAEI,IAAK,IADD5V,KACKrgB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCqgB,EAAMrgB,GAAMlG,UAAUkG,GAE1B,OAAO,SAAUU,GACb,IAAIiC,EAAY0d,EAAMA,EAAMjnB,OAAS,GACjC+iB,EAAcJ,YAAYpZ,GAC1B0d,EAAMC,MAGN3d,EAAY,KAEhB,IAAI1G,EAAMokB,EAAMjnB,OAChB,OAAY,IAAR6C,EACOkoB,EAAS7oB,OAAO,IAAI4kB,EAAmBF,iBAAiBK,EAAM,GAAI1d,GAAYjC,GAEhFzE,EAAM,EACJkoB,EAAS7oB,OAAO,IAAIilB,EAAkBH,gBAAgBC,EAAO1d,GAAYjC,GAGzEyjB,EAAS7oB,OAAO,IAAI6kB,EAAkBF,gBAAgBtd,GAAYjC,OAOzF1I,OAAO,4BAA4B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GAC1K,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsDtDH,EAAQg+B,UALR,SAAmBjsB,EAASkZ,GACxB,OAAO,SAAmCziB,GACtC,OAAOA,EAAOF,KAAK,IAAI21B,EAAkBlsB,EAASkZ,MAI1D,IAAIgT,EAAmC,WACnC,SAASA,EAAkBlsB,EAASkZ,GAChCtpB,KAAKoQ,QAAUA,EACfpQ,KAAKspB,eAAiBA,EAK1B,OAHAgT,EAAkBr6B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAI+1B,EAAoB93B,EAAYzE,KAAKoQ,QAASpQ,KAAKspB,kBAE5EgT,EAR2B,GAelCC,EAAqC,SAAUn8B,GAE/C,SAASm8B,EAAoBj4B,EAAa8L,EAASkZ,GAC/C,IAAIhpB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAM8P,QAAUA,EAChB9P,EAAMgpB,eAAiBA,EACvBhpB,EAAM6B,MAAQ,EACP7B,EAwDX,OA9DAJ,EAAQc,UAAUu7B,EAAqBn8B,GAQvCm8B,EAAoBt6B,UAAUyC,MAAQ,SAAUlG,GAC5C,IAAIkS,EACAvO,EAAQnC,KAAKmC,QACjB,IACIuO,EAAS1Q,KAAKoQ,QAAQ5R,EAAO2D,GAEjC,MAAOmB,GAEH,YADAtD,KAAKsE,YAAYhB,MAAMA,GAG3BtD,KAAK2pB,UAAUjZ,EAAQlS,EAAO2D,IAElCo6B,EAAoBt6B,UAAU0nB,UAAY,SAAUjZ,EAAQlS,EAAO2D,GAC/D,IAAI0f,EAAoB7hB,KAAK6hB,kBACzBA,GACAA,EAAkBlgB,cAEtB3B,KAAKyC,IAAIzC,KAAK6hB,kBAAoBP,EAAoBN,kBAAkBhhB,KAAM0Q,EAAQlS,EAAO2D,KAEjGo6B,EAAoBt6B,UAAU2C,UAAY,WACtC,IAAIid,EAAoB7hB,KAAK6hB,kBACxBA,IAAqBA,EAAkBjgB,QACxCxB,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAGxCu8B,EAAoBt6B,UAAUD,aAAe,WACzChC,KAAK6hB,kBAAoB,MAE7B0a,EAAoBt6B,UAAUse,eAAiB,SAAUF,GACrDrgB,KAAKqC,OAAOge,GACZrgB,KAAK6hB,kBAAoB,KACrB7hB,KAAKqE,WACLjE,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAGxCu8B,EAAoBt6B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC7FrgB,KAAKspB,eACLtpB,KAAKw8B,eAAevc,EAAYC,EAAYC,EAAYC,GAGxDpgB,KAAKsE,YAAYjB,KAAK6c,IAG9Bqc,EAAoBt6B,UAAUu6B,eAAiB,SAAUvc,EAAYC,EAAYC,EAAYC,GACzF,IAAI1P,EACJ,IACIA,EAAS1Q,KAAKspB,eAAerJ,EAAYC,EAAYC,EAAYC,GAErE,MAAO5f,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAKsE,YAAYjB,KAAKqN,IAEnB6rB,EA/D6B,CAgEtClb,EAAkBtB,mBAGxB5hB,OAAO,4BAA4B,UAAW,UAAW,cAAe,oBAAqB,SAAUC,EAASC,EAASo+B,EAAa1S,GAClI,aACAzrB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQq+B,UAHR,WACI,OAAOD,EAAYJ,UAAUtS,EAAWF,aAKhD1rB,OAAO,8BAA8B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GAC5K,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+CtDH,EAAQs+B,YAHR,SAAqBjS,EAAiBpB,GAClC,OAAO,SAAUziB,GAAU,OAAOA,EAAOF,KAAK,IAAIi2B,EAAoBlS,EAAiBpB,MAG3F,IAAIsT,EAAqC,WACrC,SAASA,EAAoBj3B,EAAY2jB,GACrCtpB,KAAK2F,WAAaA,EAClB3F,KAAKspB,eAAiBA,EAK1B,OAHAsT,EAAoB36B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACvD,OAAOA,EAAOL,UAAU,IAAIq2B,EAAsBp4B,EAAYzE,KAAK2F,WAAY3F,KAAKspB,kBAEjFsT,EAR6B,GAepCC,EAAuC,SAAUz8B,GAEjD,SAASy8B,EAAsBv4B,EAAaw4B,EAAOxT,GAC/C,IAAIhpB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAMw8B,MAAQA,EACdx8B,EAAMgpB,eAAiBA,EACvBhpB,EAAM6B,MAAQ,EACP7B,EA8CX,OApDAJ,EAAQc,UAAU67B,EAAuBz8B,GAQzCy8B,EAAsB56B,UAAUyC,MAAQ,SAAUlG,GAC9C,IAAIqjB,EAAoB7hB,KAAK6hB,kBACzBA,GACAA,EAAkBlgB,cAEtB3B,KAAKyC,IAAIzC,KAAK6hB,kBAAoBP,EAAoBN,kBAAkBhhB,KAAMA,KAAK88B,MAAOt+B,EAAOwB,KAAKmC,WAE1G06B,EAAsB56B,UAAU2C,UAAY,WACxC,IAAIid,EAAoB7hB,KAAK6hB,kBACxBA,IAAqBA,EAAkBjgB,QACxCxB,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAGxC68B,EAAsB56B,UAAUD,aAAe,WAC3ChC,KAAK6hB,kBAAoB,MAE7Bgb,EAAsB56B,UAAUse,eAAiB,SAAUF,GACvDrgB,KAAKqC,OAAOge,GACZrgB,KAAK6hB,kBAAoB,KACrB7hB,KAAKqE,WACLjE,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAGxC68B,EAAsB56B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACnG,IAAeiJ,EAANtpB,KAA0BspB,eAAgBhlB,EAA1CtE,KAA2DsE,YAChEglB,EACAtpB,KAAK+8B,kBAAkB9c,EAAYC,EAAYC,EAAYC,GAG3D9b,EAAYjB,KAAK6c,IAGzB2c,EAAsB56B,UAAU86B,kBAAoB,SAAU9c,EAAYC,EAAYC,EAAYC,GAC9F,IACI1P,EADW4Y,EAANtpB,KAA0BspB,eAAgBhlB,EAA1CtE,KAA2DsE,YAEpE,IACIoM,EAAS4Y,EAAerJ,EAAYC,EAAYC,EAAYC,GAEhE,MAAO5f,GAEH,YADA8D,EAAYhB,MAAM9C,GAGtB8D,EAAYjB,KAAKqN,IAEdmsB,EArD+B,CAsDxCxb,EAAkBtB,mBAGxB5hB,OAAO,uBAAuB,UAAW,UAAW,QAAS,gBAAiB,kCAAmC,iCAAkC,SAAUC,EAASC,EAAS6B,EAASoF,EAAcypB,EAA2BzI,GAC7N,aACAhoB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQ2+B,KAVR,SAAcvsB,GACV,OAAO,SAAU5J,GACb,OAAc,IAAV4J,EACO,IAAI6V,EAAkBF,gBAGtBvf,EAAOF,KAAK,IAAIs2B,EAAaxsB,MAKhD,IAAIwsB,EAA8B,WAC9B,SAASA,EAAa1I,GAElB,GADAv0B,KAAKu0B,MAAQA,EACTv0B,KAAKu0B,MAAQ,EACb,MAAM,IAAIxF,EAA0Bvf,wBAM5C,OAHAytB,EAAah7B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAChD,OAAOA,EAAOL,UAAU,IAAI02B,EAAez4B,EAAYzE,KAAKu0B,SAEzD0I,EAVsB,GAiB7BC,EAAgC,SAAU98B,GAE1C,SAAS88B,EAAe54B,EAAaiwB,GACjC,IAAIj0B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMi0B,MAAQA,EACdj0B,EAAMmQ,MAAQ,EACPnQ,EAaX,OAlBAJ,EAAQc,UAAUk8B,EAAgB98B,GAOlC88B,EAAej7B,UAAUyC,MAAQ,SAAUlG,GACvC,IAAI+1B,EAAQv0B,KAAKu0B,MACb9jB,IAAUzQ,KAAKyQ,MACfA,GAAS8jB,IACTv0B,KAAKsE,YAAYjB,KAAK7E,GAClBiS,IAAU8jB,IACVv0B,KAAKsE,YAAYf,WACjBvD,KAAK2B,iBAIVu7B,EAnBwB,CAoBjC53B,EAAatB,cAGnB7F,OAAO,4BAA4B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GAC1K,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqCtDH,EAAQ8+B,UAHR,SAAmB9E,GACf,OAAO,SAAUxxB,GAAU,OAAOA,EAAOF,KAAK,IAAIy2B,EAAkB/E,MAGxE,IAAI+E,EAAmC,WACnC,SAASA,EAAkB/E,GACvBr4B,KAAKq4B,SAAWA,EAKpB,OAHA+E,EAAkBn7B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAI62B,EAAoB54B,EAAYzE,KAAKq4B,YAE9D+E,EAP2B,GAclCC,EAAqC,SAAUj9B,GAE/C,SAASi9B,EAAoB/4B,EAAa+zB,GACtC,IAAI/3B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAM+3B,SAAWA,EACjB/3B,EAAMmC,IAAI6e,EAAoBN,kBAAkB1gB,EAAO+3B,IAChD/3B,EAQX,OAbAJ,EAAQc,UAAUq8B,EAAqBj9B,GAOvCi9B,EAAoBp7B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACjGrgB,KAAKuD,YAET85B,EAAoBp7B,UAAUse,eAAiB,aAGxC8c,EAd6B,CAetChc,EAAkBtB,mBAGxB5hB,OAAO,4BAA4B,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GACrH,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwCtDH,EAAQi/B,UAHR,SAAmB3S,GACf,OAAO,SAAU9jB,GAAU,OAAOA,EAAOF,KAAK,IAAI42B,EAAkB5S,MAGxE,IAAI4S,EAAmC,WACnC,SAASA,EAAkB5S,GACvB3qB,KAAK2qB,UAAYA,EAKrB,OAHA4S,EAAkBt7B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACrD,OAAOA,EAAOL,UAAU,IAAIg3B,EAAoB/4B,EAAYzE,KAAK2qB,aAE9D4S,EAP2B,GAclCC,EAAqC,SAAUp9B,GAE/C,SAASo9B,EAAoBl5B,EAAaqmB,GACtC,IAAIrqB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAMqqB,UAAYA,EAClBrqB,EAAM6B,MAAQ,EACP7B,EAuBX,OA5BAJ,EAAQc,UAAUw8B,EAAqBp9B,GAOvCo9B,EAAoBv7B,UAAUyC,MAAQ,SAAUlG,GAC5C,IACIkS,EADApM,EAActE,KAAKsE,YAEvB,IACIoM,EAAS1Q,KAAK2qB,UAAUnsB,EAAOwB,KAAKmC,SAExC,MAAO3B,GAEH,YADA8D,EAAYhB,MAAM9C,GAGtBR,KAAKy9B,eAAej/B,EAAOkS,IAE/B8sB,EAAoBv7B,UAAUw7B,eAAiB,SAAUj/B,EAAOk/B,GAC5D,IAAIp5B,EAActE,KAAKsE,YACnBqX,QAAQ+hB,GACRp5B,EAAYjB,KAAK7E,GAGjB8F,EAAYf,YAGbi6B,EA7B6B,CA8BtCl4B,EAAatB,cAGnB7F,OAAO,sBAAsB,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAASoF,GAC/G,aACAhH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgDtDH,EAAQs/B,IALR,SAAan4B,EAAgBlC,EAAOC,GAChC,OAAO,SAA6BsD,GAChC,OAAOA,EAAOF,KAAK,IAAIi3B,EAAWp4B,EAAgBlC,EAAOC,MAIjE,IAAIq6B,EAA4B,WAC5B,SAASA,EAAWp4B,EAAgBlC,EAAOC,GACvCvD,KAAKwF,eAAiBA,EACtBxF,KAAKsD,MAAQA,EACbtD,KAAKuD,SAAWA,EAKpB,OAHAq6B,EAAW37B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAC9C,OAAOA,EAAOL,UAAU,IAAIq3B,EAAap5B,EAAYzE,KAAKwF,eAAgBxF,KAAKsD,MAAOtD,KAAKuD,YAExFq6B,EAToB,GAgB3BC,EAA8B,SAAUz9B,GAExC,SAASy9B,EAAav5B,EAAakB,EAAgBlC,EAAOC,GACtD,IAAIjD,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAC1C89B,EAAiB,IAAIx4B,EAAatB,WAAWwB,EAAgBlC,EAAOC,GAIxE,OAHAu6B,EAAe15B,oBAAqB,EACpC9D,EAAMmC,IAAIq7B,GACVx9B,EAAMw9B,eAAiBA,EAChBx9B,EAgCX,OAvCAJ,EAAQc,UAAU68B,EAAcz9B,GAShCy9B,EAAa57B,UAAUyC,MAAQ,SAAUlG,GACrC,IAAIs/B,EAAiB99B,KAAK89B,eAC1BA,EAAez6B,KAAK7E,GAChBs/B,EAAe35B,gBACfnE,KAAKsE,YAAYhB,MAAMw6B,EAAe55B,gBAGtClE,KAAKsE,YAAYjB,KAAK7E,IAG9Bq/B,EAAa57B,UAAU0C,OAAS,SAAUnE,GACtC,IAAIs9B,EAAiB99B,KAAK89B,eAC1BA,EAAex6B,MAAM9C,GACjBs9B,EAAe35B,gBACfnE,KAAKsE,YAAYhB,MAAMw6B,EAAe55B,gBAGtClE,KAAKsE,YAAYhB,MAAM9C,IAG/Bq9B,EAAa57B,UAAU2C,UAAY,WAC/B,IAAIk5B,EAAiB99B,KAAK89B,eAC1BA,EAAev6B,WACXu6B,EAAe35B,gBACfnE,KAAKsE,YAAYhB,MAAMw6B,EAAe55B,gBAGtClE,KAAKsE,YAAYf,YAGlBs6B,EAxCsB,CAyC/Bv4B,EAAatB,cAGnB7F,OAAO,2BAA2B,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GACzK,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ0/B,uBACJC,SAAS,EACTC,UAAU,GA8Cd5/B,EAAQ6/B,SAJR,SAAkB1c,EAAkBra,GAEhC,YADe,IAAXA,IAAqBA,EAAS9I,EAAQ0/B,uBACnC,SAAUl3B,GAAU,OAAOA,EAAOF,KAAK,IAAIw3B,EAAiB3c,EAAkBra,EAAO62B,QAAS72B,EAAO82B,aAGhH,IAAIE,EAAkC,WAClC,SAASA,EAAiB3c,EAAkBwc,EAASC,GACjDj+B,KAAKwhB,iBAAmBA,EACxBxhB,KAAKg+B,QAAUA,EACfh+B,KAAKi+B,SAAWA,EAKpB,OAHAE,EAAiBl8B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACpD,OAAOA,EAAOL,UAAU,IAAI43B,EAAmB35B,EAAYzE,KAAKwhB,iBAAkBxhB,KAAKg+B,QAASh+B,KAAKi+B,YAElGE,EAT0B,GAgBjCC,EAAoC,SAAUh+B,GAE9C,SAASg+B,EAAmB95B,EAAakd,EAAkB6c,EAAUC,GACjE,IAAIh+B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAMgE,YAAcA,EACpBhE,EAAMkhB,iBAAmBA,EACzBlhB,EAAM+9B,SAAWA,EACjB/9B,EAAMg+B,UAAYA,EAClBh+B,EAAMi+B,mBAAoB,EACnBj+B,EA0DX,OAlEAJ,EAAQc,UAAUo9B,EAAoBh+B,GAUtCg+B,EAAmBn8B,UAAUyC,MAAQ,SAAUlG,GAC3C,GAAIwB,KAAK2hB,UACD3hB,KAAKs+B,YACLt+B,KAAKu+B,mBAAoB,EACzBv+B,KAAKw+B,eAAiBhgC,OAGzB,CACD,IAAIojB,EAAW5hB,KAAKy+B,oBAAoBjgC,GACpCojB,GACA5hB,KAAKyC,IAAIzC,KAAK2hB,UAAYL,EAAoBN,kBAAkBhhB,KAAM4hB,IAEtE5hB,KAAKq+B,WACLr+B,KAAKsE,YAAYjB,KAAK7E,GAClBwB,KAAKs+B,YACLt+B,KAAKu+B,mBAAoB,EACzBv+B,KAAKw+B,eAAiBhgC,MAKtC4/B,EAAmBn8B,UAAUw8B,oBAAsB,SAAUjgC,GACzD,IACI,OAAOwB,KAAKwhB,iBAAiBhjB,GAEjC,MAAOgC,GAEH,OADAR,KAAKsE,YAAYhB,MAAM9C,GAChB,OAGf49B,EAAmBn8B,UAAUD,aAAe,WACxC,IAAe2f,EAAN3hB,KAAqB2hB,UAArB3hB,KAAoDw+B,eAApDx+B,KAA2Fu+B,kBAA3Fv+B,KAA6Hs+B,UACtIt+B,KAAKw+B,eAAiB,KACtBx+B,KAAKu+B,mBAAoB,EACrB5c,IACA3hB,KAAKqC,OAAOsf,GACZ3hB,KAAK2hB,UAAY,KACjBA,EAAUhgB,gBAGlBy8B,EAAmBn8B,UAAUy8B,cAAgB,WACzC,IAAIpsB,EAAKtS,KAAMsE,EAAcgO,EAAGhO,YAAaqd,EAAYrP,EAAGqP,UAAW2c,EAAYhsB,EAAGgsB,UAAWE,EAAiBlsB,EAAGksB,eAAgBD,EAAoBjsB,EAAGisB,kBACxJ5c,GAAa2c,GAAaC,IAC1Bj6B,EAAYjB,KAAKm7B,GACjBx+B,KAAKw+B,eAAiB,KACtBx+B,KAAKu+B,mBAAoB,IAGjCH,EAAmBn8B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAChGrgB,KAAK0+B,gBACL1+B,KAAKgC,gBAETo8B,EAAmBn8B,UAAUse,eAAiB,WAC1CvgB,KAAK0+B,gBACL1+B,KAAKgC,gBAEFo8B,EAnE4B,CAoErC/c,EAAkBtB,mBAGxB5hB,OAAO,+BAA+B,UAAW,UAAW,QAAS,gBAAiB,qBAAsB,cAAe,SAAUC,EAASC,EAAS6B,EAASoF,EAAcqK,EAASgvB,GACnL,aACArgC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6CtDH,EAAQugC,aALR,SAAsBhd,EAAU9Y,EAAW3B,GAGvC,YAFkB,IAAd2B,IAAwBA,EAAY6G,EAAQD,YACjC,IAAXvI,IAAqBA,EAASw3B,EAAWZ,uBACtC,SAAUl3B,GAAU,OAAOA,EAAOF,KAAK,IAAIk4B,EAAqBjd,EAAU9Y,EAAW3B,EAAO62B,QAAS72B,EAAO82B,aAGvH,IAAIY,EAAsC,WACtC,SAASA,EAAqBjd,EAAU9Y,EAAWk1B,EAASC,GACxDj+B,KAAK4hB,SAAWA,EAChB5hB,KAAK8I,UAAYA,EACjB9I,KAAKg+B,QAAUA,EACfh+B,KAAKi+B,SAAWA,EAKpB,OAHAY,EAAqB58B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACxD,OAAOA,EAAOL,UAAU,IAAIs4B,EAAuBr6B,EAAYzE,KAAK4hB,SAAU5hB,KAAK8I,UAAW9I,KAAKg+B,QAASh+B,KAAKi+B,YAE9GY,EAV8B,GAiBrCC,EAAwC,SAAU1+B,GAElD,SAAS0+B,EAAuBx6B,EAAasd,EAAU9Y,EAAWk1B,EAASC,GACvE,IAAI39B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAO9C,OANAM,EAAMshB,SAAWA,EACjBthB,EAAMwI,UAAYA,EAClBxI,EAAM09B,QAAUA,EAChB19B,EAAM29B,SAAWA,EACjB39B,EAAMi+B,mBAAoB,EAC1Bj+B,EAAMk+B,eAAiB,KAChBl+B,EA6BX,OAtCAJ,EAAQc,UAAU89B,EAAwB1+B,GAW1C0+B,EAAuB78B,UAAUyC,MAAQ,SAAUlG,GAC3CwB,KAAK2hB,UACD3hB,KAAKi+B,WACLj+B,KAAKw+B,eAAiBhgC,EACtBwB,KAAKu+B,mBAAoB,IAI7Bv+B,KAAKyC,IAAIzC,KAAK2hB,UAAY3hB,KAAK8I,UAAUE,SAqBrD,SAAsBuD,GACDA,EAAI9H,WACVqd,iBAvB6D9hB,KAAK4hB,UAAYnd,WAAYzE,QACzFA,KAAKg+B,SACLh+B,KAAKsE,YAAYjB,KAAK7E,KAIlCsgC,EAAuB78B,UAAU6f,cAAgB,WAC7C,IAAIH,EAAY3hB,KAAK2hB,UACjBA,IACI3hB,KAAKi+B,UAAYj+B,KAAKu+B,oBACtBv+B,KAAKsE,YAAYjB,KAAKrD,KAAKw+B,gBAC3Bx+B,KAAKw+B,eAAiB,KACtBx+B,KAAKu+B,mBAAoB,GAE7B5c,EAAUhgB,cACV3B,KAAKqC,OAAOsf,GACZ3hB,KAAK2hB,UAAY,OAGlBmd,EAvCgC,CAwCzCx5B,EAAatB,cAOnB7F,OAAO,0BAA0B,UAAW,UAAW,QAAS,qBAAsB,iBAAkB,gBAAiB,wBAAyB,SAAUC,EAASC,EAAS6B,EAASyP,EAAS4S,EAAUjd,EAAcy5B,GACpN,aACAzgC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwEtDH,EAAQoZ,QANR,SAAiBunB,EAAKl2B,QACA,IAAdA,IAAwBA,EAAY6G,EAAQD,OAChD,IAAIuvB,EAAkB1c,EAASJ,OAAO6c,GAClCE,EAAUD,GAAoBD,EAAMl2B,EAAUwB,MAASqD,KAAK6a,IAAIwW,GACpE,OAAO,SAAUn4B,GAAU,OAAOA,EAAOF,KAAK,IAAIw4B,EAAgBD,EAASD,EAAiBn2B,EAAW,IAAIi2B,EAAetvB,iBAG9H,IAAI0vB,EAAiC,WACjC,SAASA,EAAgBD,EAASD,EAAiBn2B,EAAWs2B,GAC1Dp/B,KAAKk/B,QAAUA,EACfl/B,KAAKi/B,gBAAkBA,EACvBj/B,KAAK8I,UAAYA,EACjB9I,KAAKo/B,cAAgBA,EAKzB,OAHAD,EAAgBl9B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACnD,OAAOA,EAAOL,UAAU,IAAI64B,EAAkB56B,EAAYzE,KAAKi/B,gBAAiBj/B,KAAKk/B,QAASl/B,KAAK8I,UAAW9I,KAAKo/B,iBAEhHD,EAVyB,GAiBhCE,EAAmC,SAAUj/B,GAE7C,SAASi/B,EAAkB/6B,EAAa26B,EAAiBC,EAASp2B,EAAWs2B,GACzE,IAAI9+B,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAO9C,OANAM,EAAM2+B,gBAAkBA,EACxB3+B,EAAM4+B,QAAUA,EAChB5+B,EAAMwI,UAAYA,EAClBxI,EAAM8+B,cAAgBA,EACtB9+B,EAAMsK,OAAS,KACftK,EAAMg/B,kBACCh/B,EA8BX,OAvCAJ,EAAQc,UAAUq+B,EAAmBj/B,GAWrCi/B,EAAkBE,gBAAkB,SAAU96B,GAC1CA,EAAWnB,MAAMmB,EAAW26B,gBAEhCC,EAAkBp9B,UAAUq9B,gBAAkB,WAC1C,IAAI10B,EAAS5K,KAAK4K,OACdA,EAMA5K,KAAK4K,OAASA,EAAO5B,SAAShJ,KAAMA,KAAKk/B,SAGzCl/B,KAAKyC,IAAIzC,KAAK4K,OAAS5K,KAAK8I,UAAUE,SAASq2B,EAAkBE,gBAAiBv/B,KAAKk/B,QAASl/B,QAGxGq/B,EAAkBp9B,UAAUyC,MAAQ,SAAUlG,GACrCwB,KAAKi/B,iBACNj/B,KAAKs/B,kBAETl/B,EAAO6B,UAAUyC,MAAMnE,KAAKP,KAAMxB,IAEtC6gC,EAAkBp9B,UAAUD,aAAe,WACvChC,KAAK4K,OAAS,KACd5K,KAAK8I,UAAY,KACjB9I,KAAKo/B,cAAgB,MAElBC,EAxC2B,CAyCpC/5B,EAAatB,cAGnB7F,OAAO,8BAA8B,UAAW,UAAW,QAAS,qBAAsB,iBAAkB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASyP,EAAS4S,EAAUlB,EAAmBC,GACvO,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAyDtDH,EAAQmhC,YARR,SAAqBR,EAAKS,EAAgB32B,GAEtC,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzC,SAAU7I,GACb,IAAIo4B,EAAkB1c,EAASJ,OAAO6c,GAClCE,EAAUD,GAAoBD,EAAMl2B,EAAUwB,MAASqD,KAAK6a,IAAIwW,GACpE,OAAOn4B,EAAOF,KAAK,IAAI+4B,EAAoBR,EAASD,EAAiBQ,EAAgB32B,MAI7F,IAAI42B,EAAqC,WACrC,SAASA,EAAoBR,EAASD,EAAiBQ,EAAgB32B,GACnE9I,KAAKk/B,QAAUA,EACfl/B,KAAKi/B,gBAAkBA,EACvBj/B,KAAKy/B,eAAiBA,EACtBz/B,KAAK8I,UAAYA,EAKrB,OAHA42B,EAAoBz9B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACvD,OAAOA,EAAOL,UAAU,IAAIm5B,EAAsBl7B,EAAYzE,KAAKi/B,gBAAiBj/B,KAAKk/B,QAASl/B,KAAKy/B,eAAgBz/B,KAAK8I,aAEzH42B,EAV6B,GAiBpCC,EAAuC,SAAUv/B,GAEjD,SAASu/B,EAAsBr7B,EAAa26B,EAAiBC,EAASO,EAAgB32B,GAClF,IAAIxI,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAO9C,OANAM,EAAM2+B,gBAAkBA,EACxB3+B,EAAM4+B,QAAUA,EAChB5+B,EAAMm/B,eAAiBA,EACvBn/B,EAAMwI,UAAYA,EAClBxI,EAAMsK,OAAS,KACftK,EAAMg/B,kBACCh/B,EAgCX,OAzCAJ,EAAQc,UAAU2+B,EAAuBv/B,GAWzCu/B,EAAsBJ,gBAAkB,SAAU96B,GAC9C,IAAIg7B,EAAiBh7B,EAAWg7B,eAChCh7B,EAAWI,yBACXJ,EAAWhC,IAAI6e,EAAoBN,kBAAkBvc,EAAYg7B,KAErEE,EAAsB19B,UAAUq9B,gBAAkB,WAC9C,IAAI10B,EAAS5K,KAAK4K,OACdA,EAMA5K,KAAK4K,OAASA,EAAO5B,SAAShJ,KAAMA,KAAKk/B,SAGzCl/B,KAAKyC,IAAIzC,KAAK4K,OAAS5K,KAAK8I,UAAUE,SAAS22B,EAAsBJ,gBAAiBv/B,KAAKk/B,QAASl/B,QAG5G2/B,EAAsB19B,UAAUyC,MAAQ,SAAUlG,GACzCwB,KAAKi/B,iBACNj/B,KAAKs/B,kBAETl/B,EAAO6B,UAAUyC,MAAMnE,KAAKP,KAAMxB,IAEtCmhC,EAAsB19B,UAAUD,aAAe,WAC3ChC,KAAK4K,OAAS,KACd5K,KAAK8I,UAAY,KACjB9I,KAAKy/B,eAAiB,MAEnBE,EA1C+B,CA2CxCte,EAAkBtB,mBAGxB5hB,OAAO,0BAA0B,UAAW,UAAW,YAAa,SAAUC,EAASC,EAASy2B,GAC5F,aACAx2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAQtDH,EAAQuhC,QAHR,WACI,OAAO9K,EAASvzB,OALpB,SAAwB2mB,EAAKhH,EAAM/e,GAE/B,OADA+lB,EAAI1lB,KAAK0e,GACFgH,UAQf/pB,OAAO,yBAAyB,UAAW,UAAW,QAAS,aAAc,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASuI,EAAW4Y,EAAmBC,GAChM,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA0CtDH,EAAQK,OALR,SAAgBmhC,GACZ,OAAO,SAAgCh5B,GACnC,OAAOA,EAAOF,KAAK,IAAIm5B,EAAeD,MAI9C,IAAIC,EAAgC,WAChC,SAASA,EAAeD,GACpB7/B,KAAK6/B,iBAAmBA,EAU5B,OARAC,EAAe79B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAClD,IAAIk5B,EAAmB,IAAIC,EAAiBv7B,GACxCw7B,EAAqBp5B,EAAOL,UAAUu5B,GAI1C,OAHKE,EAAmBr+B,QACpBm+B,EAAiBt9B,IAAI6e,EAAoBN,kBAAkB+e,EAAkB//B,KAAK6/B,mBAE/EI,GAEJH,EAZwB,GAmB/BE,EAAkC,SAAU5/B,GAE5C,SAAS4/B,EAAiB17B,GACtB,IAAIhE,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAM5B,OAAS,IAAI+J,EAAUP,QAC7B5D,EAAYjB,KAAK/C,EAAM5B,QAChB4B,EAkCX,OAvCAJ,EAAQc,UAAUg/B,EAAkB5/B,GAOpC4/B,EAAiB/9B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC9FrgB,KAAKkgC,cAETF,EAAiB/9B,UAAUqe,YAAc,SAAUhd,EAAO+c,GACtDrgB,KAAK2E,OAAOrB,IAEhB08B,EAAiB/9B,UAAUse,eAAiB,SAAUF,GAClDrgB,KAAK4E,aAETo7B,EAAiB/9B,UAAUyC,MAAQ,SAAUlG,GACzCwB,KAAKtB,OAAO2E,KAAK7E,IAErBwhC,EAAiB/9B,UAAU0C,OAAS,SAAUnE,GAC1CR,KAAKtB,OAAO4E,MAAM9C,GAClBR,KAAKsE,YAAYhB,MAAM9C,IAE3Bw/B,EAAiB/9B,UAAU2C,UAAY,WACnC5E,KAAKtB,OAAO6E,WACZvD,KAAKsE,YAAYf,YAErBy8B,EAAiB/9B,UAAUD,aAAe,WACtChC,KAAKtB,OAAS,MAElBshC,EAAiB/9B,UAAUi+B,WAAa,WACpC,IAAIC,EAAangC,KAAKtB,OAClByhC,GACAA,EAAW58B,WAEf,IAAIe,EAActE,KAAKsE,YACnB87B,EAAYpgC,KAAKtB,OAAS,IAAI+J,EAAUP,QAC5C5D,EAAYjB,KAAK+8B,IAEdJ,EAxC0B,CAyCnC3e,EAAkBtB,mBAGxB5hB,OAAO,8BAA8B,UAAW,UAAW,QAAS,gBAAiB,cAAe,SAAUC,EAASC,EAAS6B,EAASoF,EAAcmD,GACnJ,aACAnK,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAuDtDH,EAAQgiC,YANR,SAAqBC,EAAYC,GAE7B,YADyB,IAArBA,IAA+BA,EAAmB,GAC/C,SAAqC15B,GACxC,OAAOA,EAAOF,KAAK,IAAI65B,EAAoBF,EAAYC,MAI/D,IAAIC,EAAqC,WACrC,SAASA,EAAoBF,EAAYC,GACrCvgC,KAAKsgC,WAAaA,EAClBtgC,KAAKugC,iBAAmBA,EAK5B,OAHAC,EAAoBv+B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACvD,OAAOA,EAAOL,UAAU,IAAIi6B,EAAsBh8B,EAAYzE,KAAKsgC,WAAYtgC,KAAKugC,oBAEjFC,EAR6B,GAepCC,EAAuC,SAAUrgC,GAEjD,SAASqgC,EAAsBn8B,EAAag8B,EAAYC,GACpD,IAAIjgC,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAO9C,OANAM,EAAMgE,YAAcA,EACpBhE,EAAMggC,WAAaA,EACnBhgC,EAAMigC,iBAAmBA,EACzBjgC,EAAMogC,SAAW,IAAIj4B,EAAUP,SAC/B5H,EAAMmQ,MAAQ,EACdnM,EAAYjB,KAAK/C,EAAMogC,QAAQ,IACxBpgC,EA2CX,OApDAJ,EAAQc,UAAUy/B,EAAuBrgC,GAWzCqgC,EAAsBx+B,UAAUyC,MAAQ,SAAUlG,GAM9C,IAAK,IALD+hC,EAAoBvgC,KAAKugC,iBAAmB,EAAKvgC,KAAKugC,iBAAmBvgC,KAAKsgC,WAC9Eh8B,EAActE,KAAKsE,YACnBg8B,EAAatgC,KAAKsgC,WAClBI,EAAU1gC,KAAK0gC,QACft+B,EAAMs+B,EAAQnhC,OACTmB,EAAI,EAAGA,EAAI0B,IAAQpC,KAAK4B,OAAQlB,IACrCggC,EAAQhgC,GAAG2C,KAAK7E,GAEpB,IAAI6W,EAAIrV,KAAKyQ,MAAQ6vB,EAAa,EAIlC,GAHIjrB,GAAK,GAAKA,EAAIkrB,GAAqB,IAAMvgC,KAAK4B,QAC9C8+B,EAAQ71B,QAAQtH,aAEdvD,KAAKyQ,MAAQ8vB,GAAqB,IAAMvgC,KAAK4B,OAAQ,CACvD,IAAI++B,EAAW,IAAIl4B,EAAUP,QAC7Bw4B,EAAQl+B,KAAKm+B,GACbr8B,EAAYjB,KAAKs9B,KAGzBF,EAAsBx+B,UAAU0C,OAAS,SAAUnE,GAC/C,IAAIkgC,EAAU1gC,KAAK0gC,QACnB,GAAIA,EACA,KAAOA,EAAQnhC,OAAS,IAAMS,KAAK4B,QAC/B8+B,EAAQ71B,QAAQvH,MAAM9C,GAG9BR,KAAKsE,YAAYhB,MAAM9C,IAE3BigC,EAAsBx+B,UAAU2C,UAAY,WACxC,IAAI87B,EAAU1gC,KAAK0gC,QACnB,GAAIA,EACA,KAAOA,EAAQnhC,OAAS,IAAMS,KAAK4B,QAC/B8+B,EAAQ71B,QAAQtH,WAGxBvD,KAAKsE,YAAYf,YAErBk9B,EAAsBx+B,UAAUD,aAAe,WAC3ChC,KAAKyQ,MAAQ,EACbzQ,KAAK0gC,QAAU,MAEZD,EArD+B,CAsDxCn7B,EAAatB,cAGnB7F,OAAO,6BAA6B,UAAW,UAAW,QAAS,aAAc,qBAAsB,gBAAiB,oBAAqB,uBAAwB,SAAUC,EAASC,EAAS6B,EAASuI,EAAWkH,EAASrK,EAAc+c,EAAaC,GACrP,aAoJA,SAASse,EAAoB33B,GACzB,IAAIxE,EAAawE,EAAMxE,WAAY/F,EAASuK,EAAMvK,OAAQsG,EAAUiE,EAAMjE,QACtEA,GAAWA,EAAQ4F,QAAU5F,EAAQpC,cACrCoC,EAAQ4F,OAAOvI,OAAO2C,EAAQpC,cAElC6B,EAAWo8B,YAAYniC,GAxJ3BJ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwBtDH,EAAQ0O,WAvBR,SAAoB+zB,GAChB,IAAIh4B,EAAY6G,EAAQD,MACpBqxB,EAAyB,KACzBC,EAAgBh0B,OAAOC,kBAgB3B,OAfIqV,EAAcJ,YAAYjiB,UAAU,MACpC6I,EAAY7I,UAAU,IAEtBqiB,EAAcJ,YAAYjiB,UAAU,IACpC6I,EAAY7I,UAAU,GAEjBoiB,EAAYN,UAAU9hB,UAAU,MACrC+gC,EAAgB/gC,UAAU,IAE1BqiB,EAAcJ,YAAYjiB,UAAU,IACpC6I,EAAY7I,UAAU,GAEjBoiB,EAAYN,UAAU9hB,UAAU,MACrC8gC,EAAyB9gC,UAAU,IAEhC,SAAoC4G,GACvC,OAAOA,EAAOF,KAAK,IAAIs6B,EAAmBH,EAAgBC,EAAwBC,EAAel4B,MAIzG,IAAIm4B,EAAoC,WACpC,SAASA,EAAmBH,EAAgBC,EAAwBC,EAAel4B,GAC/E9I,KAAK8gC,eAAiBA,EACtB9gC,KAAK+gC,uBAAyBA,EAC9B/gC,KAAKghC,cAAgBA,EACrBhhC,KAAK8I,UAAYA,EAKrB,OAHAm4B,EAAmBh/B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACtD,OAAOA,EAAOL,UAAU,IAAI06B,EAAqBz8B,EAAYzE,KAAK8gC,eAAgB9gC,KAAK+gC,uBAAwB/gC,KAAKghC,cAAehhC,KAAK8I,aAErIm4B,EAV4B,GAYnCE,EAAgC,SAAU/gC,GAE1C,SAAS+gC,IACL,IAAI7gC,EAAmB,OAAXF,GAAmBA,EAAOL,MAAMC,KAAMC,YAAcD,KAEhE,OADAM,EAAM8gC,sBAAwB,EACvB9gC,EAaX,OAjBAJ,EAAQc,UAAUmgC,EAAgB/gC,GAMlC+gC,EAAel/B,UAAUoB,KAAO,SAAU7E,GACtCwB,KAAKohC,wBACLhhC,EAAO6B,UAAUoB,KAAK9C,KAAKP,KAAMxB,IAErCF,OAAOC,eAAe4iC,EAAel/B,UAAW,wBAC5C8L,IAAK,WACD,OAAO/N,KAAKohC,uBAEhBnzB,YAAY,EACZC,cAAc,IAEXizB,EAlBwB,CAmBjC14B,EAAUP,SAMRg5B,EAAsC,SAAU9gC,GAEhD,SAAS8gC,EAAqB58B,EAAaw8B,EAAgBC,EAAwBC,EAAel4B,GAC9F,IAAIxI,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAC9CM,EAAMgE,YAAcA,EACpBhE,EAAMwgC,eAAiBA,EACvBxgC,EAAMygC,uBAAyBA,EAC/BzgC,EAAM0gC,cAAgBA,EACtB1gC,EAAMwI,UAAYA,EAClBxI,EAAMogC,WACN,IAAIhiC,EAAS4B,EAAM4/B,aACnB,GAA+B,OAA3Ba,GAAmCA,GAA0B,EAAG,CAChE,IAAInc,GAAengB,WAAYnE,EAAO5B,OAAQA,EAAQsG,QAAS,MAC3D6f,GAAkBic,eAAgBA,EAAgBC,uBAAwBA,EAAwBt8B,WAAYnE,EAAOwI,UAAWA,GACpIxI,EAAMmC,IAAIqG,EAAUE,SAAS43B,EAAqBE,EAAgBlc,IAClEtkB,EAAMmC,IAAIqG,EAAUE,SA4DhC,SAAgCC,GAC5B,IAAI63B,EAAiB73B,EAAM63B,eAAgBr8B,EAAawE,EAAMxE,WAAYqE,EAAYG,EAAMH,UAAWi4B,EAAyB93B,EAAM83B,uBAGlI/7B,GAAY4F,OADH5K,KACmB4C,aAAc,MAC1Cy+B,GAAkB58B,WAAYA,EAAY/F,OAHjC+F,EAAWy7B,aAGsCl7B,QAASA,GACvEA,EAAQpC,aAAekG,EAAUE,SAAS43B,EAAqBE,EAAgBO,GAHlErhC,KAINyC,IAAIuC,EAAQpC,cAJN5C,KAKNgJ,SAASC,EAAO83B,IApEsCA,EAAwBlc,QAE5E,CACD,IAAIF,GAAsBlgB,WAAYnE,EAAO5B,OAAQA,EAAQoiC,eAAgBA,GAC7ExgC,EAAMmC,IAAIqG,EAAUE,SAgDhC,SAAoCC,GAChC,IAAIxE,EAAawE,EAAMxE,WAAYq8B,EAAiB73B,EAAM63B,eAAgBpiC,EAASuK,EAAMvK,OACrFA,GACA+F,EAAWo8B,YAAYniC,GAE3BuK,EAAMvK,OAAS+F,EAAWy7B,aAC1BlgC,KAAKgJ,SAASC,EAAO63B,IAtD4CA,EAAgBnc,IAE7E,OAAOrkB,EA4CX,OAhEAJ,EAAQc,UAAUkgC,EAAsB9gC,GAsBxC8gC,EAAqBj/B,UAAUyC,MAAQ,SAAUlG,GAG7C,IAAK,IAFDkiC,EAAU1gC,KAAK0gC,QACft+B,EAAMs+B,EAAQnhC,OACTmB,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAIigC,EAAWD,EAAQhgC,GAClBigC,EAAS/+B,SACV++B,EAASt9B,KAAK7E,GACVmiC,EAASW,sBAAwBthC,KAAKghC,eACtChhC,KAAK6gC,YAAYF,MAKjCO,EAAqBj/B,UAAU0C,OAAS,SAAUnE,GAE9C,IADA,IAAIkgC,EAAU1gC,KAAK0gC,QACZA,EAAQnhC,OAAS,GACpBmhC,EAAQ71B,QAAQvH,MAAM9C,GAE1BR,KAAKsE,YAAYhB,MAAM9C,IAE3B0gC,EAAqBj/B,UAAU2C,UAAY,WAEvC,IADA,IAAI87B,EAAU1gC,KAAK0gC,QACZA,EAAQnhC,OAAS,GAAG,CACvB,IAAIgiC,EAAWb,EAAQ71B,QAClB02B,EAAS3/B,QACV2/B,EAASh+B,WAGjBvD,KAAKsE,YAAYf,YAErB29B,EAAqBj/B,UAAUi+B,WAAa,WACxC,IAAIxhC,EAAS,IAAIyiC,EACjBnhC,KAAK0gC,QAAQl+B,KAAK9D,GAGlB,OAFkBsB,KAAKsE,YACXjB,KAAK3E,GACVA,GAEXwiC,EAAqBj/B,UAAU4+B,YAAc,SAAUniC,GACnDA,EAAO6E,WACP,IAAIm9B,EAAU1gC,KAAK0gC,QACnBA,EAAQx9B,OAAOw9B,EAAQz9B,QAAQvE,GAAS,IAErCwiC,EAjE8B,CAkEvC57B,EAAatB,cA4BnB7F,OAAO,+BAA+B,UAAW,UAAW,QAAS,aAAc,kBAAmB,mBAAoB,sBAAuB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASuI,EAAW5E,EAAgBzC,EAAYzB,EAAe0hB,EAAmBC,GAC/S,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6CtDH,EAAQmjC,aAHR,SAAsBvc,EAAUC,GAC5B,OAAO,SAAUre,GAAU,OAAOA,EAAOF,KAAK,IAAI86B,EAAqBxc,EAAUC,MAGrF,IAAIuc,EAAsC,WACtC,SAASA,EAAqBxc,EAAUC,GACpCllB,KAAKilB,SAAWA,EAChBjlB,KAAKklB,gBAAkBA,EAK3B,OAHAuc,EAAqBx/B,UAAU1B,KAAO,SAAUkE,EAAYoC,GACxD,OAAOA,EAAOL,UAAU,IAAIk7B,EAAuBj9B,EAAYzE,KAAKilB,SAAUjlB,KAAKklB,mBAEhFuc,EAR8B,GAerCC,EAAwC,SAAUthC,GAElD,SAASshC,EAAuBp9B,EAAa2gB,EAAUC,GACnD,IAAI5kB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAM2kB,SAAWA,EACjB3kB,EAAM4kB,gBAAkBA,EACxB5kB,EAAMmkB,YACNnkB,EAAMmC,IAAInC,EAAMqhC,iBAAmBrgB,EAAoBN,kBAAkB1gB,EAAO2kB,EAAUA,IACnF3kB,EAkGX,OAzGAJ,EAAQc,UAAU0gC,EAAwBthC,GAS1CshC,EAAuBz/B,UAAUyC,MAAQ,SAAUlG,GAC/C,IAAIimB,EAAWzkB,KAAKykB,SACpB,GAAIA,EAEA,IAAK,IADDriB,EAAMqiB,EAASllB,OACVmB,EAAI,EAAGA,EAAI0B,EAAK1B,IACrB+jB,EAAS/jB,GAAGhC,OAAO2E,KAAK7E,IAIpCkjC,EAAuBz/B,UAAU0C,OAAS,SAAUnE,GAChD,IAAIikB,EAAWzkB,KAAKykB,SAEpB,GADAzkB,KAAKykB,SAAW,KACZA,EAGA,IAFA,IAAIriB,EAAMqiB,EAASllB,OACf4C,GAAS,IACJA,EAAQC,GAAK,CAClB,IAAI4C,EAAUyf,EAAStiB,GACvB6C,EAAQtG,OAAO4E,MAAM9C,GACrBwE,EAAQpC,aAAajB,cAG7BvB,EAAO6B,UAAU0C,OAAOpE,KAAKP,KAAMQ,IAEvCkhC,EAAuBz/B,UAAU2C,UAAY,WACzC,IAAI6f,EAAWzkB,KAAKykB,SAEpB,GADAzkB,KAAKykB,SAAW,KACZA,EAGA,IAFA,IAAIriB,EAAMqiB,EAASllB,OACf4C,GAAS,IACJA,EAAQC,GAAK,CAClB,IAAI4C,EAAUyf,EAAStiB,GACvB6C,EAAQtG,OAAO6E,WACfyB,EAAQpC,aAAajB,cAG7BvB,EAAO6B,UAAU2C,UAAUrE,KAAKP,OAEpC0hC,EAAuBz/B,UAAUD,aAAe,WAC5C,IAAIyiB,EAAWzkB,KAAKykB,SAEpB,GADAzkB,KAAKykB,SAAW,KACZA,EAGA,IAFA,IAAIriB,EAAMqiB,EAASllB,OACf4C,GAAS,IACJA,EAAQC,GAAK,CAClB,IAAI4C,EAAUyf,EAAStiB,GACvB6C,EAAQtG,OAAOiD,cACfqD,EAAQpC,aAAajB,gBAIjC+/B,EAAuBz/B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACpG,GAAIJ,IAAejgB,KAAKilB,SAAU,CAC9B,IAAIC,EAAkBllB,KAAKklB,gBACvBhC,EAAkB9hB,EAAWvB,SAASqlB,EAApB9jB,CAAqC8e,GAC3D,GAAIgD,IAAoBvjB,EAAcF,YAClC,OAAOO,KAAKsD,MAAM3D,EAAcF,YAAYC,GAG5C,IAAIihC,EAAW,IAAIl4B,EAAUP,QACzBtF,EAAe,IAAIiB,EAAenC,aAClCsD,GAAYtG,OAAQiiC,EAAU/9B,aAAcA,GAChD5C,KAAKykB,SAASjiB,KAAKwC,GACnB,IAAI6c,EAAoBP,EAAoBN,kBAAkBhhB,KAAMkjB,EAAiBle,GACjF6c,EAAkBjgB,OAClB5B,KAAK6gC,YAAY7gC,KAAKykB,SAASllB,OAAS,IAGxCsiB,EAAkB7c,QAAUA,EAC5BpC,EAAaH,IAAIof,IAErB7hB,KAAKsE,YAAYjB,KAAKs9B,QAI1B3gC,KAAK6gC,YAAY7gC,KAAKykB,SAASxhB,QAAQgd,KAG/CyhB,EAAuBz/B,UAAUqe,YAAc,SAAU9f,GACrDR,KAAKsD,MAAM9C,IAEfkhC,EAAuBz/B,UAAUse,eAAiB,SAAUuc,GACpDA,IAAU98B,KAAK2hC,kBACf3hC,KAAK6gC,YAAY7gC,KAAKykB,SAASxhB,QAAQ65B,EAAM93B,WAGrD08B,EAAuBz/B,UAAU4+B,YAAc,SAAU1+B,GACrD,IAAe,IAAXA,EAAJ,CAGA,IAAIsiB,EAAWzkB,KAAKykB,SAChBzf,EAAUyf,EAAStiB,GACnBzD,EAASsG,EAAQtG,OAAQkE,EAAeoC,EAAQpC,aACpD6hB,EAASvhB,OAAOf,EAAO,GACvBzD,EAAO6E,WACPX,EAAajB,gBAEV+/B,EA1GgC,CA2GzCrgB,EAAkBtB,mBAGxB5hB,OAAO,6BAA6B,UAAW,UAAW,QAAS,aAAc,mBAAoB,sBAAuB,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASuI,EAAWrH,EAAYzB,EAAe0hB,EAAmBC,GAC1Q,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQujC,WALR,SAAoB1c,GAChB,OAAO,SAAoCre,GACvC,OAAOA,EAAOF,KAAK,IAAIm5B,EAAe5a,MAI9C,IAAI4a,EAAgC,WAChC,SAASA,EAAe5a,GACpBllB,KAAKklB,gBAAkBA,EAK3B,OAHA4a,EAAe79B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAClD,OAAOA,EAAOL,UAAU,IAAIw5B,EAAiBv7B,EAAYzE,KAAKklB,mBAE3D4a,EAPwB,GAc/BE,EAAkC,SAAU5/B,GAE5C,SAAS4/B,EAAiB17B,EAAa4gB,GACnC,IAAI5kB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAI9C,OAHAM,EAAMgE,YAAcA,EACpBhE,EAAM4kB,gBAAkBA,EACxB5kB,EAAM4/B,aACC5/B,EAmDX,OAzDAJ,EAAQc,UAAUg/B,EAAkB5/B,GAQpC4/B,EAAiB/9B,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC9FrgB,KAAKkgC,WAAW7f,IAEpB2f,EAAiB/9B,UAAUqe,YAAc,SAAUhd,EAAO+c,GACtDrgB,KAAK2E,OAAOrB,IAEhB08B,EAAiB/9B,UAAUse,eAAiB,SAAUF,GAClDrgB,KAAKkgC,WAAW7f,IAEpB2f,EAAiB/9B,UAAUyC,MAAQ,SAAUlG,GACzCwB,KAAKtB,OAAO2E,KAAK7E,IAErBwhC,EAAiB/9B,UAAU0C,OAAS,SAAUnE,GAC1CR,KAAKtB,OAAO4E,MAAM9C,GAClBR,KAAKsE,YAAYhB,MAAM9C,GACvBR,KAAK6hC,kCAET7B,EAAiB/9B,UAAU2C,UAAY,WACnC5E,KAAKtB,OAAO6E,WACZvD,KAAKsE,YAAYf,WACjBvD,KAAK6hC,kCAET7B,EAAiB/9B,UAAU4/B,+BAAiC,WACpD7hC,KAAK8hC,qBACL9hC,KAAK8hC,oBAAoBngC,eAGjCq+B,EAAiB/9B,UAAUi+B,WAAa,SAAU7f,QAC7B,IAAbA,IAAuBA,EAAW,MAClCA,IACArgB,KAAKqC,OAAOge,GACZA,EAAS1e,eAEb,IAAIw+B,EAAangC,KAAKtB,OAClByhC,GACAA,EAAW58B,WAEf,IAAI7E,EAASsB,KAAKtB,OAAS,IAAI+J,EAAUP,QACzClI,KAAKsE,YAAYjB,KAAK3E,GACtB,IAAIwkB,EAAkB9hB,EAAWvB,SAASG,KAAKklB,gBAAzB9jB,GACtB,GAAI8hB,IAAoBvjB,EAAcF,YAAa,CAC/C,IAAIe,EAAMb,EAAcF,YAAYC,EACpCM,KAAKsE,YAAYhB,MAAM9C,GACvBR,KAAKtB,OAAO4E,MAAM9C,QAGlBR,KAAKyC,IAAIzC,KAAK8hC,oBAAsBxgB,EAAoBN,kBAAkBhhB,KAAMkjB,KAGjF8c,EA1D0B,CA2DnC3e,EAAkBtB,mBAGxB5hB,OAAO,iCAAiC,UAAW,UAAW,QAAS,qBAAsB,6BAA8B,SAAUC,EAASC,EAAS6B,EAASmhB,EAAmBC,GAC/K,aACAhjB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsDtDH,EAAQ0jC,eAdR,WAEI,IAAK,IADDzlB,KACKnW,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCmW,EAAKnW,GAAMlG,UAAUkG,GAEzB,OAAO,SAAUU,GACb,IAAIuJ,EACiC,mBAA1BkM,EAAKA,EAAK/c,OAAS,KAC1B6Q,EAAUkM,EAAKmK,OAEnB,IAAII,EAAcvK,EAClB,OAAOzV,EAAOF,KAAK,IAAIq7B,EAAuBnb,EAAazW,MAInE,IAAI4xB,EAAwC,WACxC,SAASA,EAAuBnb,EAAazW,GACzCpQ,KAAK6mB,YAAcA,EACnB7mB,KAAKoQ,QAAUA,EAKnB,OAHA4xB,EAAuB//B,UAAU1B,KAAO,SAAUkE,EAAYoC,GAC1D,OAAOA,EAAOL,UAAU,IAAIy7B,EAAyBx9B,EAAYzE,KAAK6mB,YAAa7mB,KAAKoQ,WAErF4xB,EARgC,GAevCC,EAA0C,SAAU7hC,GAEpD,SAAS6hC,EAAyB39B,EAAauiB,EAAazW,GACxD,IAAI9P,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAC9CM,EAAMumB,YAAcA,EACpBvmB,EAAM8P,QAAUA,EAChB9P,EAAM0mB,aACN,IAAI5kB,EAAMykB,EAAYtnB,OACtBe,EAAMwT,OAAS,IAAIxU,MAAM8C,GACzB,IAAS1B,EAAI,EAAGA,EAAI0B,EAAK1B,IACrBJ,EAAM0mB,UAAUxkB,KAAK9B,GAEzB,IAAK,IAAIA,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAIiF,EAAakhB,EAAYnmB,GAC7BJ,EAAMmC,IAAI6e,EAAoBN,kBAAkB1gB,EAAOqF,EAAYA,EAAYjF,IAEnF,OAAOJ,EAqCX,OApDAJ,EAAQc,UAAUihC,EAA0B7hC,GAiB5C6hC,EAAyBhgC,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GACtGrgB,KAAK8T,OAAOqM,GAAcD,EAC1B,IAAI8G,EAAYhnB,KAAKgnB,UACrB,GAAIA,EAAUznB,OAAS,EAAG,CACtB,IAAI2iC,EAAQlb,EAAU/jB,QAAQkd,IACf,IAAX+hB,GACAlb,EAAU9jB,OAAOg/B,EAAO,KAIpCD,EAAyBhgC,UAAUse,eAAiB,aAGpD0hB,EAAyBhgC,UAAUyC,MAAQ,SAAUlG,GACjD,GAA8B,IAA1BwB,KAAKgnB,UAAUznB,OAAc,CAC7B,IAAI+c,GAAQ9d,GAAOiD,OAAOzB,KAAK8T,QAC3B9T,KAAKoQ,QACLpQ,KAAKmnB,YAAY7K,GAGjBtc,KAAKsE,YAAYjB,KAAKiZ,KAIlC2lB,EAAyBhgC,UAAUklB,YAAc,SAAU7K,GACvD,IAAI5L,EACJ,IACIA,EAAS1Q,KAAKoQ,QAAQrQ,MAAMC,KAAMsc,GAEtC,MAAO9b,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAKsE,YAAYjB,KAAKqN,IAEnBuxB,EArDkC,CAsD3C5gB,EAAkBtB,mBAGxB5hB,OAAO,sBAAsB,UAAW,UAAW,QAAS,gCAAiC,kBAAmB,gBAAiB,qBAAsB,4BAA6B,sBAAuB,SAAUC,EAASC,EAAS6B,EAASwmB,EAAmBzlB,EAAWqE,EAAc+b,EAAmBC,EAAqBR,GAChU,aAmDA,SAASqhB,IAEL,IAAK,IADDtb,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,IAAIiK,EAAUyW,EAAYA,EAAYtnB,OAAS,GAI/C,MAHuB,mBAAZ6Q,GACPyW,EAAYJ,MAET,IAAIC,EAAkBH,gBAAgBM,GAAalgB,KAAK,IAAIy7B,EAAYhyB,IA3DnF9R,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiBtDH,EAAQgkC,IATR,WAEI,IAAK,IADDxb,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAO,SAA6BU,GAChC,OAAOA,EAAOF,KAAKpG,KAAK4hC,EAAUpiC,WAAM,GAAS8G,GAAQpF,OAAOolB,OA+CxExoB,EAAQ8jC,UAAYA,EACpB,IAAIC,EAA6B,WAC7B,SAASA,EAAYhyB,GACjBpQ,KAAKoQ,QAAUA,EAKnB,OAHAgyB,EAAYngC,UAAU1B,KAAO,SAAUkE,EAAYoC,GAC/C,OAAOA,EAAOL,UAAU,IAAI87B,EAAc79B,EAAYzE,KAAKoQ,WAExDgyB,EAPqB,GAShC/jC,EAAQ+jC,YAAcA,EAMtB,IAAIE,EAA+B,SAAUliC,GAEzC,SAASkiC,EAAch+B,EAAa8L,EAAS0D,QAC1B,IAAXA,IAAqBA,EAASxV,OAAOkG,OAAO,OAChD,IAAIlE,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMiiC,aACNjiC,EAAMoK,OAAS,EACfpK,EAAM8P,QAA8B,mBAAZA,EAA0BA,EAAU,KAC5D9P,EAAMwT,OAASA,EACRxT,EAsFX,OA9FAJ,EAAQc,UAAUshC,EAAeliC,GAUjCkiC,EAAcrgC,UAAUyC,MAAQ,SAAUlG,GACtC,IAAI+jC,EAAYviC,KAAKuiC,UACjBthC,EAAU5B,QAAQb,GAClB+jC,EAAU//B,KAAK,IAAIggC,EAAoBhkC,IAEI,mBAA/BA,EAAMsiB,EAAWrB,UAC7B8iB,EAAU//B,KAAK,IAAIigC,EAAejkC,EAAMsiB,EAAWrB,cAGnD8iB,EAAU//B,KAAK,IAAIkgC,EAAkB1iC,KAAKsE,YAAatE,KAAMxB,KAGrE8jC,EAAcrgC,UAAU2C,UAAY,WAChC,IAAI29B,EAAYviC,KAAKuiC,UACjBngC,EAAMmgC,EAAUhjC,OACpB,GAAY,IAAR6C,EAAJ,CAIApC,KAAK0K,OAAStI,EACd,IAAK,IAAI1B,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAI+e,EAAW8iB,EAAU7hC,GACrB+e,EAASkjB,kBACT3iC,KAAKyC,IAAIgd,EAASjZ,UAAUiZ,EAAU/e,IAGtCV,KAAK0K,eAVT1K,KAAKsE,YAAYf,YAczB++B,EAAcrgC,UAAU2gC,eAAiB,WACrC5iC,KAAK0K,SACe,IAAhB1K,KAAK0K,QACL1K,KAAKsE,YAAYf,YAGzB++B,EAAcrgC,UAAU4gC,eAAiB,WAKrC,IAAK,IAJDN,EAAYviC,KAAKuiC,UACjBngC,EAAMmgC,EAAUhjC,OAChB+E,EAActE,KAAKsE,YAEd5D,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAE1B,GAAiC,mBAD7B+e,EAAW8iB,EAAU7hC,IACL2K,WAA4BoU,EAASpU,WACrD,OAKR,IAAK,IAFDy3B,GAAiB,EACjBxmB,KACK5b,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAI+e,EAAW8iB,EAAU7hC,GACrBgQ,EAAS+O,EAASpc,OAMtB,GAHIoc,EAAS7W,iBACTk6B,GAAiB,GAEjBpyB,EAAOwH,KAEP,YADA5T,EAAYf,WAGhB+Y,EAAK9Z,KAAKkO,EAAOlS,OAEjBwB,KAAKoQ,QACLpQ,KAAKmnB,YAAY7K,GAGjBhY,EAAYjB,KAAKiZ,GAEjBwmB,GACAx+B,EAAYf,YAGpB++B,EAAcrgC,UAAUklB,YAAc,SAAU7K,GAC5C,IAAI5L,EACJ,IACIA,EAAS1Q,KAAKoQ,QAAQrQ,MAAMC,KAAMsc,GAEtC,MAAO9b,GAEH,YADAR,KAAKsE,YAAYhB,MAAM9C,GAG3BR,KAAKsE,YAAYjB,KAAKqN,IAEnB4xB,EA/FuB,CAgGhCh9B,EAAatB,YACf3F,EAAQikC,cAAgBA,EACxB,IAAIG,EAAgC,WAChC,SAASA,EAAehjB,GACpBzf,KAAKyf,SAAWA,EAChBzf,KAAK+iC,WAAatjB,EAASpc,OAc/B,OAZAo/B,EAAexgC,UAAUoJ,SAAW,WAChC,OAAO,GAEXo3B,EAAexgC,UAAUoB,KAAO,WAC5B,IAAIqN,EAAS1Q,KAAK+iC,WAElB,OADA/iC,KAAK+iC,WAAa/iC,KAAKyf,SAASpc,OACzBqN,GAEX+xB,EAAexgC,UAAU2G,aAAe,WACpC,IAAIm6B,EAAa/iC,KAAK+iC,WACtB,OAAOA,GAAcA,EAAW7qB,MAE7BuqB,EAjBwB,GAmB/BD,EAAqC,WACrC,SAASA,EAAoBhc,GACzBxmB,KAAKwmB,MAAQA,EACbxmB,KAAKmC,MAAQ,EACbnC,KAAKT,OAAS,EACdS,KAAKT,OAASinB,EAAMjnB,OAgBxB,OAdAijC,EAAoBvgC,UAAU6e,EAAWrB,UAAY,WACjD,OAAOzf,MAEXwiC,EAAoBvgC,UAAUoB,KAAO,SAAU7E,GAC3C,IAAIkC,EAAIV,KAAKmC,QACTqkB,EAAQxmB,KAAKwmB,MACjB,OAAO9lB,EAAIV,KAAKT,QAAWf,MAAOgoB,EAAM9lB,GAAIwX,MAAM,IAAY1Z,MAAO,KAAM0Z,MAAM,IAErFsqB,EAAoBvgC,UAAUoJ,SAAW,WACrC,OAAOrL,KAAKwmB,MAAMjnB,OAASS,KAAKmC,OAEpCqgC,EAAoBvgC,UAAU2G,aAAe,WACzC,OAAO5I,KAAKwmB,MAAMjnB,SAAWS,KAAKmC,OAE/BqgC,EArB6B,GA4BpCE,EAAmC,SAAUtiC,GAE7C,SAASsiC,EAAkBp+B,EAAanB,EAAQwC,GAC5C,IAAIrF,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAM9C,OALAM,EAAM6C,OAASA,EACf7C,EAAMqF,WAAaA,EACnBrF,EAAMqiC,mBAAoB,EAC1BriC,EAAM2iB,UACN3iB,EAAMi6B,YAAa,EACZj6B,EAsCX,OA9CAJ,EAAQc,UAAU0hC,EAAmBtiC,GAUrCsiC,EAAkBzgC,UAAU6e,EAAWrB,UAAY,WAC/C,OAAOzf,MAIX0iC,EAAkBzgC,UAAUoB,KAAO,WAC/B,IAAI4f,EAASjjB,KAAKijB,OAClB,OAAsB,IAAlBA,EAAO1jB,QAAgBS,KAAKu6B,YACnB/7B,MAAO,KAAM0Z,MAAM,IAGnB1Z,MAAOykB,EAAOpY,QAASqN,MAAM,IAG9CwqB,EAAkBzgC,UAAUoJ,SAAW,WACnC,OAAOrL,KAAKijB,OAAO1jB,OAAS,GAEhCmjC,EAAkBzgC,UAAU2G,aAAe,WACvC,OAA8B,IAAvB5I,KAAKijB,OAAO1jB,QAAgBS,KAAKu6B,YAE5CmI,EAAkBzgC,UAAUse,eAAiB,WACrCvgB,KAAKijB,OAAO1jB,OAAS,GACrBS,KAAKu6B,YAAa,EAClBv6B,KAAKmD,OAAOy/B,kBAGZ5iC,KAAKsE,YAAYf,YAGzBm/B,EAAkBzgC,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAC/FrgB,KAAKijB,OAAOzgB,KAAK0d,GACjBlgB,KAAKmD,OAAO0/B,kBAEhBH,EAAkBzgC,UAAUuE,UAAY,SAAUhI,EAAO2D,GACrD,OAAOmf,EAAoBN,kBAAkBhhB,KAAMA,KAAK2F,WAAY3F,KAAMmC,IAEvEugC,EA/C2B,CAgDpCrhB,EAAkBtB,mBAGxB5hB,OAAO,yBAAyB,UAAW,UAAW,SAAU,SAAUC,EAASC,EAAS2kC,GACxF,aACA1kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAItDH,EAAQ4kC,OAHR,SAAgB7yB,GACZ,OAAO,SAAUvJ,GAAU,OAAOA,EAAOF,KAAK,IAAIq8B,EAAMZ,YAAYhyB,QAK5EjS,OAAO,wBAAwB,UAAW,UAAW,UAAW,cAAe,WAAY,gBAAiB,eAAgB,iBAAkB,eAAgB,eAAgB,eAAgB,kBAAmB,WAAY,cAAe,cAAe,gBAAiB,UAAW,aAAc,iBAAkB,mBAAoB,UAAW,cAAe,kBAAmB,aAAc,yBAA0B,4BAA6B,cAAe,UAAW,YAAa,eAAgB,WAAY,WAAY,aAAc,SAAU,cAAe,UAAW,YAAa,mBAAoB,YAAa,SAAU,QAAS,UAAW,gBAAiB,QAAS,UAAW,aAAc,aAAc,aAAc,eAAgB,cAAe,QAAS,cAAe,cAAe,sBAAuB,aAAc,cAAe,UAAW,YAAa,oBAAqB,gBAAiB,kBAAmB,SAAU,WAAY,WAAY,eAAgB,UAAW,cAAe,aAAc,WAAY,eAAgB,SAAU,kBAAmB,UAAW,gBAAiB,WAAY,SAAU,aAAc,cAAe,cAAe,cAAe,cAAe,cAAe,gBAAiB,SAAU,aAAc,cAAe,cAAe,QAAS,aAAc,iBAAkB,iBAAkB,YAAa,gBAAiB,cAAe,YAAa,WAAY,gBAAiB,eAAgB,iBAAkB,eAAgB,mBAAoB,QAAS,YAAa,SAAUC,EAASC,EAASykB,EAASogB,EAAaC,EAAUC,EAAeC,EAAcC,EAAgBC,EAAcC,EAAcC,EAAcrc,EAAiBkD,EAAUD,EAAaG,EAAakZ,EAAeC,EAASC,EAAYC,EAAgBjP,EAAkBzI,EAAS2X,EAAaC,EAAiBC,EAAYnV,EAAwBoV,EAA2BC,EAAaC,EAASC,EAAWC,EAAcC,EAAU3N,EAAU4N,EAAYzT,EAAQ0T,EAAaC,EAASC,EAAWC,EAAkBC,EAAWC,EAAQl0B,EAAOm0B,EAASC,EAAeC,EAAOC,EAAShb,EAAYH,EAAYob,EAAYC,EAAcC,EAAaC,EAAOlO,EAAavqB,EAAa04B,EAAqBC,GAAYC,GAAaC,GAASC,GAAWC,GAAmBC,GAAeC,GAAiB7N,GAAQlD,GAAUgR,GAAUC,GAAcC,GAASC,GAAap3B,GAAYq3B,GAAUC,GAAczR,GAAQ0R,GAAiBC,GAASC,GAAeC,GAAUC,GAAQC,GAAYC,GAAaC,GAAaC,GAAaC,GAAapK,GAAaqK,GAAeC,GAAQpS,GAAYqS,GAAaC,GAAaC,GAAOvI,GAAYwI,GAAgBh3B,GAAgBi3B,GAAWC,GAAeC,GAAaC,GAAW5G,GAAU6G,GAAeC,GAAcC,GAAgBC,GAAcC,GAAkB5E,GAAO6E,IAC5vF,aACAvpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQkjB,MAAQuB,EAAQvB,MACxBljB,EAAQ2kB,UAAYkgB,EAAYlgB,UAChC3kB,EAAQ4kB,OAASkgB,EAASlgB,OAC1B5kB,EAAQglB,YAAc+f,EAAc/f,YACpChlB,EAAQ8lB,WAAakf,EAAalf,WAClC9lB,EAAQ2mB,aAAese,EAAete,aACtC3mB,EAAQmnB,WAAa+d,EAAa/d,WAClCnnB,EAAQwnB,WAAa2d,EAAa3d,WAClCxnB,EAAQgpB,WAAaoc,EAAapc,WAClChpB,EAAQuoB,cAAgBQ,EAAgBR,cACxCvoB,EAAQoD,OAAS6oB,EAAS7oB,OAC1BpD,EAAQ6rB,UAAYG,EAAYH,UAChC7rB,EAAQksB,UAAYC,EAAYD,UAChClsB,EAAQosB,YAAciZ,EAAcjZ,YACpCpsB,EAAQoS,MAAQkzB,EAAQlzB,MACxBpS,EAAQ0sB,SAAW6Y,EAAW7Y,SAC9B1sB,EAAQ+sB,aAAeyY,EAAezY,aACtC/sB,EAAQstB,eAAiBiJ,EAAiBjJ,eAC1CttB,EAAQ6K,MAAQijB,EAAQjjB,MACxB7K,EAAQkuB,UAAYuX,EAAYvX,UAChCluB,EAAQmvB,cAAgBuW,EAAgBvW,cACxCnvB,EAAQ2vB,SAAWgW,EAAWhW,SAC9B3vB,EAAQkwB,qBAAuBM,EAAuBN,qBACtDlwB,EAAQywB,wBAA0BmV,EAA0BnV,wBAC5DzwB,EAAQ2wB,UAAYkV,EAAYlV,UAChC3wB,EAAQ8wB,MAAQgV,EAAQhV,MACxB9wB,EAAQkxB,QAAU6U,EAAU7U,QAC5BlxB,EAAQsxB,WAAa0U,EAAa1U,WAClCtxB,EAAQ2xB,OAASsU,EAAStU,OAC1B3xB,EAAQ4W,OAAS0hB,EAAS1hB,OAC1B5W,EAAQiyB,SAAWiU,EAAWjU,SAC9BjyB,EAAQqyB,KAAOI,EAAOJ,KACtBryB,EAAQ0yB,UAAYyT,EAAYzT,UAChC1yB,EAAQ4yB,MAAQwT,EAAQxT,MACxB5yB,EAAQ0zB,QAAU2S,EAAU3S,QAC5B1zB,EAAQ20B,eAAiB2R,EAAiB3R,eAC1C30B,EAAQ0tB,QAAU6Y,EAAU7Y,QAC5B1tB,EAAQg1B,KAAOwR,EAAOxR,KACtBh1B,EAAQoC,IAAMkQ,EAAMlQ,IACpBpC,EAAQm1B,MAAQsR,EAAQtR,MACxBn1B,EAAQs1B,YAAcoR,EAAcpR,YACpCt1B,EAAQuP,IAAMo3B,EAAMp3B,IACpBvP,EAAQ42B,MAAQgQ,EAAQhQ,MACxB52B,EAAQ2rB,SAAWC,EAAWD,SAC9B3rB,EAAQgrB,SAAWS,EAAWT,SAC9BhrB,EAAQypC,QAAU5C,EAAW7b,SAC7BhrB,EAAQ62B,WAAaiQ,EAAajQ,WAClC72B,EAAQg3B,UAAY+P,EAAY/P,UAChCh3B,EAAQm3B,IAAM6P,EAAM7P,IACpBn3B,EAAQq3B,UAAYyB,EAAYzB,UAChCr3B,EAAQ8N,UAAYS,EAAYT,UAChC9N,EAAQw3B,kBAAoByP,EAAoBzP,kBAChDx3B,EAAQ83B,SAAWoP,GAAWpP,SAC9B93B,EAAQu4B,UAAY4O,GAAY5O,UAChCv4B,EAAQw4B,MAAQ4O,GAAQ5O,MACxBx4B,EAAQ+4B,QAAUsO,GAAUtO,QAC5B/4B,EAAQi5B,gBAAkBqO,GAAkBrO,gBAC5Cj5B,EAAQm5B,YAAcoO,GAAcpO,YACpCn5B,EAAQq5B,cAAgBmO,GAAgBnO,cACxCr5B,EAAQu5B,KAAOI,GAAOJ,KACtBv5B,EAAQkD,OAASuzB,GAASvzB,OAC1BlD,EAAQ45B,OAAS6N,GAAS7N,OAC1B55B,EAAQ+5B,WAAa2N,GAAa3N,WAClC/5B,EAAQw6B,MAAQmN,GAAQnN,MACxBx6B,EAAQ26B,UAAYiN,GAAYjN,UAChC36B,EAAQ8P,SAAWU,GAAWV,SAC9B9P,EAAQ86B,OAAS+M,GAAS/M,OAC1B96B,EAAQk7B,WAAa4M,GAAa5M,WAClCl7B,EAAQy1B,KAAOY,GAAOZ,KACtBz1B,EAAQq7B,cAAgB0M,GAAgB1M,cACxCr7B,EAAQg8B,MAAQgM,GAAQhM,MACxBh8B,EAAQi8B,YAAcgM,GAAchM,YACpCj8B,EAAQo8B,OAAS8L,GAAS9L,OAC1Bp8B,EAAQ08B,KAAOyL,GAAOzL,KACtB18B,EAAQ68B,SAAWuL,GAAWvL,SAC9B78B,EAAQs9B,UAAY+K,GAAY/K,UAChCt9B,EAAQ09B,UAAY4K,GAAY5K,UAChC19B,EAAQ+9B,UAAYwK,GAAYxK,UAChC/9B,EAAQq+B,UAAYmK,GAAYnK,UAChCr+B,EAAQg+B,UAAYI,GAAYJ,UAChCh+B,EAAQs+B,YAAcmK,GAAcnK,YACpCt+B,EAAQ2+B,KAAO+J,GAAO/J,KACtB3+B,EAAQg2B,SAAWM,GAAWN,SAC9Bh2B,EAAQ8+B,UAAY6J,GAAY7J,UAChC9+B,EAAQi/B,UAAY2J,GAAY3J,UAChCj/B,EAAQs/B,IAAMuJ,GAAMvJ,IACpBt/B,EAAQ6/B,SAAWS,GAAWT,SAC9B7/B,EAAQugC,aAAeuI,GAAevI,aACtCvgC,EAAQuR,aAAeO,GAAeP,aACtCvR,EAAQoZ,QAAU2vB,GAAU3vB,QAC5BpZ,EAAQmhC,YAAc6H,GAAc7H,YACpCnhC,EAAQuS,UAAY02B,GAAY12B,UAChCvS,EAAQuhC,QAAU2H,GAAU3H,QAC5BvhC,EAAQK,OAASiiC,GAASjiC,OAC1BL,EAAQgiC,YAAcmH,GAAcnH,YACpChiC,EAAQ0O,WAAa06B,GAAa16B,WAClC1O,EAAQmjC,aAAekG,GAAelG,aACtCnjC,EAAQujC,WAAa+F,GAAa/F,WAClCvjC,EAAQ0jC,eAAiB6F,GAAiB7F,eAC1C1jC,EAAQgkC,IAAMW,GAAMX,IACpBhkC,EAAQ4kC,OAAS4E,GAAS5E,SAG9B9kC,OAAO,kBAAmB,wBAAyB,SAAU4pC,GAAQ,OAAOA,IAE5E5pC,OAAO,2CAA2C,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,sBAAuB,mBAAoB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAc1G,EAAYzB,EAAe43B,GAC3O,aA2PA,SAASjQ,EAAa/a,GAClB,IAAI/N,EAAQ+N,EAAI/N,MAAOmJ,EAAU4E,EAAI5E,QACrCA,EAAQtE,KAAK7E,GACbmJ,EAAQpE,WA7PZjF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIwpC,EAAyC,SAAU5nC,GAEnD,SAAS4nC,EAAwBC,EAAcniB,EAAUxJ,EAAMtX,EAAS8D,GACpE,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAMjC,OALAM,EAAM2nC,aAAeA,EACrB3nC,EAAMwlB,SAAWA,EACjBxlB,EAAMgc,KAAOA,EACbhc,EAAM0E,QAAUA,EAChB1E,EAAMwI,UAAYA,EACXxI,EAwOX,OAhPAJ,EAAQc,UAAUgnC,EAAyB5nC,GAsJ3C4nC,EAAwBxjC,OAAS,SAAU0jC,EAAMpiB,EAAUhd,GAEvD,YADiB,IAAbgd,IAAuBA,OAAWlc,GAC/B,WAEH,IAAK,IADD0S,KACKnW,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCmW,EAAKnW,GAAMlG,UAAUkG,GAEzB,OAAO,IAAI6hC,EAAwBE,EAAMpiB,EAAUxJ,EAAMtc,KAAM8I,KAGvEk/B,EAAwB/lC,UAAUyE,WAAa,SAAUjC,GACrD,IAAIwjC,EAAejoC,KAAKioC,aACpB3rB,EAAOtc,KAAKsc,KACZxT,EAAY9I,KAAK8I,UACjBnB,EAAU3H,KAAK2H,QACnB,GAAKmB,EAmCD,OAAOA,EAAUE,SAASg/B,EAAwB17B,SAAU,GAAKzF,OAAQ7G,KAAMyE,WAAYA,EAAYO,QAAShF,KAAKgF,UAlCrH,IAAK2C,EAAS,CACVA,EAAU3H,KAAK2H,QAAU,IAAI4vB,EAAe7uB,aAC5C,IAAI2T,EAAU,SAAS8rB,IAEnB,IAAK,IADDC,KACKjiC,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCiiC,EAAUjiC,GAAMlG,UAAUkG,GAE9B,IAAIU,EAASshC,EAAUthC,OACnBif,EAAWjf,EAAOif,SAAUne,EAAUd,EAAOc,QACjD,GAAIme,EAAU,CACV,IAAIuiB,EAAWjnC,EAAWvB,SAASimB,GAAU/lB,MAAMC,KAAMooC,GACrDC,IAAa1oC,EAAcF,YAC3BkI,EAAQrE,MAAM3D,EAAcF,YAAYC,IAGxCiI,EAAQtE,KAAKglC,GACb1gC,EAAQpE,iBAIZoE,EAAQtE,KAAK+kC,EAAU7oC,QAAU,EAAI6oC,EAAU,GAAKA,GACpDzgC,EAAQpE,YAIhB8Y,EAAQxV,OAAS7G,KACJoB,EAAWvB,SAASooC,GAAcloC,MAAMC,KAAKgF,QAASsX,EAAK7a,OAAO4a,MAChE1c,EAAcF,aACzBkI,EAAQrE,MAAM3D,EAAcF,YAAYC,GAGhD,OAAOiI,EAAQnB,UAAU/B,IAMjCujC,EAAwB17B,SAAW,SAAUrD,GACzC,IAAIrK,EAAOoB,KACP6G,EAASoC,EAAMpC,OAAQpC,EAAawE,EAAMxE,WAAYO,EAAUiE,EAAMjE,QACtEijC,EAAephC,EAAOohC,aAAc3rB,EAAOzV,EAAOyV,KAAMxT,EAAYjC,EAAOiC,UAC3EnB,EAAUd,EAAOc,QACrB,IAAKA,EAAS,CACVA,EAAUd,EAAOc,QAAU,IAAI4vB,EAAe7uB,aAC9C,IAAI2T,EAAU,SAAS8rB,IAEnB,IAAK,IADDC,KACKjiC,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCiiC,EAAUjiC,GAAMlG,UAAUkG,GAE9B,IAAIU,EAASshC,EAAUthC,OACnBif,EAAWjf,EAAOif,SAAUne,EAAUd,EAAOc,QACjD,GAAIme,EAAU,CACV,IAAIwiB,EAAWlnC,EAAWvB,SAASimB,GAAU/lB,MAAMC,KAAMooC,GACrDE,IAAa3oC,EAAcF,YAC3Bb,EAAK6D,IAAIqG,EAAUE,SA4B3C,SAAuBuD,GACnB,IAAI/L,EAAM+L,EAAI/L,IAAe+L,EAAI5E,QACzBrE,MAAM9C,IA9BiD,GAAKA,IAAKb,EAAcF,YAAYC,EAAGiI,QAASA,KAG3F/I,EAAK6D,IAAIqG,EAAUE,SAASse,EAAc,GAAK9oB,MAAO8pC,EAAU3gC,QAASA,SAG5E,CACD,IAAInJ,EAAQ4pC,EAAU7oC,QAAU,EAAI6oC,EAAU,GAAKA,EACnDxpC,EAAK6D,IAAIqG,EAAUE,SAASse,EAAc,GAAK9oB,MAAOA,EAAOmJ,QAASA,OAI9E0U,EAAQxV,OAASA,EACJzF,EAAWvB,SAASooC,GAAcloC,MAAMiF,EAASsX,EAAK7a,OAAO4a,MAC3D1c,EAAcF,aACzBkI,EAAQrE,MAAM3D,EAAcF,YAAYC,GAGhDd,EAAK6D,IAAIkF,EAAQnB,UAAU/B,KAExBujC,EAjPiC,CAkP1ClgC,EAAavB,YACflI,EAAQ2pC,wBAA0BA,IAYtC7pC,OAAO,gCAAgC,UAAW,UAAW,6BAA8B,SAAUC,EAASC,EAASkqC,GACnH,aACAjqC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQmqC,aAAeD,EAA0BP,wBAAwBxjC,SAG7ErG,OAAO,oCAAoC,UAAW,UAAW,mBAAoB,iCAAkC,SAAUC,EAASC,EAASyJ,EAAc2gC,GAC7J,aACAnqC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWiiC,aAAeC,EAAeD,eAG1DrqC,OAAO,+CAA+C,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,sBAAuB,mBAAoB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAc1G,EAAYzB,EAAe43B,GAC/O,aAsPA,SAASjQ,EAAa/a,GAClB,IAAI/N,EAAQ+N,EAAI/N,MAAOmJ,EAAU4E,EAAI5E,QACrCA,EAAQtE,KAAK7E,GACbmJ,EAAQpE,WAEZ,SAASmlC,EAAcn8B,GACnB,IAAI/L,EAAM+L,EAAI/L,IAAe+L,EAAI5E,QACzBrE,MAAM9C,GA5PlBlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAImqC,EAA6C,SAAUvoC,GAEvD,SAASuoC,EAA4BV,EAAcniB,EAAUxJ,EAAMtX,EAAS8D,GACxE,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAMjC,OALAM,EAAM2nC,aAAeA,EACrB3nC,EAAMwlB,SAAWA,EACjBxlB,EAAMgc,KAAOA,EACbhc,EAAM0E,QAAUA,EAChB1E,EAAMwI,UAAYA,EACXxI,EAyLX,OAjMAJ,EAAQc,UAAU2nC,EAA6BvoC,GAwI/CuoC,EAA4BnkC,OAAS,SAAU0jC,EAAMpiB,EAAUhd,GAE3D,YADiB,IAAbgd,IAAuBA,OAAWlc,GAC/B,WAEH,IAAK,IADD0S,KACKnW,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCmW,EAAKnW,GAAMlG,UAAUkG,GAEzB,OAAO,IAAIwiC,EAA4BT,EAAMpiB,EAAUxJ,EAAMtc,KAAM8I,KAG3E6/B,EAA4B1mC,UAAUyE,WAAa,SAAUjC,GACzD,IAAIwjC,EAAejoC,KAAKioC,aACpB3rB,EAAOtc,KAAKsc,KACZxT,EAAY9I,KAAK8I,UACjBnB,EAAU3H,KAAK2H,QACnB,GAAKmB,EAuCD,OAAOA,EAAUE,SAM7B,SAAkBC,GACd,IAAIrK,EAAOoB,KACP6G,EAASoC,EAAMpC,OAAQpC,EAAawE,EAAMxE,WAAYO,EAAUiE,EAAMjE,QAEtEsN,EAAKzL,EAAQohC,EAAe31B,EAAG21B,aAAc3rB,EAAOhK,EAAGgK,KAAMxT,EAAYwJ,EAAGxJ,UAC5EnB,EAAUd,EAAOc,QACrB,IAAKA,EAAS,CACVA,EAAUd,EAAOc,QAAU,IAAI4vB,EAAe7uB,aAC9C,IAAI2T,EAAU,SAAS8rB,IAEnB,IAAK,IADDC,KACKjiC,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCiiC,EAAUjiC,GAAMlG,UAAUkG,GAE9B,IAAIU,EAASshC,EAAUthC,OACnBif,EAAWjf,EAAOif,SAAUne,EAAUd,EAAOc,QAC7CnH,EAAM4nC,EAAUv9B,QACpB,GAAIrK,EACA5B,EAAK6D,IAAIqG,EAAUE,SAAS0/B,EAAe,GAAKloC,IAAKA,EAAKmH,QAASA,UAElE,GAAIme,EAAU,CACf,IAAIwiB,EAAWlnC,EAAWvB,SAASimB,GAAU/lB,MAAMC,KAAMooC,GACrDE,IAAa3oC,EAAcF,YAC3Bb,EAAK6D,IAAIqG,EAAUE,SAAS0/B,EAAe,GAAKloC,IAAKb,EAAcF,YAAYC,EAAGiI,QAASA,KAG3F/I,EAAK6D,IAAIqG,EAAUE,SAASse,EAAc,GAAK9oB,MAAO8pC,EAAU3gC,QAASA,SAG5E,CACD,IAAInJ,EAAQ4pC,EAAU7oC,QAAU,EAAI6oC,EAAU,GAAKA,EACnDxpC,EAAK6D,IAAIqG,EAAUE,SAASse,EAAc,GAAK9oB,MAAOA,EAAOmJ,QAASA,OAI9E0U,EAAQxV,OAASA,EACJzF,EAAWvB,SAASooC,GAAcloC,MAAMiF,EAASsX,EAAK7a,OAAO4a,MAC3D1c,EAAcF,aACzBb,EAAK6D,IAAIqG,EAAUE,SAAS0/B,EAAe,GAAKloC,IAAKb,EAAcF,YAAYC,EAAGiI,QAASA,KAGnG/I,EAAK6D,IAAIkF,EAAQnB,UAAU/B,KA9CiB,GAAKoC,OAAQ7G,KAAMyE,WAAYA,EAAYO,QAAShF,KAAKgF,UAtC7F,IAAK2C,EAAS,CACVA,EAAU3H,KAAK2H,QAAU,IAAI4vB,EAAe7uB,aAC5C,IAAI2T,EAAU,SAAS8rB,IAEnB,IAAK,IADDC,KACKjiC,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCiiC,EAAUjiC,GAAMlG,UAAUkG,GAE9B,IAAIU,EAASshC,EAAUthC,OACnBif,EAAWjf,EAAOif,SAAUne,EAAUd,EAAOc,QAC7CnH,EAAM4nC,EAAUv9B,QACpB,GAAIrK,EACAmH,EAAQrE,MAAM9C,QAEb,GAAIslB,EAAU,CACf,IAAIuiB,EAAWjnC,EAAWvB,SAASimB,GAAU/lB,MAAMC,KAAMooC,GACrDC,IAAa1oC,EAAcF,YAC3BkI,EAAQrE,MAAM3D,EAAcF,YAAYC,IAGxCiI,EAAQtE,KAAKglC,GACb1gC,EAAQpE,iBAIZoE,EAAQtE,KAAK+kC,EAAU7oC,QAAU,EAAI6oC,EAAU,GAAKA,GACpDzgC,EAAQpE,YAIhB8Y,EAAQxV,OAAS7G,KACJoB,EAAWvB,SAASooC,GAAcloC,MAAMC,KAAKgF,QAASsX,EAAK7a,OAAO4a,MAChE1c,EAAcF,aACzBkI,EAAQrE,MAAM3D,EAAcF,YAAYC,GAGhD,OAAOiI,EAAQnB,UAAU/B,IAM1BkkC,EAlMqC,CAmM9C7gC,EAAavB,YACflI,EAAQsqC,4BAA8BA,IAsD1CxqC,OAAO,oCAAoC,UAAW,UAAW,iCAAkC,SAAUC,EAASC,EAASuqC,GAC3H,aACAtqC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQwqC,iBAAmBD,EAA8BD,4BAA4BnkC,SAGzFrG,OAAO,wCAAwC,UAAW,UAAW,mBAAoB,qCAAsC,SAAUC,EAASC,EAASyJ,EAAcghC,GACrK,aACAxqC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWsiC,iBAAmBC,EAAmBD,mBAGlE1qC,OAAO,iCAAiC,UAAW,UAAW,sBAAuB,kBAAmB,oBAAqB,8BAA+B,SAAUC,EAASC,EAASikB,EAAerhB,EAAWylB,EAAmBU,GACjO,aACA9oB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkItDH,EAAQuoB,cApBR,WAEI,IAAK,IADDC,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,IAAIiK,EAAU,KACVtH,EAAY,KAYhB,OAXIwZ,EAAcJ,YAAY2E,EAAYA,EAAYtnB,OAAS,MAC3DuJ,EAAY+d,EAAYJ,OAEuB,mBAAxCI,EAAYA,EAAYtnB,OAAS,KACxC6Q,EAAUyW,EAAYJ,OAIC,IAAvBI,EAAYtnB,QAAgB0B,EAAU5B,QAAQwnB,EAAY,MAC1DA,EAAcA,EAAY,IAEvB,IAAIH,EAAkBH,gBAAgBM,EAAa/d,GAAWnC,KAAK,IAAIygB,EAAgBN,sBAAsB1W,OAK5HjS,OAAO,qCAAqC,UAAW,UAAW,mBAAoB,kCAAmC,SAAUC,EAASC,EAASyJ,EAAcsf,GAC/J,aACA9oB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWqgB,cAAgBQ,EAAgBR,gBAG5DzoB,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAcwiB,GACjJ,aACAhsB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW9E,OAAS6oB,EAAS7oB,SAG9CtD,OAAO,mCAAmC,UAAW,UAAW,QAAS,gBAAiB,4BAA6B,sBAAuB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcwZ,EAAqBD,GAClN,aACA/iB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIuqC,EAAiC,SAAU3oC,GAE3C,SAAS2oC,EAAgBC,GACrB,IAAI1oC,EAAQF,EAAOG,KAAKP,OAASA,KAEjC,OADAM,EAAM0oC,kBAAoBA,EACnB1oC,EAsDX,OA1DAJ,EAAQc,UAAU+nC,EAAiB3oC,GAoDnC2oC,EAAgBvkC,OAAS,SAAUwkC,GAC/B,OAAO,IAAID,EAAgBC,IAE/BD,EAAgB9mC,UAAUyE,WAAa,SAAUjC,GAC7C,OAAO,IAAIwkC,EAAgBxkC,EAAYzE,KAAKgpC,oBAEzCD,EA3DyB,CA4DlCjhC,EAAavB,YACflI,EAAQ0qC,gBAAkBA,EAC1B,IAAIE,EAAiC,SAAU7oC,GAE3C,SAAS6oC,EAAgB3kC,EAAa4kC,GAClC,IAAI5oC,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAG9C,OAFAM,EAAM4oC,QAAUA,EAChB5oC,EAAM6oC,WACC7oC,EAgBX,OArBAJ,EAAQc,UAAUioC,EAAiB7oC,GAOnC6oC,EAAgBhnC,UAAUknC,SAAW,WACjC,IACInpC,KAAKopC,eAET,MAAO5oC,GACHR,KAAK2E,OAAOnE,KAGpByoC,EAAgBhnC,UAAUmnC,aAAe,WACrC,IAAI14B,EAAS1Q,KAAKkpC,UACdx4B,GACA1Q,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAM0Q,KAGtDu4B,EAtByB,CAuBlC5nB,EAAkBtB,mBAGxB5hB,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASgrC,GACpG,aACA/qC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQirC,MAAQD,EAAkBN,gBAAgBvkC,SAGtDrG,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcyhC,GAC/I,aACAjrC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW+iC,MAAQC,EAAQD,QAG5CnrC,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASioB,GACpG,aACAhoB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ+E,MAAQkjB,EAAkBF,gBAAgB5hB,SAGtDrG,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAc0hC,GAC/I,aACAlrC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWnD,MAAQomC,EAAQpmC,QAG5CjF,OAAO,sCAAsC,UAAW,UAAW,QAAS,gBAAiB,oBAAqB,kBAAmB,4BAA6B,sBAAuB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcwe,EAAmBrlB,EAAWqgB,EAAqBD,GAC3R,aACA/iB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIirC,EAAoC,SAAUrpC,GAE9C,SAASqpC,EAAmBC,EAASpgB,GACjC,IAAIhpB,EAAQF,EAAOG,KAAKP,OAASA,KAGjC,OAFAM,EAAMopC,QAAUA,EAChBppC,EAAMgpB,eAAiBA,EAChBhpB,EA6HX,OAlIAJ,EAAQc,UAAUyoC,EAAoBrpC,GAyGtCqpC,EAAmBjlC,OAAS,WAExB,IAAK,IADDklC,KACKvjC,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCujC,EAAQvjC,GAAMlG,UAAUkG,GAE5B,GAAgB,OAAZujC,GAAyC,IAArBzpC,UAAUV,OAC9B,OAAO,IAAI+mB,EAAkBF,gBAEjC,IAAIkD,EAAiB,KASrB,MAR2C,mBAAhCogB,EAAQA,EAAQnqC,OAAS,KAChC+pB,EAAiBogB,EAAQjjB,OAIN,IAAnBijB,EAAQnqC,QAAgB0B,EAAU5B,QAAQqqC,EAAQ,MAClDA,EAAUA,EAAQ,IAEC,IAAnBA,EAAQnqC,OACD,IAAI+mB,EAAkBF,gBAE1B,IAAIqjB,EAAmBC,EAASpgB,IAE3CmgB,EAAmBxnC,UAAUyE,WAAa,SAAUjC,GAChD,OAAO,IAAIklC,EAAmBllC,EAAYzE,KAAK0pC,QAAS1pC,KAAKspB,iBAE1DmgB,EAnI4B,CAoIrC3hC,EAAavB,YACflI,EAAQorC,mBAAqBA,EAM7B,IAAIE,EAAoC,SAAUvpC,GAE9C,SAASupC,EAAmBrlC,EAAaolC,EAASpgB,GAC9C,IAAIhpB,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAC9CM,EAAMopC,QAAUA,EAChBppC,EAAMgpB,eAAiBA,EACvBhpB,EAAMusB,UAAY,EAClBvsB,EAAMspC,WAAa,EACnB,IAAIxnC,EAAMsnC,EAAQnqC,OAClBe,EAAMi0B,MAAQnyB,EACd9B,EAAMwT,OAAS,IAAIxU,MAAM8C,GACzB,IAAK,IAAI1B,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAImG,EAAS6iC,EAAQhpC,GACjBmhB,EAAoBP,EAAoBN,kBAAkB1gB,EAAOuG,EAAQ,KAAMnG,GAC/EmhB,IACAA,EAAkB1B,WAAazf,EAC/BJ,EAAMmC,IAAIof,IAGlB,OAAOvhB,EA2BX,OA7CAJ,EAAQc,UAAU2oC,EAAoBvpC,GAoBtCupC,EAAmB1nC,UAAU+d,WAAa,SAAUC,EAAYC,EAAYC,EAAYC,EAAYC,GAChGrgB,KAAK8T,OAAOqM,GAAcD,EACrBG,EAASwpB,YACVxpB,EAASwpB,WAAY,EACrB7pC,KAAK4pC,eAGbD,EAAmB1nC,UAAUse,eAAiB,SAAUF,GACpD,IAAI/b,EAActE,KAAKsE,YACRslC,EAAN5pC,KAAsB4pC,WAAYtgB,EAAlCtpB,KAAsDspB,eAAgBxV,EAAtE9T,KAAkF8T,OACvF1R,EAAM0R,EAAOvU,OACjB,GAAK8gB,EAASwpB,WAKd,GADA7pC,KAAK6sB,YACD7sB,KAAK6sB,YAAczqB,EAAvB,CAGA,GAAIwnC,IAAexnC,EAAK,CACpB,IAAI5D,EAAQ8qB,EAAiBA,EAAevpB,MAAMC,KAAM8T,GAAUA,EAClExP,EAAYjB,KAAK7E,GAErB8F,EAAYf,iBAXRe,EAAYf,YAabomC,EA9C4B,CA+CrCtoB,EAAkBtB,mBAGxB5hB,OAAO,4BAA4B,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAASyrC,GAC1G,aACAxrC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ0rC,SAAWD,EAAqBL,mBAAmBjlC,SAG/DrG,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAckiC,GACrJ,aACA1rC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWwjC,SAAWC,EAAWD,WAGlD5rC,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAcsiB,GAC7I,aACA9rB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW6iB,KAAOgB,EAAOhB,OAG1CjrB,OAAO,uCAAuC,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,qBAAsB,sBAAuB,mBAAoB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAc1G,EAAYD,EAAcxB,EAAekE,GAC3Q,aACAvF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAImC,EAAWrC,OAAO2D,UAAUtB,SAqB5BspC,EAAqC,SAAU7pC,GAE/C,SAAS6pC,EAAoBC,EAAWC,EAAWrkB,EAAUskB,GACzD,IAAI9pC,EAAQF,EAAOG,KAAKP,OAASA,KAKjC,OAJAM,EAAM4pC,UAAYA,EAClB5pC,EAAM6pC,UAAYA,EAClB7pC,EAAMwlB,SAAWA,EACjBxlB,EAAM8pC,QAAUA,EACT9pC,EA6KX,OApLAJ,EAAQc,UAAUipC,EAAqB7pC,GA8HvC6pC,EAAoBzlC,OAAS,SAAU6lC,EAAQF,EAAWC,EAAStkB,GAK/D,OAJI3kB,EAAahC,WAAWirC,KACxBtkB,EAAWskB,EACXA,OAAUxgC,GAEP,IAAIqgC,EAAoBI,EAAQF,EAAWrkB,EAAUskB,IAEhEH,EAAoBK,kBAAoB,SAAUJ,EAAWC,EAAW9tB,EAAS5X,EAAY2lC,GACzF,IAAIzoC,EACJ,GAtJR,SAAoBuoC,GAChB,QAASA,GAA0C,sBAA7BvpC,EAASJ,KAAK2pC,GAqJ5BK,CAAWL,IAnJvB,SAA0BA,GACtB,QAASA,GAA0C,4BAA7BvpC,EAASJ,KAAK2pC,GAkJHM,CAAiBN,GAC1C,IAAK,IAAIxpC,EAAI,EAAG0B,EAAM8nC,EAAU3qC,OAAQmB,EAAI0B,EAAK1B,IAC7CupC,EAAoBK,kBAAkBJ,EAAUxpC,GAAIypC,EAAW9tB,EAAS5X,EAAY2lC,QAGvF,GArJb,SAAuBF,GACnB,QAASA,GAAmD,mBAA/BA,EAAUjtB,kBAA4E,mBAAlCitB,EAAUO,oBAoJ9EC,CAAcR,GAAY,CAC/B,IAAIS,EAAWT,EACfA,EAAUjtB,iBAAiBktB,EAAW9tB,EAAS+tB,GAC/CzoC,EAAc,WAAc,OAAOgpC,EAASF,oBAAoBN,EAAW9tB,SAE1E,GAnKb,SAAmC6tB,GAC/B,QAASA,GAAqC,mBAAjBA,EAAUU,IAA8C,mBAAlBV,EAAUW,IAkKhEC,CAA0BZ,GAAY,CAC3C,IAAIa,EAAWb,EACfA,EAAUU,GAAGT,EAAW9tB,GACxB1a,EAAc,WAAc,OAAOopC,EAASF,IAAIV,EAAW9tB,QAE1D,CAAA,IA3Kb,SAAiC6tB,GAC7B,QAASA,GAA8C,mBAA1BA,EAAUc,aAAkE,mBAA7Bd,EAAUe,eA0KzEC,CAAwBhB,GAM7B,MAAM,IAAI55B,UAAU,wBALpB,IAAI66B,EAAWjB,EACfA,EAAUc,YAAYb,EAAW9tB,GACjC1a,EAAc,WAAc,OAAOwpC,EAASF,eAAed,EAAW9tB,IAK1E5X,EAAWhC,IAAI,IAAIoB,EAAenC,aAAaC,KAEnDsoC,EAAoBhoC,UAAUyE,WAAa,SAAUjC,GACjD,IAAIylC,EAAYlqC,KAAKkqC,UACjBC,EAAYnqC,KAAKmqC,UACjBC,EAAUpqC,KAAKoqC,QACftkB,EAAW9lB,KAAK8lB,SAcpBmkB,EAAoBK,kBAAkBJ,EAAWC,EAbnCrkB,EAAW,WAErB,IAAK,IADDxJ,KACKnW,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCmW,EAAKnW,GAAMlG,UAAUkG,GAEzB,IAAIuK,EAAStP,EAAWvB,SAASimB,GAAU/lB,WAAM,EAAQuc,GACrD5L,IAAW/Q,EAAcF,YACzBgF,EAAWnB,MAAM3D,EAAcF,YAAYC,GAG3C+E,EAAWpB,KAAKqN,IAEpB,SAAUhR,GAAK,OAAO+E,EAAWpB,KAAK3D,IAC2B+E,EAAY2lC,IAE9EH,EArL6B,CAsLtCniC,EAAavB,YACflI,EAAQ4rC,oBAAsBA,IAGlC9rC,OAAO,6BAA6B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAAS+sC,GAC5G,aACA9sC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQgtC,UAAYD,EAAsBnB,oBAAoBzlC,SAGlErG,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAcwjC,GACvJ,aACAhtC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW8kC,UAAYC,EAAYD,YAGpDltC,OAAO,8CAA8C,UAAW,UAAW,QAAS,qBAAsB,gBAAiB,mBAAoB,SAAUC,EAASC,EAAS6B,EAASiB,EAAc2G,EAAcjE,GAC5M,aACAvF,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI+sC,EAA4C,SAAUnrC,GAEtD,SAASmrC,EAA2BC,EAAYC,EAAe3lB,GAC3D,IAAIxlB,EAAQF,EAAOG,KAAKP,OAASA,KAIjC,OAHAM,EAAMkrC,WAAaA,EACnBlrC,EAAMmrC,cAAgBA,EACtBnrC,EAAMwlB,SAAWA,EACVxlB,EAyFX,OA/FAJ,EAAQc,UAAUuqC,EAA4BnrC,GAwD9CmrC,EAA2B/mC,OAAS,SAAUgnC,EAAYC,EAAe3lB,GACrE,OAAO,IAAIylB,EAA2BC,EAAYC,EAAe3lB,IAErEylB,EAA2BtpC,UAAUyE,WAAa,SAAUjC,GACxD,IAAInE,EAAQN,KACRyrC,EAAgBzrC,KAAKyrC,cACrBpvB,EAAYrc,KAAK8lB,SAAW,WAE5B,IAAK,IADDxJ,KACKnW,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCmW,EAAKnW,GAAMlG,UAAUkG,GAEzB7F,EAAMorC,cAAcjnC,EAAY6X,IAChC,SAAU5c,GAAK+E,EAAWpB,KAAK3D,IAC/BisC,EAAW3rC,KAAK4rC,gBAAgBvvB,EAAS5X,GACxCtD,EAAahC,WAAWssC,IAG7BhnC,EAAWhC,IAAI,IAAIoB,EAAenC,aAAa,WAE3C+pC,EAAcpvB,EAASsvB,OAG/BJ,EAA2BtpC,UAAUypC,cAAgB,SAAUjnC,EAAY6X,GACvE,IACI,IAAI5L,EAAS1Q,KAAK8lB,SAAS/lB,MAAMC,KAAMsc,GACvC7X,EAAWpB,KAAKqN,GAEpB,MAAOhR,GACH+E,EAAWnB,MAAM5D,KAGzB6rC,EAA2BtpC,UAAU2pC,gBAAkB,SAAUvvB,EAASwvB,GACtE,IACI,OAAO7rC,KAAKwrC,WAAWnvB,IAAY,KAEvC,MAAO3c,GACHmsC,EAAgBvoC,MAAM5D,KAGvB6rC,EAhGoC,CAiG7CzjC,EAAavB,YACflI,EAAQktC,2BAA6BA,IAGzCptC,OAAO,oCAAoC,UAAW,UAAW,gCAAiC,SAAUC,EAASC,EAASytC,GAC1H,aACAxtC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ0tC,iBAAmBD,EAA6BP,2BAA2B/mC,SAGvFrG,OAAO,wCAAwC,UAAW,UAAW,mBAAoB,qCAAsC,SAAUC,EAASC,EAASyJ,EAAckkC,GACrK,aACA1tC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWwlC,iBAAmBC,EAAmBD,mBAGlE5tC,OAAO,+BAA+B,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASyqB,GAC5G,aACAxqB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ4tC,YAAcnjB,EAAoBvB,kBAAkB/iB,SAGhErG,OAAO,mCAAmC,UAAW,UAAW,mBAAoB,gCAAiC,SAAUC,EAASC,EAASyJ,EAAcokC,GAC3J,aACA5tC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW0lC,YAAcC,EAAcD,cAGxD9tC,OAAO,sCAAsC,UAAW,UAAW,QAAS,gBAAiB,uBAAwB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcwa,GACpK,aACAhkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtD,IAAI2tC,EAAe,SAAU3tC,GAAS,OAAOA,GAMzC4tC,EAAoC,SAAUhsC,GAE9C,SAASgsC,EAAmBC,EAAcC,EAAWC,EAASjjB,EAAgBxgB,GAC1E,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAMjC,OALAM,EAAM+rC,aAAeA,EACrB/rC,EAAMgsC,UAAYA,EAClBhsC,EAAMisC,QAAUA,EAChBjsC,EAAMgpB,eAAiBA,EACvBhpB,EAAMwI,UAAYA,EACXxI,EA8GX,OAtHAJ,EAAQc,UAAUorC,EAAoBhsC,GAUtCgsC,EAAmB5nC,OAAS,SAAUgoC,EAAuBF,EAAWC,EAASE,EAA4B3jC,GACzG,OAAwB,GAApB7I,UAAUV,OACH,IAAI6sC,EAAmBI,EAAsBH,aAAcG,EAAsBF,UAAWE,EAAsBD,QAASC,EAAsBljB,gBAAkB6iB,EAAcK,EAAsB1jC,gBAE/Kc,IAA/B6iC,GAA4CnqB,EAAcJ,YAAYuqB,GAC/D,IAAIL,EAAmBI,EAAuBF,EAAWC,EAASJ,EAAcM,GAEpF,IAAIL,EAAmBI,EAAuBF,EAAWC,EAASE,EAA4B3jC,IAEzGsjC,EAAmBnqC,UAAUyE,WAAa,SAAUjC,GAChD,IAAIwE,EAAQjJ,KAAKqsC,aACjB,GAAIrsC,KAAK8I,UACL,OAAO9I,KAAK8I,UAAUE,SAASojC,EAAmB9/B,SAAU,GACxD7H,WAAYA,EACZ8nC,QAASvsC,KAAKusC,QACdD,UAAWtsC,KAAKssC,UAChBhjB,eAAgBtpB,KAAKspB,eACrBrgB,MAAOA,IAIf,IADA,IAAeqjC,EAANtsC,KAAqBssC,UAAWhjB,EAAhCtpB,KAAoDspB,eAAgBijB,EAApEvsC,KAAiFusC,UACvF,CACC,GAAID,EAAW,CACX,IAAII,OAAkB,EACtB,IACIA,EAAkBJ,EAAUrjC,GAEhC,MAAOzI,GAEH,YADAiE,EAAWnB,MAAM9C,GAGrB,IAAKksC,EAAiB,CAClBjoC,EAAWlB,WACX,OAGR,IAAI/E,OAAQ,EACZ,IACIA,EAAQ8qB,EAAergB,GAE3B,MAAOzI,GAEH,YADAiE,EAAWnB,MAAM9C,GAIrB,GADAiE,EAAWpB,KAAK7E,GACZiG,EAAW7C,OACX,MAEJ,IACIqH,EAAQsjC,EAAQtjC,GAEpB,MAAOzI,GAEH,YADAiE,EAAWnB,MAAM9C,MAK7B4rC,EAAmB9/B,SAAW,SAAUrD,GACpC,IAAIxE,EAAawE,EAAMxE,WAAY6nC,EAAYrjC,EAAMqjC,UACrD,IAAI7nC,EAAW7C,OAAf,CAGA,GAAIqH,EAAM0jC,YACN,IACI1jC,EAAMA,MAAQA,EAAMsjC,QAAQtjC,EAAMA,OAEtC,MAAOzI,GAEH,YADAiE,EAAWnB,MAAM9C,QAKrByI,EAAM0jC,aAAc,EAExB,GAAIL,EAAW,CACX,IAAII,OAAkB,EACtB,IACIA,EAAkBJ,EAAUrjC,EAAMA,OAEtC,MAAOzI,GAEH,YADAiE,EAAWnB,MAAM9C,GAGrB,IAAKksC,EAED,YADAjoC,EAAWlB,WAGf,GAAIkB,EAAW7C,OACX,OAGR,IAAIpD,EACJ,IACIA,EAAQyK,EAAMqgB,eAAergB,EAAMA,OAEvC,MAAOzI,GAEH,YADAiE,EAAWnB,MAAM9C,GAGrB,IAAIiE,EAAW7C,SAGf6C,EAAWpB,KAAK7E,IACZiG,EAAW7C,QAGf,OAAO5B,KAAKgJ,SAASC,KAElBmjC,EAvH4B,CAwHrCtkC,EAAavB,YACflI,EAAQ+tC,mBAAqBA,IAGjCjuC,OAAO,4BAA4B,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAASuuC,GAC1G,aACAtuC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQwuC,SAAWD,EAAqBR,mBAAmB5nC,SAG/DrG,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAcglC,GACrJ,aACAxuC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWsmC,SAAWC,EAAWD,WAGlD1uC,OAAO,gCAAgC,UAAW,UAAW,QAAS,gBAAiB,4BAA6B,sBAAuB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcwZ,EAAqBD,GAC/M,aACA/iB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIuuC,EAA8B,SAAU3sC,GAExC,SAAS2sC,EAAaT,EAAWU,EAAYC,GACzC,IAAI3sC,EAAQF,EAAOG,KAAKP,OAASA,KAIjC,OAHAM,EAAMgsC,UAAYA,EAClBhsC,EAAM0sC,WAAaA,EACnB1sC,EAAM2sC,WAAaA,EACZ3sC,EASX,OAfAJ,EAAQc,UAAU+rC,EAAc3sC,GAQhC2sC,EAAavoC,OAAS,SAAU8nC,EAAWU,EAAYC,GACnD,OAAO,IAAIF,EAAaT,EAAWU,EAAYC,IAEnDF,EAAa9qC,UAAUyE,WAAa,SAAUjC,GAC1C,IAAe6nC,EAANtsC,KAAqBssC,UAAWU,EAAhChtC,KAAgDgtC,WAAYC,EAA5DjtC,KAA4EitC,WACrF,OAAO,IAAIC,EAAazoC,EAAY6nC,EAAWU,EAAYC,IAExDF,EAhBsB,CAiB/BjlC,EAAavB,YACflI,EAAQ0uC,aAAeA,EACvB,IAAIG,EAA8B,SAAU9sC,GAExC,SAAS8sC,EAAa5oC,EAAagoC,EAAWU,EAAYC,GACtD,IAAI3sC,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMgsC,UAAYA,EAClBhsC,EAAM0sC,WAAaA,EACnB1sC,EAAM2sC,WAAaA,EACnB3sC,EAAM6sC,QACC7sC,EAmBX,OA1BAJ,EAAQc,UAAUksC,EAAc9sC,GAShC8sC,EAAajrC,UAAUkrC,MAAQ,WAC3B,IACIz8B,EADW47B,EAANtsC,KAAqBssC,UAAWU,EAAhChtC,KAAgDgtC,WAAYC,EAA5DjtC,KAA4EitC,WAErF,IAEI,IAAIpmC,GADJ6J,EAAS47B,KACaU,EAAaC,EAC/BpmC,EACA7G,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAM6G,IAGrD7G,KAAK4E,YAGb,MAAOpE,GACHR,KAAK2E,OAAOnE,KAGb0sC,EA3BsB,CA4B/B7rB,EAAkBtB,mBAGxB5hB,OAAO,sBAAsB,UAAW,UAAW,kBAAmB,SAAUC,EAASC,EAAS+uC,GAC9F,aACA9uC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQgvC,IAAMD,EAAeL,aAAavoC,SAG9CrG,OAAO,0BAA0B,UAAW,UAAW,mBAAoB,uBAAwB,SAAUC,EAASC,EAASyJ,EAAcwlC,GACzI,aACAhvC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWgnC,GAAKD,EAAKD,MAGtClvC,OAAO,sCAAsC,UAAW,UAAW,QAAS,oBAAqB,gBAAiB,sBAAuB,SAAUC,EAASC,EAAS6B,EAASmiB,EAAava,EAAc6H,GACrM,aACArR,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIgvC,EAAoC,SAAUptC,GAE9C,SAASotC,EAAmB9qB,EAAQ5Z,QACjB,IAAX4Z,IAAqBA,EAAS,QAChB,IAAd5Z,IAAwBA,EAAY6G,EAAQD,OAChD,IAAIpP,EAAQF,EAAOG,KAAKP,OAASA,KASjC,OARAM,EAAMoiB,OAASA,EACfpiB,EAAMwI,UAAYA,IACbuZ,EAAYN,UAAUW,IAAWA,EAAS,KAC3CpiB,EAAMoiB,OAAS,GAEd5Z,GAA2C,mBAAvBA,EAAUE,WAC/B1I,EAAMwI,UAAY6G,EAAQD,OAEvBpP,EAyDX,OAtEAJ,EAAQc,UAAUwsC,EAAoBptC,GAgDtCotC,EAAmBhpC,OAAS,SAAUke,EAAQ5Z,GAG1C,YAFe,IAAX4Z,IAAqBA,EAAS,QAChB,IAAd5Z,IAAwBA,EAAY6G,EAAQD,OACzC,IAAI89B,EAAmB9qB,EAAQ5Z,IAE1C0kC,EAAmBlhC,SAAW,SAAUrD,GACpC,IAAI9G,EAAQ8G,EAAM9G,MAAOsC,EAAawE,EAAMxE,WAAYie,EAASzZ,EAAMyZ,OACvEje,EAAWpB,KAAKlB,GACZsC,EAAW7C,SAGfqH,EAAM9G,OAAS,EACfnC,KAAKgJ,SAASC,EAAOyZ,KAEzB8qB,EAAmBvrC,UAAUyE,WAAa,SAAUjC,GAChD,IACIie,EAAS1iB,KAAK0iB,OACd5Z,EAAY9I,KAAK8I,UACrBrE,EAAWhC,IAAIqG,EAAUE,SAASwkC,EAAmBlhC,SAAUoW,GAC3DvgB,MAJQ,EAIMsC,WAAYA,EAAYie,OAAQA,MAG/C8qB,EAvE4B,CAwErC1lC,EAAavB,YACflI,EAAQmvC,mBAAqBA,IAGjCrvC,OAAO,4BAA4B,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAASovC,GAC1G,aACAnvC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ0R,SAAW09B,EAAqBD,mBAAmBhpC,SAG/DrG,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAc4lC,GACrJ,aACApvC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWwJ,SAAW29B,EAAW39B,WAGlD5R,OAAO,uBAAuB,UAAW,UAAW,qBAAsB,sBAAuB,SAAUC,EAASC,EAAS4mC,EAAS0I,GAClI,aACArvC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ22B,YAAc2Y,EAAQ3Y,YAuD9B32B,EAAQ42B,MAPR,WAEI,IAAK,IADDpO,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAO8+B,EAAQhQ,MAAMl1B,WAAM,EAAQ8mB,EAA5Boe,CAAyCjlC,SAKxD7B,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAAS4mC,GACpG,aACA3mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ42B,MAAQgQ,EAAQjQ,cAG5B72B,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcm9B,GAC/I,aACA3mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW0uB,MAAQgQ,EAAQhQ,QAG5C92B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAckwB,GAC7I,aACA15B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWqxB,KAAOI,EAAOJ,OAG1Cz5B,OAAO,mCAAmC,UAAW,UAAW,QAAS,gBAAiB,gBAAiB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcjC,GAC1J,aACAvH,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIovC,EAAiC,SAAUxtC,GAE3C,SAASwtC,IACL,OAAOxtC,EAAOG,KAAKP,OAASA,KAuChC,OAzCAE,EAAQc,UAAU4sC,EAAiBxtC,GAmCnCwtC,EAAgBppC,OAAS,WACrB,OAAO,IAAIopC,GAEfA,EAAgB3rC,UAAUyE,WAAa,SAAUjC,GAC7CoB,EAAOD,QAEJgoC,EA1CyB,CA2ClC9lC,EAAavB,YACflI,EAAQuvC,gBAAkBA,IAG9BzvC,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASwvC,GACpG,aACAvvC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQyvC,MAAQD,EAAkBD,gBAAgBppC,SAGtDrG,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcimC,GAC/I,aACAzvC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWunC,MAAQC,EAAQD,QAG5C3vC,OAAO,0BAA0B,UAAW,UAAW,mBAAoB,uBAAwB,SAAUC,EAASC,EAASyJ,EAAcqiB,GACzI,aACA7rB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWoF,GAAKwe,EAAKxe,KAGtCxN,OAAO,qCAAqC,UAAW,UAAW,kCAAmC,SAAUC,EAASC,EAASinC,GAC7H,aACAhnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQw3B,kBAAoByP,EAAoBtP,0BAGpD73B,OAAO,yCAAyC,UAAW,UAAW,mBAAoB,sCAAuC,SAAUC,EAASC,EAASyJ,EAAcw9B,GACvK,aACAhnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWsvB,kBAAoByP,EAAoBzP,oBAGpE13B,OAAO,mCAAmC,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAAS4H,GAC5H,aACAxJ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiBtD,IAAIwvC,EAAiC,SAAU5tC,GAE3C,SAAS4tC,EAAgBtmB,EAAK5e,GAC1B,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAIjC,OAHAM,EAAMonB,IAAMA,EACZpnB,EAAMwI,UAAYA,EAClBxI,EAAM0Y,KAAO1a,OAAO0a,KAAK0O,GAClBpnB,EAoDX,OA1DAJ,EAAQc,UAAUgtC,EAAiB5tC,GAuCnC4tC,EAAgBxpC,OAAS,SAAUkjB,EAAK5e,GACpC,OAAO,IAAIklC,EAAgBtmB,EAAK5e,IAEpCklC,EAAgB/rC,UAAUyE,WAAa,SAAUjC,GAC7C,IAAeuU,EAANhZ,KAAgBgZ,KAAMlQ,EAAtB9I,KAAqC8I,UAC1CvJ,EAASyZ,EAAKzZ,OAClB,GAAIuJ,EACA,OAAOA,EAAUE,SA/D7B,SAAkBC,GACd,IAAIye,EAAMze,EAAMye,IAAK1O,EAAO/P,EAAM+P,KAAMzZ,EAAS0J,EAAM1J,OAAQ4C,EAAQ8G,EAAM9G,MAAOsC,EAAawE,EAAMxE,WACvG,GAAItC,IAAU5C,EAAd,CAIA,IAAI0Z,EAAMD,EAAK7W,GACfsC,EAAWpB,MAAM4V,EAAKyO,EAAIzO,KAC1BhQ,EAAM9G,MAAQA,EAAQ,EACtBnC,KAAKgJ,SAASC,QANVxE,EAAWlB,YA4D6B,GAChCmkB,IAAK1nB,KAAK0nB,IAAK1O,KAAMA,EAAMzZ,OAAQA,EAAQ4C,MAAO,EAAGsC,WAAYA,IAIrE,IAAK,IAAIujB,EAAM,EAAGA,EAAMzoB,EAAQyoB,IAAO,CACnC,IAAI/O,EAAMD,EAAKgP,GACfvjB,EAAWpB,MAAM4V,EAAKjZ,KAAK0nB,IAAIzO,KAEnCxU,EAAWlB,YAGZyqC,EA3DyB,CA4DlClmC,EAAavB,YACflI,EAAQ2vC,gBAAkBA,IAG9B7vC,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAAS4vC,GACpG,aACA3vC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ6vC,MAAQD,EAAkBD,gBAAgBxpC,SAGtDrG,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcqmC,GAC/I,aACA7vC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW2nC,MAAQC,EAAQD,QAG5C/vC,OAAO,mCAAmC,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAAS4H,GAC5H,aACAxJ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAI4vC,EAAiC,SAAUhuC,GAE3C,SAASguC,EAAgBC,EAAO59B,EAAO3H,GACnC,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAIjC,OAHAM,EAAM+tC,MAAQA,EACd/tC,EAAMg7B,OAAS7qB,EACfnQ,EAAMwI,UAAYA,EACXxI,EA0EX,OAhFAJ,EAAQc,UAAUotC,EAAiBhuC,GAsCnCguC,EAAgB5pC,OAAS,SAAU6pC,EAAO59B,EAAO3H,GAG7C,YAFc,IAAVulC,IAAoBA,EAAQ,QAClB,IAAV59B,IAAoBA,EAAQ,GACzB,IAAI29B,EAAgBC,EAAO59B,EAAO3H,IAE7CslC,EAAgB9hC,SAAW,SAAUrD,GACjC,IAAIolC,EAAQplC,EAAMolC,MAAOlsC,EAAQ8G,EAAM9G,MAAOsO,EAAQxH,EAAMwH,MAAOhM,EAAawE,EAAMxE,WAClFtC,GAASsO,EACThM,EAAWlB,YAGfkB,EAAWpB,KAAKgrC,GACZ5pC,EAAW7C,SAGfqH,EAAM9G,MAAQA,EAAQ,EACtB8G,EAAMolC,MAAQA,EAAQ,EACtBruC,KAAKgJ,SAASC,MAElBmlC,EAAgBnsC,UAAUyE,WAAa,SAAUjC,GAC7C,IAAItC,EAAQ,EACRksC,EAAQruC,KAAKquC,MACb59B,EAAQzQ,KAAKs7B,OACbxyB,EAAY9I,KAAK8I,UACrB,GAAIA,EACA,OAAOA,EAAUE,SAASolC,EAAgB9hC,SAAU,GAChDnK,MAAOA,EAAOsO,MAAOA,EAAO49B,MAAOA,EAAO5pC,WAAYA,IAI1D,OAAG,CACC,GAAItC,KAAWsO,EAAO,CAClBhM,EAAWlB,WACX,MAGJ,GADAkB,EAAWpB,KAAKgrC,KACZ5pC,EAAW7C,OACX,QAKTwsC,EAjFyB,CAkFlCtmC,EAAavB,YACflI,EAAQ+vC,gBAAkBA,IAG9BjwC,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASiwC,GACpG,aACAhwC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQkwC,MAAQD,EAAkBF,gBAAgB5pC,SAGtDrG,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAc0mC,GAC/I,aACAlwC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWgoC,MAAQC,EAAQD,QAG5CpwC,OAAO,mCAAmC,UAAW,UAAW,QAAS,gBAAiB,4BAA6B,sBAAuB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcwZ,EAAqBD,GAClN,aACA/iB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIiwC,EAAiC,SAAUruC,GAE3C,SAASquC,EAAgBC,EAAiB1F,GACtC,IAAI1oC,EAAQF,EAAOG,KAAKP,OAASA,KAGjC,OAFAM,EAAMouC,gBAAkBA,EACxBpuC,EAAM0oC,kBAAoBA,EACnB1oC,EAgBX,OArBAJ,EAAQc,UAAUytC,EAAiBruC,GAOnCquC,EAAgBjqC,OAAS,SAAUkqC,EAAiB1F,GAChD,OAAO,IAAIyF,EAAgBC,EAAiB1F,IAEhDyF,EAAgBxsC,UAAUyE,WAAa,SAAUjC,GAC7C,IACIkqC,EADWD,EAAN1uC,KAA2B0uC,gBAAiB1F,EAA5ChpC,KAAmEgpC,kBAE5E,IAEI,OADA2F,EAAWD,IACJ,IAAIE,EAAgBnqC,EAAYkqC,EAAU3F,GAErD,MAAOxoC,GACHiE,EAAWnB,MAAM9C,KAGlBiuC,EAtByB,CAuBlC3mC,EAAavB,YACflI,EAAQowC,gBAAkBA,EAC1B,IAAIG,EAAiC,SAAUxuC,GAE3C,SAASwuC,EAAgBtqC,EAAaqqC,EAAU3F,GAC5C,IAAI1oC,EAAQF,EAAOG,KAAKP,KAAMsE,IAAgBtE,KAK9C,OAJAM,EAAMquC,SAAWA,EACjBruC,EAAM0oC,kBAAoBA,EAC1B1kC,EAAY7B,IAAIksC,GAChBruC,EAAMuuC,SACCvuC,EAaX,OApBAJ,EAAQc,UAAU4tC,EAAiBxuC,GASnCwuC,EAAgB3sC,UAAU4sC,OAAS,WAC/B,IACI,IAAIhoC,EAAS7G,KAAKgpC,kBAAkBzoC,KAAKP,KAAMA,KAAK2uC,UAChD9nC,GACA7G,KAAKyC,IAAI6e,EAAoBN,kBAAkBhhB,KAAM6G,IAG7D,MAAOrG,GACHR,KAAK2E,OAAOnE,KAGbouC,EArByB,CAsBlCvtB,EAAkBtB,mBAGxB5hB,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASywC,GACpG,aACAxwC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ0wC,MAAQD,EAAkBL,gBAAgBjqC,SAGtDrG,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcknC,GAC/I,aACA1wC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWwoC,MAAQC,EAAQD,QAG5C5wC,OAAO,mCAAmC,UAAW,UAAW,QAAS,iBAAkB,SAAUC,EAASC,EAAS6B,EAAS4H,GAC5H,aACAxJ,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIywC,EAAiC,SAAU7uC,GAE3C,SAAS6uC,EAAgB3rC,EAAOwF,GAC5B,IAAIxI,EAAQF,EAAOG,KAAKP,OAASA,KAGjC,OAFAM,EAAMgD,MAAQA,EACdhD,EAAMwI,UAAYA,EACXxI,EA8DX,OAnEAJ,EAAQc,UAAUiuC,EAAiB7uC,GA+CnC6uC,EAAgBzqC,OAAS,SAAUlB,EAAOwF,GACtC,OAAO,IAAImmC,EAAgB3rC,EAAOwF,IAEtCmmC,EAAgB3iC,SAAW,SAAUC,GACjC,IAAIjJ,EAAQiJ,EAAIjJ,MAAoBiJ,EAAI9H,WAC7BnB,MAAMA,IAErB2rC,EAAgBhtC,UAAUyE,WAAa,SAAUjC,GAC7C,IAAInB,EAAQtD,KAAKsD,MACbwF,EAAY9I,KAAK8I,UAErB,GADArE,EAAWL,oBAAqB,EAC5B0E,EACA,OAAOA,EAAUE,SAASimC,EAAgB3iC,SAAU,GAChDhJ,MAAOA,EAAOmB,WAAYA,IAI9BA,EAAWnB,MAAMA,IAGlB2rC,EApEyB,CAqElCnnC,EAAavB,YACflI,EAAQ4wC,gBAAkBA,IAG9B9wC,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAAS6wC,GACpG,aACA5wC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ8wC,OAASD,EAAkBD,gBAAgBzqC,SAGvDrG,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcsnC,GAC/I,aACA9wC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWqF,MAAQwjC,EAAQD,SAG5ChxC,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcib,GAC/I,aACAzkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWsc,MAAQE,EAAQF,QAG5C1kB,OAAO,uBAAuB,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAAS2kC,GACjG,aACA1kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQgkC,IAAMW,EAAMb,YAGxBhkC,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAck7B,GAC3I,aACA1kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW87B,IAAMW,EAAMX,MAGxClkC,OAAO,4BAA4B,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAASgxC,GACtG,aACA/wC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQixC,KAAOD,EAAiBx5B,eAAerR,SAGnDrG,OAAO,gCAAgC,UAAW,UAAW,sBAAuB,gCAAiC,SAAUC,EAASC,EAASyJ,EAAcynC,GAC3J,aACAjxC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW+oC,KAAOC,EAAOD,OAG1CnxC,OAAO,oBAAoB,UAAW,UAAW,UAAW,SAAUC,EAASC,EAASmF,GACpF,aAEA,SAASgsC,EAAWnF,GAEhB,IAAK,IADDX,KACKvjC,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCujC,EAAQvjC,EAAK,GAAKlG,UAAUkG,GAGhC,IAAK,IADD/D,EAAMsnC,EAAQnqC,OACTmB,EAAI,EAAGA,EAAI0B,EAAK1B,IAAK,CAC1B,IAAImG,EAAS6iC,EAAQhpC,GACrB,IAAK,IAAI+uC,KAAK5oC,EACNA,EAAO8Q,eAAe83B,KACtBpF,EAAOoF,GAAK5oC,EAAO4oC,IAI/B,OAAOpF,EAIX,SAASqF,EAAUzwC,GACf,OAAOA,EAAKX,OAAOqxC,QAAUH,EApBjClxC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiBtDH,EAAQmxC,WAAaA,EAKrBnxC,EAAQqxC,UAAYA,EACpBrxC,EAAQsxC,OAASD,EAAUlsC,EAAOvE,QAGtCd,OAAO,wCAAwC,UAAW,UAAW,QAAS,gBAAiB,mBAAoB,mBAAoB,qBAAsB,kBAAmB,sBAAuB,sBAAuB,yBAA0B,qBAAsB,SAAUC,EAASC,EAAS6B,EAASuI,EAAWnD,EAAcwC,EAAcjE,EAAgBL,EAAQi0B,EAAiBr2B,EAAYzB,EAAeiwC,GAC1Z,aACAtxC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIqxC,EAAkC,SAAUzvC,GAE5C,SAASyvC,EAAiBC,EAAmBxrC,GACzC,IAAIhE,EAAQN,KACZ,GAAI8vC,aAA6BhoC,EAAavB,WAC1CjG,EAAQF,EAAOG,KAAKP,KAAMsE,EAAawrC,IAAsB9vC,SAE5D,CAWD,GAVAM,EAAQF,EAAOG,KAAKP,OAASA,KAC7BM,EAAMyvC,cAAgBvsC,EAAOvE,KAAK+wC,UAClC1vC,EAAM2vC,QAAU,IAAIxnC,EAAUP,QACG,iBAAtB4nC,EACPxvC,EAAMqV,IAAMm6B,EAIZF,EAASD,OAAOrvC,EAAOwvC,IAEtBxvC,EAAMyvC,cACP,MAAM,IAAI7wC,MAAM,yCAEpBoB,EAAMgE,YAAc,IAAImzB,EAAgB5qB,cAE5C,OAAOvM,EA6MX,OAnOAJ,EAAQc,UAAU6uC,EAAkBzvC,GAwBpCyvC,EAAiB5tC,UAAUqnB,eAAiB,SAAU5pB,GAClD,OAAOgX,KAAKC,MAAMjX,EAAEsd,OAwCxB6yB,EAAiBrrC,OAAS,SAAUsrC,GAChC,OAAO,IAAID,EAAiBC,IAEhCD,EAAiB5tC,UAAU0E,KAAO,SAAUC,GACxC,IAAIspC,EAAO,IAAIL,EAAiB7vC,KAAMA,KAAKsE,aAE3C,OADA4rC,EAAKtpC,SAAWA,EACTspC,GAEXL,EAAiB5tC,UAAUkuC,YAAc,WACrCnwC,KAAKowC,OAAS,KACTpwC,KAAK6G,SACN7G,KAAKsE,YAAc,IAAImzB,EAAgB5qB,eAE3C7M,KAAKiwC,QAAU,IAAIxnC,EAAUP,SAGjC2nC,EAAiB5tC,UAAUouC,UAAY,SAAUC,EAAQC,EAAUC,GAC/D,IAAI5xC,EAAOoB,KACX,OAAO,IAAI8H,EAAavB,WAAW,SAAUgF,GACzC,IAAImF,EAAStP,EAAWvB,SAASywC,EAApBlvC,GACTsP,IAAW/Q,EAAcF,YACzB8L,EAASjI,MAAM3D,EAAcF,YAAYC,GAGzCd,EAAKyE,KAAKqN,GAEd,IAAI9N,EAAehE,EAAK4H,UAAU,SAAUpH,GACxC,IAAIsR,EAAStP,EAAWvB,SAAS2wC,EAApBpvC,CAAmChC,GAC5CsR,IAAW/Q,EAAcF,YACzB8L,EAASjI,MAAM3D,EAAcF,YAAYC,GAEpCgR,GACLnF,EAASlI,KAAKjE,IAEnB,SAAUoB,GAAO,OAAO+K,EAASjI,MAAM9C,IAAS,WAAc,OAAO+K,EAAShI,aACjF,OAAO,WACH,IAAImN,EAAStP,EAAWvB,SAAS0wC,EAApBnvC,GACTsP,IAAW/Q,EAAcF,YACzB8L,EAASjI,MAAM3D,EAAcF,YAAYC,GAGzCd,EAAKyE,KAAKqN,GAEd9N,EAAajB,kBAIzBkuC,EAAiB5tC,UAAUwuC,eAAiB,WACxC,IAAInwC,EAAQN,KACR+vC,EAAgB/vC,KAAK+vC,cACrBxkC,EAAWvL,KAAKiwC,QAChBG,EAAS,KACb,IACIA,EAASpwC,KAAK0wC,SACV,IAAIX,EAAc/vC,KAAK2V,IAAK3V,KAAK0wC,UACjC,IAAIX,EAAc/vC,KAAK2V,KAC3B3V,KAAKowC,OAASA,EACVpwC,KAAK2wC,aACL3wC,KAAKowC,OAAOO,WAAa3wC,KAAK2wC,YAGtC,MAAOjxC,GAEH,YADA6L,EAASjI,MAAM5D,GAGnB,IAAIkD,EAAe,IAAIiB,EAAenC,aAAa,WAC/CpB,EAAM8vC,OAAS,KACXA,GAAgC,IAAtBA,EAAO32B,YACjB22B,EAAOQ,UAGfR,EAAOS,OAAS,SAAUnxC,GACtB,IAAIoxC,EAAexwC,EAAMwwC,aACrBA,GACAA,EAAaztC,KAAK3D,GAEtB,IAAIwL,EAAQ5K,EAAMgE,YAClBhE,EAAMgE,YAAcgB,EAAatB,WAAWQ,OAAO,SAAUpF,GAAK,OAA6B,IAAtBgxC,EAAO32B,YAAoB22B,EAAO/3B,KAAKjZ,IAAO,SAAUM,GAC7H,IAAIqxC,EAAkBzwC,EAAMywC,gBACxBA,GACAA,EAAgB1tC,UAAKuG,GAErBlK,GAAKA,EAAEsxC,KACPZ,EAAOQ,MAAMlxC,EAAEsxC,KAAMtxC,EAAEuxC,QAGvB1lC,EAASjI,MAAM,IAAIgN,UAAU,sIAGjChQ,EAAM6vC,eACP,WACC,IAAIY,EAAkBzwC,EAAMywC,gBACxBA,GACAA,EAAgB1tC,UAAKuG,GAEzBwmC,EAAOQ,QACPtwC,EAAM6vC,gBAENjlC,GAASA,aAAiBusB,EAAgB5qB,eAC1CjK,EAAaH,IAAIyI,EAAM1E,UAAUlG,EAAMgE,eAG/C8rC,EAAOl2B,QAAU,SAAUxa,GACvBY,EAAM6vC,cACN5kC,EAASjI,MAAM5D,IAEnB0wC,EAAOc,QAAU,SAAUxxC,GACvBY,EAAM6vC,cACN,IAAIgB,EAAgB7wC,EAAM6wC,cACtBA,GACAA,EAAc9tC,KAAK3D,GAEnBA,EAAE0xC,SACF7lC,EAAShI,WAGTgI,EAASjI,MAAM5D,IAGvB0wC,EAAOj0B,UAAY,SAAUzc,GACzB,IAAIgR,EAAStP,EAAWvB,SAASS,EAAMgpB,eAA1BloB,CAA0C1B,GACnDgR,IAAW/Q,EAAcF,YACzB8L,EAASjI,MAAM3D,EAAcF,YAAYC,GAGzC6L,EAASlI,KAAKqN,KAI1Bm/B,EAAiB5tC,UAAUyE,WAAa,SAAUjC,GAC9C,IAAInE,EAAQN,KACR6G,EAAS7G,KAAK6G,OAClB,GAAIA,EACA,OAAOA,EAAOL,UAAU/B,GAEvBzE,KAAKowC,QACNpwC,KAAKywC,iBAET,IAAI7tC,EAAe,IAAIiB,EAAenC,aAWtC,OAVAkB,EAAaH,IAAIzC,KAAKiwC,QAAQzpC,UAAU/B,IACxC7B,EAAaH,IAAI,WACb,IAAI2tC,EAAS9vC,EAAM8vC,OACoB,IAAnC9vC,EAAM2vC,QAAQroC,UAAUrI,SACpB6wC,GAAgC,IAAtBA,EAAO32B,YACjB22B,EAAOQ,QAEXtwC,EAAM6vC,iBAGPvtC,GAEXitC,EAAiB5tC,UAAUN,YAAc,WACrC,IAAekF,EAAN7G,KAAkB6G,OAAQupC,EAA1BpwC,KAAsCowC,OAC3CA,GAAgC,IAAtBA,EAAO32B,aACjB22B,EAAOQ,QACP5wC,KAAKmwC,eAET/vC,EAAO6B,UAAUN,YAAYpB,KAAKP,MAC7B6G,IACD7G,KAAKsE,YAAc,IAAImzB,EAAgB5qB,gBAGxCgjC,EApO0B,CAqOnCpnC,EAAUJ,kBACZhK,EAAQwxC,iBAAmBA,IAG/B1xC,OAAO,iCAAiC,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAASgzC,GAC7G,aACA/yC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQizC,UAAYD,EAAmBxB,iBAAiBrrC,SAG5DrG,OAAO,qCAAqC,UAAW,UAAW,sBAAuB,qCAAsC,SAAUC,EAASC,EAASyJ,EAAcypC,GACrK,aACAjzC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAW+qC,UAAYC,EAAYD,YAGpDnzC,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAAS8kC,GACrG,aACA7kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoCtDH,EAAQ4kB,OAHR,SAAgBC,GACZ,OAAOigB,EAASlgB,OAAOC,EAAhBigB,CAAiCnjC,SAKhD7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAcq7B,GAC7I,aACA7kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUghB,OAASkgB,EAASlgB,SAGxD9kB,OAAO,6BAA6B,UAAW,UAAW,4BAA6B,SAAUC,EAASC,EAAS+kC,GAC/G,aACA9kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQglB,YAJR,SAAqBvW,EAAYwW,GAE7B,YADyB,IAArBA,IAA+BA,EAAmB,MAC/C8f,EAAc/f,YAAYvW,EAAYwW,EAAtC8f,CAAwDpjC,SAKvE7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAcs7B,GACvJ,aACA9kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUohB,YAAc+f,EAAc/f,cAGlEllB,OAAO,4BAA4B,UAAW,UAAW,qBAAsB,sBAAuB,2BAA4B,SAAUC,EAASC,EAASsR,EAAS2S,EAAe+gB,GAClL,aACA/kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8DtDH,EAAQ8lB,WAjBR,SAAoBF,GAChB,IAAI1kB,EAASU,UAAUV,OACnBuJ,EAAY6G,EAAQD,MACpB4S,EAAcJ,YAAYjiB,UAAUA,UAAUV,OAAS,MACvDuJ,EAAY7I,UAAUA,UAAUV,OAAS,GACzCA,KAEJ,IAAI6kB,EAAyB,KACzB7kB,GAAU,IACV6kB,EAAyBnkB,UAAU,IAEvC,IAAIokB,EAAgBrX,OAAOC,kBAI3B,OAHI1N,GAAU,IACV8kB,EAAgBpkB,UAAU,IAEvBojC,EAAalf,WAAWF,EAAgBG,EAAwBC,EAAevb,EAA/Eu6B,CAA0FrjC,SAKzG7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAcu7B,GACrJ,aACA/kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUkiB,WAAakf,EAAalf,aAGhEhmB,OAAO,8BAA8B,UAAW,UAAW,6BAA8B,SAAUC,EAASC,EAASilC,GACjH,aACAhlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA0CtDH,EAAQ2mB,aAHR,SAAsBC,EAAUC,GAC5B,OAAOoe,EAAete,aAAaC,EAAUC,EAAtCoe,CAAuDtjC,SAKtE7B,OAAO,kCAAkC,UAAW,UAAW,mBAAoB,+BAAgC,SAAUC,EAASC,EAASyJ,EAAcw7B,GACzJ,aACAhlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+iB,aAAese,EAAete,eAGpE7mB,OAAO,4BAA4B,UAAW,UAAW,2BAA4B,SAAUC,EAASC,EAASklC,GAC7G,aACAjlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqCtDH,EAAQmnB,WAHR,SAAoBN,GAChB,OAAOqe,EAAa/d,WAAWN,EAAxBqe,CAAyCvjC,SAKxD7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAcy7B,GACrJ,aACAjlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUujB,WAAa+d,EAAa/d,aAGhErnB,OAAO,uBAAuB,UAAW,UAAW,2BAA4B,SAAUC,EAASC,EAASmlC,GACxG,aACAllC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+DtDH,EAAQmzC,OAHR,SAAgB1rB,GACZ,OAAO0d,EAAa3d,WAAWC,EAAxB0d,CAAkCxjC,SAKjD7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAc2pC,GAC3I,aACAnzC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUyvC,MAAQD,EAAQD,OAClD1pC,EAAavB,WAAWtE,UAAUuvC,OAASC,EAAQD,SAGvDrzC,OAAO,4BAA4B,UAAW,UAAW,2BAA4B,SAAUC,EAASC,EAASolC,GAC7G,aACAnlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQgpB,WAHR,SAAoBjX,GAChB,OAAOqzB,EAAapc,WAAWjX,EAAxBqzB,CAAiCzjC,SAKhD7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAc27B,GACrJ,aACAnlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUolB,WAAaoc,EAAapc,aAGhElpB,OAAO,+BAA+B,UAAW,UAAW,8BAA+B,SAAUC,EAASC,EAAS+oB,GACnH,aACA9oB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoDtDH,EAAQuoB,cAPR,WAEI,IAAK,IADDC,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAOihB,EAAgBR,cAAc7mB,WAAM,EAAQ8mB,EAA5CO,CAAyDpnB,SAKxE7B,OAAO,mCAAmC,UAAW,UAAW,mBAAoB,gCAAiC,SAAUC,EAASC,EAASyJ,EAAcsf,GAC3J,aACA9oB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU2kB,cAAgBQ,EAAgBR,gBAGtEzoB,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASisB,GACrG,aACAhsB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA0DtDH,EAAQoD,OAPR,WAEI,IAAK,IADDolB,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAOmkB,EAAS7oB,OAAO1B,WAAM,EAAQ8mB,EAA9ByD,CAA2CtqB,SAK1D7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAcwiB,GAC7I,aACAhsB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUR,OAAS6oB,EAAS7oB,SAGxDtD,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASgsB,GAC3G,aACA/rB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQ6rB,UAHR,WACI,OAAOG,EAAYH,WAAZG,CAAwBrqB,SAKvC7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAcuiB,GACnJ,aACA/rB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUioB,UAAYG,EAAYH,YAG9D/rB,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASmsB,GAC3G,aACAlsB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgEtDH,EAAQksB,UAHR,SAAmBna,EAASkZ,GACxB,OAAOkB,EAAYD,UAAUna,EAASkZ,EAA/BkB,CAA+CxqB,SAK9D7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAc0iB,GACnJ,aACAlsB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUsoB,UAAYC,EAAYD,YAG9DpsB,OAAO,6BAA6B,UAAW,UAAW,4BAA6B,SAAUC,EAASC,EAASqlC,GAC/G,aACAplC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6DtDH,EAAQosB,YAHR,SAAqBC,EAAiBpB,GAClC,OAAOoa,EAAcjZ,YAAYC,EAAiBpB,EAA3Coa,CAA2D1jC,SAK1E7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAc47B,GACvJ,aACAplC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUwoB,YAAciZ,EAAcjZ,cAGlEtsB,OAAO,uBAAuB,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAASslC,GACnG,aACArlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoDtDH,EAAQoS,MAHR,SAAeka,GACX,OAAOgZ,EAAQlzB,MAAMka,EAAdgZ,CAAyB3jC,SAKxC7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAc67B,GAC3I,aACArlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUwO,MAAQkzB,EAAQlzB,QAGtDtS,OAAO,+BAA+B,UAAW,UAAW,8BAA+B,SAAUC,EAASC,EAAS0lC,GACnH,aACAzlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQmvB,cAHR,WACI,OAAOuW,EAAgBvW,eAAhBuW,CAAgC/jC,SAK/C7B,OAAO,mCAAmC,UAAW,UAAW,mBAAoB,gCAAiC,SAAUC,EAASC,EAASyJ,EAAci8B,GAC3J,aACAzlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUurB,cAAgBuW,EAAgBvW,gBAGtErvB,OAAO,0BAA0B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAASulC,GACzG,aACAtlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQ0sB,SAHR,SAAkBvJ,GACd,OAAOoiB,EAAW7Y,SAASvJ,EAApBoiB,CAAsC5jC,SAKrD7B,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAc87B,GACjJ,aACAtlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU8oB,SAAW6Y,EAAW7Y,WAG5D5sB,OAAO,8BAA8B,UAAW,UAAW,qBAAsB,6BAA8B,SAAUC,EAASC,EAASsR,EAASk0B,GAChJ,aACAvlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAmDtDH,EAAQ+sB,aAJR,SAAsB3I,EAAS3Z,GAE3B,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzCm0B,EAAezY,aAAa3I,EAAS3Z,EAArC+6B,CAAgD7jC,SAK/D7B,OAAO,kCAAkC,UAAW,UAAW,mBAAoB,+BAAgC,SAAUC,EAASC,EAASyJ,EAAc+7B,GACzJ,aACAvlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUmpB,aAAeyY,EAAezY,eAGpEjtB,OAAO,gCAAgC,UAAW,UAAW,+BAAgC,SAAUC,EAASC,EAASu2B,GACrH,aACAt2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoCtDH,EAAQstB,eAJR,SAAwBC,GAEpB,YADqB,IAAjBA,IAA2BA,EAAe,MACvCgJ,EAAiBjJ,eAAeC,EAAhCgJ,CAA8C50B,SAK7D7B,OAAO,oCAAoC,UAAW,UAAW,mBAAoB,iCAAkC,SAAUC,EAASC,EAASyJ,EAAc8sB,GAC7J,aACAt2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU0pB,eAAiBiJ,EAAiBjJ,iBAGxExtB,OAAO,uBAAuB,UAAW,UAAW,qBAAsB,sBAAuB,SAAUC,EAASC,EAASsR,EAASwc,GAClI,aACA7tB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQ6K,MAJR,SAAeA,EAAOJ,GAElB,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzCyc,EAAQjjB,MAAMA,EAAOJ,EAArBqjB,CAAgCnsB,SAK/C7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAcqkB,GAC3I,aACA7tB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUiH,MAAQijB,EAAQjjB,QAGtD/K,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASylC,GAC3G,aACAxlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiDtDH,EAAQkuB,UAHR,SAAmBC,EAAuBC,GACtC,OAAOqX,EAAYvX,UAAUC,EAAuBC,EAA7CqX,CAAgE9jC,SAK/E7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAcg8B,GACnJ,aACAxlC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUsqB,UAAYuX,EAAYvX,YAG9DpuB,OAAO,0BAA0B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAAS2lC,GACzG,aACA1lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiDtDH,EAAQ2vB,SAHR,SAAkBC,EAAaC,GAC3B,OAAO8V,EAAWhW,SAASC,EAAaC,EAAjC8V,CAA0ChkC,SAKzD7B,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAck8B,GACjJ,aACA1lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+rB,SAAWgW,EAAWhW,WAG5D7vB,OAAO,sCAAsC,UAAW,UAAW,qCAAsC,SAAUC,EAASC,EAASwwB,GACjI,aACAvwB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQkwB,qBAHR,SAA8BC,EAASP,GACnC,OAAOY,EAAuBN,qBAAqBC,EAASP,EAArDY,CAAkE7uB,SAKjF7B,OAAO,0CAA0C,UAAW,UAAW,mBAAoB,uCAAwC,SAAUC,EAASC,EAASyJ,EAAc+mB,GACzK,aACAvwB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUssB,qBAAuBM,EAAuBN,uBAGpFpwB,OAAO,yCAAyC,UAAW,UAAW,wCAAyC,SAAUC,EAASC,EAAS4lC,GACvI,aACA3lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8DtDH,EAAQywB,wBAHR,SAAiC7V,EAAKuV,GAClC,OAAOyV,EAA0BnV,wBAAwB7V,EAAKuV,EAAvDyV,CAAgEjkC,SAK/E7B,OAAO,6CAA6C,UAAW,UAAW,mBAAoB,0CAA2C,SAAUC,EAASC,EAASyJ,EAAcm8B,GAC/K,aACA3lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU6sB,wBAA0BmV,EAA0BnV,0BAG1F3wB,OAAO,oBAAoB,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAAS6oC,GAC9F,aACA5oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgDtDH,EAAQszC,IAHR,SAAansC,EAAgBlC,EAAOC,GAChC,OAAO2jC,EAAMvJ,IAAIn4B,EAAgBlC,EAAOC,EAAjC2jC,CAA2ClnC,SAK1D7B,OAAO,wBAAwB,UAAW,UAAW,mBAAoB,qBAAsB,SAAUC,EAASC,EAASyJ,EAAc8pC,GACrI,aACAtzC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUuJ,GAAKomC,EAAKD,IAC5C7pC,EAAavB,WAAWtE,UAAU0vC,IAAMC,EAAKD,MAGjDxzC,OAAO,yBAAyB,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAAS+lC,GACvG,aACA9lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAuCtDH,EAAQkxB,QAHR,WACI,OAAO6U,EAAU7U,SAAV6U,CAAoBpkC,SAKnC7B,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcs8B,GAC/I,aACA9lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUstB,QAAU6U,EAAU7U,UAG1DpxB,OAAO,4BAA4B,UAAW,UAAW,2BAA4B,SAAUC,EAASC,EAASgmC,GAC7G,aACA/lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkDtDH,EAAQsxB,WAHR,SAAoBvf,EAASkZ,GACzB,OAAO+a,EAAa1U,WAAWvf,EAASkZ,EAAjC+a,CAAiDrkC,SAKhE7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAcu8B,GACrJ,aACA/lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU0tB,WAAa0U,EAAa1U,aAGhExxB,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASimC,GACrG,aACAhmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQ2xB,OANR,SAAgB5f,EAASmZ,EAAYzgB,GAIjC,YAHmB,IAAfygB,IAAyBA,EAAavc,OAAOC,wBAC/B,IAAdnE,IAAwBA,OAAYc,GACxC2f,GAAcA,GAAc,GAAK,EAAIvc,OAAOC,kBAAoBsc,EACzD+a,EAAStU,OAAO5f,EAASmZ,EAAYzgB,EAArCw7B,CAAgDtkC,SAK/D7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAcw8B,GAC7I,aACAhmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+tB,OAASsU,EAAStU,SAGxD7xB,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAAS6lC,GAC3G,aACA5lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQ2wB,UAHR,SAAmB7sB,EAAOypB,GACtB,OAAOsY,EAAYlV,UAAU7sB,EAAOypB,EAA7BsY,CAA2ClkC,SAK1D7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAco8B,GACnJ,aACA5lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+sB,UAAYkV,EAAYlV,YAG9D7wB,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASs4B,GACrG,aACAr4B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQ4W,OAHR,SAAgB0V,EAAWta,GACvB,OAAOsmB,EAAS1hB,OAAO0V,EAAWta,EAA3BsmB,CAAoC32B,SAKnD7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAc6uB,GAC7I,aACAr4B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUgT,OAAS0hB,EAAS1hB,SAGxD9W,OAAO,yBAAyB,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAASkmC,GACxG,aACAjmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAYtDH,EAAQwzC,SAHR,SAAkBthB,GACd,OAAOgU,EAAWjU,SAASC,EAApBgU,CAA8BvkC,SAK7C7B,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcgqC,GAC/I,aACAxzC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU8vC,QAAUD,EAAUD,SACtD/pC,EAAavB,WAAWtE,UAAU4vC,SAAWC,EAAUD,WAG3D1zC,OAAO,sBAAsB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASyyB,GACjG,aACAxyB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQqyB,KAHR,SAAc/F,EAAWta,GACrB,OAAOygB,EAAOJ,KAAK/F,EAAWta,EAAvBygB,CAAgC9wB,SAK/C7B,OAAO,0BAA0B,UAAW,UAAW,mBAAoB,uBAAwB,SAAUC,EAASC,EAASyJ,EAAcgpB,GACzI,aACAxyB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUyuB,KAAOI,EAAOJ,OAGpDvyB,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASmmC,GAC3G,aACAlmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQ0yB,UAHR,SAAmBpG,EAAWta,GAC1B,OAAOm0B,EAAYzT,UAAUpG,EAAWta,EAAjCm0B,CAA0CxkC,SAKzD7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAc08B,GACnJ,aACAlmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU8uB,UAAYyT,EAAYzT,YAG9D5yB,OAAO,uBAAuB,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAASomC,GACnG,aACAnmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQ4yB,MAHR,SAAetG,EAAWrB,EAAgBsC,GACtC,OAAO6Y,EAAQxT,MAAMtG,EAAWrB,EAAgBsC,EAAzC6Y,CAAuDzkC,SAKtE7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAc28B,GAC3I,aACAnmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUgvB,MAAQwT,EAAQxT,QAGtD9yB,OAAO,yBAAyB,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAASqmC,GACvG,aACApmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQq0B,kBAAoBgS,EAAUhS,kBAwEtCr0B,EAAQ0zB,QAHR,SAAiB9D,EAAa+D,EAAiBxQ,EAAkByQ,GAC7D,OAAOyS,EAAU3S,QAAQ9D,EAAa+D,EAAiBxQ,EAAkByQ,EAAlEyS,CAAmF1kC,SAKlG7B,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAc48B,GAC/I,aACApmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU8vB,QAAU2S,EAAU3S,UAG1D5zB,OAAO,gCAAgC,UAAW,UAAW,+BAAgC,SAAUC,EAASC,EAASsmC,GACrH,aACArmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IActDH,EAAQ20B,eAHR,WACI,OAAO2R,EAAiB3R,gBAAjB2R,CAAkC3kC,SAMjD7B,OAAO,oCAAoC,UAAW,UAAW,mBAAoB,iCAAkC,SAAUC,EAASC,EAASyJ,EAAc68B,GAC7J,aACArmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+wB,eAAiB2R,EAAiB3R,iBAGxE70B,OAAO,yBAAyB,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAASumC,GACvG,aACAtmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAatDH,EAAQ0tB,QAHR,WACI,OAAO6Y,EAAU7Y,SAAV6Y,CAAoB5kC,SAKnC7B,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAc88B,GAC/I,aACAtmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU8pB,QAAU6Y,EAAU7Y,UAG1D5tB,OAAO,uBAAuB,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAASykB,GACnG,aACAxkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA4CtDH,EAAQkjB,MAHR,SAAeC,GACX,OAAOsB,EAAQvB,MAAMC,EAAdsB,CAAgC9iB,SAK/C7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAcgb,GAC3I,aACAxkB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUsf,MAAQuB,EAAQvB,QAGtDpjB,OAAO,2BAA2B,UAAW,UAAW,qBAAsB,0BAA2B,SAAUC,EAASC,EAASsR,EAASuzB,GAC1I,aACA5kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+CtDH,EAAQ2kB,UAJR,SAAmBpB,EAAU9Y,GAEzB,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzCwzB,EAAYlgB,UAAUpB,EAAU9Y,EAAhCo6B,CAA2CljC,SAK1D7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAco7B,GACnJ,aACA5kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+gB,UAAYkgB,EAAYlgB,YAG9D7kB,OAAO,sBAAsB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASwmC,GACjG,aACAvmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsBtDH,EAAQg1B,KAHR,SAAc1I,EAAWrB,EAAgBsC,GACrC,OAAOiZ,EAAOxR,KAAK1I,EAAWrB,EAAgBsC,EAAvCiZ,CAAqD7kC,SAKpE7B,OAAO,0BAA0B,UAAW,UAAW,mBAAoB,uBAAwB,SAAUC,EAASC,EAASyJ,EAAc+8B,GACzI,aACAvmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUoxB,KAAOwR,EAAOxR,OAGpDl1B,OAAO,qBAAqB,UAAW,WAAY,SAAUC,EAASC,GAClE,aACAC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAUtDH,EAAQ2zC,SAHR,SAAkB9J,GACd,OAAOA,EAAKloC,SAKpB7B,OAAO,yBAAyB,UAAW,UAAW,mBAAoB,sBAAuB,SAAUC,EAASC,EAASyJ,EAAcmqC,GACvI,aACA3zC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUiwC,IAAMD,EAAMD,SAC9ClqC,EAAavB,WAAWtE,UAAUkwC,QAAUF,EAAMD,WAGtD7zC,OAAO,uBAAuB,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAAS8lC,GACnG,aACA7lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQ8wB,MAHR,SAAexE,EAAWta,GACtB,OAAO8zB,EAAQhV,MAAMxE,EAAWta,EAAzB8zB,CAAkCnkC,SAKjD7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAcq8B,GAC3I,aACA7lC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUktB,MAAQgV,EAAQhV,QAGtDhxB,OAAO,qBAAqB,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAASsS,GAC/F,aACArS,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqCtDH,EAAQoC,IAHR,SAAa2P,EAASC,GAClB,OAAOM,EAAMlQ,IAAI2P,EAASC,EAAnBM,CAA4B3Q,SAK3C7B,OAAO,yBAAyB,UAAW,UAAW,mBAAoB,sBAAuB,SAAUC,EAASC,EAASyJ,EAAc6I,GACvI,aACArS,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUxB,IAAMkQ,EAAMlQ,MAGlDtC,OAAO,uBAAuB,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAASymC,GACnG,aACAxmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8BtDH,EAAQm1B,MAHR,SAAeh1B,GACX,OAAOsmC,EAAQtR,MAAMh1B,EAAdsmC,CAAqB9kC,SAKpC7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAcg9B,GAC3I,aACAxmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUuxB,MAAQsR,EAAQtR,QAGtDr1B,OAAO,6BAA6B,UAAW,UAAW,4BAA6B,SAAUC,EAASC,EAAS0mC,GAC/G,aACAzmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgDtDH,EAAQs1B,YAHR,WACI,OAAOoR,EAAcpR,aAAdoR,CAA4B/kC,SAK3C7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAci9B,GACvJ,aACAzmC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU0xB,YAAcoR,EAAcpR,cAGlEx1B,OAAO,qBAAqB,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAAS2mC,GAC/F,aACA1mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAmCtDH,EAAQuP,IAHR,SAAamnB,GACT,OAAOiQ,EAAMp3B,IAAImnB,EAAViQ,CAAoBhlC,SAKnC7B,OAAO,yBAAyB,UAAW,UAAW,mBAAoB,sBAAuB,SAAUC,EAASC,EAASyJ,EAAck9B,GACvI,aACA1mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU2L,IAAMo3B,EAAMp3B,MAGlDzP,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAcm9B,GAC3I,aACA3mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUgzB,MAAQgQ,EAAQhQ,QAGtD92B,OAAO,0BAA0B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAAS4rB,GACzG,aACA3rB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiDtDH,EAAQ2rB,SAJR,SAAkBT,GAEd,YADmB,IAAfA,IAAyBA,EAAavc,OAAOC,mBAC1Cgd,EAAWD,SAAST,EAApBU,CAAgCjqB,SAK/C7B,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAcmiB,GACjJ,aACA3rB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+nB,SAAWC,EAAWD,WAG5D7rB,OAAO,0BAA0B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAASyrB,GACzG,aACAxrB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgEtDH,EAAQgrB,SAJR,SAAkBjZ,EAASkZ,EAAgBC,GAEvC,YADmB,IAAfA,IAAyBA,EAAavc,OAAOC,mBAC1C6c,EAAWT,SAASjZ,EAASkZ,EAAgBC,EAA7CO,CAAyD9pB,SAKxE7B,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAcgiB,GACjJ,aACAxrB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUonB,SAAWS,EAAWT,SACxDvhB,EAAavB,WAAWtE,UAAU6lC,QAAUhe,EAAWT,WAG3DlrB,OAAO,4BAA4B,UAAW,UAAW,2BAA4B,SAAUC,EAASC,EAAS8mC,GAC7G,aACA7mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiDtDH,EAAQ62B,WAJR,SAAoBxK,EAAiBpB,EAAgBC,GAEjD,YADmB,IAAfA,IAAyBA,EAAavc,OAAOC,mBAC1Ck4B,EAAajQ,WAAWxK,EAAiBpB,EAAgBC,EAAzD4b,CAAqEnlC,SAKpF7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAcq9B,GACrJ,aACA7mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUmwC,UAAYjN,EAAajQ,WAC3DptB,EAAavB,WAAWtE,UAAUizB,WAAaiQ,EAAajQ,aAGhE/2B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAAS+mC,GAC3G,aACA9mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoCtDH,EAAQg3B,UAJR,SAAmBtB,EAAaC,EAAMzK,GAElC,YADmB,IAAfA,IAAyBA,EAAavc,OAAOC,mBAC1Cm4B,EAAY/P,UAAUtB,EAAaC,EAAMzK,EAAzC6b,CAAqDplC,SAKpE7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAcs9B,GACnJ,aACA9mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUozB,UAAY+P,EAAY/P,YAG9Dl3B,OAAO,qBAAqB,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAASgnC,GAC/F,aACA/mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAmCtDH,EAAQm3B,IAHR,SAAaT,GACT,OAAOsQ,EAAM7P,IAAIT,EAAVsQ,CAAoBrlC,SAKnC7B,OAAO,yBAAyB,UAAW,UAAW,mBAAoB,sBAAuB,SAAUC,EAASC,EAASyJ,EAAcu9B,GACvI,aACA/mC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUuzB,IAAM6P,EAAM7P,MAGlDr3B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAAS84B,GAC3G,aACA74B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAmGtDH,EAAQq3B,UAHR,SAAmBC,EAAyB7P,GACxC,OAAOqR,EAAYzB,UAAUC,EAAyB7P,EAA/CqR,CAAyDn3B,SAKxE7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAcqvB,GACnJ,aACA74B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUyzB,UAAYyB,EAAYzB,YAG9Dv3B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASuO,GAC3G,aACAtO,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAmDtDH,EAAQ8N,UAJR,SAAmBrD,EAAWI,GAE1B,YADc,IAAVA,IAAoBA,EAAQ,GACzB0D,EAAYT,UAAUrD,EAAWI,EAAjC0D,CAAwC5M,SAKvD7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAc8E,GACnJ,aACAtO,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUkK,UAAYS,EAAYT,YAG9DhO,OAAO,mCAAmC,UAAW,UAAW,kCAAmC,SAAUC,EAASC,EAASinC,GAC3H,aACAhnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsEtDH,EAAQw3B,kBAPR,WAEI,IAAK,IADDC,KACK3vB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC2vB,EAAY3vB,GAAMlG,UAAUkG,GAEhC,OAAOm/B,EAAoBzP,kBAAkB91B,WAAM,EAAQ+1B,EAApDwP,CAAiEtlC,SAKhF7B,OAAO,uCAAuC,UAAW,UAAW,mBAAoB,oCAAqC,SAAUC,EAASC,EAASyJ,EAAcw9B,GACnK,aACAhnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU4zB,kBAAoByP,EAAoBzP,oBAG9E13B,OAAO,0BAA0B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAASknC,GACzG,aACAjnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAuCtDH,EAAQ83B,SAHR,WACI,OAAOoP,EAAWpP,UAAXoP,CAAsBvlC,SAKrC7B,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAcy9B,GACjJ,aACAjnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUk0B,SAAWoP,EAAWpP,WAG5Dh4B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASmnC,GAC3G,aACAlnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6CtDH,EAAQu4B,UAHR,SAAmBjM,EAAWta,GAC1B,OAAOm1B,EAAY5O,UAAUjM,EAAWta,EAAjCm1B,CAA0CxlC,SAKzD7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAc09B,GACnJ,aACAlnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU20B,UAAY4O,EAAY5O,YAG9Dz4B,OAAO,uBAAuB,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAASonC,GACnG,aACAnnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkCtDH,EAAQw4B,MAPR,WAEI,IAAK,IADDC,KACK3wB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC2wB,EAAW3wB,GAAMlG,UAAUkG,GAE/B,OAAOs/B,EAAQ5O,MAAM92B,WAAM,EAAQ+2B,EAA5B2O,CAAwCzlC,SAKvD7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAc29B,GAC3I,aACAnnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU40B,MAAQ4O,EAAQ5O,QAGtD14B,OAAO,yBAAyB,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAASqnC,GACvG,aACApnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQ+4B,QAHR,SAAiBtR,GACb,OAAO4f,EAAUtO,QAAQtR,EAAlB4f,CAA4B1lC,SAK3C7B,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAc49B,GAC/I,aACApnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUm1B,QAAUsO,EAAUtO,UAG1Dj5B,OAAO,iCAAiC,UAAW,UAAW,gCAAiC,SAAUC,EAASC,EAASsnC,GACvH,aACArnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAUtDH,EAAQi5B,gBAHR,SAAyB94B,GACrB,OAAOmnC,EAAkBrO,gBAAgB94B,EAAlCmnC,CAAyC3lC,SAKxD7B,OAAO,qCAAqC,UAAW,UAAW,mBAAoB,kCAAmC,SAAUC,EAASC,EAASyJ,EAAc69B,GAC/J,aACArnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUq1B,gBAAkBqO,EAAkBrO,kBAG1En5B,OAAO,+BAA+B,UAAW,UAAW,8BAA+B,SAAUC,EAASC,EAASwnC,GACnH,aACAvnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IActDH,EAAQq5B,cAHR,SAAuB5qB,EAAYC,EAAY4qB,EAAqB7uB,GAChE,OAAO+8B,EAAgBnO,cAAc5qB,EAAYC,EAAY4qB,EAAqB7uB,EAA3E+8B,CAAsF7lC,SAKrG7B,OAAO,mCAAmC,UAAW,UAAW,mBAAoB,gCAAiC,SAAUC,EAASC,EAASyJ,EAAc+9B,GAC3J,aACAvnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUy1B,cAAgBmO,EAAgBnO,gBAGtEv5B,OAAO,6BAA6B,UAAW,UAAW,4BAA6B,SAAUC,EAASC,EAASunC,GAC/G,aACAtnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAUtDH,EAAQm5B,YAJR,WAEI,OAAOoO,EAAcpO,aAAdoO,CAA4B5lC,SAK3C7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAc89B,GACvJ,aACAtnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUu1B,YAAcoO,EAAcpO,cAGlEr5B,OAAO,sBAAsB,UAAW,UAAW,oBAAqB,sBAAuB,SAAUC,EAASC,EAAS25B,EAAQqa,GAC/H,aACA/zC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQi0C,WAAaD,EAAOza,KAiB5Bv5B,EAAQu5B,KAPR,WAEI,IAAK,IADD/Q,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAO6xB,EAAOJ,KAAK73B,WAAM,EAAQ8mB,EAA1BmR,CAAuCh4B,SAKtD7B,OAAO,0BAA0B,UAAW,UAAW,mBAAoB,uBAAwB,SAAUC,EAASC,EAASyJ,EAAckwB,GACzI,aACA15B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU21B,KAAOI,EAAOJ,OAGpDz5B,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASy2B,GACrG,aACAx2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAyDtDH,EAAQkD,OAXR,SAAgBwyB,EAAaC,GAMzB,OAAI/zB,UAAUV,QAAU,EACbu1B,EAASvzB,OAAOwyB,EAAaC,EAA7Bc,CAAmC90B,MAEvC80B,EAASvzB,OAAOwyB,EAAhBe,CAA6B90B,SAK5C7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAcgtB,GAC7I,aACAx2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUV,OAASuzB,EAASvzB,SAGxDpD,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASynC,GACrG,aACAxnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAiBtDH,EAAQ45B,OAJR,SAAgBxnB,GAEZ,YADc,IAAVA,IAAoBA,GAAS,GAC1Bq1B,EAAS7N,OAAOxnB,EAAhBq1B,CAAuB9lC,SAKtC7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAcg+B,GAC7I,aACAxnC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUg2B,OAAS6N,EAAS7N,SAGxD95B,OAAO,4BAA4B,UAAW,UAAW,2BAA4B,SAAUC,EAASC,EAAS0nC,GAC7G,aACAznC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQ+5B,WAHR,SAAoBC,GAChB,OAAO0N,EAAa3N,WAAWC,EAAxB0N,CAAkC/lC,SAKjD7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAci+B,GACrJ,aACAznC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUm2B,WAAa2N,EAAa3N,aAGhEj6B,OAAO,uBAAuB,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAAS2nC,GACnG,aACA1nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqBtDH,EAAQw6B,MAJR,SAAepoB,GAEX,YADc,IAAVA,IAAoBA,GAAS,GAC1Bu1B,EAAQnN,MAAMpoB,EAAdu1B,CAAqBhmC,SAKpC7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAck+B,GAC3I,aACA1nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU42B,MAAQmN,EAAQnN,QAGtD16B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAAS4nC,GAC3G,aACA3nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQ26B,UAHR,SAAmBX,GACf,OAAO4N,EAAYjN,UAAUX,EAAtB4N,CAAgCjmC,SAK/C7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAcm+B,GACnJ,aACA3nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+2B,UAAYiN,EAAYjN,YAG9D76B,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAAS6nC,GACrG,aACA5nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsCtDH,EAAQ86B,OAHR,SAAgBd,GACZ,OAAO6N,EAAS/M,OAAOd,EAAhB6N,CAA0BlmC,SAKzC7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAco+B,GAC7I,aACA5nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUk3B,OAAS+M,EAAS/M,SAGxDh7B,OAAO,4BAA4B,UAAW,UAAW,qBAAsB,2BAA4B,SAAUC,EAASC,EAASsR,EAASw2B,GAC5I,aACA7nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAyCtDH,EAAQk7B,WAJR,SAAoB7W,EAAQ5Z,GAExB,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzCy2B,EAAa5M,WAAW7W,EAAQ5Z,EAAhCq9B,CAA2CnmC,SAK1D7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAcq+B,GACrJ,aACA7nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUs3B,WAAa4M,EAAa5M,aAGhEp7B,OAAO,sBAAsB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASq2B,GACjG,aACAp2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6CtDH,EAAQy1B,KANR,SAAcC,EAAaC,GACvB,OAAI/zB,UAAUV,QAAU,EACbm1B,EAAOZ,KAAKC,EAAaC,EAAzBU,CAA+B10B,MAEnC00B,EAAOZ,KAAKC,EAAZW,CAAyB10B,SAKxC7B,OAAO,0BAA0B,UAAW,UAAW,mBAAoB,uBAAwB,SAAUC,EAASC,EAASyJ,EAAc4sB,GACzI,aACAp2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU6xB,KAAOY,EAAOZ,OAGpD31B,OAAO,+BAA+B,UAAW,UAAW,8BAA+B,SAAUC,EAASC,EAAS+nC,GACnH,aACA9nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwDtDH,EAAQq7B,cAHR,SAAuBC,EAAWC,GAC9B,OAAOwM,EAAgB1M,cAAcC,EAAWC,EAAzCwM,CAAmDpmC,SAKlE7B,OAAO,mCAAmC,UAAW,UAAW,mBAAoB,gCAAiC,SAAUC,EAASC,EAASyJ,EAAcs+B,GAC3J,aACA9nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUy3B,cAAgB0M,EAAgB1M,gBAGtEv7B,OAAO,uBAAuB,UAAW,UAAW,sBAAuB,SAAUC,EAASC,EAASgoC,GACnG,aACA/nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoBtDH,EAAQg8B,MAHR,WACI,OAAOgM,EAAQhM,OAARgM,CAAgBrmC,SAM/B7B,OAAO,2BAA2B,UAAW,UAAW,mBAAoB,wBAAyB,SAAUC,EAASC,EAASyJ,EAAcu+B,GAC3I,aACA/nC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUo4B,MAAQgM,EAAQhM,QAGtDl8B,OAAO,6BAA6B,UAAW,UAAW,4BAA6B,SAAUC,EAASC,EAASioC,GAC/G,aACAhoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAQtDH,EAAQi8B,YAHR,SAAqBxtB,EAAYC,EAAYjE,GACzC,OAAOw9B,EAAchM,YAAYxtB,EAAYC,EAAYjE,EAAlDw9B,CAA6DtmC,SAM5E7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAcw+B,GACvJ,aACAhoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUq4B,YAAcgM,EAAchM,cAGlEn8B,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASkoC,GACrG,aACAjoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoBtDH,EAAQo8B,OAHR,SAAgB9P,GACZ,OAAO4b,EAAS9L,OAAO9P,EAAhB4b,CAA2BvmC,SAK1C7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAcy+B,GAC7I,aACAjoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUw4B,OAAS8L,EAAS9L,SAGxDt8B,OAAO,sBAAsB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAASmoC,GACjG,aACAloC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAetDH,EAAQ08B,KAHR,SAActqB,GACV,OAAO+1B,EAAOzL,KAAKtqB,EAAZ+1B,CAAmBxmC,SAKlC7B,OAAO,0BAA0B,UAAW,UAAW,mBAAoB,uBAAwB,SAAUC,EAASC,EAASyJ,EAAc0+B,GACzI,aACAloC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU84B,KAAOyL,EAAOzL,OAGpD58B,OAAO,0BAA0B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAASooC,GACzG,aACAnoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoCtDH,EAAQ68B,SAHR,SAAkBzqB,GACd,OAAOg2B,EAAWvL,SAASzqB,EAApBg2B,CAA2BzmC,SAK1C7B,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAc2+B,GACjJ,aACAnoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUi5B,SAAWuL,EAAWvL,WAG5D/8B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASqoC,GAC3G,aACApoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgBtDH,EAAQs9B,UAHR,SAAmBtD,GACf,OAAOqO,EAAY/K,UAAUtD,EAAtBqO,CAAgC1mC,SAK/C7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAc4+B,GACnJ,aACApoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU05B,UAAY+K,EAAY/K,YAG9Dx9B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASsoC,GAC3G,aACAroC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgBtDH,EAAQ09B,UAHR,SAAmBpR,GACf,OAAOgc,EAAY5K,UAAUpR,EAAtBgc,CAAiC3mC,SAKhD7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAc6+B,GACnJ,aACAroC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU85B,UAAY4K,EAAY5K,YAG9D59B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASuoC,GAC3G,aACAtoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAuBtDH,EAAQ+9B,UAPR,WAEI,IAAK,IADD5V,KACKrgB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCqgB,EAAMrgB,GAAMlG,UAAUkG,GAE1B,OAAOygC,EAAYxK,UAAUr8B,WAAM,EAAQymB,EAApCogB,CAA2C5mC,SAK1D7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAc8+B,GACnJ,aACAtoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUm6B,UAAYwK,EAAYxK,YAG9Dj+B,OAAO,yCAAyC,UAAW,UAAW,QAAS,gBAAiB,oBAAqB,qBAAsB,SAAUC,EAASC,EAAS6B,EAAS4H,EAAcyqC,EAAQlwB,GAClM,aACA/jB,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAMtD,IAAIg0C,EAAuC,SAAUpyC,GAEjD,SAASoyC,EAAsB3rC,EAAQ4rC,EAAW3pC,QAC5B,IAAd2pC,IAAwBA,EAAY,QACtB,IAAd3pC,IAAwBA,EAAYypC,EAAOp0B,MAC/C,IAAI7d,EAAQF,EAAOG,KAAKP,OAASA,KAUjC,OATAM,EAAMuG,OAASA,EACfvG,EAAMmyC,UAAYA,EAClBnyC,EAAMwI,UAAYA,IACbuZ,EAAYN,UAAU0wB,IAAcA,EAAY,KACjDnyC,EAAMmyC,UAAY,GAEjB3pC,GAA2C,mBAAvBA,EAAUE,WAC/B1I,EAAMwI,UAAYypC,EAAOp0B,MAEtB7d,EAmBX,OAjCAJ,EAAQc,UAAUwxC,EAAuBpyC,GAgBzCoyC,EAAsBhuC,OAAS,SAAUqC,EAAQqC,EAAOJ,GAGpD,YAFc,IAAVI,IAAoBA,EAAQ,QACd,IAAdJ,IAAwBA,EAAYypC,EAAOp0B,MACxC,IAAIq0B,EAAsB3rC,EAAQqC,EAAOJ,IAEpD0pC,EAAsBlmC,SAAW,SAAUC,GACvC,IAAI1F,EAAS0F,EAAI1F,OAAQpC,EAAa8H,EAAI9H,WAC1C,OAAOzE,KAAKyC,IAAIoE,EAAOL,UAAU/B,KAErC+tC,EAAsBvwC,UAAUyE,WAAa,SAAUjC,GACnD,IAAIyE,EAAQlJ,KAAKyyC,UACb5rC,EAAS7G,KAAK6G,OAElB,OADgB7G,KAAK8I,UACJE,SAASwpC,EAAsBlmC,SAAUpD,GACtDrC,OAAQA,EAAQpC,WAAYA,KAG7B+tC,EAlC+B,CAmCxC1qC,EAAavB,YACflI,EAAQm0C,sBAAwBA,IAGpCr0C,OAAO,8BAA8B,UAAW,UAAW,uCAAwC,SAAUC,EAASC,EAASq0C,GAC3H,aACAp0C,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAkBtDH,EAAQs0C,YANR,SAAqB7pC,EAAWI,GAE5B,YADc,IAAVA,IAAoBA,EAAQ,GACzB,SAAqCrC,GACxC,OAAOA,EAAOF,KAAK,IAAIisC,EAAoB9pC,EAAWI,MAI9D,IAAI0pC,EAAqC,WACrC,SAASA,EAAoB9pC,EAAWI,GACpClJ,KAAK8I,UAAYA,EACjB9I,KAAKkJ,MAAQA,EAKjB,OAHA0pC,EAAoB3wC,UAAU1B,KAAO,SAAUkE,EAAYoC,GACvD,OAAO,IAAI6rC,EAAwBF,sBAAsB3rC,EAAQ7G,KAAKkJ,MAAOlJ,KAAK8I,WAAWtC,UAAU/B,IAEpGmuC,EAR6B,KAY5Cz0C,OAAO,6BAA6B,UAAW,UAAW,4BAA6B,SAAUC,EAASC,EAASw0C,GAC/G,aACAv0C,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAgBtDH,EAAQs0C,YAJR,SAAqB7pC,EAAWI,GAE5B,YADc,IAAVA,IAAoBA,EAAQ,GACzB2pC,EAAcF,YAAY7pC,EAAWI,EAArC2pC,CAA4C7yC,SAK3D7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAc+qC,GACvJ,aACAv0C,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU0wC,YAAcE,EAAcF,cAGlEx0C,OAAO,wBAAwB,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASwoC,GACxG,aACAvoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA8CtDH,EAAQy0C,QAHR,WACI,OAAOjM,EAAYnK,WAAZmK,CAAwB7mC,SAKvC7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAcirC,GAC7I,aACAz0C,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+wC,OAASD,EAASD,QACpDhrC,EAAavB,WAAWtE,UAAU6wC,QAAUC,EAASD,UAGzD30C,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAASo+B,GAC3G,aACAn+B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAoDtDH,EAAQg+B,UAHR,SAAmBjsB,EAASkZ,GACxB,OAAOmT,EAAYJ,UAAUjsB,EAASkZ,EAA/BmT,CAA+Cz8B,SAK9D7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAc20B,GACnJ,aACAn+B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUo6B,UAAYI,EAAYJ,YAG9Dl+B,OAAO,6BAA6B,UAAW,UAAW,4BAA6B,SAAUC,EAASC,EAASyoC,GAC/G,aACAxoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+CtDH,EAAQs+B,YAHR,SAAqBjS,EAAiBpB,GAClC,OAAOwd,EAAcnK,YAAYjS,EAAiBpB,EAA3Cwd,CAA2D9mC,SAK1E7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAcg/B,GACvJ,aACAxoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU06B,YAAcmK,EAAcnK,cAGlEx+B,OAAO,sBAAsB,UAAW,UAAW,qBAAsB,SAAUC,EAASC,EAAS0oC,GACjG,aACAzoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqCtDH,EAAQ2+B,KAHR,SAAcvsB,GACV,OAAOs2B,EAAO/J,KAAKvsB,EAAZs2B,CAAmB/mC,SAKlC7B,OAAO,0BAA0B,UAAW,UAAW,mBAAoB,uBAAwB,SAAUC,EAASC,EAASyJ,EAAci/B,GACzI,aACAzoC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU+6B,KAAO+J,EAAO/J,OAGpD7+B,OAAO,0BAA0B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAASs2B,GACzG,aACAr2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwCtDH,EAAQg2B,SAHR,SAAkB5jB,GACd,OAAOkkB,EAAWN,SAAS5jB,EAApBkkB,CAA2B30B,SAK1C7B,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAc6sB,GACjJ,aACAr2B,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUoyB,SAAWM,EAAWN,WAG5Dl2B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAAS2oC,GAC3G,aACA1oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqCtDH,EAAQ8+B,UAHR,SAAmB9E,GACf,OAAO2O,EAAY7J,UAAU9E,EAAtB2O,CAAgChnC,SAK/C7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAck/B,GACnJ,aACA1oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUk7B,UAAY6J,EAAY7J,YAG9Dh/B,OAAO,2BAA2B,UAAW,UAAW,0BAA2B,SAAUC,EAASC,EAAS4oC,GAC3G,aACA3oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwCtDH,EAAQi/B,UAHR,SAAmB3S,GACf,OAAOsc,EAAY3J,UAAU3S,EAAtBsc,CAAiCjnC,SAKhD7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAcm/B,GACnJ,aACA3oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUq7B,UAAY2J,EAAY3J,YAG9Dn/B,OAAO,0BAA0B,UAAW,UAAW,yBAA0B,SAAUC,EAASC,EAASsgC,GACzG,aACArgC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6CtDH,EAAQ6/B,SAJR,SAAkB1c,EAAkBra,GAEhC,YADe,IAAXA,IAAqBA,EAASw3B,EAAWZ,uBACtCY,EAAWT,SAAS1c,EAAkBra,EAAtCw3B,CAA8C3+B,SAK7D7B,OAAO,8BAA8B,UAAW,UAAW,mBAAoB,2BAA4B,SAAUC,EAASC,EAASyJ,EAAc62B,GACjJ,aACArgC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUi8B,SAAWS,EAAWT,WAG5D//B,OAAO,8BAA8B,UAAW,UAAW,qBAAsB,wBAAyB,6BAA8B,SAAUC,EAASC,EAASsR,EAASgvB,EAAYwI,GACrL,aACA7oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6CtDH,EAAQugC,aALR,SAAsBhd,EAAU9Y,EAAW3B,GAGvC,YAFkB,IAAd2B,IAAwBA,EAAY6G,EAAQD,YACjC,IAAXvI,IAAqBA,EAASw3B,EAAWZ,uBACtCoJ,EAAevI,aAAahd,EAAU9Y,EAAW3B,EAAjDggC,CAAyDnnC,SAKxE7B,OAAO,kCAAkC,UAAW,UAAW,mBAAoB,+BAAgC,SAAUC,EAASC,EAASyJ,EAAcq/B,GACzJ,aACA7oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU28B,aAAeuI,EAAevI,eAGpEzgC,OAAO,kCAAkC,UAAW,UAAW,mBAAoB,+BAAgC,SAAUC,EAASC,EAASyJ,EAAcqI,GACzJ,aACA7R,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU2N,aAAeO,EAAeP,eAGpEzR,OAAO,yBAAyB,UAAW,UAAW,qBAAsB,wBAAyB,SAAUC,EAASC,EAASsR,EAASy3B,GACtI,aACA9oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsEtDH,EAAQoZ,QAJR,SAAiBunB,EAAKl2B,GAElB,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzC03B,EAAU3vB,QAAQunB,EAAKl2B,EAAvBs+B,CAAkCpnC,SAKjD7B,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcs/B,GAC/I,aACA9oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUwV,QAAU2vB,EAAU3vB,UAG1DtZ,OAAO,6BAA6B,UAAW,UAAW,qBAAsB,4BAA6B,SAAUC,EAASC,EAASsR,EAAS03B,GAC9I,aACA/oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQmhC,YAJR,SAAqBR,EAAKS,EAAgB32B,GAEtC,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzC23B,EAAc7H,YAAYR,EAAKS,EAAgB32B,EAA/Cu+B,CAA0DrnC,SAKzE7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAcu/B,GACvJ,aACA/oC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUu9B,YAAc6H,EAAc7H,cAGlErhC,OAAO,2BAA2B,UAAW,UAAW,qBAAsB,0BAA2B,SAAUC,EAASC,EAASsR,EAAS23B,GAC1I,aACAhpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAWtDH,EAAQuS,UAJR,SAAmB9H,GAEf,YADkB,IAAdA,IAAwBA,EAAY6G,EAAQD,OACzC43B,EAAY12B,UAAU9H,EAAtBw+B,CAAiCtnC,SAKhD7B,OAAO,+BAA+B,UAAW,UAAW,mBAAoB,4BAA6B,SAAUC,EAASC,EAASyJ,EAAcw/B,GACnJ,aACAhpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU2O,UAAY02B,EAAY12B,YAG9DzS,OAAO,yBAAyB,UAAW,UAAW,wBAAyB,SAAUC,EAASC,EAASkpC,GACvG,aACAjpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA2BtDH,EAAQuhC,QAHR,WACI,OAAO2H,EAAU3H,SAAV2H,CAAoBvnC,SAKnC7B,OAAO,6BAA6B,UAAW,UAAW,mBAAoB,0BAA2B,SAAUC,EAASC,EAASyJ,EAAcy/B,GAC/I,aACAjpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU29B,QAAU2H,EAAU3H,UAM1DzhC,OAAO,8BAA+B,cAEtCA,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASsiC,GACrG,aACAriC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAwCtDH,EAAQK,OAHR,SAAgBmhC,GACZ,OAAOc,EAASjiC,OAAOmhC,EAAhBc,CAAkC3gC,SAKjD7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAc64B,GAC7I,aACAriC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUvD,OAASiiC,EAASjiC,SAGxDP,OAAO,6BAA6B,UAAW,UAAW,4BAA6B,SAAUC,EAASC,EAASmpC,GAC/G,aACAlpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAqDtDH,EAAQgiC,YAJR,SAAqBC,EAAYC,GAE7B,YADyB,IAArBA,IAA+BA,EAAmB,GAC/CiH,EAAcnH,YAAYC,EAAYC,EAAtCiH,CAAwDxnC,SAKvE7B,OAAO,iCAAiC,UAAW,UAAW,mBAAoB,8BAA+B,SAAUC,EAASC,EAASyJ,EAAc0/B,GACvJ,aACAlpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUo+B,YAAcmH,EAAcnH,cAGlEliC,OAAO,4BAA4B,UAAW,UAAW,qBAAsB,oBAAqB,sBAAuB,2BAA4B,SAAUC,EAASC,EAASsR,EAAS0S,EAAaC,EAAemlB,GACpN,aACAnpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAsBtDH,EAAQ0O,WArBR,SAAoB+zB,GAChB,IAAIh4B,EAAY6G,EAAQD,MACpBqxB,EAAyB,KACzBC,EAAgBh0B,OAAOC,kBAgB3B,OAfIqV,EAAcJ,YAAYjiB,UAAU,MACpC6I,EAAY7I,UAAU,IAEtBqiB,EAAcJ,YAAYjiB,UAAU,IACpC6I,EAAY7I,UAAU,GAEjBoiB,EAAYN,UAAU9hB,UAAU,MACrC+gC,EAAgB/gC,UAAU,IAE1BqiB,EAAcJ,YAAYjiB,UAAU,IACpC6I,EAAY7I,UAAU,GAEjBoiB,EAAYN,UAAU9hB,UAAU,MACrC8gC,EAAyB9gC,UAAU,IAEhCwnC,EAAa16B,WAAW+zB,EAAgBC,EAAwBC,EAAel4B,EAA/E2+B,CAA0FznC,SAKzG7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAc2/B,GACrJ,aACAnpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU8K,WAAa06B,EAAa16B,aAGhE5O,OAAO,8BAA8B,UAAW,UAAW,6BAA8B,SAAUC,EAASC,EAASqpC,GACjH,aACAppC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA6CtDH,EAAQmjC,aAHR,SAAsBvc,EAAUC,GAC5B,OAAOwiB,EAAelG,aAAavc,EAAUC,EAAtCwiB,CAAuD1nC,SAKtE7B,OAAO,kCAAkC,UAAW,UAAW,mBAAoB,+BAAgC,SAAUC,EAASC,EAASyJ,EAAc4/B,GACzJ,aACAppC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUu/B,aAAekG,EAAelG,eAGpErjC,OAAO,4BAA4B,UAAW,UAAW,2BAA4B,SAAUC,EAASC,EAASspC,GAC7G,aACArpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA0CtDH,EAAQujC,WAHR,SAAoB1c,GAChB,OAAOyiB,EAAa/F,WAAW1c,EAAxByiB,CAAyC3nC,SAKxD7B,OAAO,gCAAgC,UAAW,UAAW,mBAAoB,6BAA8B,SAAUC,EAASC,EAASyJ,EAAc6/B,GACrJ,aACArpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU2/B,WAAa+F,EAAa/F,aAGhEzjC,OAAO,gCAAgC,UAAW,UAAW,+BAAgC,SAAUC,EAASC,EAASupC,GACrH,aACAtpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IA+CtDH,EAAQ0jC,eAPR,WAEI,IAAK,IADDzlB,KACKnW,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpCmW,EAAKnW,GAAMlG,UAAUkG,GAEzB,OAAOyhC,EAAiB7F,eAAehiC,WAAM,EAAQuc,EAA9CsrB,CAAoD5nC,SAKnE7B,OAAO,oCAAoC,UAAW,UAAW,mBAAoB,iCAAkC,SAAUC,EAASC,EAASyJ,EAAc8/B,GAC7J,aACAtpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAU8/B,eAAiB6F,EAAiB7F,iBAGxE5jC,OAAO,qBAAqB,UAAW,UAAW,oBAAqB,SAAUC,EAASC,EAAS2kC,GAC/F,aACA1kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAetDH,EAAQ40C,SAPR,WAEI,IAAK,IADDpsB,KACK1gB,EAAK,EAAGA,EAAKlG,UAAUV,OAAQ4G,IACpC0gB,EAAY1gB,GAAMlG,UAAUkG,GAEhC,OAAO68B,EAAMX,IAAItiC,WAAM,EAAQ8mB,EAAxBmc,CAAqChjC,SAKpD7B,OAAO,yBAAyB,UAAW,UAAW,mBAAoB,sBAAuB,SAAUC,EAASC,EAASyJ,EAAck7B,GACvI,aACA1kC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUogC,IAAMW,EAAMiQ,WAGlD90C,OAAO,wBAAwB,UAAW,UAAW,uBAAwB,SAAUC,EAASC,EAASwpC,GACrG,aACAvpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IAUtDH,EAAQ4kC,OAHR,SAAgB7yB,GACZ,OAAOy3B,EAAS5E,OAAO7yB,EAAhBy3B,CAAyB7nC,SAKxC7B,OAAO,4BAA4B,UAAW,UAAW,mBAAoB,yBAA0B,SAAUC,EAASC,EAASyJ,EAAc+/B,GAC7I,aACAvpC,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDsJ,EAAavB,WAAWtE,UAAUghC,OAAS4E,EAAS5E,SAGxD9kC,OAAO,WAAW,UAAW,UAAW,YAAa,eAAgB,iBAAkB,eAAgB,iBAAkB,kBAAmB,oBAAqB,qCAAsC,iBAAkB,oBAAqB,iCAAkC,iCAAkC,sBAAuB,6BAA8B,0BAA2B,wBAAyB,0BAA2B,mCAAoC,kCAAmC,cAAe,mBAAoB,oBAAqB,oBAAqB,6BAA8B,wBAAyB,oBAAqB,sBAAuB,cAAe,gCAAiC,oCAAqC,iCAAkC,0BAA2B,yBAA0B,yBAA0B,4BAA6B,wBAAyB,6BAA8B,oCAAqC,+BAAgC,4BAA6B,sBAAuB,4BAA6B,yBAA0B,wBAAyB,yBAA0B,sBAAuB,qCAAsC,yBAA0B,yBAA0B,yBAA0B,yBAA0B,yBAA0B,uBAAwB,4BAA6B,iCAAkC,wBAAyB,6BAA8B,4BAA6B,8BAA+B,4BAA6B,uBAAwB,4BAA6B,+BAAgC,wBAAyB,2BAA4B,2BAA4B,6BAA8B,uBAAwB,+BAAgC,0BAA2B,8BAA+B,gCAAiC,uBAAwB,2BAA4B,0BAA2B,sCAAuC,yCAA0C,oBAAqB,yBAA0B,4BAA6B,wBAAyB,2BAA4B,wBAAyB,yBAA0B,sBAAuB,2BAA4B,uBAAwB,yBAA0B,gCAAiC,yBAA0B,uBAAwB,2BAA4B,sBAAuB,qBAAsB,uBAAwB,qBAAsB,uBAAwB,6BAA8B,qBAAsB,uBAAwB,0BAA2B,0BAA2B,4BAA6B,2BAA4B,qBAAsB,2BAA4B,2BAA4B,mCAAoC,0BAA2B,2BAA4B,uBAAwB,yBAA0B,iCAAkC,+BAAgC,6BAA8B,sBAAuB,wBAAyB,wBAAyB,4BAA6B,uBAAwB,2BAA4B,wBAAyB,4BAA6B,sBAAuB,+BAAgC,uBAAwB,6BAA8B,wBAAyB,sBAAuB,0BAA2B,2BAA4B,2BAA4B,2BAA4B,6BAA8B,wBAAyB,2BAA4B,6BAA8B,sBAAuB,0BAA2B,2BAA4B,2BAA4B,0BAA2B,8BAA+B,8BAA+B,yBAA0B,6BAA8B,2BAA4B,yBAA0B,2BAA4B,wBAAyB,6BAA8B,4BAA6B,8BAA+B,4BAA6B,gCAAiC,qBAAsB,yBAA0B,SAAUC,EAASC,EAASoK,EAAWX,EAAcjE,EAAgByB,EAAciyB,EAAgBE,EAAiBJ,EAAmB5B,EAAyBvpB,EAAgB8kB,EAAcjC,EAA2BhnB,EAA2Bg3B,EAAgB19B,EAAuB8O,EAAgBm3B,EAAa4L,EAAiB9/B,EAAwBi8B,EAAkB/oC,EAAQisC,EAAQ5iC,EAAShD,EAASwmC,EAAkBpvC,EAAgB+c,EAAYza,EAAc+sC,GAChoJ,aACA90C,OAAOC,eAAeF,EAAS,cAAgBG,OAAO,IACtDH,EAAQ6J,QAAUO,EAAUP,QAC5B7J,EAAQgK,iBAAmBI,EAAUJ,iBACrChK,EAAQkI,WAAauB,EAAavB,WAClClI,EAAQqD,aAAemC,EAAenC,aACtCrD,EAAQ2F,WAAasB,EAAatB,WAClC3F,EAAQqK,aAAe6uB,EAAe7uB,aACtCrK,EAAQwO,cAAgB4qB,EAAgB5qB,cACxCxO,EAAQwP,gBAAkBwpB,EAAkBxpB,gBAC5CxP,EAAQyQ,sBAAwB2mB,EAAwB3mB,sBACxDzQ,EAAQ8M,aAAee,EAAef,aACtC9M,EAAQkR,WAAayhB,EAAazhB,WAClClR,EAAQmR,wBAA0Buf,EAA0Bvf,wBAC5DnR,EAAQoJ,wBAA0BM,EAA0BN,wBAC5DpJ,EAAQoR,aAAesvB,EAAetvB,aACtCpR,EAAQ8B,oBAAsBkB,EAAsBlB,oBACpD9B,EAAQyR,aAAeK,EAAeL,aACtCzR,EAAQwS,UAAYy2B,EAAYz2B,UAChCxS,EAAQiV,cAAgB4/B,EAAgB5/B,cACxCjV,EAAQqU,qBAAuBU,EAAuBV,qBACtDrU,EAAQia,aAAe+2B,EAAiB/2B,aACxCja,EAAQub,UAAYy1B,EAAiBz1B,UACrCvb,EAAQkb,iBAAmB81B,EAAiB91B,iBAC5Clb,EAAQ6H,KAAOI,EAAOJ,KACtB7H,EAAQg1C,UAAYD,EAepB,IAAIhpC,GACA+T,KAAMo0B,EAAOp0B,KACbjT,MAAOyB,EAAQzB,MACfqU,eAAgB4zB,EAAiB5zB,eACjC7P,MAAOC,EAAQD,OAEnBrR,EAAQ+L,UAAYA,EAcpB,IAAI3G,GACAC,aAAcK,EAAeL,aAC7BiC,WAAYU,EAAaV,WACzB8Z,SAAUqB,EAAWrB,UAEzBphB,EAAQoF,OAASA","file":"rxjs.min.js","sourcesContent":["define('rxjs/util/root',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // CommonJS / Node have global context exposed as \"global\" variable.\n    // We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n    // the global \"global\" var for now.\n    var __window = typeof window !== 'undefined' && window;\n    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self;\n    var __global = typeof global !== 'undefined' && global;\n    var _root = __window || __global || __self;\n    exports.root = _root;\n    // Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n    // This is needed when used with angular/tsickle which inserts a goog.module statement.\n    // Wrap in IIFE\n    (function () {\n        if (!_root) {\n            throw new Error('RxJS could not find any global context (window, self, global)');\n        }\n    })();\n});\n\ndefine('rxjs/util/isFunction',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isFunction(x) {\n        return typeof x === 'function';\n    }\n    exports.isFunction = isFunction;\n});\n\ndefine('rxjs/util/isArray',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n});\n\ndefine('rxjs/util/isObject',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isObject(x) {\n        return x != null && typeof x === 'object';\n    }\n    exports.isObject = isObject;\n});\n\ndefine('rxjs/util/errorObject',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // typeof any so that it we don't have to cast when comparing a result to the error object\n    exports.errorObject = { e: {} };\n});\n\ndefine('rxjs/util/tryCatch',[\"require\", \"exports\", \"./errorObject\"], function (require, exports, errorObject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var tryCatchTarget;\n    function tryCatcher() {\n        try {\n            return tryCatchTarget.apply(this, arguments);\n        }\n        catch (e) {\n            errorObject_1.errorObject.e = e;\n            return errorObject_1.errorObject;\n        }\n    }\n    function tryCatch(fn) {\n        tryCatchTarget = fn;\n        return tryCatcher;\n    }\n    exports.tryCatch = tryCatch;\n    ;\n});\n\ndefine('rxjs/util/UnsubscriptionError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when one or more errors have occurred during the\n     * `unsubscribe` of a {@link Subscription}.\n     */\n    var UnsubscriptionError = /** @class */ (function (_super) {\n        tslib_1.__extends(UnsubscriptionError, _super);\n        function UnsubscriptionError(errors) {\n            var _this = _super.call(this) || this;\n            _this.errors = errors;\n            var err = Error.call(_this, errors ?\n                errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ') : '');\n            _this.name = err.name = 'UnsubscriptionError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return UnsubscriptionError;\n    }(Error));\n    exports.UnsubscriptionError = UnsubscriptionError;\n});\n\ndefine('rxjs/Subscription',[\"require\", \"exports\", \"./util/isArray\", \"./util/isObject\", \"./util/isFunction\", \"./util/tryCatch\", \"./util/errorObject\", \"./util/UnsubscriptionError\"], function (require, exports, isArray_1, isObject_1, isFunction_1, tryCatch_1, errorObject_1, UnsubscriptionError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represents a disposable resource, such as the execution of an Observable. A\n     * Subscription has one important method, `unsubscribe`, that takes no argument\n     * and just disposes the resource held by the subscription.\n     *\n     * Additionally, subscriptions may be grouped together through the `add()`\n     * method, which will attach a child Subscription to the current Subscription.\n     * When a Subscription is unsubscribed, all its children (and its grandchildren)\n     * will be unsubscribed as well.\n     *\n     * @class Subscription\n     */\n    var Subscription = /** @class */ (function () {\n        /**\n         * @param {function(): void} [unsubscribe] A function describing how to\n         * perform the disposal of resources when the `unsubscribe` method is called.\n         */\n        function Subscription(unsubscribe) {\n            /**\n             * A flag to indicate whether this Subscription has already been unsubscribed.\n             * @type {boolean}\n             */\n            this.closed = false;\n            this._parent = null;\n            this._parents = null;\n            this._subscriptions = null;\n            if (unsubscribe) {\n                this._unsubscribe = unsubscribe;\n            }\n        }\n        /**\n         * Disposes the resources held by the subscription. May, for instance, cancel\n         * an ongoing Observable execution or cancel any other type of work that\n         * started when the Subscription was created.\n         * @return {void}\n         */\n        Subscription.prototype.unsubscribe = function () {\n            var hasErrors = false;\n            var errors;\n            if (this.closed) {\n                return;\n            }\n            var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n            this.closed = true;\n            this._parent = null;\n            this._parents = null;\n            // null out _subscriptions first so any child subscriptions that attempt\n            // to remove themselves from this subscription will noop\n            this._subscriptions = null;\n            var index = -1;\n            var len = _parents ? _parents.length : 0;\n            // if this._parent is null, then so is this._parents, and we\n            // don't have to remove ourselves from any parent subscriptions.\n            while (_parent) {\n                _parent.remove(this);\n                // if this._parents is null or index >= len,\n                // then _parent is set to null, and the loop exits\n                _parent = ++index < len && _parents[index] || null;\n            }\n            if (isFunction_1.isFunction(_unsubscribe)) {\n                var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n                if (trial === errorObject_1.errorObject) {\n                    hasErrors = true;\n                    errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                        flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n                }\n            }\n            if (isArray_1.isArray(_subscriptions)) {\n                index = -1;\n                len = _subscriptions.length;\n                while (++index < len) {\n                    var sub = _subscriptions[index];\n                    if (isObject_1.isObject(sub)) {\n                        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                        if (trial === errorObject_1.errorObject) {\n                            hasErrors = true;\n                            errors = errors || [];\n                            var err = errorObject_1.errorObject.e;\n                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                                errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n            }\n            if (hasErrors) {\n                throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n            }\n        };\n        /**\n         * Adds a tear down to be called during the unsubscribe() of this\n         * Subscription.\n         *\n         * If the tear down being added is a subscription that is already\n         * unsubscribed, is the same reference `add` is being called on, or is\n         * `Subscription.EMPTY`, it will not be added.\n         *\n         * If this subscription is already in an `closed` state, the passed\n         * tear down logic will be executed immediately.\n         *\n         * @param {TeardownLogic} teardown The additional logic to execute on\n         * teardown.\n         * @return {Subscription} Returns the Subscription used or created to be\n         * added to the inner subscriptions list. This Subscription can be used with\n         * `remove()` to remove the passed teardown logic from the inner subscriptions\n         * list.\n         */\n        Subscription.prototype.add = function (teardown) {\n            if (!teardown || (teardown === Subscription.EMPTY)) {\n                return Subscription.EMPTY;\n            }\n            if (teardown === this) {\n                return this;\n            }\n            var subscription = teardown;\n            switch (typeof teardown) {\n                case 'function':\n                    subscription = new Subscription(teardown);\n                case 'object':\n                    if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                        return subscription;\n                    }\n                    else if (this.closed) {\n                        subscription.unsubscribe();\n                        return subscription;\n                    }\n                    else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                        var tmp = subscription;\n                        subscription = new Subscription();\n                        subscription._subscriptions = [tmp];\n                    }\n                    break;\n                default:\n                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n            }\n            var subscriptions = this._subscriptions || (this._subscriptions = []);\n            subscriptions.push(subscription);\n            subscription._addParent(this);\n            return subscription;\n        };\n        /**\n         * Removes a Subscription from the internal list of subscriptions that will\n         * unsubscribe during the unsubscribe process of this Subscription.\n         * @param {Subscription} subscription The subscription to remove.\n         * @return {void}\n         */\n        Subscription.prototype.remove = function (subscription) {\n            var subscriptions = this._subscriptions;\n            if (subscriptions) {\n                var subscriptionIndex = subscriptions.indexOf(subscription);\n                if (subscriptionIndex !== -1) {\n                    subscriptions.splice(subscriptionIndex, 1);\n                }\n            }\n        };\n        Subscription.prototype._addParent = function (parent) {\n            var _a = this, _parent = _a._parent, _parents = _a._parents;\n            if (!_parent || _parent === parent) {\n                // If we don't have a parent, or the new parent is the same as the\n                // current parent, then set this._parent to the new parent.\n                this._parent = parent;\n            }\n            else if (!_parents) {\n                // If there's already one parent, but not multiple, allocate an Array to\n                // store the rest of the parent Subscriptions.\n                this._parents = [parent];\n            }\n            else if (_parents.indexOf(parent) === -1) {\n                // Only add the new parent to the _parents list if it's not already there.\n                _parents.push(parent);\n            }\n        };\n        Subscription.EMPTY = (function (empty) {\n            empty.closed = true;\n            return empty;\n        }(new Subscription()));\n        return Subscription;\n    }());\n    exports.Subscription = Subscription;\n    function flattenUnsubscriptionErrors(errors) {\n        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n    }\n});\n\ndefine('rxjs/Observer',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.empty = {\n        closed: true,\n        next: function (value) { },\n        error: function (err) { throw err; },\n        complete: function () { }\n    };\n});\n\ndefine('rxjs/symbol/rxSubscriber',[\"require\", \"exports\", \"../util/root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Symbol = root_1.root.Symbol;\n    exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n        Symbol.for('rxSubscriber') : '@@rxSubscriber';\n    /**\n     * @deprecated use rxSubscriber instead\n     */\n    exports.$$rxSubscriber = exports.rxSubscriber;\n});\n\ndefine('rxjs/Subscriber',[\"require\", \"exports\", \"tslib\", \"./util/isFunction\", \"./Subscription\", \"./Observer\", \"./symbol/rxSubscriber\"], function (require, exports, tslib_1, isFunction_1, Subscription_1, Observer_1, rxSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Implements the {@link Observer} interface and extends the\n     * {@link Subscription} class. While the {@link Observer} is the public API for\n     * consuming the values of an {@link Observable}, all Observers get converted to\n     * a Subscriber, in order to provide Subscription-like capabilities such as\n     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n     * implementing operators, but it is rarely used as a public API.\n     *\n     * @class Subscriber<T>\n     */\n    var Subscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(Subscriber, _super);\n        /**\n         * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n         * defined Observer or a `next` callback function.\n         * @param {function(e: ?any): void} [error] The `error` callback of an\n         * Observer.\n         * @param {function(): void} [complete] The `complete` callback of an\n         * Observer.\n         */\n        function Subscriber(destinationOrNext, error, complete) {\n            var _this = _super.call(this) || this;\n            _this.syncErrorValue = null;\n            _this.syncErrorThrown = false;\n            _this.syncErrorThrowable = false;\n            _this.isStopped = false;\n            switch (arguments.length) {\n                case 0:\n                    _this.destination = Observer_1.empty;\n                    break;\n                case 1:\n                    if (!destinationOrNext) {\n                        _this.destination = Observer_1.empty;\n                        break;\n                    }\n                    if (typeof destinationOrNext === 'object') {\n                        if (destinationOrNext instanceof Subscriber) {\n                            _this.destination = destinationOrNext;\n                            _this.destination.add(_this);\n                        }\n                        else {\n                            _this.syncErrorThrowable = true;\n                            _this.destination = new SafeSubscriber(_this, destinationOrNext);\n                        }\n                        break;\n                    }\n                default:\n                    _this.syncErrorThrowable = true;\n                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n                    break;\n            }\n            return _this;\n        }\n        Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };\n        /**\n         * A static factory for a Subscriber, given a (potentially partial) definition\n         * of an Observer.\n         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n         * @param {function(e: ?any): void} [error] The `error` callback of an\n         * Observer.\n         * @param {function(): void} [complete] The `complete` callback of an\n         * Observer.\n         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n         * Observer represented by the given arguments.\n         */\n        Subscriber.create = function (next, error, complete) {\n            var subscriber = new Subscriber(next, error, complete);\n            subscriber.syncErrorThrowable = false;\n            return subscriber;\n        };\n        /**\n         * The {@link Observer} callback to receive notifications of type `next` from\n         * the Observable, with a value. The Observable may call this method 0 or more\n         * times.\n         * @param {T} [value] The `next` value.\n         * @return {void}\n         */\n        Subscriber.prototype.next = function (value) {\n            if (!this.isStopped) {\n                this._next(value);\n            }\n        };\n        /**\n         * The {@link Observer} callback to receive notifications of type `error` from\n         * the Observable, with an attached {@link Error}. Notifies the Observer that\n         * the Observable has experienced an error condition.\n         * @param {any} [err] The `error` exception.\n         * @return {void}\n         */\n        Subscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this._error(err);\n            }\n        };\n        /**\n         * The {@link Observer} callback to receive a valueless notification of type\n         * `complete` from the Observable. Notifies the Observer that the Observable\n         * has finished sending push-based notifications.\n         * @return {void}\n         */\n        Subscriber.prototype.complete = function () {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this._complete();\n            }\n        };\n        Subscriber.prototype.unsubscribe = function () {\n            if (this.closed) {\n                return;\n            }\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n        };\n        Subscriber.prototype._next = function (value) {\n            this.destination.next(value);\n        };\n        Subscriber.prototype._error = function (err) {\n            this.destination.error(err);\n            this.unsubscribe();\n        };\n        Subscriber.prototype._complete = function () {\n            this.destination.complete();\n            this.unsubscribe();\n        };\n        Subscriber.prototype._unsubscribeAndRecycle = function () {\n            var _a = this, _parent = _a._parent, _parents = _a._parents;\n            this._parent = null;\n            this._parents = null;\n            this.unsubscribe();\n            this.closed = false;\n            this.isStopped = false;\n            this._parent = _parent;\n            this._parents = _parents;\n            return this;\n        };\n        return Subscriber;\n    }(Subscription_1.Subscription));\n    exports.Subscriber = Subscriber;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SafeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SafeSubscriber, _super);\n        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n            var _this = _super.call(this) || this;\n            _this._parentSubscriber = _parentSubscriber;\n            var next;\n            var context = _this;\n            if (isFunction_1.isFunction(observerOrNext)) {\n                next = observerOrNext;\n            }\n            else if (observerOrNext) {\n                next = observerOrNext.next;\n                error = observerOrNext.error;\n                complete = observerOrNext.complete;\n                if (observerOrNext !== Observer_1.empty) {\n                    context = Object.create(observerOrNext);\n                    if (isFunction_1.isFunction(context.unsubscribe)) {\n                        _this.add(context.unsubscribe.bind(context));\n                    }\n                    context.unsubscribe = _this.unsubscribe.bind(_this);\n                }\n            }\n            _this._context = context;\n            _this._next = next;\n            _this._error = error;\n            _this._complete = complete;\n            return _this;\n        }\n        SafeSubscriber.prototype.next = function (value) {\n            if (!this.isStopped && this._next) {\n                var _parentSubscriber = this._parentSubscriber;\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._next, value);\n                }\n                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var _parentSubscriber = this._parentSubscriber;\n                if (this._error) {\n                    if (!_parentSubscriber.syncErrorThrowable) {\n                        this.__tryOrUnsub(this._error, err);\n                        this.unsubscribe();\n                    }\n                    else {\n                        this.__tryOrSetError(_parentSubscriber, this._error, err);\n                        this.unsubscribe();\n                    }\n                }\n                else if (!_parentSubscriber.syncErrorThrowable) {\n                    this.unsubscribe();\n                    throw err;\n                }\n                else {\n                    _parentSubscriber.syncErrorValue = err;\n                    _parentSubscriber.syncErrorThrown = true;\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.complete = function () {\n            var _this = this;\n            if (!this.isStopped) {\n                var _parentSubscriber = this._parentSubscriber;\n                if (this._complete) {\n                    var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                    if (!_parentSubscriber.syncErrorThrowable) {\n                        this.__tryOrUnsub(wrappedComplete);\n                        this.unsubscribe();\n                    }\n                    else {\n                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                        this.unsubscribe();\n                    }\n                }\n                else {\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n            try {\n                fn.call(this._context, value);\n            }\n            catch (err) {\n                this.unsubscribe();\n                throw err;\n            }\n        };\n        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n            try {\n                fn.call(this._context, value);\n            }\n            catch (err) {\n                parent.syncErrorValue = err;\n                parent.syncErrorThrown = true;\n                return true;\n            }\n            return false;\n        };\n        SafeSubscriber.prototype._unsubscribe = function () {\n            var _parentSubscriber = this._parentSubscriber;\n            this._context = null;\n            this._parentSubscriber = null;\n            _parentSubscriber.unsubscribe();\n        };\n        return SafeSubscriber;\n    }(Subscriber));\n});\n\ndefine('rxjs/util/toSubscriber',[\"require\", \"exports\", \"../Subscriber\", \"../symbol/rxSubscriber\", \"../Observer\"], function (require, exports, Subscriber_1, rxSubscriber_1, Observer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function toSubscriber(nextOrObserver, error, complete) {\n        if (nextOrObserver) {\n            if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n                return nextOrObserver;\n            }\n            if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {\n                return nextOrObserver[rxSubscriber_1.rxSubscriber]();\n            }\n        }\n        if (!nextOrObserver && !error && !complete) {\n            return new Subscriber_1.Subscriber(Observer_1.empty);\n        }\n        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n    }\n    exports.toSubscriber = toSubscriber;\n});\n\ndefine('rxjs/symbol/observable',[\"require\", \"exports\", \"../util/root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getSymbolObservable(context) {\n        var $$observable;\n        var Symbol = context.Symbol;\n        if (typeof Symbol === 'function') {\n            if (Symbol.observable) {\n                $$observable = Symbol.observable;\n            }\n            else {\n                $$observable = Symbol('observable');\n                Symbol.observable = $$observable;\n            }\n        }\n        else {\n            $$observable = '@@observable';\n        }\n        return $$observable;\n    }\n    exports.getSymbolObservable = getSymbolObservable;\n    exports.observable = getSymbolObservable(root_1.root);\n    /**\n     * @deprecated use observable instead\n     */\n    exports.$$observable = exports.observable;\n});\n\ndefine('rxjs/util/noop',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:disable:no-empty */\n    function noop() { }\n    exports.noop = noop;\n});\n\ndefine('rxjs/util/pipe',[\"require\", \"exports\", \"./noop\"], function (require, exports, noop_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    function pipe() {\n        var fns = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fns[_i] = arguments[_i];\n        }\n        return pipeFromArray(fns);\n    }\n    exports.pipe = pipe;\n    /* @internal */\n    function pipeFromArray(fns) {\n        if (!fns) {\n            return noop_1.noop;\n        }\n        if (fns.length === 1) {\n            return fns[0];\n        }\n        return function piped(input) {\n            return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n        };\n    }\n    exports.pipeFromArray = pipeFromArray;\n});\n\ndefine('rxjs/Observable',[\"require\", \"exports\", \"./util/root\", \"./util/toSubscriber\", \"./symbol/observable\", \"./util/pipe\"], function (require, exports, root_1, toSubscriber_1, observable_1, pipe_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A representation of any set of values over any amount of time. This is the most basic building block\n     * of RxJS.\n     *\n     * @class Observable<T>\n     */\n    var Observable = /** @class */ (function () {\n        /**\n         * @constructor\n         * @param {Function} subscribe the function that is called when the Observable is\n         * initially subscribed to. This function is given a Subscriber, to which new values\n         * can be `next`ed, or an `error` method can be called to raise an error, or\n         * `complete` can be called to notify of a successful completion.\n         */\n        function Observable(subscribe) {\n            this._isScalar = false;\n            if (subscribe) {\n                this._subscribe = subscribe;\n            }\n        }\n        /**\n         * Creates a new Observable, with this Observable as the source, and the passed\n         * operator defined as the new observable's operator.\n         * @method lift\n         * @param {Operator} operator the operator defining the operation to take on the observable\n         * @return {Observable} a new observable with the Operator applied\n         */\n        Observable.prototype.lift = function (operator) {\n            var observable = new Observable();\n            observable.source = this;\n            observable.operator = operator;\n            return observable;\n        };\n        /**\n         * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n         *\n         * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n         *\n         * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n         * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n         * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n         * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n         * thought.\n         *\n         * Apart from starting the execution of an Observable, this method allows you to listen for values\n         * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n         * following ways.\n         *\n         * The first way is creating an object that implements {@link Observer} interface. It should have methods\n         * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n         * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n         * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n         * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n         * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n         * be left uncaught.\n         *\n         * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n         * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n         * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n         * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n         * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n         * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n         *\n         * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n         * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n         * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n         * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n         *\n         * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n         * It is an Observable itself that decides when these functions will be called. For example {@link of}\n         * by default emits all its values synchronously. Always check documentation for how given Observable\n         * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n         *\n         * @example <caption>Subscribe with an Observer</caption>\n         * const sumObserver = {\n         *   sum: 0,\n         *   next(value) {\n         *     console.log('Adding: ' + value);\n         *     this.sum = this.sum + value;\n         *   },\n         *   error() { // We actually could just remove this method,\n         *   },        // since we do not really care about errors right now.\n         *   complete() {\n         *     console.log('Sum equals: ' + this.sum);\n         *   }\n         * };\n         *\n         * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n         * .subscribe(sumObserver);\n         *\n         * // Logs:\n         * // \"Adding: 1\"\n         * // \"Adding: 2\"\n         * // \"Adding: 3\"\n         * // \"Sum equals: 6\"\n         *\n         *\n         * @example <caption>Subscribe with functions</caption>\n         * let sum = 0;\n         *\n         * Rx.Observable.of(1, 2, 3)\n         * .subscribe(\n         *   function(value) {\n         *     console.log('Adding: ' + value);\n         *     sum = sum + value;\n         *   },\n         *   undefined,\n         *   function() {\n         *     console.log('Sum equals: ' + sum);\n         *   }\n         * );\n         *\n         * // Logs:\n         * // \"Adding: 1\"\n         * // \"Adding: 2\"\n         * // \"Adding: 3\"\n         * // \"Sum equals: 6\"\n         *\n         *\n         * @example <caption>Cancel a subscription</caption>\n         * const subscription = Rx.Observable.interval(1000).subscribe(\n         *   num => console.log(num),\n         *   undefined,\n         *   () => console.log('completed!') // Will not be called, even\n         * );                                // when cancelling subscription\n         *\n         *\n         * setTimeout(() => {\n         *   subscription.unsubscribe();\n         *   console.log('unsubscribed!');\n         * }, 2500);\n         *\n         * // Logs:\n         * // 0 after 1s\n         * // 1 after 2s\n         * // \"unsubscribed!\" after 2.5s\n         *\n         *\n         * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n         *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n         *  Observable.\n         * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n         *  the error will be thrown as unhandled.\n         * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n         * @return {ISubscription} a subscription reference to the registered handlers\n         * @method subscribe\n         */\n        Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n            var operator = this.operator;\n            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n            if (operator) {\n                operator.call(sink, this.source);\n            }\n            else {\n                sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));\n            }\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n            return sink;\n        };\n        Observable.prototype._trySubscribe = function (sink) {\n            try {\n                return this._subscribe(sink);\n            }\n            catch (err) {\n                sink.syncErrorThrown = true;\n                sink.syncErrorValue = err;\n                sink.error(err);\n            }\n        };\n        /**\n         * @method forEach\n         * @param {Function} next a handler for each value emitted by the observable\n         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n         * @return {Promise} a promise that either resolves on observable completion or\n         *  rejects with the handled error\n         */\n        Observable.prototype.forEach = function (next, PromiseCtor) {\n            var _this = this;\n            if (!PromiseCtor) {\n                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                    PromiseCtor = root_1.root.Rx.config.Promise;\n                }\n                else if (root_1.root.Promise) {\n                    PromiseCtor = root_1.root.Promise;\n                }\n            }\n            if (!PromiseCtor) {\n                throw new Error('no Promise impl found');\n            }\n            return new PromiseCtor(function (resolve, reject) {\n                // Must be declared in a separate statement to avoid a RefernceError when\n                // accessing subscription below in the closure due to Temporal Dead Zone.\n                var subscription;\n                subscription = _this.subscribe(function (value) {\n                    if (subscription) {\n                        // if there is a subscription, then we can surmise\n                        // the next handling is asynchronous. Any errors thrown\n                        // need to be rejected explicitly and unsubscribe must be\n                        // called manually\n                        try {\n                            next(value);\n                        }\n                        catch (err) {\n                            reject(err);\n                            subscription.unsubscribe();\n                        }\n                    }\n                    else {\n                        // if there is NO subscription, then we're getting a nexted\n                        // value synchronously during subscription. We can just call it.\n                        // If it errors, Observable's `subscribe` will ensure the\n                        // unsubscription logic is called, then synchronously rethrow the error.\n                        // After that, Promise will trap the error and send it\n                        // down the rejection path.\n                        next(value);\n                    }\n                }, reject, resolve);\n            });\n        };\n        Observable.prototype._subscribe = function (subscriber) {\n            return this.source.subscribe(subscriber);\n        };\n        /**\n         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n         * @method Symbol.observable\n         * @return {Observable} this instance of the observable\n         */\n        Observable.prototype[observable_1.observable] = function () {\n            return this;\n        };\n        /* tslint:enable:max-line-length */\n        /**\n         * Used to stitch together functional operators into a chain.\n         * @method pipe\n         * @return {Observable} the Observable result of all of the operators having\n         * been called in the order they were passed in.\n         *\n         * @example\n         *\n         * import { map, filter, scan } from 'rxjs/operators';\n         *\n         * Rx.Observable.interval(1000)\n         *   .pipe(\n         *     filter(x => x % 2 === 0),\n         *     map(x => x + x),\n         *     scan((acc, x) => acc + x)\n         *   )\n         *   .subscribe(x => console.log(x))\n         */\n        Observable.prototype.pipe = function () {\n            var operations = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                operations[_i] = arguments[_i];\n            }\n            if (operations.length === 0) {\n                return this;\n            }\n            return pipe_1.pipeFromArray(operations)(this);\n        };\n        /* tslint:enable:max-line-length */\n        Observable.prototype.toPromise = function (PromiseCtor) {\n            var _this = this;\n            if (!PromiseCtor) {\n                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                    PromiseCtor = root_1.root.Rx.config.Promise;\n                }\n                else if (root_1.root.Promise) {\n                    PromiseCtor = root_1.root.Promise;\n                }\n            }\n            if (!PromiseCtor) {\n                throw new Error('no Promise impl found');\n            }\n            return new PromiseCtor(function (resolve, reject) {\n                var value;\n                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n            });\n        };\n        // HACK: Since TypeScript inherits static properties too, we have to\n        // fight against TypeScript here so Subject can have a different static create signature\n        /**\n         * Creates a new cold Observable by calling the Observable constructor\n         * @static true\n         * @owner Observable\n         * @method create\n         * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n         * @return {Observable} a new cold observable\n         */\n        Observable.create = function (subscribe) {\n            return new Observable(subscribe);\n        };\n        return Observable;\n    }());\n    exports.Observable = Observable;\n});\n\ndefine('rxjs/util/ObjectUnsubscribedError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when an action is invalid because the object has been\n     * unsubscribed.\n     *\n     * @see {@link Subject}\n     * @see {@link BehaviorSubject}\n     *\n     * @class ObjectUnsubscribedError\n     */\n    var ObjectUnsubscribedError = /** @class */ (function (_super) {\n        tslib_1.__extends(ObjectUnsubscribedError, _super);\n        function ObjectUnsubscribedError() {\n            var _this = this;\n            var err = _this = _super.call(this, 'object unsubscribed') || this;\n            _this.name = err.name = 'ObjectUnsubscribedError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return ObjectUnsubscribedError;\n    }(Error));\n    exports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n});\n\ndefine('rxjs/SubjectSubscription',[\"require\", \"exports\", \"tslib\", \"./Subscription\"], function (require, exports, tslib_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SubjectSubscription = /** @class */ (function (_super) {\n        tslib_1.__extends(SubjectSubscription, _super);\n        function SubjectSubscription(subject, subscriber) {\n            var _this = _super.call(this) || this;\n            _this.subject = subject;\n            _this.subscriber = subscriber;\n            _this.closed = false;\n            return _this;\n        }\n        SubjectSubscription.prototype.unsubscribe = function () {\n            if (this.closed) {\n                return;\n            }\n            this.closed = true;\n            var subject = this.subject;\n            var observers = subject.observers;\n            this.subject = null;\n            if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n                return;\n            }\n            var subscriberIndex = observers.indexOf(this.subscriber);\n            if (subscriberIndex !== -1) {\n                observers.splice(subscriberIndex, 1);\n            }\n        };\n        return SubjectSubscription;\n    }(Subscription_1.Subscription));\n    exports.SubjectSubscription = SubjectSubscription;\n});\n\ndefine('rxjs/Subject',[\"require\", \"exports\", \"tslib\", \"./Observable\", \"./Subscriber\", \"./Subscription\", \"./util/ObjectUnsubscribedError\", \"./SubjectSubscription\", \"./symbol/rxSubscriber\"], function (require, exports, tslib_1, Observable_1, Subscriber_1, Subscription_1, ObjectUnsubscribedError_1, SubjectSubscription_1, rxSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class SubjectSubscriber<T>\n     */\n    var SubjectSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SubjectSubscriber, _super);\n        function SubjectSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            return _this;\n        }\n        return SubjectSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.SubjectSubscriber = SubjectSubscriber;\n    /**\n     * @class Subject<T>\n     */\n    var Subject = /** @class */ (function (_super) {\n        tslib_1.__extends(Subject, _super);\n        function Subject() {\n            var _this = _super.call(this) || this;\n            _this.observers = [];\n            _this.closed = false;\n            _this.isStopped = false;\n            _this.hasError = false;\n            _this.thrownError = null;\n            return _this;\n        }\n        Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\n            return new SubjectSubscriber(this);\n        };\n        Subject.prototype.lift = function (operator) {\n            var subject = new AnonymousSubject(this, this);\n            subject.operator = operator;\n            return subject;\n        };\n        Subject.prototype.next = function (value) {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            if (!this.isStopped) {\n                var observers = this.observers;\n                var len = observers.length;\n                var copy = observers.slice();\n                for (var i = 0; i < len; i++) {\n                    copy[i].next(value);\n                }\n            }\n        };\n        Subject.prototype.error = function (err) {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            this.hasError = true;\n            this.thrownError = err;\n            this.isStopped = true;\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].error(err);\n            }\n            this.observers.length = 0;\n        };\n        Subject.prototype.complete = function () {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            this.isStopped = true;\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].complete();\n            }\n            this.observers.length = 0;\n        };\n        Subject.prototype.unsubscribe = function () {\n            this.isStopped = true;\n            this.closed = true;\n            this.observers = null;\n        };\n        Subject.prototype._trySubscribe = function (subscriber) {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            else {\n                return _super.prototype._trySubscribe.call(this, subscriber);\n            }\n        };\n        Subject.prototype._subscribe = function (subscriber) {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            else if (this.hasError) {\n                subscriber.error(this.thrownError);\n                return Subscription_1.Subscription.EMPTY;\n            }\n            else if (this.isStopped) {\n                subscriber.complete();\n                return Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this.observers.push(subscriber);\n                return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n            }\n        };\n        Subject.prototype.asObservable = function () {\n            var observable = new Observable_1.Observable();\n            observable.source = this;\n            return observable;\n        };\n        Subject.create = function (destination, source) {\n            return new AnonymousSubject(destination, source);\n        };\n        return Subject;\n    }(Observable_1.Observable));\n    exports.Subject = Subject;\n    /**\n     * @class AnonymousSubject<T>\n     */\n    var AnonymousSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(AnonymousSubject, _super);\n        function AnonymousSubject(destination, source) {\n            var _this = _super.call(this) || this;\n            _this.destination = destination;\n            _this.source = source;\n            return _this;\n        }\n        AnonymousSubject.prototype.next = function (value) {\n            var destination = this.destination;\n            if (destination && destination.next) {\n                destination.next(value);\n            }\n        };\n        AnonymousSubject.prototype.error = function (err) {\n            var destination = this.destination;\n            if (destination && destination.error) {\n                this.destination.error(err);\n            }\n        };\n        AnonymousSubject.prototype.complete = function () {\n            var destination = this.destination;\n            if (destination && destination.complete) {\n                this.destination.complete();\n            }\n        };\n        AnonymousSubject.prototype._subscribe = function (subscriber) {\n            var source = this.source;\n            if (source) {\n                return this.source.subscribe(subscriber);\n            }\n            else {\n                return Subscription_1.Subscription.EMPTY;\n            }\n        };\n        return AnonymousSubject;\n    }(Subject));\n    exports.AnonymousSubject = AnonymousSubject;\n});\n\ndefine('rxjs/AsyncSubject',[\"require\", \"exports\", \"tslib\", \"./Subject\", \"./Subscription\"], function (require, exports, tslib_1, Subject_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class AsyncSubject<T>\n     */\n    var AsyncSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(AsyncSubject, _super);\n        function AsyncSubject() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.value = null;\n            _this.hasNext = false;\n            _this.hasCompleted = false;\n            return _this;\n        }\n        AsyncSubject.prototype._subscribe = function (subscriber) {\n            if (this.hasError) {\n                subscriber.error(this.thrownError);\n                return Subscription_1.Subscription.EMPTY;\n            }\n            else if (this.hasCompleted && this.hasNext) {\n                subscriber.next(this.value);\n                subscriber.complete();\n                return Subscription_1.Subscription.EMPTY;\n            }\n            return _super.prototype._subscribe.call(this, subscriber);\n        };\n        AsyncSubject.prototype.next = function (value) {\n            if (!this.hasCompleted) {\n                this.value = value;\n                this.hasNext = true;\n            }\n        };\n        AsyncSubject.prototype.error = function (error) {\n            if (!this.hasCompleted) {\n                _super.prototype.error.call(this, error);\n            }\n        };\n        AsyncSubject.prototype.complete = function () {\n            this.hasCompleted = true;\n            if (this.hasNext) {\n                _super.prototype.next.call(this, this.value);\n            }\n            _super.prototype.complete.call(this);\n        };\n        return AsyncSubject;\n    }(Subject_1.Subject));\n    exports.AsyncSubject = AsyncSubject;\n});\n\ndefine('rxjs/scheduler/Action',[\"require\", \"exports\", \"tslib\", \"../Subscription\"], function (require, exports, tslib_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A unit of work to be executed in a {@link Scheduler}. An action is typically\n     * created from within a Scheduler and an RxJS user does not need to concern\n     * themselves about creating and manipulating an Action.\n     *\n     * ```ts\n     * class Action<T> extends Subscription {\n     *   new (scheduler: Scheduler, work: (state?: T) => void);\n     *   schedule(state?: T, delay: number = 0): Subscription;\n     * }\n     * ```\n     *\n     * @class Action<T>\n     */\n    var Action = /** @class */ (function (_super) {\n        tslib_1.__extends(Action, _super);\n        function Action(scheduler, work) {\n            return _super.call(this) || this;\n        }\n        /**\n         * Schedules this action on its parent Scheduler for execution. May be passed\n         * some context object, `state`. May happen at some point in the future,\n         * according to the `delay` parameter, if specified.\n         * @param {T} [state] Some contextual data that the `work` function uses when\n         * called by the Scheduler.\n         * @param {number} [delay] Time to wait before executing the work, where the\n         * time unit is implicit and defined by the Scheduler.\n         * @return {void}\n         */\n        Action.prototype.schedule = function (state, delay) {\n            if (delay === void 0) { delay = 0; }\n            return this;\n        };\n        return Action;\n    }(Subscription_1.Subscription));\n    exports.Action = Action;\n});\n\ndefine('rxjs/scheduler/AsyncAction',[\"require\", \"exports\", \"tslib\", \"../util/root\", \"./Action\"], function (require, exports, tslib_1, root_1, Action_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AsyncAction = /** @class */ (function (_super) {\n        tslib_1.__extends(AsyncAction, _super);\n        function AsyncAction(scheduler, work) {\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            _this.pending = false;\n            return _this;\n        }\n        AsyncAction.prototype.schedule = function (state, delay) {\n            if (delay === void 0) { delay = 0; }\n            if (this.closed) {\n                return this;\n            }\n            // Always replace the current state with the new state.\n            this.state = state;\n            // Set the pending flag indicating that this action has been scheduled, or\n            // has recursively rescheduled itself.\n            this.pending = true;\n            var id = this.id;\n            var scheduler = this.scheduler;\n            //\n            // Important implementation note:\n            //\n            // Actions only execute once by default, unless rescheduled from within the\n            // scheduled callback. This allows us to implement single and repeat\n            // actions via the same code path, without adding API surface area, as well\n            // as mimic traditional recursion but across asynchronous boundaries.\n            //\n            // However, JS runtimes and timers distinguish between intervals achieved by\n            // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n            // serial `setTimeout` calls can be individually delayed, which delays\n            // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n            // guarantee the interval callback will be invoked more precisely to the\n            // interval period, regardless of load.\n            //\n            // Therefore, we use `setInterval` to schedule single and repeat actions.\n            // If the action reschedules itself with the same delay, the interval is not\n            // canceled. If the action doesn't reschedule, or reschedules with a\n            // different delay, the interval will be canceled after scheduled callback\n            // execution.\n            //\n            if (id != null) {\n                this.id = this.recycleAsyncId(scheduler, id, delay);\n            }\n            this.delay = delay;\n            // If this action has already an async Id, don't request a new one.\n            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n            return this;\n        };\n        AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n        };\n        AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If this action is rescheduled with the same delay time, don't clear the interval id.\n            if (delay !== null && this.delay === delay && this.pending === false) {\n                return id;\n            }\n            // Otherwise, if the action's delay time is different from the current delay,\n            // or the action has been rescheduled before it's executed, clear the interval id\n            return root_1.root.clearInterval(id) && undefined || undefined;\n        };\n        /**\n         * Immediately executes this action and the `work` it contains.\n         * @return {any}\n         */\n        AsyncAction.prototype.execute = function (state, delay) {\n            if (this.closed) {\n                return new Error('executing a cancelled action');\n            }\n            this.pending = false;\n            var error = this._execute(state, delay);\n            if (error) {\n                return error;\n            }\n            else if (this.pending === false && this.id != null) {\n                // Dequeue if the action didn't reschedule itself. Don't call\n                // unsubscribe(), because the action could reschedule later.\n                // For example:\n                // ```\n                // scheduler.schedule(function doWork(counter) {\n                //   /* ... I'm a busy worker bee ... */\n                //   var originalAction = this;\n                //   /* wait 100ms before rescheduling the action */\n                //   setTimeout(function () {\n                //     originalAction.schedule(counter + 1);\n                //   }, 100);\n                // }, 1000);\n                // ```\n                this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n            }\n        };\n        AsyncAction.prototype._execute = function (state, delay) {\n            var errored = false;\n            var errorValue = undefined;\n            try {\n                this.work(state);\n            }\n            catch (e) {\n                errored = true;\n                errorValue = !!e && e || new Error(e);\n            }\n            if (errored) {\n                this.unsubscribe();\n                return errorValue;\n            }\n        };\n        AsyncAction.prototype._unsubscribe = function () {\n            var id = this.id;\n            var scheduler = this.scheduler;\n            var actions = scheduler.actions;\n            var index = actions.indexOf(this);\n            this.work = null;\n            this.state = null;\n            this.pending = false;\n            this.scheduler = null;\n            if (index !== -1) {\n                actions.splice(index, 1);\n            }\n            if (id != null) {\n                this.id = this.recycleAsyncId(scheduler, id, null);\n            }\n            this.delay = null;\n        };\n        return AsyncAction;\n    }(Action_1.Action));\n    exports.AsyncAction = AsyncAction;\n});\n\ndefine('rxjs/scheduler/QueueAction',[\"require\", \"exports\", \"tslib\", \"./AsyncAction\"], function (require, exports, tslib_1, AsyncAction_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var QueueAction = /** @class */ (function (_super) {\n        tslib_1.__extends(QueueAction, _super);\n        function QueueAction(scheduler, work) {\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            return _this;\n        }\n        QueueAction.prototype.schedule = function (state, delay) {\n            if (delay === void 0) { delay = 0; }\n            if (delay > 0) {\n                return _super.prototype.schedule.call(this, state, delay);\n            }\n            this.delay = delay;\n            this.state = state;\n            this.scheduler.flush(this);\n            return this;\n        };\n        QueueAction.prototype.execute = function (state, delay) {\n            return (delay > 0 || this.closed) ?\n                _super.prototype.execute.call(this, state, delay) :\n                this._execute(state, delay);\n        };\n        QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay exists and is greater than 0, or if the delay is null (the\n            // action wasn't rescheduled) but was originally scheduled as an async\n            // action, then recycle as an async action.\n            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n            }\n            // Otherwise flush the scheduler starting with this action.\n            return scheduler.flush(this);\n        };\n        return QueueAction;\n    }(AsyncAction_1.AsyncAction));\n    exports.QueueAction = QueueAction;\n});\n\ndefine('rxjs/Scheduler',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An execution context and a data structure to order tasks and schedule their\n     * execution. Provides a notion of (potentially virtual) time, through the\n     * `now()` getter method.\n     *\n     * Each unit of work in a Scheduler is called an {@link Action}.\n     *\n     * ```ts\n     * class Scheduler {\n     *   now(): number;\n     *   schedule(work, delay?, state?): Subscription;\n     * }\n     * ```\n     *\n     * @class Scheduler\n     */\n    var Scheduler = /** @class */ (function () {\n        function Scheduler(SchedulerAction, now) {\n            if (now === void 0) { now = Scheduler.now; }\n            this.SchedulerAction = SchedulerAction;\n            this.now = now;\n        }\n        /**\n         * Schedules a function, `work`, for execution. May happen at some point in\n         * the future, according to the `delay` parameter, if specified. May be passed\n         * some context object, `state`, which will be passed to the `work` function.\n         *\n         * The given arguments will be processed an stored as an Action object in a\n         * queue of actions.\n         *\n         * @param {function(state: ?T): ?Subscription} work A function representing a\n         * task, or some unit of work to be executed by the Scheduler.\n         * @param {number} [delay] Time to wait before executing the work, where the\n         * time unit is implicit and defined by the Scheduler itself.\n         * @param {T} [state] Some contextual data that the `work` function uses when\n         * called by the Scheduler.\n         * @return {Subscription} A subscription in order to be able to unsubscribe\n         * the scheduled work.\n         */\n        Scheduler.prototype.schedule = function (work, delay, state) {\n            if (delay === void 0) { delay = 0; }\n            return new this.SchedulerAction(this, work).schedule(state, delay);\n        };\n        Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n        return Scheduler;\n    }());\n    exports.Scheduler = Scheduler;\n});\n\ndefine('rxjs/scheduler/AsyncScheduler',[\"require\", \"exports\", \"tslib\", \"../Scheduler\"], function (require, exports, tslib_1, Scheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var AsyncScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(AsyncScheduler, _super);\n        function AsyncScheduler() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.actions = [];\n            /**\n             * A flag to indicate whether the Scheduler is currently executing a batch of\n             * queued actions.\n             * @type {boolean}\n             */\n            _this.active = false;\n            /**\n             * An internal ID used to track the latest asynchronous task such as those\n             * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n             * others.\n             * @type {any}\n             */\n            _this.scheduled = undefined;\n            return _this;\n        }\n        AsyncScheduler.prototype.flush = function (action) {\n            var actions = this.actions;\n            if (this.active) {\n                actions.push(action);\n                return;\n            }\n            var error;\n            this.active = true;\n            do {\n                if (error = action.execute(action.state, action.delay)) {\n                    break;\n                }\n            } while (action = actions.shift()); // exhaust the scheduler queue\n            this.active = false;\n            if (error) {\n                while (action = actions.shift()) {\n                    action.unsubscribe();\n                }\n                throw error;\n            }\n        };\n        return AsyncScheduler;\n    }(Scheduler_1.Scheduler));\n    exports.AsyncScheduler = AsyncScheduler;\n});\n\ndefine('rxjs/scheduler/QueueScheduler',[\"require\", \"exports\", \"tslib\", \"./AsyncScheduler\"], function (require, exports, tslib_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var QueueScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(QueueScheduler, _super);\n        function QueueScheduler() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return QueueScheduler;\n    }(AsyncScheduler_1.AsyncScheduler));\n    exports.QueueScheduler = QueueScheduler;\n});\n\ndefine('rxjs/scheduler/queue',[\"require\", \"exports\", \"./QueueAction\", \"./QueueScheduler\"], function (require, exports, QueueAction_1, QueueScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Queue Scheduler\n     *\n     * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n     *\n     * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n     *\n     * When used without delay, it schedules given task synchronously - executes it right when\n     * it is scheduled. However when called recursively, that is when inside the scheduled task,\n     * another task is scheduled with queue scheduler, instead of executing immediately as well,\n     * that task will be put on a queue and wait for current one to finish.\n     *\n     * This means that when you execute task with `queue` scheduler, you are sure it will end\n     * before any other task scheduled with that scheduler will start.\n     *\n     * @examples <caption>Schedule recursively first, then do something</caption>\n     *\n     * Rx.Scheduler.queue.schedule(() => {\n     *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n     *\n     *   console.log('first');\n     * });\n     *\n     * // Logs:\n     * // \"first\"\n     * // \"second\"\n     *\n     *\n     * @example <caption>Reschedule itself recursively</caption>\n     *\n     * Rx.Scheduler.queue.schedule(function(state) {\n     *   if (state !== 0) {\n     *     console.log('before', state);\n     *     this.schedule(state - 1); // `this` references currently executing Action,\n     *                               // which we reschedule with new state\n     *     console.log('after', state);\n     *   }\n     * }, 0, 3);\n     *\n     * // In scheduler that runs recursively, you would expect:\n     * // \"before\", 3\n     * // \"before\", 2\n     * // \"before\", 1\n     * // \"after\", 1\n     * // \"after\", 2\n     * // \"after\", 3\n     *\n     * // But with queue it logs:\n     * // \"before\", 3\n     * // \"after\", 3\n     * // \"before\", 2\n     * // \"after\", 2\n     * // \"before\", 1\n     * // \"after\", 1\n     *\n     *\n     * @static true\n     * @name queue\n     * @owner Scheduler\n     */\n    exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n});\n\ndefine('rxjs/Notification',[\"require\", \"exports\", \"./Observable\"], function (require, exports, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represents a push-based event or value that an {@link Observable} can emit.\n     * This class is particularly useful for operators that manage notifications,\n     * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n     * others. Besides wrapping the actual delivered value, it also annotates it\n     * with metadata of, for instance, what type of push message it is (`next`,\n     * `error`, or `complete`).\n     *\n     * @see {@link materialize}\n     * @see {@link dematerialize}\n     * @see {@link observeOn}\n     *\n     * @class Notification<T>\n     */\n    var Notification = /** @class */ (function () {\n        function Notification(kind, value, error) {\n            this.kind = kind;\n            this.value = value;\n            this.error = error;\n            this.hasValue = kind === 'N';\n        }\n        /**\n         * Delivers to the given `observer` the value wrapped by this Notification.\n         * @param {Observer} observer\n         * @return\n         */\n        Notification.prototype.observe = function (observer) {\n            switch (this.kind) {\n                case 'N':\n                    return observer.next && observer.next(this.value);\n                case 'E':\n                    return observer.error && observer.error(this.error);\n                case 'C':\n                    return observer.complete && observer.complete();\n            }\n        };\n        /**\n         * Given some {@link Observer} callbacks, deliver the value represented by the\n         * current Notification to the correctly corresponding callback.\n         * @param {function(value: T): void} next An Observer `next` callback.\n         * @param {function(err: any): void} [error] An Observer `error` callback.\n         * @param {function(): void} [complete] An Observer `complete` callback.\n         * @return {any}\n         */\n        Notification.prototype.do = function (next, error, complete) {\n            var kind = this.kind;\n            switch (kind) {\n                case 'N':\n                    return next && next(this.value);\n                case 'E':\n                    return error && error(this.error);\n                case 'C':\n                    return complete && complete();\n            }\n        };\n        /**\n         * Takes an Observer or its individual callback functions, and calls `observe`\n         * or `do` methods accordingly.\n         * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n         * the `next` callback.\n         * @param {function(err: any): void} [error] An Observer `error` callback.\n         * @param {function(): void} [complete] An Observer `complete` callback.\n         * @return {any}\n         */\n        Notification.prototype.accept = function (nextOrObserver, error, complete) {\n            if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n                return this.observe(nextOrObserver);\n            }\n            else {\n                return this.do(nextOrObserver, error, complete);\n            }\n        };\n        /**\n         * Returns a simple Observable that just delivers the notification represented\n         * by this Notification instance.\n         * @return {any}\n         */\n        Notification.prototype.toObservable = function () {\n            var kind = this.kind;\n            switch (kind) {\n                case 'N':\n                    return Observable_1.Observable.of(this.value);\n                case 'E':\n                    return Observable_1.Observable.throw(this.error);\n                case 'C':\n                    return Observable_1.Observable.empty();\n            }\n            throw new Error('unexpected notification kind value');\n        };\n        /**\n         * A shortcut to create a Notification instance of the type `next` from a\n         * given value.\n         * @param {T} value The `next` value.\n         * @return {Notification<T>} The \"next\" Notification representing the\n         * argument.\n         */\n        Notification.createNext = function (value) {\n            if (typeof value !== 'undefined') {\n                return new Notification('N', value);\n            }\n            return Notification.undefinedValueNotification;\n        };\n        /**\n         * A shortcut to create a Notification instance of the type `error` from a\n         * given error.\n         * @param {any} [err] The `error` error.\n         * @return {Notification<T>} The \"error\" Notification representing the\n         * argument.\n         */\n        Notification.createError = function (err) {\n            return new Notification('E', undefined, err);\n        };\n        /**\n         * A shortcut to create a Notification instance of the type `complete`.\n         * @return {Notification<any>} The valueless \"complete\" Notification.\n         */\n        Notification.createComplete = function () {\n            return Notification.completeNotification;\n        };\n        Notification.completeNotification = new Notification('C');\n        Notification.undefinedValueNotification = new Notification('N', undefined);\n        return Notification;\n    }());\n    exports.Notification = Notification;\n});\n\ndefine('rxjs/operators/observeOn',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Notification\"], function (require, exports, tslib_1, Subscriber_1, Notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Re-emits all notifications from source Observable with specified scheduler.\n     *\n     * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n     *\n     * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n     * notifications emitted by the source Observable. It might be useful, if you do not have control over\n     * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n     *\n     * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n     * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n     * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n     * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n     * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n     * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n     * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n     * little bit more, to ensure that they are emitted at expected moments.\n     *\n     * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n     * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n     * will delay all notifications - including error notifications - while `delay` will pass through error\n     * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n     * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n     * for notification emissions in general.\n     *\n     * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n     * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n     *                                               // with async scheduler by default...\n     *\n     * intervals\n     * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n     * .subscribe(val => {                           // scheduler to ensure smooth animation.\n     *   someDiv.style.height = val + 'px';\n     * });\n     *\n     * @see {@link delay}\n     *\n     * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n     * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n     * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n     * but with provided scheduler.\n     *\n     * @method observeOn\n     * @owner Observable\n     */\n    function observeOn(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        return function observeOnOperatorFunction(source) {\n            return source.lift(new ObserveOnOperator(scheduler, delay));\n        };\n    }\n    exports.observeOn = observeOn;\n    var ObserveOnOperator = /** @class */ (function () {\n        function ObserveOnOperator(scheduler, delay) {\n            if (delay === void 0) { delay = 0; }\n            this.scheduler = scheduler;\n            this.delay = delay;\n        }\n        ObserveOnOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n        };\n        return ObserveOnOperator;\n    }());\n    exports.ObserveOnOperator = ObserveOnOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ObserveOnSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ObserveOnSubscriber, _super);\n        function ObserveOnSubscriber(destination, scheduler, delay) {\n            if (delay === void 0) { delay = 0; }\n            var _this = _super.call(this, destination) || this;\n            _this.scheduler = scheduler;\n            _this.delay = delay;\n            return _this;\n        }\n        ObserveOnSubscriber.dispatch = function (arg) {\n            var notification = arg.notification, destination = arg.destination;\n            notification.observe(destination);\n            this.unsubscribe();\n        };\n        ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n            this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n        };\n        ObserveOnSubscriber.prototype._next = function (value) {\n            this.scheduleMessage(Notification_1.Notification.createNext(value));\n        };\n        ObserveOnSubscriber.prototype._error = function (err) {\n            this.scheduleMessage(Notification_1.Notification.createError(err));\n        };\n        ObserveOnSubscriber.prototype._complete = function () {\n            this.scheduleMessage(Notification_1.Notification.createComplete());\n        };\n        return ObserveOnSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.ObserveOnSubscriber = ObserveOnSubscriber;\n    var ObserveOnMessage = /** @class */ (function () {\n        function ObserveOnMessage(notification, destination) {\n            this.notification = notification;\n            this.destination = destination;\n        }\n        return ObserveOnMessage;\n    }());\n    exports.ObserveOnMessage = ObserveOnMessage;\n});\n\ndefine('rxjs/ReplaySubject',[\"require\", \"exports\", \"tslib\", \"./Subject\", \"./scheduler/queue\", \"./Subscription\", \"./operators/observeOn\", \"./util/ObjectUnsubscribedError\", \"./SubjectSubscription\"], function (require, exports, tslib_1, Subject_1, queue_1, Subscription_1, observeOn_1, ObjectUnsubscribedError_1, SubjectSubscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class ReplaySubject<T>\n     */\n    var ReplaySubject = /** @class */ (function (_super) {\n        tslib_1.__extends(ReplaySubject, _super);\n        function ReplaySubject(bufferSize, windowTime, scheduler) {\n            if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n            if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n            var _this = _super.call(this) || this;\n            _this.scheduler = scheduler;\n            _this._events = [];\n            _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n            _this._windowTime = windowTime < 1 ? 1 : windowTime;\n            return _this;\n        }\n        ReplaySubject.prototype.next = function (value) {\n            var now = this._getNow();\n            this._events.push(new ReplayEvent(now, value));\n            this._trimBufferThenGetEvents();\n            _super.prototype.next.call(this, value);\n        };\n        ReplaySubject.prototype._subscribe = function (subscriber) {\n            var _events = this._trimBufferThenGetEvents();\n            var scheduler = this.scheduler;\n            var subscription;\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            else if (this.hasError) {\n                subscription = Subscription_1.Subscription.EMPTY;\n            }\n            else if (this.isStopped) {\n                subscription = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this.observers.push(subscriber);\n                subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n            }\n            if (scheduler) {\n                subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n            }\n            var len = _events.length;\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n            if (this.hasError) {\n                subscriber.error(this.thrownError);\n            }\n            else if (this.isStopped) {\n                subscriber.complete();\n            }\n            return subscription;\n        };\n        ReplaySubject.prototype._getNow = function () {\n            return (this.scheduler || queue_1.queue).now();\n        };\n        ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n            var now = this._getNow();\n            var _bufferSize = this._bufferSize;\n            var _windowTime = this._windowTime;\n            var _events = this._events;\n            var eventsCount = _events.length;\n            var spliceCount = 0;\n            // Trim events that fall out of the time window.\n            // Start at the front of the list. Break early once\n            // we encounter an event that falls within the window.\n            while (spliceCount < eventsCount) {\n                if ((now - _events[spliceCount].time) < _windowTime) {\n                    break;\n                }\n                spliceCount++;\n            }\n            if (eventsCount > _bufferSize) {\n                spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n            }\n            if (spliceCount > 0) {\n                _events.splice(0, spliceCount);\n            }\n            return _events;\n        };\n        return ReplaySubject;\n    }(Subject_1.Subject));\n    exports.ReplaySubject = ReplaySubject;\n    var ReplayEvent = /** @class */ (function () {\n        function ReplayEvent(time, value) {\n            this.time = time;\n            this.value = value;\n        }\n        return ReplayEvent;\n    }());\n});\n\ndefine('rxjs/BehaviorSubject',[\"require\", \"exports\", \"tslib\", \"./Subject\", \"./util/ObjectUnsubscribedError\"], function (require, exports, tslib_1, Subject_1, ObjectUnsubscribedError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class BehaviorSubject<T>\n     */\n    var BehaviorSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(BehaviorSubject, _super);\n        function BehaviorSubject(_value) {\n            var _this = _super.call(this) || this;\n            _this._value = _value;\n            return _this;\n        }\n        Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n            get: function () {\n                return this.getValue();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BehaviorSubject.prototype._subscribe = function (subscriber) {\n            var subscription = _super.prototype._subscribe.call(this, subscriber);\n            if (subscription && !subscription.closed) {\n                subscriber.next(this._value);\n            }\n            return subscription;\n        };\n        BehaviorSubject.prototype.getValue = function () {\n            if (this.hasError) {\n                throw this.thrownError;\n            }\n            else if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            else {\n                return this._value;\n            }\n        };\n        BehaviorSubject.prototype.next = function (value) {\n            _super.prototype.next.call(this, this._value = value);\n        };\n        return BehaviorSubject;\n    }(Subject_1.Subject));\n    exports.BehaviorSubject = BehaviorSubject;\n});\n\ndefine('rxjs/operators/refCount',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function refCount() {\n        return function refCountOperatorFunction(source) {\n            return source.lift(new RefCountOperator(source));\n        };\n    }\n    exports.refCount = refCount;\n    var RefCountOperator = /** @class */ (function () {\n        function RefCountOperator(connectable) {\n            this.connectable = connectable;\n        }\n        RefCountOperator.prototype.call = function (subscriber, source) {\n            var connectable = this.connectable;\n            connectable._refCount++;\n            var refCounter = new RefCountSubscriber(subscriber, connectable);\n            var subscription = source.subscribe(refCounter);\n            if (!refCounter.closed) {\n                refCounter.connection = connectable.connect();\n            }\n            return subscription;\n        };\n        return RefCountOperator;\n    }());\n    var RefCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RefCountSubscriber, _super);\n        function RefCountSubscriber(destination, connectable) {\n            var _this = _super.call(this, destination) || this;\n            _this.connectable = connectable;\n            return _this;\n        }\n        RefCountSubscriber.prototype._unsubscribe = function () {\n            var connectable = this.connectable;\n            if (!connectable) {\n                this.connection = null;\n                return;\n            }\n            this.connectable = null;\n            var refCount = connectable._refCount;\n            if (refCount <= 0) {\n                this.connection = null;\n                return;\n            }\n            connectable._refCount = refCount - 1;\n            if (refCount > 1) {\n                this.connection = null;\n                return;\n            }\n            ///\n            // Compare the local RefCountSubscriber's connection Subscription to the\n            // connection Subscription on the shared ConnectableObservable. In cases\n            // where the ConnectableObservable source synchronously emits values, and\n            // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n            // execution continues to here before the RefCountOperator has a chance to\n            // supply the RefCountSubscriber with the shared connection Subscription.\n            // For example:\n            // ```\n            // Observable.range(0, 10)\n            //   .publish()\n            //   .refCount()\n            //   .take(5)\n            //   .subscribe();\n            // ```\n            // In order to account for this case, RefCountSubscriber should only dispose\n            // the ConnectableObservable's shared connection Subscription if the\n            // connection Subscription exists, *and* either:\n            //   a. RefCountSubscriber doesn't have a reference to the shared connection\n            //      Subscription yet, or,\n            //   b. RefCountSubscriber's connection Subscription reference is identical\n            //      to the shared connection Subscription\n            ///\n            var connection = this.connection;\n            var sharedConnection = connectable._connection;\n            this.connection = null;\n            if (sharedConnection && (!connection || sharedConnection === connection)) {\n                sharedConnection.unsubscribe();\n            }\n        };\n        return RefCountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/observable/ConnectableObservable',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../Observable\", \"../Subscriber\", \"../Subscription\", \"../operators/refCount\"], function (require, exports, tslib_1, Subject_1, Observable_1, Subscriber_1, Subscription_1, refCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class ConnectableObservable<T>\n     */\n    var ConnectableObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ConnectableObservable, _super);\n        function ConnectableObservable(source, subjectFactory) {\n            var _this = _super.call(this) || this;\n            _this.source = source;\n            _this.subjectFactory = subjectFactory;\n            _this._refCount = 0;\n            _this._isComplete = false;\n            return _this;\n        }\n        ConnectableObservable.prototype._subscribe = function (subscriber) {\n            return this.getSubject().subscribe(subscriber);\n        };\n        ConnectableObservable.prototype.getSubject = function () {\n            var subject = this._subject;\n            if (!subject || subject.isStopped) {\n                this._subject = this.subjectFactory();\n            }\n            return this._subject;\n        };\n        ConnectableObservable.prototype.connect = function () {\n            var connection = this._connection;\n            if (!connection) {\n                this._isComplete = false;\n                connection = this._connection = new Subscription_1.Subscription();\n                connection.add(this.source\n                    .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n                if (connection.closed) {\n                    this._connection = null;\n                    connection = Subscription_1.Subscription.EMPTY;\n                }\n                else {\n                    this._connection = connection;\n                }\n            }\n            return connection;\n        };\n        ConnectableObservable.prototype.refCount = function () {\n            return refCount_1.refCount()(this);\n        };\n        return ConnectableObservable;\n    }(Observable_1.Observable));\n    exports.ConnectableObservable = ConnectableObservable;\n    var connectableProto = ConnectableObservable.prototype;\n    exports.connectableObservableDescriptor = {\n        operator: { value: null },\n        _refCount: { value: 0, writable: true },\n        _subject: { value: null, writable: true },\n        _connection: { value: null, writable: true },\n        _subscribe: { value: connectableProto._subscribe },\n        _isComplete: { value: connectableProto._isComplete, writable: true },\n        getSubject: { value: connectableProto.getSubject },\n        connect: { value: connectableProto.connect },\n        refCount: { value: connectableProto.refCount }\n    };\n    var ConnectableSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ConnectableSubscriber, _super);\n        function ConnectableSubscriber(destination, connectable) {\n            var _this = _super.call(this, destination) || this;\n            _this.connectable = connectable;\n            return _this;\n        }\n        ConnectableSubscriber.prototype._error = function (err) {\n            this._unsubscribe();\n            _super.prototype._error.call(this, err);\n        };\n        ConnectableSubscriber.prototype._complete = function () {\n            this.connectable._isComplete = true;\n            this._unsubscribe();\n            _super.prototype._complete.call(this);\n        };\n        ConnectableSubscriber.prototype._unsubscribe = function () {\n            var connectable = this.connectable;\n            if (connectable) {\n                this.connectable = null;\n                var connection = connectable._connection;\n                connectable._refCount = 0;\n                connectable._subject = null;\n                connectable._connection = null;\n                if (connection) {\n                    connection.unsubscribe();\n                }\n            }\n        };\n        return ConnectableSubscriber;\n    }(Subject_1.SubjectSubscriber));\n    var RefCountOperator = /** @class */ (function () {\n        function RefCountOperator(connectable) {\n            this.connectable = connectable;\n        }\n        RefCountOperator.prototype.call = function (subscriber, source) {\n            var connectable = this.connectable;\n            connectable._refCount++;\n            var refCounter = new RefCountSubscriber(subscriber, connectable);\n            var subscription = source.subscribe(refCounter);\n            if (!refCounter.closed) {\n                refCounter.connection = connectable.connect();\n            }\n            return subscription;\n        };\n        return RefCountOperator;\n    }());\n    var RefCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RefCountSubscriber, _super);\n        function RefCountSubscriber(destination, connectable) {\n            var _this = _super.call(this, destination) || this;\n            _this.connectable = connectable;\n            return _this;\n        }\n        RefCountSubscriber.prototype._unsubscribe = function () {\n            var connectable = this.connectable;\n            if (!connectable) {\n                this.connection = null;\n                return;\n            }\n            this.connectable = null;\n            var refCount = connectable._refCount;\n            if (refCount <= 0) {\n                this.connection = null;\n                return;\n            }\n            connectable._refCount = refCount - 1;\n            if (refCount > 1) {\n                this.connection = null;\n                return;\n            }\n            ///\n            // Compare the local RefCountSubscriber's connection Subscription to the\n            // connection Subscription on the shared ConnectableObservable. In cases\n            // where the ConnectableObservable source synchronously emits values, and\n            // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n            // execution continues to here before the RefCountOperator has a chance to\n            // supply the RefCountSubscriber with the shared connection Subscription.\n            // For example:\n            // ```\n            // Observable.range(0, 10)\n            //   .publish()\n            //   .refCount()\n            //   .take(5)\n            //   .subscribe();\n            // ```\n            // In order to account for this case, RefCountSubscriber should only dispose\n            // the ConnectableObservable's shared connection Subscription if the\n            // connection Subscription exists, *and* either:\n            //   a. RefCountSubscriber doesn't have a reference to the shared connection\n            //      Subscription yet, or,\n            //   b. RefCountSubscriber's connection Subscription reference is identical\n            //      to the shared connection Subscription\n            ///\n            var connection = this.connection;\n            var sharedConnection = connectable._connection;\n            this.connection = null;\n            if (sharedConnection && (!connection || sharedConnection === connection)) {\n                sharedConnection.unsubscribe();\n            }\n        };\n        return RefCountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/util/EmptyError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when an Observable or a sequence was queried but has no\n     * elements.\n     *\n     * @see {@link first}\n     * @see {@link last}\n     * @see {@link single}\n     *\n     * @class EmptyError\n     */\n    var EmptyError = /** @class */ (function (_super) {\n        tslib_1.__extends(EmptyError, _super);\n        function EmptyError() {\n            var _this = this;\n            var err = _this = _super.call(this, 'no elements in sequence') || this;\n            _this.name = err.name = 'EmptyError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return EmptyError;\n    }(Error));\n    exports.EmptyError = EmptyError;\n});\n\ndefine('rxjs/util/ArgumentOutOfRangeError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when an element was queried at a certain index of an\n     * Observable, but no such index or position exists in that sequence.\n     *\n     * @see {@link elementAt}\n     * @see {@link take}\n     * @see {@link takeLast}\n     *\n     * @class ArgumentOutOfRangeError\n     */\n    var ArgumentOutOfRangeError = /** @class */ (function (_super) {\n        tslib_1.__extends(ArgumentOutOfRangeError, _super);\n        function ArgumentOutOfRangeError() {\n            var _this = this;\n            var err = _this = _super.call(this, 'argument out of range') || this;\n            _this.name = err.name = 'ArgumentOutOfRangeError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return ArgumentOutOfRangeError;\n    }(Error));\n    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n});\n\ndefine('rxjs/util/TimeoutError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when duetime elapses.\n     *\n     * @see {@link timeout}\n     *\n     * @class TimeoutError\n     */\n    var TimeoutError = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeoutError, _super);\n        function TimeoutError() {\n            var _this = this;\n            var err = _this = _super.call(this, 'Timeout has occurred') || this;\n            _this.name = err.name = 'TimeoutError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return TimeoutError;\n    }(Error));\n    exports.TimeoutError = TimeoutError;\n});\n\ndefine('rxjs/scheduler/async',[\"require\", \"exports\", \"./AsyncAction\", \"./AsyncScheduler\"], function (require, exports, AsyncAction_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Async Scheduler\n     *\n     * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n     *\n     * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n     * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n     * in intervals.\n     *\n     * If you just want to \"defer\" task, that is to perform it right after currently\n     * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n     * better choice will be the {@link asap} scheduler.\n     *\n     * @example <caption>Use async scheduler to delay task</caption>\n     * const task = () => console.log('it works!');\n     *\n     * Rx.Scheduler.async.schedule(task, 2000);\n     *\n     * // After 2 seconds logs:\n     * // \"it works!\"\n     *\n     *\n     * @example <caption>Use async scheduler to repeat task in intervals</caption>\n     * function task(state) {\n     *   console.log(state);\n     *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n     *                                   // which we reschedule with new state and delay\n     * }\n     *\n     * Rx.Scheduler.async.schedule(task, 3000, 0);\n     *\n     * // Logs:\n     * // 0 after 3s\n     * // 1 after 4s\n     * // 2 after 5s\n     * // 3 after 6s\n     *\n     * @static true\n     * @name async\n     * @owner Scheduler\n     */\n    exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n});\n\ndefine('rxjs/operators/timeInterval',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../scheduler/async\"], function (require, exports, tslib_1, Subscriber_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function timeInterval(scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };\n    }\n    exports.timeInterval = timeInterval;\n    var TimeInterval = /** @class */ (function () {\n        function TimeInterval(value, interval) {\n            this.value = value;\n            this.interval = interval;\n        }\n        return TimeInterval;\n    }());\n    exports.TimeInterval = TimeInterval;\n    ;\n    var TimeIntervalOperator = /** @class */ (function () {\n        function TimeIntervalOperator(scheduler) {\n            this.scheduler = scheduler;\n        }\n        TimeIntervalOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n        };\n        return TimeIntervalOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TimeIntervalSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeIntervalSubscriber, _super);\n        function TimeIntervalSubscriber(destination, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.scheduler = scheduler;\n            _this.lastTime = 0;\n            _this.lastTime = scheduler.now();\n            return _this;\n        }\n        TimeIntervalSubscriber.prototype._next = function (value) {\n            var now = this.scheduler.now();\n            var span = now - this.lastTime;\n            this.lastTime = now;\n            this.destination.next(new TimeInterval(value, span));\n        };\n        return TimeIntervalSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operator/timeInterval',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/timeInterval\"], function (require, exports, async_1, timeInterval_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.TimeInterval = timeInterval_1.TimeInterval;\n    /**\n     * @param scheduler\n     * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}\n     * @method timeInterval\n     * @owner Observable\n     */\n    function timeInterval(scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return timeInterval_1.timeInterval(scheduler)(this);\n    }\n    exports.timeInterval = timeInterval;\n});\n\ndefine('rxjs/operators/map',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Applies a given `project` function to each value emitted by the source\n     * Observable, and emits the resulting values as an Observable.\n     *\n     * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n     * it passes each source value through a transformation function to get\n     * corresponding output values.</span>\n     *\n     * <img src=\"./img/map.png\" width=\"100%\">\n     *\n     * Similar to the well known `Array.prototype.map` function, this operator\n     * applies a projection to each value and emits that projection in the output\n     * Observable.\n     *\n     * @example <caption>Map every click to the clientX position of that click</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var positions = clicks.map(ev => ev.clientX);\n     * positions.subscribe(x => console.log(x));\n     *\n     * @see {@link mapTo}\n     * @see {@link pluck}\n     *\n     * @param {function(value: T, index: number): R} project The function to apply\n     * to each `value` emitted by the source Observable. The `index` parameter is\n     * the number `i` for the i-th emission that has happened since the\n     * subscription, starting from the number `0`.\n     * @param {any} [thisArg] An optional argument to define what `this` is in the\n     * `project` function.\n     * @return {Observable<R>} An Observable that emits the values from the source\n     * Observable transformed by the given `project` function.\n     * @method map\n     * @owner Observable\n     */\n    function map(project, thisArg) {\n        return function mapOperation(source) {\n            if (typeof project !== 'function') {\n                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n            }\n            return source.lift(new MapOperator(project, thisArg));\n        };\n    }\n    exports.map = map;\n    var MapOperator = /** @class */ (function () {\n        function MapOperator(project, thisArg) {\n            this.project = project;\n            this.thisArg = thisArg;\n        }\n        MapOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n        };\n        return MapOperator;\n    }());\n    exports.MapOperator = MapOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MapSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MapSubscriber, _super);\n        function MapSubscriber(destination, project, thisArg) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.count = 0;\n            _this.thisArg = thisArg || _this;\n            return _this;\n        }\n        // NOTE: This looks unoptimized, but it's actually purposefully NOT\n        // using try/catch optimizations.\n        MapSubscriber.prototype._next = function (value) {\n            var result;\n            try {\n                result = this.project.call(this.thisArg, value, this.count++);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return MapSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/timestamp',[\"require\", \"exports\", \"../scheduler/async\", \"./map\"], function (require, exports, async_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param scheduler\n     * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n     * @method timestamp\n     * @owner Observable\n     */\n    function timestamp(scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });\n        // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n    }\n    exports.timestamp = timestamp;\n    var Timestamp = /** @class */ (function () {\n        function Timestamp(value, timestamp) {\n            this.value = value;\n            this.timestamp = timestamp;\n        }\n        return Timestamp;\n    }());\n    exports.Timestamp = Timestamp;\n    ;\n});\n\ndefine('rxjs/testing/SubscriptionLog',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var SubscriptionLog = /** @class */ (function () {\n        function SubscriptionLog(subscribedFrame, unsubscribedFrame) {\n            if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }\n            this.subscribedFrame = subscribedFrame;\n            this.unsubscribedFrame = unsubscribedFrame;\n        }\n        return SubscriptionLog;\n    }());\n    exports.SubscriptionLog = SubscriptionLog;\n});\n\ndefine('rxjs/testing/SubscriptionLoggable',[\"require\", \"exports\", \"./SubscriptionLog\"], function (require, exports, SubscriptionLog_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var SubscriptionLoggable = /** @class */ (function () {\n        function SubscriptionLoggable() {\n            this.subscriptions = [];\n        }\n        SubscriptionLoggable.prototype.logSubscribedFrame = function () {\n            this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));\n            return this.subscriptions.length - 1;\n        };\n        SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {\n            var subscriptionLogs = this.subscriptions;\n            var oldSubscriptionLog = subscriptionLogs[index];\n            subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());\n        };\n        return SubscriptionLoggable;\n    }());\n    exports.SubscriptionLoggable = SubscriptionLoggable;\n});\n\ndefine('rxjs/util/applyMixins',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function applyMixins(derivedCtor, baseCtors) {\n        for (var i = 0, len = baseCtors.length; i < len; i++) {\n            var baseCtor = baseCtors[i];\n            var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);\n            for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {\n                var name_1 = propertyKeys[j];\n                derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];\n            }\n        }\n    }\n    exports.applyMixins = applyMixins;\n});\n\ndefine('rxjs/testing/ColdObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../Subscription\", \"./SubscriptionLoggable\", \"../util/applyMixins\"], function (require, exports, tslib_1, Observable_1, Subscription_1, SubscriptionLoggable_1, applyMixins_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ColdObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ColdObservable, _super);\n        function ColdObservable(messages, scheduler) {\n            var _this = _super.call(this, function (subscriber) {\n                var observable = this;\n                var index = observable.logSubscribedFrame();\n                subscriber.add(new Subscription_1.Subscription(function () {\n                    observable.logUnsubscribedFrame(index);\n                }));\n                observable.scheduleMessages(subscriber);\n                return subscriber;\n            }) || this;\n            _this.messages = messages;\n            _this.subscriptions = [];\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        ColdObservable.prototype.scheduleMessages = function (subscriber) {\n            var messagesLength = this.messages.length;\n            for (var i = 0; i < messagesLength; i++) {\n                var message = this.messages[i];\n                subscriber.add(this.scheduler.schedule(function (_a) {\n                    var message = _a.message, subscriber = _a.subscriber;\n                    message.notification.observe(subscriber);\n                }, message.frame, { message: message, subscriber: subscriber }));\n            }\n        };\n        return ColdObservable;\n    }(Observable_1.Observable));\n    exports.ColdObservable = ColdObservable;\n    applyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n});\n\ndefine('rxjs/testing/HotObservable',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../Subscription\", \"./SubscriptionLoggable\", \"../util/applyMixins\"], function (require, exports, tslib_1, Subject_1, Subscription_1, SubscriptionLoggable_1, applyMixins_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var HotObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(HotObservable, _super);\n        function HotObservable(messages, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.messages = messages;\n            _this.subscriptions = [];\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        HotObservable.prototype._subscribe = function (subscriber) {\n            var subject = this;\n            var index = subject.logSubscribedFrame();\n            subscriber.add(new Subscription_1.Subscription(function () {\n                subject.logUnsubscribedFrame(index);\n            }));\n            return _super.prototype._subscribe.call(this, subscriber);\n        };\n        HotObservable.prototype.setup = function () {\n            var subject = this;\n            var messagesLength = subject.messages.length;\n            /* tslint:disable:no-var-keyword */\n            for (var i = 0; i < messagesLength; i++) {\n                (function () {\n                    var message = subject.messages[i];\n                    /* tslint:enable */\n                    subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);\n                })();\n            }\n        };\n        return HotObservable;\n    }(Subject_1.Subject));\n    exports.HotObservable = HotObservable;\n    applyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n});\n\ndefine('rxjs/scheduler/VirtualTimeScheduler',[\"require\", \"exports\", \"tslib\", \"./AsyncAction\", \"./AsyncScheduler\"], function (require, exports, tslib_1, AsyncAction_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var VirtualTimeScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(VirtualTimeScheduler, _super);\n        function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n            if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }\n            if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }\n            var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;\n            _this.maxFrames = maxFrames;\n            _this.frame = 0;\n            _this.index = -1;\n            return _this;\n        }\n        /**\n         * Prompt the Scheduler to execute all of its queued actions, therefore\n         * clearing its queue.\n         * @return {void}\n         */\n        VirtualTimeScheduler.prototype.flush = function () {\n            var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n            var error, action;\n            while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\n                if (error = action.execute(action.state, action.delay)) {\n                    break;\n                }\n            }\n            if (error) {\n                while (action = actions.shift()) {\n                    action.unsubscribe();\n                }\n                throw error;\n            }\n        };\n        VirtualTimeScheduler.frameTimeFactor = 10;\n        return VirtualTimeScheduler;\n    }(AsyncScheduler_1.AsyncScheduler));\n    exports.VirtualTimeScheduler = VirtualTimeScheduler;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var VirtualAction = /** @class */ (function (_super) {\n        tslib_1.__extends(VirtualAction, _super);\n        function VirtualAction(scheduler, work, index) {\n            if (index === void 0) { index = scheduler.index += 1; }\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            _this.index = index;\n            _this.active = true;\n            _this.index = scheduler.index = index;\n            return _this;\n        }\n        VirtualAction.prototype.schedule = function (state, delay) {\n            if (delay === void 0) { delay = 0; }\n            if (!this.id) {\n                return _super.prototype.schedule.call(this, state, delay);\n            }\n            this.active = false;\n            // If an action is rescheduled, we save allocations by mutating its state,\n            // pushing it to the end of the scheduler queue, and recycling the action.\n            // But since the VirtualTimeScheduler is used for testing, VirtualActions\n            // must be immutable so they can be inspected later.\n            var action = new VirtualAction(this.scheduler, this.work);\n            this.add(action);\n            return action.schedule(state, delay);\n        };\n        VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            this.delay = scheduler.frame + delay;\n            var actions = scheduler.actions;\n            actions.push(this);\n            actions.sort(VirtualAction.sortActions);\n            return true;\n        };\n        VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            return undefined;\n        };\n        VirtualAction.prototype._execute = function (state, delay) {\n            if (this.active === true) {\n                return _super.prototype._execute.call(this, state, delay);\n            }\n        };\n        VirtualAction.sortActions = function (a, b) {\n            if (a.delay === b.delay) {\n                if (a.index === b.index) {\n                    return 0;\n                }\n                else if (a.index > b.index) {\n                    return 1;\n                }\n                else {\n                    return -1;\n                }\n            }\n            else if (a.delay > b.delay) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        };\n        return VirtualAction;\n    }(AsyncAction_1.AsyncAction));\n    exports.VirtualAction = VirtualAction;\n});\n\ndefine('rxjs/testing/TestScheduler',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../Notification\", \"./ColdObservable\", \"./HotObservable\", \"./SubscriptionLog\", \"../scheduler/VirtualTimeScheduler\"], function (require, exports, tslib_1, Observable_1, Notification_1, ColdObservable_1, HotObservable_1, SubscriptionLog_1, VirtualTimeScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var defaultMaxFrame = 750;\n    var TestScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(TestScheduler, _super);\n        function TestScheduler(assertDeepEqual) {\n            var _this = _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame) || this;\n            _this.assertDeepEqual = assertDeepEqual;\n            _this.hotObservables = [];\n            _this.coldObservables = [];\n            _this.flushTests = [];\n            return _this;\n        }\n        TestScheduler.prototype.createTime = function (marbles) {\n            var indexOf = marbles.indexOf('|');\n            if (indexOf === -1) {\n                throw new Error('marble diagram for time should have a completion marker \"|\"');\n            }\n            return indexOf * TestScheduler.frameTimeFactor;\n        };\n        TestScheduler.prototype.createColdObservable = function (marbles, values, error) {\n            if (marbles.indexOf('^') !== -1) {\n                throw new Error('cold observable cannot have subscription offset \"^\"');\n            }\n            if (marbles.indexOf('!') !== -1) {\n                throw new Error('cold observable cannot have unsubscription marker \"!\"');\n            }\n            var messages = TestScheduler.parseMarbles(marbles, values, error);\n            var cold = new ColdObservable_1.ColdObservable(messages, this);\n            this.coldObservables.push(cold);\n            return cold;\n        };\n        TestScheduler.prototype.createHotObservable = function (marbles, values, error) {\n            if (marbles.indexOf('!') !== -1) {\n                throw new Error('hot observable cannot have unsubscription marker \"!\"');\n            }\n            var messages = TestScheduler.parseMarbles(marbles, values, error);\n            var subject = new HotObservable_1.HotObservable(messages, this);\n            this.hotObservables.push(subject);\n            return subject;\n        };\n        TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {\n            var _this = this;\n            var messages = [];\n            observable.subscribe(function (value) {\n                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });\n            }, function (err) {\n                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });\n            }, function () {\n                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });\n            });\n            return messages;\n        };\n        TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {\n            var _this = this;\n            if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }\n            var actual = [];\n            var flushTest = { actual: actual, ready: false };\n            var unsubscriptionFrame = TestScheduler\n                .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n            var subscription;\n            this.schedule(function () {\n                subscription = observable.subscribe(function (x) {\n                    var value = x;\n                    // Support Observable-of-Observables\n                    if (x instanceof Observable_1.Observable) {\n                        value = _this.materializeInnerObservable(value, _this.frame);\n                    }\n                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });\n                }, function (err) {\n                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });\n                }, function () {\n                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });\n                });\n            }, 0);\n            if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);\n            }\n            this.flushTests.push(flushTest);\n            return {\n                toBe: function (marbles, values, errorValue) {\n                    flushTest.ready = true;\n                    flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n                }\n            };\n        };\n        TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {\n            var flushTest = { actual: actualSubscriptionLogs, ready: false };\n            this.flushTests.push(flushTest);\n            return {\n                toBe: function (marbles) {\n                    var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                    flushTest.ready = true;\n                    flushTest.expected = marblesArray.map(function (marbles) {\n                        return TestScheduler.parseMarblesAsSubscriptions(marbles);\n                    });\n                }\n            };\n        };\n        TestScheduler.prototype.flush = function () {\n            var hotObservables = this.hotObservables;\n            while (hotObservables.length > 0) {\n                hotObservables.shift().setup();\n            }\n            _super.prototype.flush.call(this);\n            var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });\n            while (readyFlushTests.length > 0) {\n                var test = readyFlushTests.shift();\n                this.assertDeepEqual(test.actual, test.expected);\n            }\n        };\n        TestScheduler.parseMarblesAsSubscriptions = function (marbles) {\n            if (typeof marbles !== 'string') {\n                return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);\n            }\n            var len = marbles.length;\n            var groupStart = -1;\n            var subscriptionFrame = Number.POSITIVE_INFINITY;\n            var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n            for (var i = 0; i < len; i++) {\n                var frame = i * this.frameTimeFactor;\n                var c = marbles[i];\n                switch (c) {\n                    case '-':\n                    case ' ':\n                        break;\n                    case '(':\n                        groupStart = frame;\n                        break;\n                    case ')':\n                        groupStart = -1;\n                        break;\n                    case '^':\n                        if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                            throw new Error('found a second subscription point \\'^\\' in a ' +\n                                'subscription marble diagram. There can only be one.');\n                        }\n                        subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                        break;\n                    case '!':\n                        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                            throw new Error('found a second subscription point \\'^\\' in a ' +\n                                'subscription marble diagram. There can only be one.');\n                        }\n                        unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                        break;\n                    default:\n                        throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                            'subscription marble diagram. Found instead \\'' + c + '\\'.');\n                }\n            }\n            if (unsubscriptionFrame < 0) {\n                return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);\n            }\n            else {\n                return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n            }\n        };\n        TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {\n            if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }\n            if (marbles.indexOf('!') !== -1) {\n                throw new Error('conventional marble diagrams cannot have the ' +\n                    'unsubscription marker \"!\"');\n            }\n            var len = marbles.length;\n            var testMessages = [];\n            var subIndex = marbles.indexOf('^');\n            var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n            var getValue = typeof values !== 'object' ?\n                function (x) { return x; } :\n                function (x) {\n                    // Support Observable-of-Observables\n                    if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {\n                        return values[x].messages;\n                    }\n                    return values[x];\n                };\n            var groupStart = -1;\n            for (var i = 0; i < len; i++) {\n                var frame = i * this.frameTimeFactor + frameOffset;\n                var notification = void 0;\n                var c = marbles[i];\n                switch (c) {\n                    case '-':\n                    case ' ':\n                        break;\n                    case '(':\n                        groupStart = frame;\n                        break;\n                    case ')':\n                        groupStart = -1;\n                        break;\n                    case '|':\n                        notification = Notification_1.Notification.createComplete();\n                        break;\n                    case '^':\n                        break;\n                    case '#':\n                        notification = Notification_1.Notification.createError(errorValue || 'error');\n                        break;\n                    default:\n                        notification = Notification_1.Notification.createNext(getValue(c));\n                        break;\n                }\n                if (notification) {\n                    testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });\n                }\n            }\n            return testMessages;\n        };\n        return TestScheduler;\n    }(VirtualTimeScheduler_1.VirtualTimeScheduler));\n    exports.TestScheduler = TestScheduler;\n});\n\ndefine('rxjs/observable/dom/AjaxObservable',[\"require\", \"exports\", \"tslib\", \"../../util/root\", \"../../util/tryCatch\", \"../../util/errorObject\", \"../../Observable\", \"../../Subscriber\", \"../../operators/map\"], function (require, exports, tslib_1, root_1, tryCatch_1, errorObject_1, Observable_1, Subscriber_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getCORSRequest() {\n        if (root_1.root.XMLHttpRequest) {\n            return new root_1.root.XMLHttpRequest();\n        }\n        else if (!!root_1.root.XDomainRequest) {\n            return new root_1.root.XDomainRequest();\n        }\n        else {\n            throw new Error('CORS is not supported by your browser');\n        }\n    }\n    function getXMLHttpRequest() {\n        if (root_1.root.XMLHttpRequest) {\n            return new root_1.root.XMLHttpRequest();\n        }\n        else {\n            var progId = void 0;\n            try {\n                var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n                for (var i = 0; i < 3; i++) {\n                    try {\n                        progId = progIds[i];\n                        if (new root_1.root.ActiveXObject(progId)) {\n                            break;\n                        }\n                    }\n                    catch (e) {\n                        //suppress exceptions\n                    }\n                }\n                return new root_1.root.ActiveXObject(progId);\n            }\n            catch (e) {\n                throw new Error('XMLHttpRequest is not supported by your browser');\n            }\n        }\n    }\n    function ajaxGet(url, headers) {\n        if (headers === void 0) { headers = null; }\n        return new AjaxObservable({ method: 'GET', url: url, headers: headers });\n    }\n    exports.ajaxGet = ajaxGet;\n    ;\n    function ajaxPost(url, body, headers) {\n        return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });\n    }\n    exports.ajaxPost = ajaxPost;\n    ;\n    function ajaxDelete(url, headers) {\n        return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });\n    }\n    exports.ajaxDelete = ajaxDelete;\n    ;\n    function ajaxPut(url, body, headers) {\n        return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });\n    }\n    exports.ajaxPut = ajaxPut;\n    ;\n    function ajaxPatch(url, body, headers) {\n        return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });\n    }\n    exports.ajaxPatch = ajaxPatch;\n    ;\n    var mapResponse = map_1.map(function (x, index) { return x.response; });\n    function ajaxGetJSON(url, headers) {\n        return mapResponse(new AjaxObservable({\n            method: 'GET',\n            url: url,\n            responseType: 'json',\n            headers: headers\n        }));\n    }\n    exports.ajaxGetJSON = ajaxGetJSON;\n    ;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var AjaxObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(AjaxObservable, _super);\n        function AjaxObservable(urlOrRequest) {\n            var _this = _super.call(this) || this;\n            var request = {\n                async: true,\n                createXHR: function () {\n                    return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n                },\n                crossDomain: false,\n                withCredentials: false,\n                headers: {},\n                method: 'GET',\n                responseType: 'json',\n                timeout: 0\n            };\n            if (typeof urlOrRequest === 'string') {\n                request.url = urlOrRequest;\n            }\n            else {\n                for (var prop in urlOrRequest) {\n                    if (urlOrRequest.hasOwnProperty(prop)) {\n                        request[prop] = urlOrRequest[prop];\n                    }\n                }\n            }\n            _this.request = request;\n            return _this;\n        }\n        AjaxObservable.prototype._subscribe = function (subscriber) {\n            return new AjaxSubscriber(subscriber, this.request);\n        };\n        /**\n         * Creates an observable for an Ajax request with either a request object with\n         * url, headers, etc or a string for a URL.\n         *\n         * @example\n         * source = Rx.Observable.ajax('/products');\n         * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n         *\n         * @param {string|Object} request Can be one of the following:\n         *   A string of the URL to make the Ajax call.\n         *   An object with the following properties\n         *   - url: URL of the request\n         *   - body: The body of the request\n         *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n         *   - async: Whether the request is async\n         *   - headers: Optional headers\n         *   - crossDomain: true if a cross domain request, else false\n         *   - createXHR: a function to override if you need to use an alternate\n         *   XMLHttpRequest implementation.\n         *   - resultSelector: a function to use to alter the output value type of\n         *   the Observable. Gets {@link AjaxResponse} as an argument.\n         * @return {Observable} An observable sequence containing the XMLHttpRequest.\n         * @static true\n         * @name ajax\n         * @owner Observable\n        */\n        AjaxObservable.create = (function () {\n            var create = function (urlOrRequest) {\n                return new AjaxObservable(urlOrRequest);\n            };\n            create.get = ajaxGet;\n            create.post = ajaxPost;\n            create.delete = ajaxDelete;\n            create.put = ajaxPut;\n            create.patch = ajaxPatch;\n            create.getJSON = ajaxGetJSON;\n            return create;\n        })();\n        return AjaxObservable;\n    }(Observable_1.Observable));\n    exports.AjaxObservable = AjaxObservable;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AjaxSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(AjaxSubscriber, _super);\n        function AjaxSubscriber(destination, request) {\n            var _this = _super.call(this, destination) || this;\n            _this.request = request;\n            _this.done = false;\n            var headers = request.headers = request.headers || {};\n            // force CORS if requested\n            if (!request.crossDomain && !headers['X-Requested-With']) {\n                headers['X-Requested-With'] = 'XMLHttpRequest';\n            }\n            // ensure content type is set\n            if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n            }\n            // properly serialize body\n            request.body = _this.serializeBody(request.body, request.headers['Content-Type']);\n            _this.send();\n            return _this;\n        }\n        AjaxSubscriber.prototype.next = function (e) {\n            this.done = true;\n            var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;\n            var response = new AjaxResponse(e, xhr, request);\n            destination.next(response);\n        };\n        AjaxSubscriber.prototype.send = function () {\n            var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;\n            var createXHR = request.createXHR;\n            var xhr = tryCatch_1.tryCatch(createXHR).call(request);\n            if (xhr === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.xhr = xhr;\n                // set up the events before open XHR\n                // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n                // You need to add the event listeners before calling open() on the request.\n                // Otherwise the progress events will not fire.\n                this.setupEvents(xhr, request);\n                // open XHR\n                var result = void 0;\n                if (user) {\n                    result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n                }\n                else {\n                    result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);\n                }\n                if (result === errorObject_1.errorObject) {\n                    this.error(errorObject_1.errorObject.e);\n                    return null;\n                }\n                // timeout, responseType and withCredentials can be set once the XHR is open\n                if (async) {\n                    xhr.timeout = request.timeout;\n                    xhr.responseType = request.responseType;\n                }\n                if ('withCredentials' in xhr) {\n                    xhr.withCredentials = !!request.withCredentials;\n                }\n                // set headers\n                this.setHeaders(xhr, headers);\n                // finally send the request\n                result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);\n                if (result === errorObject_1.errorObject) {\n                    this.error(errorObject_1.errorObject.e);\n                    return null;\n                }\n            }\n            return xhr;\n        };\n        AjaxSubscriber.prototype.serializeBody = function (body, contentType) {\n            if (!body || typeof body === 'string') {\n                return body;\n            }\n            else if (root_1.root.FormData && body instanceof root_1.root.FormData) {\n                return body;\n            }\n            if (contentType) {\n                var splitIndex = contentType.indexOf(';');\n                if (splitIndex !== -1) {\n                    contentType = contentType.substring(0, splitIndex);\n                }\n            }\n            switch (contentType) {\n                case 'application/x-www-form-urlencoded':\n                    return Object.keys(body).map(function (key) { return encodeURI(key) + \"=\" + encodeURI(body[key]); }).join('&');\n                case 'application/json':\n                    return JSON.stringify(body);\n                default:\n                    return body;\n            }\n        };\n        AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {\n            for (var key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        };\n        AjaxSubscriber.prototype.setupEvents = function (xhr, request) {\n            var progressSubscriber = request.progressSubscriber;\n            function xhrTimeout(e) {\n                var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n                if (progressSubscriber) {\n                    progressSubscriber.error(e);\n                }\n                subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n            }\n            ;\n            xhr.ontimeout = xhrTimeout;\n            xhrTimeout.request = request;\n            xhrTimeout.subscriber = this;\n            xhrTimeout.progressSubscriber = progressSubscriber;\n            if (xhr.upload && 'withCredentials' in xhr) {\n                if (progressSubscriber) {\n                    var xhrProgress_1;\n                    xhrProgress_1 = function (e) {\n                        var progressSubscriber = xhrProgress_1.progressSubscriber;\n                        progressSubscriber.next(e);\n                    };\n                    if (root_1.root.XDomainRequest) {\n                        xhr.onprogress = xhrProgress_1;\n                    }\n                    else {\n                        xhr.upload.onprogress = xhrProgress_1;\n                    }\n                    xhrProgress_1.progressSubscriber = progressSubscriber;\n                }\n                var xhrError_1;\n                xhrError_1 = function (e) {\n                    var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;\n                    if (progressSubscriber) {\n                        progressSubscriber.error(e);\n                    }\n                    subscriber.error(new AjaxError('ajax error', this, request));\n                };\n                xhr.onerror = xhrError_1;\n                xhrError_1.request = request;\n                xhrError_1.subscriber = this;\n                xhrError_1.progressSubscriber = progressSubscriber;\n            }\n            function xhrReadyStateChange(e) {\n                var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n                if (this.readyState === 4) {\n                    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                    var status_1 = this.status === 1223 ? 204 : this.status;\n                    var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n                    // fix status code when it is 0 (0 status is undocumented).\n                    // Occurs when accessing file resources or on Android 4.1 stock browser\n                    // while retrieving files from application cache.\n                    if (status_1 === 0) {\n                        status_1 = response ? 200 : 0;\n                    }\n                    if (200 <= status_1 && status_1 < 300) {\n                        if (progressSubscriber) {\n                            progressSubscriber.complete();\n                        }\n                        subscriber.next(e);\n                        subscriber.complete();\n                    }\n                    else {\n                        if (progressSubscriber) {\n                            progressSubscriber.error(e);\n                        }\n                        subscriber.error(new AjaxError('ajax error ' + status_1, this, request));\n                    }\n                }\n            }\n            ;\n            xhr.onreadystatechange = xhrReadyStateChange;\n            xhrReadyStateChange.subscriber = this;\n            xhrReadyStateChange.progressSubscriber = progressSubscriber;\n            xhrReadyStateChange.request = request;\n        };\n        AjaxSubscriber.prototype.unsubscribe = function () {\n            var _a = this, done = _a.done, xhr = _a.xhr;\n            if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n                xhr.abort();\n            }\n            _super.prototype.unsubscribe.call(this);\n        };\n        return AjaxSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.AjaxSubscriber = AjaxSubscriber;\n    /**\n     * A normalized AJAX response.\n     *\n     * @see {@link ajax}\n     *\n     * @class AjaxResponse\n     */\n    var AjaxResponse = /** @class */ (function () {\n        function AjaxResponse(originalEvent, xhr, request) {\n            this.originalEvent = originalEvent;\n            this.xhr = xhr;\n            this.request = request;\n            this.status = xhr.status;\n            this.responseType = xhr.responseType || request.responseType;\n            this.response = parseXhrResponse(this.responseType, xhr);\n        }\n        return AjaxResponse;\n    }());\n    exports.AjaxResponse = AjaxResponse;\n    /**\n     * A normalized AJAX error.\n     *\n     * @see {@link ajax}\n     *\n     * @class AjaxError\n     */\n    var AjaxError = /** @class */ (function (_super) {\n        tslib_1.__extends(AjaxError, _super);\n        function AjaxError(message, xhr, request) {\n            var _this = _super.call(this, message) || this;\n            _this.message = message;\n            _this.xhr = xhr;\n            _this.request = request;\n            _this.status = xhr.status;\n            _this.responseType = xhr.responseType || request.responseType;\n            _this.response = parseXhrResponse(_this.responseType, xhr);\n            return _this;\n        }\n        return AjaxError;\n    }(Error));\n    exports.AjaxError = AjaxError;\n    function parseXhrResponse(responseType, xhr) {\n        switch (responseType) {\n            case 'json':\n                if ('response' in xhr) {\n                    //IE does not support json as responseType, parse it internally\n                    return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n                }\n                else {\n                    return JSON.parse(xhr.responseText || 'null');\n                }\n            case 'xml':\n                return xhr.responseXML;\n            case 'text':\n            default:\n                return ('response' in xhr) ? xhr.response : xhr.responseText;\n        }\n    }\n    /**\n     * @see {@link ajax}\n     *\n     * @class AjaxTimeoutError\n     */\n    var AjaxTimeoutError = /** @class */ (function (_super) {\n        tslib_1.__extends(AjaxTimeoutError, _super);\n        function AjaxTimeoutError(xhr, request) {\n            return _super.call(this, 'ajax timeout', xhr, request) || this;\n        }\n        return AjaxTimeoutError;\n    }(AjaxError));\n    exports.AjaxTimeoutError = AjaxTimeoutError;\n});\n\n/**\nSome credit for this helper goes to http://github.com/YuzuJS/setImmediate\n*/\ndefine('rxjs/util/Immediate',[\"require\", \"exports\", \"./root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ImmediateDefinition = /** @class */ (function () {\n        function ImmediateDefinition(root) {\n            this.root = root;\n            if (root.setImmediate && typeof root.setImmediate === 'function') {\n                this.setImmediate = root.setImmediate.bind(root);\n                this.clearImmediate = root.clearImmediate.bind(root);\n            }\n            else {\n                this.nextHandle = 1;\n                this.tasksByHandle = {};\n                this.currentlyRunningATask = false;\n                // Don't get fooled by e.g. browserify environments.\n                if (this.canUseProcessNextTick()) {\n                    // For Node.js before 0.9\n                    this.setImmediate = this.createProcessNextTickSetImmediate();\n                }\n                else if (this.canUsePostMessage()) {\n                    // For non-IE10 modern browsers\n                    this.setImmediate = this.createPostMessageSetImmediate();\n                }\n                else if (this.canUseMessageChannel()) {\n                    // For web workers, where supported\n                    this.setImmediate = this.createMessageChannelSetImmediate();\n                }\n                else if (this.canUseReadyStateChange()) {\n                    // For IE 68\n                    this.setImmediate = this.createReadyStateChangeSetImmediate();\n                }\n                else {\n                    // For older browsers\n                    this.setImmediate = this.createSetTimeoutSetImmediate();\n                }\n                var ci = function clearImmediate(handle) {\n                    delete clearImmediate.instance.tasksByHandle[handle];\n                };\n                ci.instance = this;\n                this.clearImmediate = ci;\n            }\n        }\n        ImmediateDefinition.prototype.identify = function (o) {\n            return this.root.Object.prototype.toString.call(o);\n        };\n        ImmediateDefinition.prototype.canUseProcessNextTick = function () {\n            return this.identify(this.root.process) === '[object process]';\n        };\n        ImmediateDefinition.prototype.canUseMessageChannel = function () {\n            return Boolean(this.root.MessageChannel);\n        };\n        ImmediateDefinition.prototype.canUseReadyStateChange = function () {\n            var document = this.root.document;\n            return Boolean(document && 'onreadystatechange' in document.createElement('script'));\n        };\n        ImmediateDefinition.prototype.canUsePostMessage = function () {\n            var root = this.root;\n            // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n            // where `root.postMessage` means something completely different and can't be used for this purpose.\n            if (root.postMessage && !root.importScripts) {\n                var postMessageIsAsynchronous_1 = true;\n                var oldOnMessage = root.onmessage;\n                root.onmessage = function () {\n                    postMessageIsAsynchronous_1 = false;\n                };\n                root.postMessage('', '*');\n                root.onmessage = oldOnMessage;\n                return postMessageIsAsynchronous_1;\n            }\n            return false;\n        };\n        // This function accepts the same arguments as setImmediate, but\n        // returns a function that requires no arguments.\n        ImmediateDefinition.prototype.partiallyApplied = function (handler) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var fn = function result() {\n                var _a = result, handler = _a.handler, args = _a.args;\n                if (typeof handler === 'function') {\n                    handler.apply(undefined, args);\n                }\n                else {\n                    (new Function('' + handler))();\n                }\n            };\n            fn.handler = handler;\n            fn.args = args;\n            return fn;\n        };\n        ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {\n            this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);\n            return this.nextHandle++;\n        };\n        ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {\n            var fn = function setImmediate() {\n                var instance = setImmediate.instance;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));\n                return handle;\n            };\n            fn.instance = this;\n            return fn;\n        };\n        ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {\n            // Installs an event handler on `global` for the `message` event: see\n            // * https://developer.mozilla.org/en/DOM/window.postMessage\n            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n            var root = this.root;\n            var messagePrefix = 'setImmediate$' + root.Math.random() + '$';\n            var onGlobalMessage = function globalMessageHandler(event) {\n                var instance = globalMessageHandler.instance;\n                if (event.source === root &&\n                    typeof event.data === 'string' &&\n                    event.data.indexOf(messagePrefix) === 0) {\n                    instance.runIfPresent(+event.data.slice(messagePrefix.length));\n                }\n            };\n            onGlobalMessage.instance = this;\n            root.addEventListener('message', onGlobalMessage, false);\n            var fn = function setImmediate() {\n                var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                instance.root.postMessage(messagePrefix + handle, '*');\n                return handle;\n            };\n            fn.instance = this;\n            fn.messagePrefix = messagePrefix;\n            return fn;\n        };\n        ImmediateDefinition.prototype.runIfPresent = function (handle) {\n            // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'\n            // So if we're currently running a task, we'll need to delay this invocation.\n            if (this.currentlyRunningATask) {\n                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n                // 'too much recursion' error.\n                this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);\n            }\n            else {\n                var task = this.tasksByHandle[handle];\n                if (task) {\n                    this.currentlyRunningATask = true;\n                    try {\n                        task();\n                    }\n                    finally {\n                        this.clearImmediate(handle);\n                        this.currentlyRunningATask = false;\n                    }\n                }\n            }\n        };\n        ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {\n            var _this = this;\n            var channel = new this.root.MessageChannel();\n            channel.port1.onmessage = function (event) {\n                var handle = event.data;\n                _this.runIfPresent(handle);\n            };\n            var fn = function setImmediate() {\n                var _a = setImmediate, channel = _a.channel, instance = _a.instance;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                channel.port2.postMessage(handle);\n                return handle;\n            };\n            fn.channel = channel;\n            fn.instance = this;\n            return fn;\n        };\n        ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {\n            var fn = function setImmediate() {\n                var instance = setImmediate.instance;\n                var root = instance.root;\n                var doc = root.document;\n                var html = doc.documentElement;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n                var script = doc.createElement('script');\n                script.onreadystatechange = function () {\n                    instance.runIfPresent(handle);\n                    script.onreadystatechange = null;\n                    html.removeChild(script);\n                    script = null;\n                };\n                html.appendChild(script);\n                return handle;\n            };\n            fn.instance = this;\n            return fn;\n        };\n        ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {\n            var fn = function setImmediate() {\n                var instance = setImmediate.instance;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);\n                return handle;\n            };\n            fn.instance = this;\n            return fn;\n        };\n        return ImmediateDefinition;\n    }());\n    exports.ImmediateDefinition = ImmediateDefinition;\n    exports.Immediate = new ImmediateDefinition(root_1.root);\n});\n\ndefine('rxjs/scheduler/AsapAction',[\"require\", \"exports\", \"tslib\", \"../util/Immediate\", \"./AsyncAction\"], function (require, exports, tslib_1, Immediate_1, AsyncAction_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AsapAction = /** @class */ (function (_super) {\n        tslib_1.__extends(AsapAction, _super);\n        function AsapAction(scheduler, work) {\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            return _this;\n        }\n        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay is greater than 0, request as an async action.\n            if (delay !== null && delay > 0) {\n                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n            }\n            // Push the action to the end of the scheduler queue.\n            scheduler.actions.push(this);\n            // If a microtask has already been scheduled, don't schedule another\n            // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n            // the current scheduled microtask id.\n            return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n        };\n        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay exists and is greater than 0, or if the delay is null (the\n            // action wasn't rescheduled) but was originally scheduled as an async\n            // action, then recycle as an async action.\n            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n            }\n            // If the scheduler queue is empty, cancel the requested microtask and\n            // set the scheduled flag to undefined so the next AsapAction will schedule\n            // its own.\n            if (scheduler.actions.length === 0) {\n                Immediate_1.Immediate.clearImmediate(id);\n                scheduler.scheduled = undefined;\n            }\n            // Return undefined so the action knows to request a new async id if it's rescheduled.\n            return undefined;\n        };\n        return AsapAction;\n    }(AsyncAction_1.AsyncAction));\n    exports.AsapAction = AsapAction;\n});\n\ndefine('rxjs/scheduler/AsapScheduler',[\"require\", \"exports\", \"tslib\", \"./AsyncScheduler\"], function (require, exports, tslib_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var AsapScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(AsapScheduler, _super);\n        function AsapScheduler() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        AsapScheduler.prototype.flush = function (action) {\n            this.active = true;\n            this.scheduled = undefined;\n            var actions = this.actions;\n            var error;\n            var index = -1;\n            var count = actions.length;\n            action = action || actions.shift();\n            do {\n                if (error = action.execute(action.state, action.delay)) {\n                    break;\n                }\n            } while (++index < count && (action = actions.shift()));\n            this.active = false;\n            if (error) {\n                while (++index < count && (action = actions.shift())) {\n                    action.unsubscribe();\n                }\n                throw error;\n            }\n        };\n        return AsapScheduler;\n    }(AsyncScheduler_1.AsyncScheduler));\n    exports.AsapScheduler = AsapScheduler;\n});\n\ndefine('rxjs/scheduler/asap',[\"require\", \"exports\", \"./AsapAction\", \"./AsapScheduler\"], function (require, exports, AsapAction_1, AsapScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Asap Scheduler\n     *\n     * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n     *\n     * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task\n     * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n     * code to end and then it will try to execute given task as fast as possible.\n     *\n     * `asap` scheduler will do its best to minimize time between end of currently executing code\n     * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n     * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n     * some (although minimal) unwanted delay.\n     *\n     * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n     * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n     * that task will execute first. That being said, if you need to schedule task asynchronously, but\n     * as soon as possible, `asap` scheduler is your best bet.\n     *\n     * @example <caption>Compare async and asap scheduler</caption>\n     *\n     * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...\n     * Rx.Scheduler.asap.schedule(() => console.log('asap'));\n     *\n     * // Logs:\n     * // \"asap\"\n     * // \"async\"\n     * // ... but 'asap' goes first!\n     *\n     * @static true\n     * @name asap\n     * @owner Scheduler\n     */\n    exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);\n});\n\ndefine('rxjs/util/AnimationFrame',[\"require\", \"exports\", \"./root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var RequestAnimationFrameDefinition = /** @class */ (function () {\n        function RequestAnimationFrameDefinition(root) {\n            if (root.requestAnimationFrame) {\n                this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.requestAnimationFrame.bind(root);\n            }\n            else if (root.mozRequestAnimationFrame) {\n                this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);\n            }\n            else if (root.webkitRequestAnimationFrame) {\n                this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);\n            }\n            else if (root.msRequestAnimationFrame) {\n                this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);\n            }\n            else if (root.oRequestAnimationFrame) {\n                this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);\n            }\n            else {\n                this.cancelAnimationFrame = root.clearTimeout.bind(root);\n                this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };\n            }\n        }\n        return RequestAnimationFrameDefinition;\n    }());\n    exports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;\n    exports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);\n});\n\ndefine('rxjs/scheduler/AnimationFrameAction',[\"require\", \"exports\", \"tslib\", \"./AsyncAction\", \"../util/AnimationFrame\"], function (require, exports, tslib_1, AsyncAction_1, AnimationFrame_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AnimationFrameAction = /** @class */ (function (_super) {\n        tslib_1.__extends(AnimationFrameAction, _super);\n        function AnimationFrameAction(scheduler, work) {\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            return _this;\n        }\n        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay is greater than 0, request as an async action.\n            if (delay !== null && delay > 0) {\n                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n            }\n            // Push the action to the end of the scheduler queue.\n            scheduler.actions.push(this);\n            // If an animation frame has already been requested, don't request another\n            // one. If an animation frame hasn't been requested yet, request one. Return\n            // the current animation frame request id.\n            return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));\n        };\n        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay exists and is greater than 0, or if the delay is null (the\n            // action wasn't rescheduled) but was originally scheduled as an async\n            // action, then recycle as an async action.\n            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n            }\n            // If the scheduler queue is empty, cancel the requested animation frame and\n            // set the scheduled flag to undefined so the next AnimationFrameAction will\n            // request its own.\n            if (scheduler.actions.length === 0) {\n                AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);\n                scheduler.scheduled = undefined;\n            }\n            // Return undefined so the action knows to request a new async id if it's rescheduled.\n            return undefined;\n        };\n        return AnimationFrameAction;\n    }(AsyncAction_1.AsyncAction));\n    exports.AnimationFrameAction = AnimationFrameAction;\n});\n\ndefine('rxjs/scheduler/AnimationFrameScheduler',[\"require\", \"exports\", \"tslib\", \"./AsyncScheduler\"], function (require, exports, tslib_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var AnimationFrameScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(AnimationFrameScheduler, _super);\n        function AnimationFrameScheduler() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        AnimationFrameScheduler.prototype.flush = function (action) {\n            this.active = true;\n            this.scheduled = undefined;\n            var actions = this.actions;\n            var error;\n            var index = -1;\n            var count = actions.length;\n            action = action || actions.shift();\n            do {\n                if (error = action.execute(action.state, action.delay)) {\n                    break;\n                }\n            } while (++index < count && (action = actions.shift()));\n            this.active = false;\n            if (error) {\n                while (++index < count && (action = actions.shift())) {\n                    action.unsubscribe();\n                }\n                throw error;\n            }\n        };\n        return AnimationFrameScheduler;\n    }(AsyncScheduler_1.AsyncScheduler));\n    exports.AnimationFrameScheduler = AnimationFrameScheduler;\n});\n\ndefine('rxjs/scheduler/animationFrame',[\"require\", \"exports\", \"./AnimationFrameAction\", \"./AnimationFrameScheduler\"], function (require, exports, AnimationFrameAction_1, AnimationFrameScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Animation Frame Scheduler\n     *\n     * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n     *\n     * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler\n     * behaviour.\n     *\n     * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n     * It makes sure scheduled task will happen just before next browser content repaint,\n     * thus performing animations as efficiently as possible.\n     *\n     * @example <caption>Schedule div height animation</caption>\n     * const div = document.querySelector('.some-div');\n     *\n     * Rx.Scheduler.schedule(function(height) {\n     *   div.style.height = height + \"px\";\n     *\n     *   this.schedule(height + 1);  // `this` references currently executing Action,\n     *                               // which we reschedule with new state\n     * }, 0, 0);\n     *\n     * // You will see .some-div element growing in height\n     *\n     *\n     * @static true\n     * @name animationFrame\n     * @owner Scheduler\n     */\n    exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);\n});\n\ndefine('rxjs/symbol/iterator',[\"require\", \"exports\", \"../util/root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function symbolIteratorPonyfill(root) {\n        var Symbol = root.Symbol;\n        if (typeof Symbol === 'function') {\n            if (!Symbol.iterator) {\n                Symbol.iterator = Symbol('iterator polyfill');\n            }\n            return Symbol.iterator;\n        }\n        else {\n            // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n            var Set_1 = root.Set;\n            if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n                return '@@iterator';\n            }\n            var Map_1 = root.Map;\n            // required for compatability with es6-shim\n            if (Map_1) {\n                var keys = Object.getOwnPropertyNames(Map_1.prototype);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n                    if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n                        return key;\n                    }\n                }\n            }\n            return '@@iterator';\n        }\n    }\n    exports.symbolIteratorPonyfill = symbolIteratorPonyfill;\n    exports.iterator = symbolIteratorPonyfill(root_1.root);\n    /**\n     * @deprecated use iterator instead\n     */\n    exports.$$iterator = exports.iterator;\n});\n\ndefine('rxjs/OuterSubscriber',[\"require\", \"exports\", \"tslib\", \"./Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var OuterSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(OuterSubscriber, _super);\n        function OuterSubscriber() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.destination.next(innerValue);\n        };\n        OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n            this.destination.error(error);\n        };\n        OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.destination.complete();\n        };\n        return OuterSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.OuterSubscriber = OuterSubscriber;\n});\n\ndefine('rxjs/util/isArrayLike',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n});\n\ndefine('rxjs/util/isPromise',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isPromise(value) {\n        return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n    }\n    exports.isPromise = isPromise;\n});\n\ndefine('rxjs/InnerSubscriber',[\"require\", \"exports\", \"tslib\", \"./Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var InnerSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(InnerSubscriber, _super);\n        function InnerSubscriber(parent, outerValue, outerIndex) {\n            var _this = _super.call(this) || this;\n            _this.parent = parent;\n            _this.outerValue = outerValue;\n            _this.outerIndex = outerIndex;\n            _this.index = 0;\n            return _this;\n        }\n        InnerSubscriber.prototype._next = function (value) {\n            this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n        };\n        InnerSubscriber.prototype._error = function (error) {\n            this.parent.notifyError(error, this);\n            this.unsubscribe();\n        };\n        InnerSubscriber.prototype._complete = function () {\n            this.parent.notifyComplete(this);\n            this.unsubscribe();\n        };\n        return InnerSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.InnerSubscriber = InnerSubscriber;\n});\n\ndefine('rxjs/util/subscribeToResult',[\"require\", \"exports\", \"./root\", \"./isArrayLike\", \"./isPromise\", \"./isObject\", \"../Observable\", \"../symbol/iterator\", \"../InnerSubscriber\", \"../symbol/observable\"], function (require, exports, root_1, isArrayLike_1, isPromise_1, isObject_1, Observable_1, iterator_1, InnerSubscriber_1, observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n        var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n        if (destination.closed) {\n            return null;\n        }\n        if (result instanceof Observable_1.Observable) {\n            if (result._isScalar) {\n                destination.next(result.value);\n                destination.complete();\n                return null;\n            }\n            else {\n                destination.syncErrorThrowable = true;\n                return result.subscribe(destination);\n            }\n        }\n        else if (isArrayLike_1.isArrayLike(result)) {\n            for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n                destination.next(result[i]);\n            }\n            if (!destination.closed) {\n                destination.complete();\n            }\n        }\n        else if (isPromise_1.isPromise(result)) {\n            result.then(function (value) {\n                if (!destination.closed) {\n                    destination.next(value);\n                    destination.complete();\n                }\n            }, function (err) { return destination.error(err); })\n                .then(null, function (err) {\n                // Escaping the Promise trap: globally throw unhandled errors\n                root_1.root.setTimeout(function () { throw err; });\n            });\n            return destination;\n        }\n        else if (result && typeof result[iterator_1.iterator] === 'function') {\n            var iterator = result[iterator_1.iterator]();\n            do {\n                var item = iterator.next();\n                if (item.done) {\n                    destination.complete();\n                    break;\n                }\n                destination.next(item.value);\n                if (destination.closed) {\n                    break;\n                }\n            } while (true);\n        }\n        else if (result && typeof result[observable_1.observable] === 'function') {\n            var obs = result[observable_1.observable]();\n            if (typeof obs.subscribe !== 'function') {\n                destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n            }\n            else {\n                return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n            }\n        }\n        else {\n            var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n            var msg = \"You provided \" + value + \" where a stream was expected.\"\n                + ' You can provide an Observable, Promise, Array, or Iterable.';\n            destination.error(new TypeError(msg));\n        }\n        return null;\n    }\n    exports.subscribeToResult = subscribeToResult;\n});\n\ndefine('rxjs/operators/audit',[\"require\", \"exports\", \"tslib\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores source values for a duration determined by another Observable, then\n     * emits the most recent value from the source Observable, then repeats this\n     * process.\n     *\n     * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n     * duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/audit.png\" width=\"100%\">\n     *\n     * `audit` is similar to `throttle`, but emits the last value from the silenced\n     * time window, instead of the first value. `audit` emits the most recent value\n     * from the source Observable on the output Observable as soon as its internal\n     * timer becomes disabled, and ignores source values while the timer is enabled.\n     * Initially, the timer is disabled. As soon as the first source value arrives,\n     * the timer is enabled by calling the `durationSelector` function with the\n     * source value, which returns the \"duration\" Observable. When the duration\n     * Observable emits a value or completes, the timer is disabled, then the most\n     * recent source value is emitted on the output Observable, and this process\n     * repeats for the next source value.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounce}\n     * @see {@link delayWhen}\n     * @see {@link sample}\n     * @see {@link throttle}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the silencing\n     * duration, returned as an Observable or a Promise.\n     * @return {Observable<T>} An Observable that performs rate-limiting of\n     * emissions from the source Observable.\n     * @method audit\n     * @owner Observable\n     */\n    function audit(durationSelector) {\n        return function auditOperatorFunction(source) {\n            return source.lift(new AuditOperator(durationSelector));\n        };\n    }\n    exports.audit = audit;\n    var AuditOperator = /** @class */ (function () {\n        function AuditOperator(durationSelector) {\n            this.durationSelector = durationSelector;\n        }\n        AuditOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n        };\n        return AuditOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AuditSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(AuditSubscriber, _super);\n        function AuditSubscriber(destination, durationSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.durationSelector = durationSelector;\n            _this.hasValue = false;\n            return _this;\n        }\n        AuditSubscriber.prototype._next = function (value) {\n            this.value = value;\n            this.hasValue = true;\n            if (!this.throttled) {\n                var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n                if (duration === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                    if (innerSubscription.closed) {\n                        this.clearThrottle();\n                    }\n                    else {\n                        this.add(this.throttled = innerSubscription);\n                    }\n                }\n            }\n        };\n        AuditSubscriber.prototype.clearThrottle = function () {\n            var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n            if (throttled) {\n                this.remove(throttled);\n                this.throttled = null;\n                throttled.unsubscribe();\n            }\n            if (hasValue) {\n                this.value = null;\n                this.hasValue = false;\n                this.destination.next(value);\n            }\n        };\n        AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n            this.clearThrottle();\n        };\n        AuditSubscriber.prototype.notifyComplete = function () {\n            this.clearThrottle();\n        };\n        return AuditSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/util/isNumeric',[\"require\", \"exports\", \"../util/isArray\"], function (require, exports, isArray_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isNumeric(val) {\n        // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n        // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n        // subtraction forces infinities to NaN\n        // adding 1 corrects loss of precision from parseFloat (#15100)\n        return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n    }\n    exports.isNumeric = isNumeric;\n    ;\n});\n\ndefine('rxjs/util/isScheduler',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isScheduler(value) {\n        return value && typeof value.schedule === 'function';\n    }\n    exports.isScheduler = isScheduler;\n});\n\ndefine('rxjs/util/isDate',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isDate(value) {\n        return value instanceof Date && !isNaN(+value);\n    }\n    exports.isDate = isDate;\n});\n\ndefine('rxjs/observable/TimerObservable',[\"require\", \"exports\", \"tslib\", \"../util/isNumeric\", \"../Observable\", \"../scheduler/async\", \"../util/isScheduler\", \"../util/isDate\"], function (require, exports, tslib_1, isNumeric_1, Observable_1, async_1, isScheduler_1, isDate_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var TimerObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(TimerObservable, _super);\n        function TimerObservable(dueTime, period, scheduler) {\n            if (dueTime === void 0) { dueTime = 0; }\n            var _this = _super.call(this) || this;\n            _this.period = -1;\n            _this.dueTime = 0;\n            if (isNumeric_1.isNumeric(period)) {\n                _this.period = Number(period) < 1 && 1 || Number(period);\n            }\n            else if (isScheduler_1.isScheduler(period)) {\n                scheduler = period;\n            }\n            if (!isScheduler_1.isScheduler(scheduler)) {\n                scheduler = async_1.async;\n            }\n            _this.scheduler = scheduler;\n            _this.dueTime = isDate_1.isDate(dueTime) ?\n                (+dueTime - _this.scheduler.now()) :\n                dueTime;\n            return _this;\n        }\n        /**\n         * Creates an Observable that starts emitting after an `initialDelay` and\n         * emits ever increasing numbers after each `period` of time thereafter.\n         *\n         * <span class=\"informal\">Its like {@link interval}, but you can specify when\n         * should the emissions start.</span>\n         *\n         * <img src=\"./img/timer.png\" width=\"100%\">\n         *\n         * `timer` returns an Observable that emits an infinite sequence of ascending\n         * integers, with a constant interval of time, `period` of your choosing\n         * between those emissions. The first emission happens after the specified\n         * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n         * operator uses the `async` IScheduler to provide a notion of time, but you\n         * may pass any IScheduler to it. If `period` is not specified, the output\n         * Observable emits only one value, `0`. Otherwise, it emits an infinite\n         * sequence.\n         *\n         * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n         * var numbers = Rx.Observable.timer(3000, 1000);\n         * numbers.subscribe(x => console.log(x));\n         *\n         * @example <caption>Emits one number after five seconds</caption>\n         * var numbers = Rx.Observable.timer(5000);\n         * numbers.subscribe(x => console.log(x));\n         *\n         * @see {@link interval}\n         * @see {@link delay}\n         *\n         * @param {number|Date} initialDelay The initial delay time to wait before\n         * emitting the first value of `0`.\n         * @param {number} [period] The period of time between emissions of the\n         * subsequent numbers.\n         * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n         * the emission of values, and providing a notion of \"time\".\n         * @return {Observable} An Observable that emits a `0` after the\n         * `initialDelay` and ever increasing numbers after each `period` of time\n         * thereafter.\n         * @static true\n         * @name timer\n         * @owner Observable\n         */\n        TimerObservable.create = function (initialDelay, period, scheduler) {\n            if (initialDelay === void 0) { initialDelay = 0; }\n            return new TimerObservable(initialDelay, period, scheduler);\n        };\n        TimerObservable.dispatch = function (state) {\n            var index = state.index, period = state.period, subscriber = state.subscriber;\n            var action = this;\n            subscriber.next(index);\n            if (subscriber.closed) {\n                return;\n            }\n            else if (period === -1) {\n                return subscriber.complete();\n            }\n            state.index = index + 1;\n            action.schedule(state, period);\n        };\n        TimerObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n            return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n                index: index, period: period, subscriber: subscriber\n            });\n        };\n        return TimerObservable;\n    }(Observable_1.Observable));\n    exports.TimerObservable = TimerObservable;\n});\n\ndefine('rxjs/observable/timer',[\"require\", \"exports\", \"./TimerObservable\"], function (require, exports, TimerObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.timer = TimerObservable_1.TimerObservable.create;\n});\n\ndefine('rxjs/operators/auditTime',[\"require\", \"exports\", \"../scheduler/async\", \"./audit\", \"../observable/timer\"], function (require, exports, async_1, audit_1, timer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores source values for `duration` milliseconds, then emits the most recent\n     * value from the source Observable, then repeats this process.\n     *\n     * <span class=\"informal\">When it sees a source values, it ignores that plus\n     * the next ones for `duration` milliseconds, and then it emits the most recent\n     * value from the source.</span>\n     *\n     * <img src=\"./img/auditTime.png\" width=\"100%\">\n     *\n     * `auditTime` is similar to `throttleTime`, but emits the last value from the\n     * silenced time window, instead of the first value. `auditTime` emits the most\n     * recent value from the source Observable on the output Observable as soon as\n     * its internal timer becomes disabled, and ignores source values while the\n     * timer is enabled. Initially, the timer is disabled. As soon as the first\n     * source value arrives, the timer is enabled. After `duration` milliseconds (or\n     * the time unit determined internally by the optional `scheduler`) has passed,\n     * the timer is disabled, then the most recent source value is emitted on the\n     * output Observable, and this process repeats for the next source value.\n     * Optionally takes a {@link IScheduler} for managing timers.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.auditTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttleTime}\n     *\n     * @param {number} duration Time to wait before emitting the most recent source\n     * value, measured in milliseconds or the time unit determined internally\n     * by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the rate-limiting behavior.\n     * @return {Observable<T>} An Observable that performs rate-limiting of\n     * emissions from the source Observable.\n     * @method auditTime\n     * @owner Observable\n     */\n    function auditTime(duration, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n    }\n    exports.auditTime = auditTime;\n});\n\ndefine('rxjs/operators/buffer',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values until `closingNotifier` emits.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * that array only when another Observable emits.</span>\n     *\n     * <img src=\"./img/buffer.png\" width=\"100%\">\n     *\n     * Buffers the incoming Observable values until the given `closingNotifier`\n     * Observable emits a value, at which point it emits the buffer on the output\n     * Observable and starts a new buffer internally, awaiting the next time\n     * `closingNotifier` emits.\n     *\n     * @example <caption>On every click, emit array of most recent interval events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var interval = Rx.Observable.interval(1000);\n     * var buffered = interval.buffer(clicks);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link window}\n     *\n     * @param {Observable<any>} closingNotifier An Observable that signals the\n     * buffer to be emitted on the output Observable.\n     * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n     * values.\n     * @method buffer\n     * @owner Observable\n     */\n    function buffer(closingNotifier) {\n        return function bufferOperatorFunction(source) {\n            return source.lift(new BufferOperator(closingNotifier));\n        };\n    }\n    exports.buffer = buffer;\n    var BufferOperator = /** @class */ (function () {\n        function BufferOperator(closingNotifier) {\n            this.closingNotifier = closingNotifier;\n        }\n        BufferOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n        };\n        return BufferOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferSubscriber, _super);\n        function BufferSubscriber(destination, closingNotifier) {\n            var _this = _super.call(this, destination) || this;\n            _this.buffer = [];\n            _this.add(subscribeToResult_1.subscribeToResult(_this, closingNotifier));\n            return _this;\n        }\n        BufferSubscriber.prototype._next = function (value) {\n            this.buffer.push(value);\n        };\n        BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var buffer = this.buffer;\n            this.buffer = [];\n            this.destination.next(buffer);\n        };\n        return BufferSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/bufferCount',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values until the size hits the maximum\n     * `bufferSize` given.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * that array only when its size reaches `bufferSize`.</span>\n     *\n     * <img src=\"./img/bufferCount.png\" width=\"100%\">\n     *\n     * Buffers a number of values from the source Observable by `bufferSize` then\n     * emits the buffer and clears it, and starts a new buffer each\n     * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n     * `null`, then new buffers are started immediately at the start of the source\n     * and when each buffer closes and is emitted.\n     *\n     * @example <caption>Emit the last two click events as an array</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferCount(2);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @example <caption>On every click, emit the last two click events as an array</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferCount(2, 1);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link pairwise}\n     * @see {@link windowCount}\n     *\n     * @param {number} bufferSize The maximum size of the buffer emitted.\n     * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n     * For example if `startBufferEvery` is `2`, then a new buffer will be started\n     * on every other value from the source. A new buffer is started at the\n     * beginning of the source by default.\n     * @return {Observable<T[]>} An Observable of arrays of buffered values.\n     * @method bufferCount\n     * @owner Observable\n     */\n    function bufferCount(bufferSize, startBufferEvery) {\n        if (startBufferEvery === void 0) { startBufferEvery = null; }\n        return function bufferCountOperatorFunction(source) {\n            return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n        };\n    }\n    exports.bufferCount = bufferCount;\n    var BufferCountOperator = /** @class */ (function () {\n        function BufferCountOperator(bufferSize, startBufferEvery) {\n            this.bufferSize = bufferSize;\n            this.startBufferEvery = startBufferEvery;\n            if (!startBufferEvery || bufferSize === startBufferEvery) {\n                this.subscriberClass = BufferCountSubscriber;\n            }\n            else {\n                this.subscriberClass = BufferSkipCountSubscriber;\n            }\n        }\n        BufferCountOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n        };\n        return BufferCountOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferCountSubscriber, _super);\n        function BufferCountSubscriber(destination, bufferSize) {\n            var _this = _super.call(this, destination) || this;\n            _this.bufferSize = bufferSize;\n            _this.buffer = [];\n            return _this;\n        }\n        BufferCountSubscriber.prototype._next = function (value) {\n            var buffer = this.buffer;\n            buffer.push(value);\n            if (buffer.length == this.bufferSize) {\n                this.destination.next(buffer);\n                this.buffer = [];\n            }\n        };\n        BufferCountSubscriber.prototype._complete = function () {\n            var buffer = this.buffer;\n            if (buffer.length > 0) {\n                this.destination.next(buffer);\n            }\n            _super.prototype._complete.call(this);\n        };\n        return BufferCountSubscriber;\n    }(Subscriber_1.Subscriber));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferSkipCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferSkipCountSubscriber, _super);\n        function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n            var _this = _super.call(this, destination) || this;\n            _this.bufferSize = bufferSize;\n            _this.startBufferEvery = startBufferEvery;\n            _this.buffers = [];\n            _this.count = 0;\n            return _this;\n        }\n        BufferSkipCountSubscriber.prototype._next = function (value) {\n            var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n            this.count++;\n            if (count % startBufferEvery === 0) {\n                buffers.push([]);\n            }\n            for (var i = buffers.length; i--;) {\n                var buffer = buffers[i];\n                buffer.push(value);\n                if (buffer.length === bufferSize) {\n                    buffers.splice(i, 1);\n                    this.destination.next(buffer);\n                }\n            }\n        };\n        BufferSkipCountSubscriber.prototype._complete = function () {\n            var _a = this, buffers = _a.buffers, destination = _a.destination;\n            while (buffers.length > 0) {\n                var buffer = buffers.shift();\n                if (buffer.length > 0) {\n                    destination.next(buffer);\n                }\n            }\n            _super.prototype._complete.call(this);\n        };\n        return BufferSkipCountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/bufferTime',[\"require\", \"exports\", \"tslib\", \"../scheduler/async\", \"../Subscriber\", \"../util/isScheduler\"], function (require, exports, tslib_1, async_1, Subscriber_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Buffers the source Observable values for a specific time period.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * those arrays periodically in time.</span>\n     *\n     * <img src=\"./img/bufferTime.png\" width=\"100%\">\n     *\n     * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n     * Unless the optional argument `bufferCreationInterval` is given, it emits and\n     * resets the buffer every `bufferTimeSpan` milliseconds. If\n     * `bufferCreationInterval` is given, this operator opens the buffer every\n     * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n     * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n     * `maxBufferSize` is specified, the buffer will be closed either after\n     * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n     *\n     * @example <caption>Every second, emit an array of the recent click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferTime(1000);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferTime(2000, 5000);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link windowTime}\n     *\n     * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n     * @param {number} [bufferCreationInterval] The interval at which to start new\n     * buffers.\n     * @param {number} [maxBufferSize] The maximum buffer size.\n     * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n     * intervals that determine buffer boundaries.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferTime\n     * @owner Observable\n     */\n    function bufferTime(bufferTimeSpan) {\n        var length = arguments.length;\n        var scheduler = async_1.async;\n        if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n            scheduler = arguments[arguments.length - 1];\n            length--;\n        }\n        var bufferCreationInterval = null;\n        if (length >= 2) {\n            bufferCreationInterval = arguments[1];\n        }\n        var maxBufferSize = Number.POSITIVE_INFINITY;\n        if (length >= 3) {\n            maxBufferSize = arguments[2];\n        }\n        return function bufferTimeOperatorFunction(source) {\n            return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n        };\n    }\n    exports.bufferTime = bufferTime;\n    var BufferTimeOperator = /** @class */ (function () {\n        function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n            this.bufferTimeSpan = bufferTimeSpan;\n            this.bufferCreationInterval = bufferCreationInterval;\n            this.maxBufferSize = maxBufferSize;\n            this.scheduler = scheduler;\n        }\n        BufferTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n        };\n        return BufferTimeOperator;\n    }());\n    var Context = /** @class */ (function () {\n        function Context() {\n            this.buffer = [];\n        }\n        return Context;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferTimeSubscriber, _super);\n        function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.bufferTimeSpan = bufferTimeSpan;\n            _this.bufferCreationInterval = bufferCreationInterval;\n            _this.maxBufferSize = maxBufferSize;\n            _this.scheduler = scheduler;\n            _this.contexts = [];\n            var context = _this.openContext();\n            _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n            if (_this.timespanOnly) {\n                var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };\n                _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n            }\n            else {\n                var closeState = { subscriber: _this, context: context };\n                var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };\n                _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n                _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n            }\n            return _this;\n        }\n        BufferTimeSubscriber.prototype._next = function (value) {\n            var contexts = this.contexts;\n            var len = contexts.length;\n            var filledBufferContext;\n            for (var i = 0; i < len; i++) {\n                var context = contexts[i];\n                var buffer = context.buffer;\n                buffer.push(value);\n                if (buffer.length == this.maxBufferSize) {\n                    filledBufferContext = context;\n                }\n            }\n            if (filledBufferContext) {\n                this.onBufferFull(filledBufferContext);\n            }\n        };\n        BufferTimeSubscriber.prototype._error = function (err) {\n            this.contexts.length = 0;\n            _super.prototype._error.call(this, err);\n        };\n        BufferTimeSubscriber.prototype._complete = function () {\n            var _a = this, contexts = _a.contexts, destination = _a.destination;\n            while (contexts.length > 0) {\n                var context = contexts.shift();\n                destination.next(context.buffer);\n            }\n            _super.prototype._complete.call(this);\n        };\n        BufferTimeSubscriber.prototype._unsubscribe = function () {\n            this.contexts = null;\n        };\n        BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n            this.closeContext(context);\n            var closeAction = context.closeAction;\n            closeAction.unsubscribe();\n            this.remove(closeAction);\n            if (!this.closed && this.timespanOnly) {\n                context = this.openContext();\n                var bufferTimeSpan = this.bufferTimeSpan;\n                var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n                this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n            }\n        };\n        BufferTimeSubscriber.prototype.openContext = function () {\n            var context = new Context();\n            this.contexts.push(context);\n            return context;\n        };\n        BufferTimeSubscriber.prototype.closeContext = function (context) {\n            this.destination.next(context.buffer);\n            var contexts = this.contexts;\n            var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n            if (spliceIndex >= 0) {\n                contexts.splice(contexts.indexOf(context), 1);\n            }\n        };\n        return BufferTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchBufferTimeSpanOnly(state) {\n        var subscriber = state.subscriber;\n        var prevContext = state.context;\n        if (prevContext) {\n            subscriber.closeContext(prevContext);\n        }\n        if (!subscriber.closed) {\n            state.context = subscriber.openContext();\n            state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n        }\n    }\n    function dispatchBufferCreation(state) {\n        var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n        var context = subscriber.openContext();\n        var action = this;\n        if (!subscriber.closed) {\n            subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n            action.schedule(state, bufferCreationInterval);\n        }\n    }\n    function dispatchBufferClose(arg) {\n        var subscriber = arg.subscriber, context = arg.context;\n        subscriber.closeContext(context);\n    }\n});\n\ndefine('rxjs/operators/bufferToggle',[\"require\", \"exports\", \"tslib\", \"../Subscription\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Subscription_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values starting from an emission from\n     * `openings` and ending when the output of `closingSelector` emits.\n     *\n     * <span class=\"informal\">Collects values from the past as an array. Starts\n     * collecting only when `opening` emits, and calls the `closingSelector`\n     * function to get an Observable that tells when to close the buffer.</span>\n     *\n     * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n     *\n     * Buffers values from the source by opening the buffer via signals from an\n     * Observable provided to `openings`, and closing and sending the buffers when\n     * a Subscribable or Promise returned by the `closingSelector` function emits.\n     *\n     * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var openings = Rx.Observable.interval(1000);\n     * var buffered = clicks.bufferToggle(openings, i =>\n     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n     * );\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferWhen}\n     * @see {@link windowToggle}\n     *\n     * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n     * buffers.\n     * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n     * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n     * which, when it emits, signals that the associated buffer should be emitted\n     * and cleared.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferToggle\n     * @owner Observable\n     */\n    function bufferToggle(openings, closingSelector) {\n        return function bufferToggleOperatorFunction(source) {\n            return source.lift(new BufferToggleOperator(openings, closingSelector));\n        };\n    }\n    exports.bufferToggle = bufferToggle;\n    var BufferToggleOperator = /** @class */ (function () {\n        function BufferToggleOperator(openings, closingSelector) {\n            this.openings = openings;\n            this.closingSelector = closingSelector;\n        }\n        BufferToggleOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n        };\n        return BufferToggleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferToggleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferToggleSubscriber, _super);\n        function BufferToggleSubscriber(destination, openings, closingSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.openings = openings;\n            _this.closingSelector = closingSelector;\n            _this.contexts = [];\n            _this.add(subscribeToResult_1.subscribeToResult(_this, openings));\n            return _this;\n        }\n        BufferToggleSubscriber.prototype._next = function (value) {\n            var contexts = this.contexts;\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].buffer.push(value);\n            }\n        };\n        BufferToggleSubscriber.prototype._error = function (err) {\n            var contexts = this.contexts;\n            while (contexts.length > 0) {\n                var context = contexts.shift();\n                context.subscription.unsubscribe();\n                context.buffer = null;\n                context.subscription = null;\n            }\n            this.contexts = null;\n            _super.prototype._error.call(this, err);\n        };\n        BufferToggleSubscriber.prototype._complete = function () {\n            var contexts = this.contexts;\n            while (contexts.length > 0) {\n                var context = contexts.shift();\n                this.destination.next(context.buffer);\n                context.subscription.unsubscribe();\n                context.buffer = null;\n                context.subscription = null;\n            }\n            this.contexts = null;\n            _super.prototype._complete.call(this);\n        };\n        BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n        };\n        BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.closeBuffer(innerSub.context);\n        };\n        BufferToggleSubscriber.prototype.openBuffer = function (value) {\n            try {\n                var closingSelector = this.closingSelector;\n                var closingNotifier = closingSelector.call(this, value);\n                if (closingNotifier) {\n                    this.trySubscribe(closingNotifier);\n                }\n            }\n            catch (err) {\n                this._error(err);\n            }\n        };\n        BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n            var contexts = this.contexts;\n            if (contexts && context) {\n                var buffer = context.buffer, subscription = context.subscription;\n                this.destination.next(buffer);\n                contexts.splice(contexts.indexOf(context), 1);\n                this.remove(subscription);\n                subscription.unsubscribe();\n            }\n        };\n        BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n            var contexts = this.contexts;\n            var buffer = [];\n            var subscription = new Subscription_1.Subscription();\n            var context = { buffer: buffer, subscription: subscription };\n            contexts.push(context);\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n            if (!innerSubscription || innerSubscription.closed) {\n                this.closeBuffer(context);\n            }\n            else {\n                innerSubscription.context = context;\n                this.add(innerSubscription);\n                subscription.add(innerSubscription);\n            }\n        };\n        return BufferToggleSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/bufferWhen',[\"require\", \"exports\", \"tslib\", \"../Subscription\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subscription_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values, using a factory function of closing\n     * Observables to determine when to close, emit, and reset the buffer.\n     *\n     * <span class=\"informal\">Collects values from the past as an array. When it\n     * starts collecting values, it calls a function that returns an Observable that\n     * tells when to close the buffer and restart collecting.</span>\n     *\n     * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n     *\n     * Opens a buffer immediately, then closes the buffer when the observable\n     * returned by calling `closingSelector` function emits a value. When it closes\n     * the buffer, it immediately opens a new buffer and repeats the process.\n     *\n     * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferWhen(() =>\n     *   Rx.Observable.interval(1000 + Math.random() * 4000)\n     * );\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link windowWhen}\n     *\n     * @param {function(): Observable} closingSelector A function that takes no\n     * arguments and returns an Observable that signals buffer closure.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferWhen\n     * @owner Observable\n     */\n    function bufferWhen(closingSelector) {\n        return function (source) {\n            return source.lift(new BufferWhenOperator(closingSelector));\n        };\n    }\n    exports.bufferWhen = bufferWhen;\n    var BufferWhenOperator = /** @class */ (function () {\n        function BufferWhenOperator(closingSelector) {\n            this.closingSelector = closingSelector;\n        }\n        BufferWhenOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n        };\n        return BufferWhenOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferWhenSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferWhenSubscriber, _super);\n        function BufferWhenSubscriber(destination, closingSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.closingSelector = closingSelector;\n            _this.subscribing = false;\n            _this.openBuffer();\n            return _this;\n        }\n        BufferWhenSubscriber.prototype._next = function (value) {\n            this.buffer.push(value);\n        };\n        BufferWhenSubscriber.prototype._complete = function () {\n            var buffer = this.buffer;\n            if (buffer) {\n                this.destination.next(buffer);\n            }\n            _super.prototype._complete.call(this);\n        };\n        BufferWhenSubscriber.prototype._unsubscribe = function () {\n            this.buffer = null;\n            this.subscribing = false;\n        };\n        BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.openBuffer();\n        };\n        BufferWhenSubscriber.prototype.notifyComplete = function () {\n            if (this.subscribing) {\n                this.complete();\n            }\n            else {\n                this.openBuffer();\n            }\n        };\n        BufferWhenSubscriber.prototype.openBuffer = function () {\n            var closingSubscription = this.closingSubscription;\n            if (closingSubscription) {\n                this.remove(closingSubscription);\n                closingSubscription.unsubscribe();\n            }\n            var buffer = this.buffer;\n            if (this.buffer) {\n                this.destination.next(buffer);\n            }\n            this.buffer = [];\n            var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n            if (closingNotifier === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                closingSubscription = new Subscription_1.Subscription();\n                this.closingSubscription = closingSubscription;\n                this.add(closingSubscription);\n                this.subscribing = true;\n                closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n                this.subscribing = false;\n            }\n        };\n        return BufferWhenSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/catchError',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n     *\n     * <img src=\"./img/catch.png\" width=\"100%\">\n     *\n     * @example <caption>Continues with a different Observable when there's an error</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     * \t   if (n == 4) {\n     * \t     throw 'four!';\n     *     }\n     *\t   return n;\n     *   })\n     *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n     *   .subscribe(x => console.log(x));\n     *   // 1, 2, 3, I, II, III, IV, V\n     *\n     * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     * \t   if (n === 4) {\n     * \t     throw 'four!';\n     *     }\n     * \t   return n;\n     *   })\n     *   .catch((err, caught) => caught)\n     *   .take(30)\n     *   .subscribe(x => console.log(x));\n     *   // 1, 2, 3, 1, 2, 3, ...\n     *\n     * @example <caption>Throws a new error when the source Observable throws an error</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     *     if (n == 4) {\n     *       throw 'four!';\n     *     }\n     *     return n;\n     *   })\n     *   .catch(err => {\n     *     throw 'error in source. Details: ' + err;\n     *   })\n     *   .subscribe(\n     *     x => console.log(x),\n     *     err => console.log(err)\n     *   );\n     *   // 1, 2, 3, error in source. Details: four!\n     *\n     * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n     *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n     *  is returned by the `selector` will be used to continue the observable chain.\n     * @return {Observable} An observable that originates from either the source or the observable returned by the\n     *  catch `selector` function.\n     * @name catchError\n     */\n    function catchError(selector) {\n        return function catchErrorOperatorFunction(source) {\n            var operator = new CatchOperator(selector);\n            var caught = source.lift(operator);\n            return (operator.caught = caught);\n        };\n    }\n    exports.catchError = catchError;\n    var CatchOperator = /** @class */ (function () {\n        function CatchOperator(selector) {\n            this.selector = selector;\n        }\n        CatchOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n        };\n        return CatchOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var CatchSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(CatchSubscriber, _super);\n        function CatchSubscriber(destination, selector, caught) {\n            var _this = _super.call(this, destination) || this;\n            _this.selector = selector;\n            _this.caught = caught;\n            return _this;\n        }\n        // NOTE: overriding `error` instead of `_error` because we don't want\n        // to have this flag this subscriber as `isStopped`. We can mimic the\n        // behavior of the RetrySubscriber (from the `retry` operator), where\n        // we unsubscribe from our source chain, reset our Subscriber flags,\n        // then subscribe to the selector result.\n        CatchSubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var result = void 0;\n                try {\n                    result = this.selector(err, this.caught);\n                }\n                catch (err2) {\n                    _super.prototype.error.call(this, err2);\n                    return;\n                }\n                this._unsubscribeAndRecycle();\n                this.add(subscribeToResult_1.subscribeToResult(this, result));\n            }\n        };\n        return CatchSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/ScalarObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ScalarObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ScalarObservable, _super);\n        function ScalarObservable(value, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.value = value;\n            _this.scheduler = scheduler;\n            _this._isScalar = true;\n            if (scheduler) {\n                _this._isScalar = false;\n            }\n            return _this;\n        }\n        ScalarObservable.create = function (value, scheduler) {\n            return new ScalarObservable(value, scheduler);\n        };\n        ScalarObservable.dispatch = function (state) {\n            var done = state.done, value = state.value, subscriber = state.subscriber;\n            if (done) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                return;\n            }\n            state.done = true;\n            this.schedule(state);\n        };\n        ScalarObservable.prototype._subscribe = function (subscriber) {\n            var value = this.value;\n            var scheduler = this.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                    done: false, value: value, subscriber: subscriber\n                });\n            }\n            else {\n                subscriber.next(value);\n                if (!subscriber.closed) {\n                    subscriber.complete();\n                }\n            }\n        };\n        return ScalarObservable;\n    }(Observable_1.Observable));\n    exports.ScalarObservable = ScalarObservable;\n});\n\ndefine('rxjs/observable/EmptyObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var EmptyObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(EmptyObservable, _super);\n        function EmptyObservable(scheduler) {\n            var _this = _super.call(this) || this;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Creates an Observable that emits no items to the Observer and immediately\n         * emits a complete notification.\n         *\n         * <span class=\"informal\">Just emits 'complete', and nothing else.\n         * </span>\n         *\n         * <img src=\"./img/empty.png\" width=\"100%\">\n         *\n         * This static operator is useful for creating a simple Observable that only\n         * emits the complete notification. It can be used for composing with other\n         * Observables, such as in a {@link mergeMap}.\n         *\n         * @example <caption>Emit the number 7, then complete.</caption>\n         * var result = Rx.Observable.empty().startWith(7);\n         * result.subscribe(x => console.log(x));\n         *\n         * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n         * var interval = Rx.Observable.interval(1000);\n         * var result = interval.mergeMap(x =>\n         *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n         * );\n         * result.subscribe(x => console.log(x));\n         *\n         * // Results in the following to the console:\n         * // x is equal to the count on the interval eg(0,1,2,3,...)\n         * // x will occur every 1000ms\n         * // if x % 2 is equal to 1 print abc\n         * // if x % 2 is not equal to 1 nothing will be output\n         *\n         * @see {@link create}\n         * @see {@link never}\n         * @see {@link of}\n         * @see {@link throw}\n         *\n         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n         * the emission of the complete notification.\n         * @return {Observable} An \"empty\" Observable: emits only the complete\n         * notification.\n         * @static true\n         * @name empty\n         * @owner Observable\n         */\n        EmptyObservable.create = function (scheduler) {\n            return new EmptyObservable(scheduler);\n        };\n        EmptyObservable.dispatch = function (arg) {\n            var subscriber = arg.subscriber;\n            subscriber.complete();\n        };\n        EmptyObservable.prototype._subscribe = function (subscriber) {\n            var scheduler = this.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n            }\n            else {\n                subscriber.complete();\n            }\n        };\n        return EmptyObservable;\n    }(Observable_1.Observable));\n    exports.EmptyObservable = EmptyObservable;\n});\n\ndefine('rxjs/observable/ArrayObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"./ScalarObservable\", \"./EmptyObservable\", \"../util/isScheduler\"], function (require, exports, tslib_1, Observable_1, ScalarObservable_1, EmptyObservable_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ArrayObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ArrayObservable, _super);\n        function ArrayObservable(array, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.array = array;\n            _this.scheduler = scheduler;\n            if (!scheduler && array.length === 1) {\n                _this._isScalar = true;\n                _this.value = array[0];\n            }\n            return _this;\n        }\n        ArrayObservable.create = function (array, scheduler) {\n            return new ArrayObservable(array, scheduler);\n        };\n        /**\n         * Creates an Observable that emits some values you specify as arguments,\n         * immediately one after the other, and then emits a complete notification.\n         *\n         * <span class=\"informal\">Emits the arguments you provide, then completes.\n         * </span>\n         *\n         * <img src=\"./img/of.png\" width=\"100%\">\n         *\n         * This static operator is useful for creating a simple Observable that only\n         * emits the arguments given, and the complete notification thereafter. It can\n         * be used for composing with other Observables, such as with {@link concat}.\n         * By default, it uses a `null` IScheduler, which means the `next`\n         * notifications are sent synchronously, although with a different IScheduler\n         * it is possible to determine when those notifications will be delivered.\n         *\n         * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n         * var numbers = Rx.Observable.of(10, 20, 30);\n         * var letters = Rx.Observable.of('a', 'b', 'c');\n         * var interval = Rx.Observable.interval(1000);\n         * var result = numbers.concat(letters).concat(interval);\n         * result.subscribe(x => console.log(x));\n         *\n         * @see {@link create}\n         * @see {@link empty}\n         * @see {@link never}\n         * @see {@link throw}\n         *\n         * @param {...T} values Arguments that represent `next` values to be emitted.\n         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n         * the emissions of the `next` notifications.\n         * @return {Observable<T>} An Observable that emits each given input value.\n         * @static true\n         * @name of\n         * @owner Observable\n         */\n        ArrayObservable.of = function () {\n            var array = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                array[_i] = arguments[_i];\n            }\n            var scheduler = array[array.length - 1];\n            if (isScheduler_1.isScheduler(scheduler)) {\n                array.pop();\n            }\n            else {\n                scheduler = null;\n            }\n            var len = array.length;\n            if (len > 1) {\n                return new ArrayObservable(array, scheduler);\n            }\n            else if (len === 1) {\n                return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n            }\n            else {\n                return new EmptyObservable_1.EmptyObservable(scheduler);\n            }\n        };\n        ArrayObservable.dispatch = function (state) {\n            var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n            if (index >= count) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(array[index]);\n            if (subscriber.closed) {\n                return;\n            }\n            state.index = index + 1;\n            this.schedule(state);\n        };\n        ArrayObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var array = this.array;\n            var count = array.length;\n            var scheduler = this.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                    array: array, index: index, count: count, subscriber: subscriber\n                });\n            }\n            else {\n                for (var i = 0; i < count && !subscriber.closed; i++) {\n                    subscriber.next(array[i]);\n                }\n                subscriber.complete();\n            }\n        };\n        return ArrayObservable;\n    }(Observable_1.Observable));\n    exports.ArrayObservable = ArrayObservable;\n});\n\ndefine('rxjs/operators/combineLatest',[\"require\", \"exports\", \"tslib\", \"../observable/ArrayObservable\", \"../util/isArray\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, ArrayObservable_1, isArray_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var none = {};\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines multiple Observables to create an Observable whose values are\n     * calculated from the latest values of each of its input Observables.\n     *\n     * <span class=\"informal\">Whenever any input Observable emits a value, it\n     * computes a formula using the latest values from all the inputs, then emits\n     * the output of that formula.</span>\n     *\n     * <img src=\"./img/combineLatest.png\" width=\"100%\">\n     *\n     * `combineLatest` combines the values from this Observable with values from\n     * Observables passed as arguments. This is done by subscribing to each\n     * Observable, in order, and collecting an array of each of the most recent\n     * values any time any of the input Observables emits, then either taking that\n     * array and passing it as arguments to an optional `project` function and\n     * emitting the return value of that, or just emitting the array of recent\n     * values directly if there is no `project` function.\n     *\n     * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n     * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n     * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n     * bmi.subscribe(x => console.log('BMI is ' + x));\n     *\n     * // With output to console:\n     * // BMI is 24.212293388429753\n     * // BMI is 23.93948099205209\n     * // BMI is 23.671253629592222\n     *\n     * @see {@link combineAll}\n     * @see {@link merge}\n     * @see {@link withLatestFrom}\n     *\n     * @param {ObservableInput} other An input Observable to combine with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {function} [project] An optional function to project the values from\n     * the combined latest values into a new value on the output Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @method combineLatest\n     * @owner Observable\n     */\n    function combineLatest() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        var project = null;\n        if (typeof observables[observables.length - 1] === 'function') {\n            project = observables.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0].slice();\n        }\n        return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };\n    }\n    exports.combineLatest = combineLatest;\n    var CombineLatestOperator = /** @class */ (function () {\n        function CombineLatestOperator(project) {\n            this.project = project;\n        }\n        CombineLatestOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n        };\n        return CombineLatestOperator;\n    }());\n    exports.CombineLatestOperator = CombineLatestOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var CombineLatestSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(CombineLatestSubscriber, _super);\n        function CombineLatestSubscriber(destination, project) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.active = 0;\n            _this.values = [];\n            _this.observables = [];\n            return _this;\n        }\n        CombineLatestSubscriber.prototype._next = function (observable) {\n            this.values.push(none);\n            this.observables.push(observable);\n        };\n        CombineLatestSubscriber.prototype._complete = function () {\n            var observables = this.observables;\n            var len = observables.length;\n            if (len === 0) {\n                this.destination.complete();\n            }\n            else {\n                this.active = len;\n                this.toRespond = len;\n                for (var i = 0; i < len; i++) {\n                    var observable = observables[i];\n                    this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n                }\n            }\n        };\n        CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n            if ((this.active -= 1) === 0) {\n                this.destination.complete();\n            }\n        };\n        CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var values = this.values;\n            var oldVal = values[outerIndex];\n            var toRespond = !this.toRespond\n                ? 0\n                : oldVal === none ? --this.toRespond : this.toRespond;\n            values[outerIndex] = innerValue;\n            if (toRespond === 0) {\n                if (this.project) {\n                    this._tryProject(values);\n                }\n                else {\n                    this.destination.next(values.slice());\n                }\n            }\n        };\n        CombineLatestSubscriber.prototype._tryProject = function (values) {\n            var result;\n            try {\n                result = this.project.apply(this, values);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return CombineLatestSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.CombineLatestSubscriber = CombineLatestSubscriber;\n});\n\ndefine('rxjs/operators/combineAll',[\"require\", \"exports\", \"../operators/combineLatest\"], function (require, exports, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function combineAll(project) {\n        return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };\n    }\n    exports.combineAll = combineAll;\n});\n\ndefine('rxjs/observable/of',[\"require\", \"exports\", \"./ArrayObservable\"], function (require, exports, ArrayObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.of = ArrayObservable_1.ArrayObservable.of;\n});\n\ndefine('rxjs/observable/PromiseObservable',[\"require\", \"exports\", \"tslib\", \"../util/root\", \"../Observable\"], function (require, exports, tslib_1, root_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var PromiseObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(PromiseObservable, _super);\n        function PromiseObservable(promise, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.promise = promise;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Converts a Promise to an Observable.\n         *\n         * <span class=\"informal\">Returns an Observable that just emits the Promise's\n         * resolved value, then completes.</span>\n         *\n         * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n         * Observable. If the Promise resolves with a value, the output Observable\n         * emits that resolved value as a `next`, and then completes. If the Promise\n         * is rejected, then the output Observable emits the corresponding Error.\n         *\n         * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n         * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         * @see {@link bindCallback}\n         * @see {@link from}\n         *\n         * @param {PromiseLike<T>} promise The promise to be converted.\n         * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n         * the delivery of the resolved value (or the rejection).\n         * @return {Observable<T>} An Observable which wraps the Promise.\n         * @static true\n         * @name fromPromise\n         * @owner Observable\n         */\n        PromiseObservable.create = function (promise, scheduler) {\n            return new PromiseObservable(promise, scheduler);\n        };\n        PromiseObservable.prototype._subscribe = function (subscriber) {\n            var _this = this;\n            var promise = this.promise;\n            var scheduler = this.scheduler;\n            if (scheduler == null) {\n                if (this._isScalar) {\n                    if (!subscriber.closed) {\n                        subscriber.next(this.value);\n                        subscriber.complete();\n                    }\n                }\n                else {\n                    promise.then(function (value) {\n                        _this.value = value;\n                        _this._isScalar = true;\n                        if (!subscriber.closed) {\n                            subscriber.next(value);\n                            subscriber.complete();\n                        }\n                    }, function (err) {\n                        if (!subscriber.closed) {\n                            subscriber.error(err);\n                        }\n                    })\n                        .then(null, function (err) {\n                        // escape the promise trap, throw unhandled errors\n                        root_1.root.setTimeout(function () { throw err; });\n                    });\n                }\n            }\n            else {\n                if (this._isScalar) {\n                    if (!subscriber.closed) {\n                        return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                    }\n                }\n                else {\n                    promise.then(function (value) {\n                        _this.value = value;\n                        _this._isScalar = true;\n                        if (!subscriber.closed) {\n                            subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                        }\n                    }, function (err) {\n                        if (!subscriber.closed) {\n                            subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                        }\n                    })\n                        .then(null, function (err) {\n                        // escape the promise trap, throw unhandled errors\n                        root_1.root.setTimeout(function () { throw err; });\n                    });\n                }\n            }\n        };\n        return PromiseObservable;\n    }(Observable_1.Observable));\n    exports.PromiseObservable = PromiseObservable;\n    function dispatchNext(arg) {\n        var value = arg.value, subscriber = arg.subscriber;\n        if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n        }\n    }\n    function dispatchError(arg) {\n        var err = arg.err, subscriber = arg.subscriber;\n        if (!subscriber.closed) {\n            subscriber.error(err);\n        }\n    }\n});\n\ndefine('rxjs/observable/IteratorObservable',[\"require\", \"exports\", \"tslib\", \"../util/root\", \"../Observable\", \"../symbol/iterator\"], function (require, exports, tslib_1, root_1, Observable_1, iterator_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var IteratorObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(IteratorObservable, _super);\n        function IteratorObservable(iterator, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.scheduler = scheduler;\n            if (iterator == null) {\n                throw new Error('iterator cannot be null.');\n            }\n            _this.iterator = getIterator(iterator);\n            return _this;\n        }\n        IteratorObservable.create = function (iterator, scheduler) {\n            return new IteratorObservable(iterator, scheduler);\n        };\n        IteratorObservable.dispatch = function (state) {\n            var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n            if (hasError) {\n                subscriber.error(state.error);\n                return;\n            }\n            var result = iterator.next();\n            if (result.done) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(result.value);\n            state.index = index + 1;\n            if (subscriber.closed) {\n                if (typeof iterator.return === 'function') {\n                    iterator.return();\n                }\n                return;\n            }\n            this.schedule(state);\n        };\n        IteratorObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                    index: index, iterator: iterator, subscriber: subscriber\n                });\n            }\n            else {\n                do {\n                    var result = iterator.next();\n                    if (result.done) {\n                        subscriber.complete();\n                        break;\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                    if (subscriber.closed) {\n                        if (typeof iterator.return === 'function') {\n                            iterator.return();\n                        }\n                        break;\n                    }\n                } while (true);\n            }\n        };\n        return IteratorObservable;\n    }(Observable_1.Observable));\n    exports.IteratorObservable = IteratorObservable;\n    var StringIterator = /** @class */ (function () {\n        function StringIterator(str, idx, len) {\n            if (idx === void 0) { idx = 0; }\n            if (len === void 0) { len = str.length; }\n            this.str = str;\n            this.idx = idx;\n            this.len = len;\n        }\n        StringIterator.prototype[iterator_1.iterator] = function () { return (this); };\n        StringIterator.prototype.next = function () {\n            return this.idx < this.len ? {\n                done: false,\n                value: this.str.charAt(this.idx++)\n            } : {\n                done: true,\n                value: undefined\n            };\n        };\n        return StringIterator;\n    }());\n    var ArrayIterator = /** @class */ (function () {\n        function ArrayIterator(arr, idx, len) {\n            if (idx === void 0) { idx = 0; }\n            if (len === void 0) { len = toLength(arr); }\n            this.arr = arr;\n            this.idx = idx;\n            this.len = len;\n        }\n        ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };\n        ArrayIterator.prototype.next = function () {\n            return this.idx < this.len ? {\n                done: false,\n                value: this.arr[this.idx++]\n            } : {\n                done: true,\n                value: undefined\n            };\n        };\n        return ArrayIterator;\n    }());\n    function getIterator(obj) {\n        var i = obj[iterator_1.iterator];\n        if (!i && typeof obj === 'string') {\n            return new StringIterator(obj);\n        }\n        if (!i && obj.length !== undefined) {\n            return new ArrayIterator(obj);\n        }\n        if (!i) {\n            throw new TypeError('object is not iterable');\n        }\n        return obj[iterator_1.iterator]();\n    }\n    var maxSafeInteger = Math.pow(2, 53) - 1;\n    function toLength(o) {\n        var len = +o.length;\n        if (isNaN(len)) {\n            return 0;\n        }\n        if (len === 0 || !numberIsFinite(len)) {\n            return len;\n        }\n        len = sign(len) * Math.floor(Math.abs(len));\n        if (len <= 0) {\n            return 0;\n        }\n        if (len > maxSafeInteger) {\n            return maxSafeInteger;\n        }\n        return len;\n    }\n    function numberIsFinite(value) {\n        return typeof value === 'number' && root_1.root.isFinite(value);\n    }\n    function sign(value) {\n        var valueAsNumber = +value;\n        if (valueAsNumber === 0) {\n            return valueAsNumber;\n        }\n        if (isNaN(valueAsNumber)) {\n            return valueAsNumber;\n        }\n        return valueAsNumber < 0 ? -1 : 1;\n    }\n});\n\ndefine('rxjs/observable/ArrayLikeObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"./ScalarObservable\", \"./EmptyObservable\"], function (require, exports, tslib_1, Observable_1, ScalarObservable_1, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ArrayLikeObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ArrayLikeObservable, _super);\n        function ArrayLikeObservable(arrayLike, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.arrayLike = arrayLike;\n            _this.scheduler = scheduler;\n            if (!scheduler && arrayLike.length === 1) {\n                _this._isScalar = true;\n                _this.value = arrayLike[0];\n            }\n            return _this;\n        }\n        ArrayLikeObservable.create = function (arrayLike, scheduler) {\n            var length = arrayLike.length;\n            if (length === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            else if (length === 1) {\n                return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n            }\n            else {\n                return new ArrayLikeObservable(arrayLike, scheduler);\n            }\n        };\n        ArrayLikeObservable.dispatch = function (state) {\n            var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n            if (subscriber.closed) {\n                return;\n            }\n            if (index >= length) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(arrayLike[index]);\n            state.index = index + 1;\n            this.schedule(state);\n        };\n        ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n            var length = arrayLike.length;\n            if (scheduler) {\n                return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                    arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n                });\n            }\n            else {\n                for (var i = 0; i < length && !subscriber.closed; i++) {\n                    subscriber.next(arrayLike[i]);\n                }\n                subscriber.complete();\n            }\n        };\n        return ArrayLikeObservable;\n    }(Observable_1.Observable));\n    exports.ArrayLikeObservable = ArrayLikeObservable;\n});\n\ndefine('rxjs/observable/FromObservable',[\"require\", \"exports\", \"tslib\", \"../util/isArray\", \"../util/isArrayLike\", \"../util/isPromise\", \"./PromiseObservable\", \"./IteratorObservable\", \"./ArrayObservable\", \"./ArrayLikeObservable\", \"../symbol/iterator\", \"../Observable\", \"../operators/observeOn\", \"../symbol/observable\"], function (require, exports, tslib_1, isArray_1, isArrayLike_1, isPromise_1, PromiseObservable_1, IteratorObservable_1, ArrayObservable_1, ArrayLikeObservable_1, iterator_1, Observable_1, observeOn_1, observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var FromObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(FromObservable, _super);\n        function FromObservable(ish, scheduler) {\n            var _this = _super.call(this, null) || this;\n            _this.ish = ish;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Creates an Observable from an Array, an array-like object, a Promise, an\n         * iterable object, or an Observable-like object.\n         *\n         * <span class=\"informal\">Converts almost anything to an Observable.</span>\n         *\n         * <img src=\"./img/from.png\" width=\"100%\">\n         *\n         * Convert various other objects and data types into Observables. `from`\n         * converts a Promise or an array-like or an\n         * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n         * object into an Observable that emits the items in that promise or array or\n         * iterable. A String, in this context, is treated as an array of characters.\n         * Observable-like objects (contains a function named with the ES2015 Symbol\n         * for Observable) can also be converted through this operator.\n         *\n         * @example <caption>Converts an array to an Observable</caption>\n         * var array = [10, 20, 30];\n         * var result = Rx.Observable.from(array);\n         * result.subscribe(x => console.log(x));\n         *\n         * // Results in the following:\n         * // 10 20 30\n         *\n         * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n         * function* generateDoubles(seed) {\n         *   var i = seed;\n         *   while (true) {\n         *     yield i;\n         *     i = 2 * i; // double it\n         *   }\n         * }\n         *\n         * var iterator = generateDoubles(3);\n         * var result = Rx.Observable.from(iterator).take(10);\n         * result.subscribe(x => console.log(x));\n         *\n         * // Results in the following:\n         * // 3 6 12 24 48 96 192 384 768 1536\n         *\n         * @see {@link create}\n         * @see {@link fromEvent}\n         * @see {@link fromEventPattern}\n         * @see {@link fromPromise}\n         *\n         * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n         * Observable-like, an Array, an iterable or an array-like object to be\n         * converted.\n         * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n         * emissions of values.\n         * @return {Observable<T>} The Observable whose values are originally from the\n         * input object that was converted.\n         * @static true\n         * @name from\n         * @owner Observable\n         */\n        FromObservable.create = function (ish, scheduler) {\n            if (ish != null) {\n                if (typeof ish[observable_1.observable] === 'function') {\n                    if (ish instanceof Observable_1.Observable && !scheduler) {\n                        return ish;\n                    }\n                    return new FromObservable(ish, scheduler);\n                }\n                else if (isArray_1.isArray(ish)) {\n                    return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n                }\n                else if (isPromise_1.isPromise(ish)) {\n                    return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n                }\n                else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n                    return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n                }\n                else if (isArrayLike_1.isArrayLike(ish)) {\n                    return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n                }\n            }\n            throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n        };\n        FromObservable.prototype._subscribe = function (subscriber) {\n            var ish = this.ish;\n            var scheduler = this.scheduler;\n            if (scheduler == null) {\n                return ish[observable_1.observable]().subscribe(subscriber);\n            }\n            else {\n                return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n            }\n        };\n        return FromObservable;\n    }(Observable_1.Observable));\n    exports.FromObservable = FromObservable;\n});\n\ndefine('rxjs/observable/from',[\"require\", \"exports\", \"./FromObservable\"], function (require, exports, FromObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.from = FromObservable_1.FromObservable.create;\n});\n\ndefine('rxjs/operators/mergeMap',[\"require\", \"exports\", \"tslib\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link mergeAll}.</span>\n     *\n     * <img src=\"./img/mergeMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an Observable, and then merging those resulting Observables and\n     * emitting the results of this merger.\n     *\n     * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var result = letters.mergeMap(x =>\n     *   Rx.Observable.interval(1000).map(i => x+i)\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // a0\n     * // b0\n     * // c0\n     * // a1\n     * // b1\n     * // c1\n     * // continues to list a,b,c with respective ascending integers\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaustMap}\n     * @see {@link merge}\n     * @see {@link mergeAll}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and merging the results of the Observables obtained\n     * from this transformation.\n     * @method mergeMap\n     * @owner Observable\n     */\n    function mergeMap(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return function mergeMapOperatorFunction(source) {\n            if (typeof resultSelector === 'number') {\n                concurrent = resultSelector;\n                resultSelector = null;\n            }\n            return source.lift(new MergeMapOperator(project, resultSelector, concurrent));\n        };\n    }\n    exports.mergeMap = mergeMap;\n    var MergeMapOperator = /** @class */ (function () {\n        function MergeMapOperator(project, resultSelector, concurrent) {\n            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n            this.project = project;\n            this.resultSelector = resultSelector;\n            this.concurrent = concurrent;\n        }\n        MergeMapOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n        };\n        return MergeMapOperator;\n    }());\n    exports.MergeMapOperator = MergeMapOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MergeMapSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MergeMapSubscriber, _super);\n        function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.resultSelector = resultSelector;\n            _this.concurrent = concurrent;\n            _this.hasCompleted = false;\n            _this.buffer = [];\n            _this.active = 0;\n            _this.index = 0;\n            return _this;\n        }\n        MergeMapSubscriber.prototype._next = function (value) {\n            if (this.active < this.concurrent) {\n                this._tryNext(value);\n            }\n            else {\n                this.buffer.push(value);\n            }\n        };\n        MergeMapSubscriber.prototype._tryNext = function (value) {\n            var result;\n            var index = this.index++;\n            try {\n                result = this.project(value, index);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.active++;\n            this._innerSub(result, value, index);\n        };\n        MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n        };\n        MergeMapSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (this.active === 0 && this.buffer.length === 0) {\n                this.destination.complete();\n            }\n        };\n        MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            if (this.resultSelector) {\n                this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                this.destination.next(innerValue);\n            }\n        };\n        MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var result;\n            try {\n                result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n            var buffer = this.buffer;\n            this.remove(innerSub);\n            this.active--;\n            if (buffer.length > 0) {\n                this._next(buffer.shift());\n            }\n            else if (this.active === 0 && this.hasCompleted) {\n                this.destination.complete();\n            }\n        };\n        return MergeMapSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.MergeMapSubscriber = MergeMapSubscriber;\n});\n\ndefine('rxjs/util/identity',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function identity(x) {\n        return x;\n    }\n    exports.identity = identity;\n});\n\ndefine('rxjs/operators/mergeAll',[\"require\", \"exports\", \"./mergeMap\", \"../util/identity\"], function (require, exports, mergeMap_1, identity_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable which\n     * concurrently delivers all values that are emitted on the inner Observables.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n     *\n     * <img src=\"./img/mergeAll.png\" width=\"100%\">\n     *\n     * `mergeAll` subscribes to an Observable that emits Observables, also known as\n     * a higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, it subscribes to that and delivers all the values from the\n     * inner Observable on the output Observable. The output Observable only\n     * completes once all inner Observables have completed. Any error delivered by\n     * a inner Observable will be immediately emitted on the output Observable.\n     *\n     * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n     * var firstOrder = higherOrder.mergeAll();\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n     * var firstOrder = higherOrder.mergeAll(2);\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link exhaust}\n     * @see {@link merge}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     * @see {@link switch}\n     * @see {@link zipAll}\n     *\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits values coming from all the\n     * inner Observables emitted by the source Observable.\n     * @method mergeAll\n     * @owner Observable\n     */\n    function mergeAll(concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);\n    }\n    exports.mergeAll = mergeAll;\n});\n\ndefine('rxjs/operators/concatAll',[\"require\", \"exports\", \"./mergeAll\"], function (require, exports, mergeAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by\n     * concatenating the inner Observables in order.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n     * inner Observable after the other.</span>\n     *\n     * <img src=\"./img/concatAll.png\" width=\"100%\">\n     *\n     * Joins every Observable emitted by the source (a higher-order Observable), in\n     * a serial fashion. It subscribes to each inner Observable only after the\n     * previous inner Observable has completed, and merges all of their values into\n     * the returned observable.\n     *\n     * __Warning:__ If the source Observable emits Observables quickly and\n     * endlessly, and the inner Observables it emits generally complete slower than\n     * the source emits, you can run into memory issues as the incoming Observables\n     * collect in an unbounded buffer.\n     *\n     * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n     * to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n     * var firstOrder = higherOrder.concatAll();\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link combineAll}\n     * @see {@link concat}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     * @see {@link exhaust}\n     * @see {@link mergeAll}\n     * @see {@link switch}\n     * @see {@link zipAll}\n     *\n     * @return {Observable} An Observable emitting values from all the inner\n     * Observables concatenated.\n     * @method concatAll\n     * @owner Observable\n     */\n    function concatAll() {\n        return mergeAll_1.mergeAll(1);\n    }\n    exports.concatAll = concatAll;\n});\n\ndefine('rxjs/observable/concat',[\"require\", \"exports\", \"../util/isScheduler\", \"./of\", \"./from\", \"../operators/concatAll\"], function (require, exports, isScheduler_1, of_1, from_1, concatAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which sequentially emits all values from given\n     * Observable and then moves on to the next.\n     *\n     * <span class=\"informal\">Concatenates multiple Observables together by\n     * sequentially emitting their values, one Observable after the other.</span>\n     *\n     * <img src=\"./img/concat.png\" width=\"100%\">\n     *\n     * `concat` joins multiple Observables together, by subscribing to them one at a time and\n     * merging their results into the output Observable. You can pass either an array of\n     * Observables, or put them directly as arguments. Passing an empty array will result\n     * in Observable that completes immediately.\n     *\n     * `concat` will subscribe to first input Observable and emit all its values, without\n     * changing or affecting them in any way. When that Observable completes, it will\n     * subscribe to then next Observable passed and, again, emit its values. This will be\n     * repeated, until the operator runs out of Observables. When last input Observable completes,\n     * `concat` will complete as well. At any given moment only one Observable passed to operator\n     * emits values. If you would like to emit values from passed Observables concurrently, check out\n     * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n     * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n     *\n     * Note that if some input Observable never completes, `concat` will also never complete\n     * and Observables following the one that did not complete will never be subscribed. On the other\n     * hand, if some Observable simply completes immediately after it is subscribed, it will be\n     * invisible for `concat`, which will just move on to the next Observable.\n     *\n     * If any Observable in chain errors, instead of passing control to the next Observable,\n     * `concat` will error immediately as well. Observables that would be subscribed after\n     * the one that emitted error, never will.\n     *\n     * If you pass to `concat` the same Observable many times, its stream of values\n     * will be \"replayed\" on every subscription, which means you can repeat given Observable\n     * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n     * you can always use {@link repeat}.\n     *\n     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n     * var timer = Rx.Observable.interval(1000).take(4);\n     * var sequence = Rx.Observable.range(1, 10);\n     * var result = Rx.Observable.concat(timer, sequence);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in:\n     * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n     *\n     *\n     * @example <caption>Concatenate an array of 3 Observables</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in the following:\n     * // (Prints to console sequentially)\n     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n     *\n     *\n     * @example <caption>Concatenate the same Observable to repeat it</caption>\n     * const timer = Rx.Observable.interval(1000).take(2);\n     *\n     * Rx.Observable.concat(timer, timer) // concating the same Observable!\n     * .subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('...and it is done!')\n     * );\n     *\n     * // Logs:\n     * // 0 after 1s\n     * // 1 after 2s\n     * // 0 after 3s\n     * // 1 after 4s\n     * // \"...and it is done!\" also after 4s\n     *\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     *\n     * @param {ObservableInput} input1 An input Observable to concatenate with others.\n     * @param {ObservableInput} input2 An input Observable to concatenate with others.\n     * More than one input Observables may be given as argument.\n     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n     * Observable subscription on.\n     * @return {Observable} All values of each passed Observable merged into a\n     * single Observable, in order, in serial fashion.\n     * @static true\n     * @name concat\n     * @owner Observable\n     */\n    function concat() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n            return from_1.from(observables[0]);\n        }\n        return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n    }\n    exports.concat = concat;\n});\n\ndefine('rxjs/operators/concat',[\"require\", \"exports\", \"../observable/concat\"], function (require, exports, concat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which sequentially emits all values from every\n     * given input Observable after the current Observable.\n     *\n     * <span class=\"informal\">Concatenates multiple Observables together by\n     * sequentially emitting their values, one Observable after the other.</span>\n     *\n     * <img src=\"./img/concat.png\" width=\"100%\">\n     *\n     * Joins this Observable with multiple other Observables by subscribing to them\n     * one at a time, starting with the source, and merging their results into the\n     * output Observable. Will wait for each Observable to complete before moving\n     * on to the next.\n     *\n     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n     * var timer = Rx.Observable.interval(1000).take(4);\n     * var sequence = Rx.Observable.range(1, 10);\n     * var result = timer.concat(sequence);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in:\n     * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n     *\n     * @example <caption>Concatenate 3 Observables</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var result = timer1.concat(timer2, timer3);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in the following:\n     * // (Prints to console sequentially)\n     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n     *\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     *\n     * @param {ObservableInput} other An input Observable to concatenate after the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n     * Observable subscription on.\n     * @return {Observable} All values of each passed Observable merged into a\n     * single Observable, in order, in serial fashion.\n     * @method concat\n     * @owner Observable\n     */\n    function concat() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n    }\n    exports.concat = concat;\n});\n\ndefine('rxjs/operators/concatMap',[\"require\", \"exports\", \"./mergeMap\"], function (require, exports, mergeMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable, in a serialized fashion waiting for each one to complete before\n     * merging the next.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link concatAll}.</span>\n     *\n     * <img src=\"./img/concatMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. Each new inner Observable is\n     * concatenated with the previous inner Observable.\n     *\n     * __Warning:__ if source values arrive endlessly and faster than their\n     * corresponding inner Observables can complete, it will result in memory issues\n     * as inner Observables amass in an unbounded buffer waiting for their turn to\n     * be subscribed to.\n     *\n     * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n     * to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link concat}\n     * @see {@link concatAll}\n     * @see {@link concatMapTo}\n     * @see {@link exhaustMap}\n     * @see {@link mergeMap}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and taking values from each projected inner\n     * Observable sequentially.\n     * @method concatMap\n     * @owner Observable\n     */\n    function concatMap(project, resultSelector) {\n        return mergeMap_1.mergeMap(project, resultSelector, 1);\n    }\n    exports.concatMap = concatMap;\n});\n\ndefine('rxjs/operators/concatMapTo',[\"require\", \"exports\", \"./concatMap\"], function (require, exports, concatMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is merged multiple\n     * times in a serialized fashion on the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n     * always to the same inner Observable.</span>\n     *\n     * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then flattens those resulting Observables into one\n     * single Observable, which is the output Observable. Each new `innerObservable`\n     * instance emitted on the output Observable is concatenated with the previous\n     * `innerObservable` instance.\n     *\n     * __Warning:__ if source values arrive endlessly and faster than their\n     * corresponding inner Observables can complete, it will result in memory issues\n     * as inner Observables amass in an unbounded buffer waiting for their turn to\n     * be subscribed to.\n     *\n     * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n     * set to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link concat}\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link mergeMapTo}\n     * @see {@link switchMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An observable of values merged together by joining the\n     * passed observable with itself, one after the other, for each value emitted\n     * from the source.\n     * @method concatMapTo\n     * @owner Observable\n     */\n    function concatMapTo(innerObservable, resultSelector) {\n        return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);\n    }\n    exports.concatMapTo = concatMapTo;\n});\n\ndefine('rxjs/operators/count',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Counts the number of emissions on the source and emits that number when the\n     * source completes.\n     *\n     * <span class=\"informal\">Tells how many values were emitted, when the source\n     * completes.</span>\n     *\n     * <img src=\"./img/count.png\" width=\"100%\">\n     *\n     * `count` transforms an Observable that emits values into an Observable that\n     * emits a single value that represents the number of values emitted by the\n     * source Observable. If the source Observable terminates with an error, `count`\n     * will pass this error notification along without emitting a value first. If\n     * the source Observable does not terminate at all, `count` will neither emit\n     * a value nor terminate. This operator takes an optional `predicate` function\n     * as argument, in which case the output emission will represent the number of\n     * source values that matched `true` with the `predicate`.\n     *\n     * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n     * var seconds = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var secondsBeforeClick = seconds.takeUntil(clicks);\n     * var result = secondsBeforeClick.count();\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n     * var numbers = Rx.Observable.range(1, 7);\n     * var result = numbers.count(i => i % 2 === 1);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // 4\n     *\n     * @see {@link max}\n     * @see {@link min}\n     * @see {@link reduce}\n     *\n     * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n     * boolean function to select what values are to be counted. It is provided with\n     * arguments of:\n     * - `value`: the value from the source Observable.\n     * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n     * - `source`: the source Observable instance itself.\n     * @return {Observable} An Observable of one number that represents the count as\n     * described above.\n     * @method count\n     * @owner Observable\n     */\n    function count(predicate) {\n        return function (source) { return source.lift(new CountOperator(predicate, source)); };\n    }\n    exports.count = count;\n    var CountOperator = /** @class */ (function () {\n        function CountOperator(predicate, source) {\n            this.predicate = predicate;\n            this.source = source;\n        }\n        CountOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n        };\n        return CountOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var CountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(CountSubscriber, _super);\n        function CountSubscriber(destination, predicate, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.source = source;\n            _this.count = 0;\n            _this.index = 0;\n            return _this;\n        }\n        CountSubscriber.prototype._next = function (value) {\n            if (this.predicate) {\n                this._tryPredicate(value);\n            }\n            else {\n                this.count++;\n            }\n        };\n        CountSubscriber.prototype._tryPredicate = function (value) {\n            var result;\n            try {\n                result = this.predicate(value, this.index++, this.source);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (result) {\n                this.count++;\n            }\n        };\n        CountSubscriber.prototype._complete = function () {\n            this.destination.next(this.count);\n            this.destination.complete();\n        };\n        return CountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/debounce',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable only after a particular time span\n     * determined by another Observable has passed without another source emission.\n     *\n     * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n     * emission silence is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/debounce.png\" width=\"100%\">\n     *\n     * `debounce` delays values emitted by the source Observable, but drops previous\n     * pending delayed emissions if a new value arrives on the source Observable.\n     * This operator keeps track of the most recent value from the source\n     * Observable, and spawns a duration Observable by calling the\n     * `durationSelector` function. The value is emitted only when the duration\n     * Observable emits a value or completes, and if no other value was emitted on\n     * the source Observable since the duration Observable was spawned. If a new\n     * value appears before the duration Observable emits, the previous value will\n     * be dropped and will not be emitted on the output Observable.\n     *\n     * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n     * delay-like operator since output emissions do not necessarily occur at the\n     * same time as they did on the source Observable.\n     *\n     * @example <caption>Emit the most recent click after a burst of clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounceTime}\n     * @see {@link delayWhen}\n     * @see {@link throttle}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the timeout\n     * duration for each source value, returned as an Observable or a Promise.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified duration Observable returned by\n     * `durationSelector`, and may drop some values if they occur too frequently.\n     * @method debounce\n     * @owner Observable\n     */\n    function debounce(durationSelector) {\n        return function (source) { return source.lift(new DebounceOperator(durationSelector)); };\n    }\n    exports.debounce = debounce;\n    var DebounceOperator = /** @class */ (function () {\n        function DebounceOperator(durationSelector) {\n            this.durationSelector = durationSelector;\n        }\n        DebounceOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n        };\n        return DebounceOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DebounceSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DebounceSubscriber, _super);\n        function DebounceSubscriber(destination, durationSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.durationSelector = durationSelector;\n            _this.hasValue = false;\n            _this.durationSubscription = null;\n            return _this;\n        }\n        DebounceSubscriber.prototype._next = function (value) {\n            try {\n                var result = this.durationSelector.call(this, value);\n                if (result) {\n                    this._tryNext(value, result);\n                }\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        DebounceSubscriber.prototype._complete = function () {\n            this.emitValue();\n            this.destination.complete();\n        };\n        DebounceSubscriber.prototype._tryNext = function (value, duration) {\n            var subscription = this.durationSubscription;\n            this.value = value;\n            this.hasValue = true;\n            if (subscription) {\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            subscription = subscribeToResult_1.subscribeToResult(this, duration);\n            if (!subscription.closed) {\n                this.add(this.durationSubscription = subscription);\n            }\n        };\n        DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.emitValue();\n        };\n        DebounceSubscriber.prototype.notifyComplete = function () {\n            this.emitValue();\n        };\n        DebounceSubscriber.prototype.emitValue = function () {\n            if (this.hasValue) {\n                var value = this.value;\n                var subscription = this.durationSubscription;\n                if (subscription) {\n                    this.durationSubscription = null;\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n                this.value = null;\n                this.hasValue = false;\n                _super.prototype._next.call(this, value);\n            }\n        };\n        return DebounceSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/debounceTime',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../scheduler/async\"], function (require, exports, tslib_1, Subscriber_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable only after a particular time span\n     * has passed without another source emission.\n     *\n     * <span class=\"informal\">It's like {@link delay}, but passes only the most\n     * recent value from each burst of emissions.</span>\n     *\n     * <img src=\"./img/debounceTime.png\" width=\"100%\">\n     *\n     * `debounceTime` delays values emitted by the source Observable, but drops\n     * previous pending delayed emissions if a new value arrives on the source\n     * Observable. This operator keeps track of the most recent value from the\n     * source Observable, and emits that only when `dueTime` enough time has passed\n     * without any other value appearing on the source Observable. If a new value\n     * appears before `dueTime` silence occurs, the previous value will be dropped\n     * and will not be emitted on the output Observable.\n     *\n     * This is a rate-limiting operator, because it is impossible for more than one\n     * value to be emitted in any time window of duration `dueTime`, but it is also\n     * a delay-like operator since output emissions do not occur at the same time as\n     * they did on the source Observable. Optionally takes a {@link IScheduler} for\n     * managing timers.\n     *\n     * @example <caption>Emit the most recent click after a burst of clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.debounceTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounce}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttleTime}\n     *\n     * @param {number} dueTime The timeout duration in milliseconds (or the time\n     * unit determined internally by the optional `scheduler`) for the window of\n     * time required to wait for emission silence before emitting the most recent\n     * source value.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the timeout for each value.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified `dueTime`, and may drop some values if they occur\n     * too frequently.\n     * @method debounceTime\n     * @owner Observable\n     */\n    function debounceTime(dueTime, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n    }\n    exports.debounceTime = debounceTime;\n    var DebounceTimeOperator = /** @class */ (function () {\n        function DebounceTimeOperator(dueTime, scheduler) {\n            this.dueTime = dueTime;\n            this.scheduler = scheduler;\n        }\n        DebounceTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n        };\n        return DebounceTimeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DebounceTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DebounceTimeSubscriber, _super);\n        function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.dueTime = dueTime;\n            _this.scheduler = scheduler;\n            _this.debouncedSubscription = null;\n            _this.lastValue = null;\n            _this.hasValue = false;\n            return _this;\n        }\n        DebounceTimeSubscriber.prototype._next = function (value) {\n            this.clearDebounce();\n            this.lastValue = value;\n            this.hasValue = true;\n            this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n        };\n        DebounceTimeSubscriber.prototype._complete = function () {\n            this.debouncedNext();\n            this.destination.complete();\n        };\n        DebounceTimeSubscriber.prototype.debouncedNext = function () {\n            this.clearDebounce();\n            if (this.hasValue) {\n                this.destination.next(this.lastValue);\n                this.lastValue = null;\n                this.hasValue = false;\n            }\n        };\n        DebounceTimeSubscriber.prototype.clearDebounce = function () {\n            var debouncedSubscription = this.debouncedSubscription;\n            if (debouncedSubscription !== null) {\n                this.remove(debouncedSubscription);\n                debouncedSubscription.unsubscribe();\n                this.debouncedSubscription = null;\n            }\n        };\n        return DebounceTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchNext(subscriber) {\n        subscriber.debouncedNext();\n    }\n});\n\ndefine('rxjs/operators/defaultIfEmpty',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Emits a given value if the source Observable completes without emitting any\n     * `next` value, otherwise mirrors the source Observable.\n     *\n     * <span class=\"informal\">If the source Observable turns out to be empty, then\n     * this operator will emit a default value.</span>\n     *\n     * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n     *\n     * `defaultIfEmpty` emits the values emitted by the source Observable or a\n     * specified default value if the source Observable is empty (completes without\n     * having emitted any `next` value).\n     *\n     * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n     * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link empty}\n     * @see {@link last}\n     *\n     * @param {any} [defaultValue=null] The default value used if the source\n     * Observable is empty.\n     * @return {Observable} An Observable that emits either the specified\n     * `defaultValue` if the source Observable emits no items, or the values emitted\n     * by the source Observable.\n     * @method defaultIfEmpty\n     * @owner Observable\n     */\n    function defaultIfEmpty(defaultValue) {\n        if (defaultValue === void 0) { defaultValue = null; }\n        return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };\n    }\n    exports.defaultIfEmpty = defaultIfEmpty;\n    var DefaultIfEmptyOperator = /** @class */ (function () {\n        function DefaultIfEmptyOperator(defaultValue) {\n            this.defaultValue = defaultValue;\n        }\n        DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n        };\n        return DefaultIfEmptyOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DefaultIfEmptySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DefaultIfEmptySubscriber, _super);\n        function DefaultIfEmptySubscriber(destination, defaultValue) {\n            var _this = _super.call(this, destination) || this;\n            _this.defaultValue = defaultValue;\n            _this.isEmpty = true;\n            return _this;\n        }\n        DefaultIfEmptySubscriber.prototype._next = function (value) {\n            this.isEmpty = false;\n            this.destination.next(value);\n        };\n        DefaultIfEmptySubscriber.prototype._complete = function () {\n            if (this.isEmpty) {\n                this.destination.next(this.defaultValue);\n            }\n            this.destination.complete();\n        };\n        return DefaultIfEmptySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/delay',[\"require\", \"exports\", \"tslib\", \"../scheduler/async\", \"../util/isDate\", \"../Subscriber\", \"../Notification\"], function (require, exports, tslib_1, async_1, isDate_1, Subscriber_1, Notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Delays the emission of items from the source Observable by a given timeout or\n     * until a given Date.\n     *\n     * <span class=\"informal\">Time shifts each item by some specified amount of\n     * milliseconds.</span>\n     *\n     * <img src=\"./img/delay.png\" width=\"100%\">\n     *\n     * If the delay argument is a Number, this operator time shifts the source\n     * Observable by that amount of time expressed in milliseconds. The relative\n     * time intervals between the values are preserved.\n     *\n     * If the delay argument is a Date, this operator time shifts the start of the\n     * Observable execution until the given date occurs.\n     *\n     * @example <caption>Delay each click by one second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @example <caption>Delay all clicks until a future date happens</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var date = new Date('March 15, 2050 12:00:00'); // in the future\n     * var delayedClicks = clicks.delay(date); // click emitted only after that date\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @see {@link debounceTime}\n     * @see {@link delayWhen}\n     *\n     * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n     * a `Date` until which the emission of the source items is delayed.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for\n     * managing the timers that handle the time-shift for each item.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified timeout or Date.\n     * @method delay\n     * @owner Observable\n     */\n    function delay(delay, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        var absoluteDelay = isDate_1.isDate(delay);\n        var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n        return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n    }\n    exports.delay = delay;\n    var DelayOperator = /** @class */ (function () {\n        function DelayOperator(delay, scheduler) {\n            this.delay = delay;\n            this.scheduler = scheduler;\n        }\n        DelayOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n        };\n        return DelayOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DelaySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DelaySubscriber, _super);\n        function DelaySubscriber(destination, delay, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.delay = delay;\n            _this.scheduler = scheduler;\n            _this.queue = [];\n            _this.active = false;\n            _this.errored = false;\n            return _this;\n        }\n        DelaySubscriber.dispatch = function (state) {\n            var source = state.source;\n            var queue = source.queue;\n            var scheduler = state.scheduler;\n            var destination = state.destination;\n            while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n                queue.shift().notification.observe(destination);\n            }\n            if (queue.length > 0) {\n                var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n                this.schedule(state, delay_1);\n            }\n            else {\n                source.active = false;\n            }\n        };\n        DelaySubscriber.prototype._schedule = function (scheduler) {\n            this.active = true;\n            this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n                source: this, destination: this.destination, scheduler: scheduler\n            }));\n        };\n        DelaySubscriber.prototype.scheduleNotification = function (notification) {\n            if (this.errored === true) {\n                return;\n            }\n            var scheduler = this.scheduler;\n            var message = new DelayMessage(scheduler.now() + this.delay, notification);\n            this.queue.push(message);\n            if (this.active === false) {\n                this._schedule(scheduler);\n            }\n        };\n        DelaySubscriber.prototype._next = function (value) {\n            this.scheduleNotification(Notification_1.Notification.createNext(value));\n        };\n        DelaySubscriber.prototype._error = function (err) {\n            this.errored = true;\n            this.queue = [];\n            this.destination.error(err);\n        };\n        DelaySubscriber.prototype._complete = function () {\n            this.scheduleNotification(Notification_1.Notification.createComplete());\n        };\n        return DelaySubscriber;\n    }(Subscriber_1.Subscriber));\n    var DelayMessage = /** @class */ (function () {\n        function DelayMessage(time, notification) {\n            this.time = time;\n            this.notification = notification;\n        }\n        return DelayMessage;\n    }());\n});\n\ndefine('rxjs/operators/delayWhen',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Observable\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subscriber_1, Observable_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Delays the emission of items from the source Observable by a given time span\n     * determined by the emissions of another Observable.\n     *\n     * <span class=\"informal\">It's like {@link delay}, but the time span of the\n     * delay duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/delayWhen.png\" width=\"100%\">\n     *\n     * `delayWhen` time shifts each emitted value from the source Observable by a\n     * time span determined by another Observable. When the source emits a value,\n     * the `delayDurationSelector` function is called with the source value as\n     * argument, and should return an Observable, called the \"duration\" Observable.\n     * The source value is emitted on the output Observable only when the duration\n     * Observable emits a value or completes.\n     *\n     * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n     * is an Observable. When `subscriptionDelay` emits its first value or\n     * completes, the source Observable is subscribed to and starts behaving like\n     * described in the previous paragraph. If `subscriptionDelay` is not provided,\n     * `delayWhen` will subscribe to the source Observable as soon as the output\n     * Observable is subscribed.\n     *\n     * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var delayedClicks = clicks.delayWhen(event =>\n     *   Rx.Observable.interval(Math.random() * 5000)\n     * );\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @see {@link debounce}\n     * @see {@link delay}\n     *\n     * @param {function(value: T): Observable} delayDurationSelector A function that\n     * returns an Observable for each value emitted by the source Observable, which\n     * is then used to delay the emission of that item on the output Observable\n     * until the Observable returned from this function emits a value.\n     * @param {Observable} subscriptionDelay An Observable that triggers the\n     * subscription to the source Observable once it emits any value.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by an amount of time specified by the Observable returned by\n     * `delayDurationSelector`.\n     * @method delayWhen\n     * @owner Observable\n     */\n    function delayWhen(delayDurationSelector, subscriptionDelay) {\n        if (subscriptionDelay) {\n            return function (source) {\n                return new SubscriptionDelayObservable(source, subscriptionDelay)\n                    .lift(new DelayWhenOperator(delayDurationSelector));\n            };\n        }\n        return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };\n    }\n    exports.delayWhen = delayWhen;\n    var DelayWhenOperator = /** @class */ (function () {\n        function DelayWhenOperator(delayDurationSelector) {\n            this.delayDurationSelector = delayDurationSelector;\n        }\n        DelayWhenOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n        };\n        return DelayWhenOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DelayWhenSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DelayWhenSubscriber, _super);\n        function DelayWhenSubscriber(destination, delayDurationSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.delayDurationSelector = delayDurationSelector;\n            _this.completed = false;\n            _this.delayNotifierSubscriptions = [];\n            _this.values = [];\n            return _this;\n        }\n        DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.destination.next(outerValue);\n            this.removeSubscription(innerSub);\n            this.tryComplete();\n        };\n        DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n            this._error(error);\n        };\n        DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n            var value = this.removeSubscription(innerSub);\n            if (value) {\n                this.destination.next(value);\n            }\n            this.tryComplete();\n        };\n        DelayWhenSubscriber.prototype._next = function (value) {\n            try {\n                var delayNotifier = this.delayDurationSelector(value);\n                if (delayNotifier) {\n                    this.tryDelay(delayNotifier, value);\n                }\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        DelayWhenSubscriber.prototype._complete = function () {\n            this.completed = true;\n            this.tryComplete();\n        };\n        DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n            subscription.unsubscribe();\n            var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n            var value = null;\n            if (subscriptionIdx !== -1) {\n                value = this.values[subscriptionIdx];\n                this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n                this.values.splice(subscriptionIdx, 1);\n            }\n            return value;\n        };\n        DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n            var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n            if (notifierSubscription && !notifierSubscription.closed) {\n                this.add(notifierSubscription);\n                this.delayNotifierSubscriptions.push(notifierSubscription);\n            }\n            this.values.push(value);\n        };\n        DelayWhenSubscriber.prototype.tryComplete = function () {\n            if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n                this.destination.complete();\n            }\n        };\n        return DelayWhenSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SubscriptionDelayObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(SubscriptionDelayObservable, _super);\n        function SubscriptionDelayObservable(source, subscriptionDelay) {\n            var _this = _super.call(this) || this;\n            _this.source = source;\n            _this.subscriptionDelay = subscriptionDelay;\n            return _this;\n        }\n        SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n            this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n        };\n        return SubscriptionDelayObservable;\n    }(Observable_1.Observable));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SubscriptionDelaySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SubscriptionDelaySubscriber, _super);\n        function SubscriptionDelaySubscriber(parent, source) {\n            var _this = _super.call(this) || this;\n            _this.parent = parent;\n            _this.source = source;\n            _this.sourceSubscribed = false;\n            return _this;\n        }\n        SubscriptionDelaySubscriber.prototype._next = function (unused) {\n            this.subscribeToSource();\n        };\n        SubscriptionDelaySubscriber.prototype._error = function (err) {\n            this.unsubscribe();\n            this.parent.error(err);\n        };\n        SubscriptionDelaySubscriber.prototype._complete = function () {\n            this.subscribeToSource();\n        };\n        SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n            if (!this.sourceSubscribed) {\n                this.sourceSubscribed = true;\n                this.unsubscribe();\n                this.source.subscribe(this.parent);\n            }\n        };\n        return SubscriptionDelaySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/dematerialize',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts an Observable of {@link Notification} objects into the emissions\n     * that they represent.\n     *\n     * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n     * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n     *\n     * <img src=\"./img/dematerialize.png\" width=\"100%\">\n     *\n     * `dematerialize` is assumed to operate an Observable that only emits\n     * {@link Notification} objects as `next` emissions, and does not emit any\n     * `error`. Such Observable is the output of a `materialize` operation. Those\n     * notifications are then unwrapped using the metadata they contain, and emitted\n     * as `next`, `error`, and `complete` on the output Observable.\n     *\n     * Use this operator in conjunction with {@link materialize}.\n     *\n     * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n     * var notifA = new Rx.Notification('N', 'A');\n     * var notifB = new Rx.Notification('N', 'B');\n     * var notifE = new Rx.Notification('E', void 0,\n     *   new TypeError('x.toUpperCase is not a function')\n     * );\n     * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n     * var upperCase = materialized.dematerialize();\n     * upperCase.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * // Results in:\n     * // A\n     * // B\n     * // TypeError: x.toUpperCase is not a function\n     *\n     * @see {@link Notification}\n     * @see {@link materialize}\n     *\n     * @return {Observable} An Observable that emits items and notifications\n     * embedded in Notification objects emitted by the source Observable.\n     * @method dematerialize\n     * @owner Observable\n     */\n    function dematerialize() {\n        return function dematerializeOperatorFunction(source) {\n            return source.lift(new DeMaterializeOperator());\n        };\n    }\n    exports.dematerialize = dematerialize;\n    var DeMaterializeOperator = /** @class */ (function () {\n        function DeMaterializeOperator() {\n        }\n        DeMaterializeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DeMaterializeSubscriber(subscriber));\n        };\n        return DeMaterializeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DeMaterializeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DeMaterializeSubscriber, _super);\n        function DeMaterializeSubscriber(destination) {\n            return _super.call(this, destination) || this;\n        }\n        DeMaterializeSubscriber.prototype._next = function (value) {\n            value.observe(this.destination);\n        };\n        return DeMaterializeSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/util/Set',[\"require\", \"exports\", \"./root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function minimalSetImpl() {\n        // THIS IS NOT a full impl of Set, this is just the minimum\n        // bits of functionality we need for this library.\n        return /** @class */ (function () {\n            function MinimalSet() {\n                this._values = [];\n            }\n            MinimalSet.prototype.add = function (value) {\n                if (!this.has(value)) {\n                    this._values.push(value);\n                }\n            };\n            MinimalSet.prototype.has = function (value) {\n                return this._values.indexOf(value) !== -1;\n            };\n            Object.defineProperty(MinimalSet.prototype, \"size\", {\n                get: function () {\n                    return this._values.length;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            MinimalSet.prototype.clear = function () {\n                this._values.length = 0;\n            };\n            return MinimalSet;\n        }());\n    }\n    exports.minimalSetImpl = minimalSetImpl;\n    exports.Set = root_1.root.Set || minimalSetImpl();\n});\n\ndefine('rxjs/operators/distinct',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\", \"../util/Set\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1, Set_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n     *\n     * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n     * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n     * source observable directly with an equality check against previous values.\n     *\n     * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n     *\n     * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n     * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n     * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n     * that the internal `Set` can be \"flushed\", basically clearing it of values.\n     *\n     * @example <caption>A simple example with numbers</caption>\n     * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n     *   .distinct()\n     *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n     *\n     * @example <caption>An example using a keySelector function</caption>\n     * interface Person {\n     *    age: number,\n     *    name: string\n     * }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'})\n     *     .distinct((p: Person) => p.name)\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     *\n     * @see {@link distinctUntilChanged}\n     * @see {@link distinctUntilKeyChanged}\n     *\n     * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n     * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n     * @method distinct\n     * @owner Observable\n     */\n    function distinct(keySelector, flushes) {\n        return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };\n    }\n    exports.distinct = distinct;\n    var DistinctOperator = /** @class */ (function () {\n        function DistinctOperator(keySelector, flushes) {\n            this.keySelector = keySelector;\n            this.flushes = flushes;\n        }\n        DistinctOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n        };\n        return DistinctOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DistinctSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DistinctSubscriber, _super);\n        function DistinctSubscriber(destination, keySelector, flushes) {\n            var _this = _super.call(this, destination) || this;\n            _this.keySelector = keySelector;\n            _this.values = new Set_1.Set();\n            if (flushes) {\n                _this.add(subscribeToResult_1.subscribeToResult(_this, flushes));\n            }\n            return _this;\n        }\n        DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.values.clear();\n        };\n        DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n            this._error(error);\n        };\n        DistinctSubscriber.prototype._next = function (value) {\n            if (this.keySelector) {\n                this._useKeySelector(value);\n            }\n            else {\n                this._finalizeNext(value, value);\n            }\n        };\n        DistinctSubscriber.prototype._useKeySelector = function (value) {\n            var key;\n            var destination = this.destination;\n            try {\n                key = this.keySelector(value);\n            }\n            catch (err) {\n                destination.error(err);\n                return;\n            }\n            this._finalizeNext(key, value);\n        };\n        DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n            var values = this.values;\n            if (!values.has(key)) {\n                values.add(key);\n                this.destination.next(value);\n            }\n        };\n        return DistinctSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.DistinctSubscriber = DistinctSubscriber;\n});\n\ndefine('rxjs/operators/distinctUntilChanged',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/tryCatch\", \"../util/errorObject\"], function (require, exports, tslib_1, Subscriber_1, tryCatch_1, errorObject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n     *\n     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n     *\n     * If a comparator function is not provided, an equality check is used by default.\n     *\n     * @example <caption>A simple example with numbers</caption>\n     * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n     *   .distinctUntilChanged()\n     *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n     *\n     * @example <caption>An example using a compare function</caption>\n     * interface Person {\n     *    age: number,\n     *    name: string\n     * }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'})\n     *     { age: 6, name: 'Foo'})\n     *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo' }\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilKeyChanged}\n     *\n     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n     * @method distinctUntilChanged\n     * @owner Observable\n     */\n    function distinctUntilChanged(compare, keySelector) {\n        return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };\n    }\n    exports.distinctUntilChanged = distinctUntilChanged;\n    var DistinctUntilChangedOperator = /** @class */ (function () {\n        function DistinctUntilChangedOperator(compare, keySelector) {\n            this.compare = compare;\n            this.keySelector = keySelector;\n        }\n        DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n        };\n        return DistinctUntilChangedOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DistinctUntilChangedSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DistinctUntilChangedSubscriber, _super);\n        function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.keySelector = keySelector;\n            _this.hasKey = false;\n            if (typeof compare === 'function') {\n                _this.compare = compare;\n            }\n            return _this;\n        }\n        DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n            return x === y;\n        };\n        DistinctUntilChangedSubscriber.prototype._next = function (value) {\n            var keySelector = this.keySelector;\n            var key = value;\n            if (keySelector) {\n                key = tryCatch_1.tryCatch(this.keySelector)(value);\n                if (key === errorObject_1.errorObject) {\n                    return this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            var result = false;\n            if (this.hasKey) {\n                result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n                if (result === errorObject_1.errorObject) {\n                    return this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                this.hasKey = true;\n            }\n            if (Boolean(result) === false) {\n                this.key = key;\n                this.destination.next(value);\n            }\n        };\n        return DistinctUntilChangedSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/distinctUntilKeyChanged',[\"require\", \"exports\", \"./distinctUntilChanged\"], function (require, exports, distinctUntilChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n     * using a property accessed by using the key provided to check if the two items are distinct.\n     *\n     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n     *\n     * If a comparator function is not provided, an equality check is used by default.\n     *\n     * @example <caption>An example comparing the name of persons</caption>\n     *\n     *  interface Person {\n     *     age: number,\n     *     name: string\n     *  }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'},\n     *     { age: 6, name: 'Foo'})\n     *     .distinctUntilKeyChanged('name')\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo' }\n     *\n     * @example <caption>An example comparing the first letters of the name</caption>\n     *\n     * interface Person {\n     *     age: number,\n     *     name: string\n     *  }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo1'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo2'},\n     *     { age: 6, name: 'Foo3'})\n     *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo1' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo2' }\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilChanged}\n     *\n     * @param {string} key String key for object property lookup on each item.\n     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n     * @method distinctUntilKeyChanged\n     * @owner Observable\n     */\n    function distinctUntilKeyChanged(key, compare) {\n        return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n    }\n    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n});\n\ndefine('rxjs/operators/elementAt',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/ArgumentOutOfRangeError\"], function (require, exports, tslib_1, Subscriber_1, ArgumentOutOfRangeError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the single value at the specified `index` in a sequence of emissions\n     * from the source Observable.\n     *\n     * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n     *\n     * <img src=\"./img/elementAt.png\" width=\"100%\">\n     *\n     * `elementAt` returns an Observable that emits the item at the specified\n     * `index` in the source Observable, or a default value if that `index` is out\n     * of range and the `default` argument is provided. If the `default` argument is\n     * not given and the `index` is out of range, the output Observable will emit an\n     * `ArgumentOutOfRangeError` error.\n     *\n     * @example <caption>Emit only the third click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.elementAt(2);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // click 1 = nothing\n     * // click 2 = nothing\n     * // click 3 = MouseEvent object logged to console\n     *\n     * @see {@link first}\n     * @see {@link last}\n     * @see {@link skip}\n     * @see {@link single}\n     * @see {@link take}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n     * Observable has completed before emitting the i-th `next` notification.\n     *\n     * @param {number} index Is the number `i` for the i-th source emission that has\n     * happened since the subscription, starting from the number `0`.\n     * @param {T} [defaultValue] The default value returned for missing indices.\n     * @return {Observable} An Observable that emits a single item, if it is found.\n     * Otherwise, will emit the default value if given. If not, then emits an error.\n     * @method elementAt\n     * @owner Observable\n     */\n    function elementAt(index, defaultValue) {\n        return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };\n    }\n    exports.elementAt = elementAt;\n    var ElementAtOperator = /** @class */ (function () {\n        function ElementAtOperator(index, defaultValue) {\n            this.index = index;\n            this.defaultValue = defaultValue;\n            if (index < 0) {\n                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n            }\n        }\n        ElementAtOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n        };\n        return ElementAtOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ElementAtSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ElementAtSubscriber, _super);\n        function ElementAtSubscriber(destination, index, defaultValue) {\n            var _this = _super.call(this, destination) || this;\n            _this.index = index;\n            _this.defaultValue = defaultValue;\n            return _this;\n        }\n        ElementAtSubscriber.prototype._next = function (x) {\n            if (this.index-- === 0) {\n                this.destination.next(x);\n                this.destination.complete();\n            }\n        };\n        ElementAtSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            if (this.index >= 0) {\n                if (typeof this.defaultValue !== 'undefined') {\n                    destination.next(this.defaultValue);\n                }\n                else {\n                    destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n                }\n            }\n            destination.complete();\n        };\n        return ElementAtSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/every',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n     *\n     * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n     *  Observable.of(1, 2, 3, 4, 5, 6)\n     *     .every(x => x < 5)\n     *     .subscribe(x => console.log(x)); // -> false\n     *\n     * @param {function} predicate A function for determining if an item meets a specified condition.\n     * @param {any} [thisArg] Optional object to use for `this` in the callback.\n     * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n     * @method every\n     * @owner Observable\n     */\n    function every(predicate, thisArg) {\n        return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };\n    }\n    exports.every = every;\n    var EveryOperator = /** @class */ (function () {\n        function EveryOperator(predicate, thisArg, source) {\n            this.predicate = predicate;\n            this.thisArg = thisArg;\n            this.source = source;\n        }\n        EveryOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n        };\n        return EveryOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var EverySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(EverySubscriber, _super);\n        function EverySubscriber(destination, predicate, thisArg, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.thisArg = thisArg;\n            _this.source = source;\n            _this.index = 0;\n            _this.thisArg = thisArg || _this;\n            return _this;\n        }\n        EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n            this.destination.next(everyValueMatch);\n            this.destination.complete();\n        };\n        EverySubscriber.prototype._next = function (value) {\n            var result = false;\n            try {\n                result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (!result) {\n                this.notifyComplete(false);\n            }\n        };\n        EverySubscriber.prototype._complete = function () {\n            this.notifyComplete(true);\n        };\n        return EverySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/exhaust',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by dropping\n     * inner Observables while the previous inner Observable has not yet completed.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n     * next inner Observables while the current inner is still executing.</span>\n     *\n     * <img src=\"./img/exhaust.png\" width=\"100%\">\n     *\n     * `exhaust` subscribes to an Observable that emits Observables, also known as a\n     * higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, the output Observable begins emitting the items emitted by that\n     * inner Observable. So far, it behaves like {@link mergeAll}. However,\n     * `exhaust` ignores every new inner Observable if the previous Observable has\n     * not yet completed. Once that one completes, it will accept and flatten the\n     * next inner Observable and repeat this process.\n     *\n     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n     * var result = higherOrder.exhaust();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link switch}\n     * @see {@link mergeAll}\n     * @see {@link exhaustMap}\n     * @see {@link zipAll}\n     *\n     * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n     * exclusively until it completes before subscribing to the next.\n     * @method exhaust\n     * @owner Observable\n     */\n    function exhaust() {\n        return function (source) { return source.lift(new SwitchFirstOperator()); };\n    }\n    exports.exhaust = exhaust;\n    var SwitchFirstOperator = /** @class */ (function () {\n        function SwitchFirstOperator() {\n        }\n        SwitchFirstOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SwitchFirstSubscriber(subscriber));\n        };\n        return SwitchFirstOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SwitchFirstSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SwitchFirstSubscriber, _super);\n        function SwitchFirstSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.hasCompleted = false;\n            _this.hasSubscription = false;\n            return _this;\n        }\n        SwitchFirstSubscriber.prototype._next = function (value) {\n            if (!this.hasSubscription) {\n                this.hasSubscription = true;\n                this.add(subscribeToResult_1.subscribeToResult(this, value));\n            }\n        };\n        SwitchFirstSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (!this.hasSubscription) {\n                this.destination.complete();\n            }\n        };\n        SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.remove(innerSub);\n            this.hasSubscription = false;\n            if (this.hasCompleted) {\n                this.destination.complete();\n            }\n        };\n        return SwitchFirstSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/exhaustMap',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable only if the previous projected Observable has completed.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link exhaust}.</span>\n     *\n     * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. When it projects a source value to\n     * an Observable, the output Observable begins emitting the items emitted by\n     * that projected Observable. However, `exhaustMap` ignores every new projected\n     * Observable if the previous projected Observable has not yet completed. Once\n     * that one completes, it will accept and flatten the next projected Observable\n     * and repeat this process.\n     *\n     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaust}\n     * @see {@link mergeMap}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable containing projected Observables\n     * of each item of the source, ignoring projected Observables that start before\n     * their preceding Observable has completed.\n     * @method exhaustMap\n     * @owner Observable\n     */\n    function exhaustMap(project, resultSelector) {\n        return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n    }\n    exports.exhaustMap = exhaustMap;\n    var SwitchFirstMapOperator = /** @class */ (function () {\n        function SwitchFirstMapOperator(project, resultSelector) {\n            this.project = project;\n            this.resultSelector = resultSelector;\n        }\n        SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n        };\n        return SwitchFirstMapOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SwitchFirstMapSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SwitchFirstMapSubscriber, _super);\n        function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.resultSelector = resultSelector;\n            _this.hasSubscription = false;\n            _this.hasCompleted = false;\n            _this.index = 0;\n            return _this;\n        }\n        SwitchFirstMapSubscriber.prototype._next = function (value) {\n            if (!this.hasSubscription) {\n                this.tryNext(value);\n            }\n        };\n        SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n            var index = this.index++;\n            var destination = this.destination;\n            try {\n                var result = this.project(value, index);\n                this.hasSubscription = true;\n                this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n            }\n            catch (err) {\n                destination.error(err);\n            }\n        };\n        SwitchFirstMapSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (!this.hasSubscription) {\n                this.destination.complete();\n            }\n        };\n        SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            if (resultSelector) {\n                this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                destination.next(innerValue);\n            }\n        };\n        SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            try {\n                var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n                destination.next(result);\n            }\n            catch (err) {\n                destination.error(err);\n            }\n        };\n        SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n            this.destination.error(err);\n        };\n        SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.remove(innerSub);\n            this.hasSubscription = false;\n            if (this.hasCompleted) {\n                this.destination.complete();\n            }\n        };\n        return SwitchFirstMapSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/expand',[\"require\", \"exports\", \"tslib\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Recursively projects each source value to an Observable which is merged in\n     * the output Observable.\n     *\n     * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n     * projection function to every source value as well as every output value.\n     * It's recursive.</span>\n     *\n     * <img src=\"./img/expand.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an Observable, and then merging those resulting Observables and\n     * emitting the results of this merger. *Expand* will re-emit on the output\n     * Observable every source value. Then, each output value is given to the\n     * `project` function which returns an inner Observable to be merged on the\n     * output Observable. Those output values resulting from the projection are also\n     * given to the `project` function to produce new output values. This is how\n     * *expand* behaves recursively.\n     *\n     * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var powersOfTwo = clicks\n     *   .mapTo(1)\n     *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n     *   .take(10);\n     * powersOfTwo.subscribe(x => console.log(x));\n     *\n     * @see {@link mergeMap}\n     * @see {@link mergeScan}\n     *\n     * @param {function(value: T, index: number) => Observable} project A function\n     * that, when applied to an item emitted by the source or the output Observable,\n     * returns an Observable.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n     * each projected inner Observable.\n     * @return {Observable} An Observable that emits the source values and also\n     * result of applying the projection function to each value emitted on the\n     * output Observable and and merging the results of the Observables obtained\n     * from this transformation.\n     * @method expand\n     * @owner Observable\n     */\n    function expand(project, concurrent, scheduler) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        if (scheduler === void 0) { scheduler = undefined; }\n        concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n        return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };\n    }\n    exports.expand = expand;\n    var ExpandOperator = /** @class */ (function () {\n        function ExpandOperator(project, concurrent, scheduler) {\n            this.project = project;\n            this.concurrent = concurrent;\n            this.scheduler = scheduler;\n        }\n        ExpandOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n        };\n        return ExpandOperator;\n    }());\n    exports.ExpandOperator = ExpandOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ExpandSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ExpandSubscriber, _super);\n        function ExpandSubscriber(destination, project, concurrent, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.concurrent = concurrent;\n            _this.scheduler = scheduler;\n            _this.index = 0;\n            _this.active = 0;\n            _this.hasCompleted = false;\n            if (concurrent < Number.POSITIVE_INFINITY) {\n                _this.buffer = [];\n            }\n            return _this;\n        }\n        ExpandSubscriber.dispatch = function (arg) {\n            var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n            subscriber.subscribeToProjection(result, value, index);\n        };\n        ExpandSubscriber.prototype._next = function (value) {\n            var destination = this.destination;\n            if (destination.closed) {\n                this._complete();\n                return;\n            }\n            var index = this.index++;\n            if (this.active < this.concurrent) {\n                destination.next(value);\n                var result = tryCatch_1.tryCatch(this.project)(value, index);\n                if (result === errorObject_1.errorObject) {\n                    destination.error(errorObject_1.errorObject.e);\n                }\n                else if (!this.scheduler) {\n                    this.subscribeToProjection(result, value, index);\n                }\n                else {\n                    var state = { subscriber: this, result: result, value: value, index: index };\n                    this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n                }\n            }\n            else {\n                this.buffer.push(value);\n            }\n        };\n        ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n            this.active++;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        };\n        ExpandSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (this.hasCompleted && this.active === 0) {\n                this.destination.complete();\n            }\n        };\n        ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this._next(innerValue);\n        };\n        ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n            var buffer = this.buffer;\n            this.remove(innerSub);\n            this.active--;\n            if (buffer && buffer.length > 0) {\n                this._next(buffer.shift());\n            }\n            if (this.hasCompleted && this.active === 0) {\n                this.destination.complete();\n            }\n        };\n        return ExpandSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.ExpandSubscriber = ExpandSubscriber;\n});\n\ndefine('rxjs/operators/filter',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Filter items emitted by the source Observable by only emitting those that\n     * satisfy a specified predicate.\n     *\n     * <span class=\"informal\">Like\n     * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n     * it only emits a value from the source if it passes a criterion function.</span>\n     *\n     * <img src=\"./img/filter.png\" width=\"100%\">\n     *\n     * Similar to the well-known `Array.prototype.filter` method, this operator\n     * takes values from the source Observable, passes them through a `predicate`\n     * function and only emits those values that yielded `true`.\n     *\n     * @example <caption>Emit only click events whose target was a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n     * clicksOnDivs.subscribe(x => console.log(x));\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilChanged}\n     * @see {@link distinctUntilKeyChanged}\n     * @see {@link ignoreElements}\n     * @see {@link partition}\n     * @see {@link skip}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates each value emitted by the source Observable. If it returns `true`,\n     * the value is emitted, if `false` the value is not passed to the output\n     * Observable. The `index` parameter is the number `i` for the i-th source\n     * emission that has happened since the subscription, starting from the number\n     * `0`.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable} An Observable of values from the source that were\n     * allowed by the `predicate` function.\n     * @method filter\n     * @owner Observable\n     */\n    function filter(predicate, thisArg) {\n        return function filterOperatorFunction(source) {\n            return source.lift(new FilterOperator(predicate, thisArg));\n        };\n    }\n    exports.filter = filter;\n    var FilterOperator = /** @class */ (function () {\n        function FilterOperator(predicate, thisArg) {\n            this.predicate = predicate;\n            this.thisArg = thisArg;\n        }\n        FilterOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n        };\n        return FilterOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var FilterSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(FilterSubscriber, _super);\n        function FilterSubscriber(destination, predicate, thisArg) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.thisArg = thisArg;\n            _this.count = 0;\n            return _this;\n        }\n        // the try catch block below is left specifically for\n        // optimization and perf reasons. a tryCatcher is not necessary here.\n        FilterSubscriber.prototype._next = function (value) {\n            var result;\n            try {\n                result = this.predicate.call(this.thisArg, value, this.count++);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (result) {\n                this.destination.next(value);\n            }\n        };\n        return FilterSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/finalize',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Subscription\"], function (require, exports, tslib_1, Subscriber_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable, but will call a specified function when\n     * the source terminates on complete or error.\n     * @param {function} callback Function to be called when source terminates.\n     * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n     * @method finally\n     * @owner Observable\n     */\n    function finalize(callback) {\n        return function (source) { return source.lift(new FinallyOperator(callback)); };\n    }\n    exports.finalize = finalize;\n    var FinallyOperator = /** @class */ (function () {\n        function FinallyOperator(callback) {\n            this.callback = callback;\n        }\n        FinallyOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n        };\n        return FinallyOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var FinallySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(FinallySubscriber, _super);\n        function FinallySubscriber(destination, callback) {\n            var _this = _super.call(this, destination) || this;\n            _this.add(new Subscription_1.Subscription(callback));\n            return _this;\n        }\n        return FinallySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/find',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first value emitted by the source Observable that meets some\n     * condition.\n     *\n     * <span class=\"informal\">Finds the first value that passes some test and emits\n     * that.</span>\n     *\n     * <img src=\"./img/find.png\" width=\"100%\">\n     *\n     * `find` searches for the first item in the source Observable that matches the\n     * specified condition embodied by the `predicate`, and returns the first\n     * occurrence in the source. Unlike {@link first}, the `predicate` is required\n     * in `find`, and does not emit an error if a valid value is not found.\n     *\n     * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link first}\n     * @see {@link findIndex}\n     * @see {@link take}\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n     * A function called with each item to test for condition matching.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable<T>} An Observable of the first item that matches the\n     * condition.\n     * @method find\n     * @owner Observable\n     */\n    function find(predicate, thisArg) {\n        if (typeof predicate !== 'function') {\n            throw new TypeError('predicate is not a function');\n        }\n        return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };\n    }\n    exports.find = find;\n    var FindValueOperator = /** @class */ (function () {\n        function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n            this.predicate = predicate;\n            this.source = source;\n            this.yieldIndex = yieldIndex;\n            this.thisArg = thisArg;\n        }\n        FindValueOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n        };\n        return FindValueOperator;\n    }());\n    exports.FindValueOperator = FindValueOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var FindValueSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(FindValueSubscriber, _super);\n        function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.source = source;\n            _this.yieldIndex = yieldIndex;\n            _this.thisArg = thisArg;\n            _this.index = 0;\n            return _this;\n        }\n        FindValueSubscriber.prototype.notifyComplete = function (value) {\n            var destination = this.destination;\n            destination.next(value);\n            destination.complete();\n        };\n        FindValueSubscriber.prototype._next = function (value) {\n            var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n            var index = this.index++;\n            try {\n                var result = predicate.call(thisArg || this, value, index, this.source);\n                if (result) {\n                    this.notifyComplete(this.yieldIndex ? index : value);\n                }\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        FindValueSubscriber.prototype._complete = function () {\n            this.notifyComplete(this.yieldIndex ? -1 : undefined);\n        };\n        return FindValueSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.FindValueSubscriber = FindValueSubscriber;\n});\n\ndefine('rxjs/operators/findIndex',[\"require\", \"exports\", \"../operators/find\"], function (require, exports, find_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the index of the first value emitted by the source Observable that\n     * meets some condition.\n     *\n     * <span class=\"informal\">It's like {@link find}, but emits the index of the\n     * found value, not the value itself.</span>\n     *\n     * <img src=\"./img/findIndex.png\" width=\"100%\">\n     *\n     * `findIndex` searches for the first item in the source Observable that matches\n     * the specified condition embodied by the `predicate`, and returns the\n     * (zero-based) index of the first occurrence in the source. Unlike\n     * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n     * an error if a valid value is not found.\n     *\n     * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link find}\n     * @see {@link first}\n     * @see {@link take}\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n     * A function called with each item to test for condition matching.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable} An Observable of the index of the first item that\n     * matches the condition.\n     * @method find\n     * @owner Observable\n     */\n    function findIndex(predicate, thisArg) {\n        return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };\n    }\n    exports.findIndex = findIndex;\n});\n\ndefine('rxjs/operators/first',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/EmptyError\"], function (require, exports, tslib_1, Subscriber_1, EmptyError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first value (or the first value that meets some condition)\n     * emitted by the source Observable.\n     *\n     * <span class=\"informal\">Emits only the first value. Or emits only the first\n     * value that passes some test.</span>\n     *\n     * <img src=\"./img/first.png\" width=\"100%\">\n     *\n     * If called with no arguments, `first` emits the first value of the source\n     * Observable, then completes. If called with a `predicate` function, `first`\n     * emits the first value of the source that matches the specified condition. It\n     * may also take a `resultSelector` function to produce the output value from\n     * the input value, and a `defaultValue` to emit in case the source completes\n     * before it is able to emit a valid value. Throws an error if `defaultValue`\n     * was not provided and a matching element is not found.\n     *\n     * @example <caption>Emit only the first click that happens on the DOM</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.first();\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits the first click that happens on a DIV</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link find}\n     * @see {@link take}\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n     * An optional function called with each item to test for condition matching.\n     * @param {function(value: T, index: number): R} [resultSelector] A function to\n     * produce the value on the output Observable based on the values\n     * and the indices of the source Observable. The arguments passed to this\n     * function are:\n     * - `value`: the value that was emitted on the source.\n     * - `index`: the \"index\" of the value from the source.\n     * @param {R} [defaultValue] The default value emitted in case no valid value\n     * was found on the source.\n     * @return {Observable<T|R>} An Observable of the first item that matches the\n     * condition.\n     * @method first\n     * @owner Observable\n     */\n    function first(predicate, resultSelector, defaultValue) {\n        return function (source) { return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source)); };\n    }\n    exports.first = first;\n    var FirstOperator = /** @class */ (function () {\n        function FirstOperator(predicate, resultSelector, defaultValue, source) {\n            this.predicate = predicate;\n            this.resultSelector = resultSelector;\n            this.defaultValue = defaultValue;\n            this.source = source;\n        }\n        FirstOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n        };\n        return FirstOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var FirstSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(FirstSubscriber, _super);\n        function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.resultSelector = resultSelector;\n            _this.defaultValue = defaultValue;\n            _this.source = source;\n            _this.index = 0;\n            _this.hasCompleted = false;\n            _this._emitted = false;\n            return _this;\n        }\n        FirstSubscriber.prototype._next = function (value) {\n            var index = this.index++;\n            if (this.predicate) {\n                this._tryPredicate(value, index);\n            }\n            else {\n                this._emit(value, index);\n            }\n        };\n        FirstSubscriber.prototype._tryPredicate = function (value, index) {\n            var result;\n            try {\n                result = this.predicate(value, index, this.source);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (result) {\n                this._emit(value, index);\n            }\n        };\n        FirstSubscriber.prototype._emit = function (value, index) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this._emitFinal(value);\n        };\n        FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n            var result;\n            try {\n                result = this.resultSelector(value, index);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this._emitFinal(result);\n        };\n        FirstSubscriber.prototype._emitFinal = function (value) {\n            var destination = this.destination;\n            if (!this._emitted) {\n                this._emitted = true;\n                destination.next(value);\n                destination.complete();\n                this.hasCompleted = true;\n            }\n        };\n        FirstSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n                destination.complete();\n            }\n            else if (!this.hasCompleted) {\n                destination.error(new EmptyError_1.EmptyError);\n            }\n        };\n        return FirstSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/util/MapPolyfill',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var MapPolyfill = /** @class */ (function () {\n        function MapPolyfill() {\n            this.size = 0;\n            this._values = [];\n            this._keys = [];\n        }\n        MapPolyfill.prototype.get = function (key) {\n            var i = this._keys.indexOf(key);\n            return i === -1 ? undefined : this._values[i];\n        };\n        MapPolyfill.prototype.set = function (key, value) {\n            var i = this._keys.indexOf(key);\n            if (i === -1) {\n                this._keys.push(key);\n                this._values.push(value);\n                this.size++;\n            }\n            else {\n                this._values[i] = value;\n            }\n            return this;\n        };\n        MapPolyfill.prototype.delete = function (key) {\n            var i = this._keys.indexOf(key);\n            if (i === -1) {\n                return false;\n            }\n            this._values.splice(i, 1);\n            this._keys.splice(i, 1);\n            this.size--;\n            return true;\n        };\n        MapPolyfill.prototype.clear = function () {\n            this._keys.length = 0;\n            this._values.length = 0;\n            this.size = 0;\n        };\n        MapPolyfill.prototype.forEach = function (cb, thisArg) {\n            for (var i = 0; i < this.size; i++) {\n                cb.call(thisArg, this._values[i], this._keys[i]);\n            }\n        };\n        return MapPolyfill;\n    }());\n    exports.MapPolyfill = MapPolyfill;\n});\n\ndefine('rxjs/util/Map',[\"require\", \"exports\", \"./root\", \"./MapPolyfill\"], function (require, exports, root_1, MapPolyfill_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n});\n\ndefine('rxjs/util/FastMap',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var FastMap = /** @class */ (function () {\n        function FastMap() {\n            this.values = {};\n        }\n        FastMap.prototype.delete = function (key) {\n            this.values[key] = null;\n            return true;\n        };\n        FastMap.prototype.set = function (key, value) {\n            this.values[key] = value;\n            return this;\n        };\n        FastMap.prototype.get = function (key) {\n            return this.values[key];\n        };\n        FastMap.prototype.forEach = function (cb, thisArg) {\n            var values = this.values;\n            for (var key in values) {\n                if (values.hasOwnProperty(key) && values[key] !== null) {\n                    cb.call(thisArg, values[key], key);\n                }\n            }\n        };\n        FastMap.prototype.clear = function () {\n            this.values = {};\n        };\n        return FastMap;\n    }());\n    exports.FastMap = FastMap;\n});\n\ndefine('rxjs/operators/groupBy',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Subscription\", \"../Observable\", \"../Subject\", \"../util/Map\", \"../util/FastMap\"], function (require, exports, tslib_1, Subscriber_1, Subscription_1, Observable_1, Subject_1, Map_1, FastMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Groups the items emitted by an Observable according to a specified criterion,\n     * and emits these grouped items as `GroupedObservables`, one\n     * {@link GroupedObservable} per group.\n     *\n     * <img src=\"./img/groupBy.png\" width=\"100%\">\n     *\n     * @example <caption>Group objects by id and return as array</caption>\n     * Observable.of<Obj>({id: 1, name: 'aze1'},\n     *                    {id: 2, name: 'sf2'},\n     *                    {id: 2, name: 'dg2'},\n     *                    {id: 1, name: 'erg1'},\n     *                    {id: 1, name: 'df1'},\n     *                    {id: 2, name: 'sfqfb2'},\n     *                    {id: 3, name: 'qfs3'},\n     *                    {id: 2, name: 'qsgqsfg2'}\n     *     )\n     *     .groupBy(p => p.id)\n     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n     *     .subscribe(p => console.log(p));\n     *\n     * // displays:\n     * // [ { id: 1, name: 'aze1' },\n     * //   { id: 1, name: 'erg1' },\n     * //   { id: 1, name: 'df1' } ]\n     * //\n     * // [ { id: 2, name: 'sf2' },\n     * //   { id: 2, name: 'dg2' },\n     * //   { id: 2, name: 'sfqfb2' },\n     * //   { id: 2, name: 'qsgqsfg2' } ]\n     * //\n     * // [ { id: 3, name: 'qfs3' } ]\n     *\n     * @example <caption>Pivot data on the id field</caption>\n     * Observable.of<Obj>({id: 1, name: 'aze1'},\n     *                    {id: 2, name: 'sf2'},\n     *                    {id: 2, name: 'dg2'},\n     *                    {id: 1, name: 'erg1'},\n     *                    {id: 1, name: 'df1'},\n     *                    {id: 2, name: 'sfqfb2'},\n     *                    {id: 3, name: 'qfs1'},\n     *                    {id: 2, name: 'qsgqsfg2'}\n     *                   )\n     *     .groupBy(p => p.id, p => p.name)\n     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n     *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n     *     .subscribe(p => console.log(p));\n     *\n     * // displays:\n     * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n     * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n     * // { id: 3, values: [ 'qfs1' ] }\n     *\n     * @param {function(value: T): K} keySelector A function that extracts the key\n     * for each item.\n     * @param {function(value: T): R} [elementSelector] A function that extracts the\n     * return element for each item.\n     * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n     * A function that returns an Observable to determine how long each group should\n     * exist.\n     * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n     * GroupedObservables, each of which corresponds to a unique key value and each\n     * of which emits those items from the source Observable that share that key\n     * value.\n     * @method groupBy\n     * @owner Observable\n     */\n    function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n        return function (source) {\n            return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n        };\n    }\n    exports.groupBy = groupBy;\n    var GroupByOperator = /** @class */ (function () {\n        function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n            this.keySelector = keySelector;\n            this.elementSelector = elementSelector;\n            this.durationSelector = durationSelector;\n            this.subjectSelector = subjectSelector;\n        }\n        GroupByOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n        };\n        return GroupByOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var GroupBySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(GroupBySubscriber, _super);\n        function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.keySelector = keySelector;\n            _this.elementSelector = elementSelector;\n            _this.durationSelector = durationSelector;\n            _this.subjectSelector = subjectSelector;\n            _this.groups = null;\n            _this.attemptedToUnsubscribe = false;\n            _this.count = 0;\n            return _this;\n        }\n        GroupBySubscriber.prototype._next = function (value) {\n            var key;\n            try {\n                key = this.keySelector(value);\n            }\n            catch (err) {\n                this.error(err);\n                return;\n            }\n            this._group(value, key);\n        };\n        GroupBySubscriber.prototype._group = function (value, key) {\n            var groups = this.groups;\n            if (!groups) {\n                groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n            }\n            var group = groups.get(key);\n            var element;\n            if (this.elementSelector) {\n                try {\n                    element = this.elementSelector(value);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            }\n            else {\n                element = value;\n            }\n            if (!group) {\n                group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n                groups.set(key, group);\n                var groupedObservable = new GroupedObservable(key, group, this);\n                this.destination.next(groupedObservable);\n                if (this.durationSelector) {\n                    var duration = void 0;\n                    try {\n                        duration = this.durationSelector(new GroupedObservable(key, group));\n                    }\n                    catch (err) {\n                        this.error(err);\n                        return;\n                    }\n                    this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n                }\n            }\n            if (!group.closed) {\n                group.next(element);\n            }\n        };\n        GroupBySubscriber.prototype._error = function (err) {\n            var groups = this.groups;\n            if (groups) {\n                groups.forEach(function (group, key) {\n                    group.error(err);\n                });\n                groups.clear();\n            }\n            this.destination.error(err);\n        };\n        GroupBySubscriber.prototype._complete = function () {\n            var groups = this.groups;\n            if (groups) {\n                groups.forEach(function (group, key) {\n                    group.complete();\n                });\n                groups.clear();\n            }\n            this.destination.complete();\n        };\n        GroupBySubscriber.prototype.removeGroup = function (key) {\n            this.groups.delete(key);\n        };\n        GroupBySubscriber.prototype.unsubscribe = function () {\n            if (!this.closed) {\n                this.attemptedToUnsubscribe = true;\n                if (this.count === 0) {\n                    _super.prototype.unsubscribe.call(this);\n                }\n            }\n        };\n        return GroupBySubscriber;\n    }(Subscriber_1.Subscriber));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var GroupDurationSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(GroupDurationSubscriber, _super);\n        function GroupDurationSubscriber(key, group, parent) {\n            var _this = _super.call(this, group) || this;\n            _this.key = key;\n            _this.group = group;\n            _this.parent = parent;\n            return _this;\n        }\n        GroupDurationSubscriber.prototype._next = function (value) {\n            this.complete();\n        };\n        GroupDurationSubscriber.prototype._unsubscribe = function () {\n            var _a = this, parent = _a.parent, key = _a.key;\n            this.key = this.parent = null;\n            if (parent) {\n                parent.removeGroup(key);\n            }\n        };\n        return GroupDurationSubscriber;\n    }(Subscriber_1.Subscriber));\n    /**\n     * An Observable representing values belonging to the same group represented by\n     * a common key. The values emitted by a GroupedObservable come from the source\n     * Observable. The common key is available as the field `key` on a\n     * GroupedObservable instance.\n     *\n     * @class GroupedObservable<K, T>\n     */\n    var GroupedObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(GroupedObservable, _super);\n        function GroupedObservable(key, groupSubject, refCountSubscription) {\n            var _this = _super.call(this) || this;\n            _this.key = key;\n            _this.groupSubject = groupSubject;\n            _this.refCountSubscription = refCountSubscription;\n            return _this;\n        }\n        GroupedObservable.prototype._subscribe = function (subscriber) {\n            var subscription = new Subscription_1.Subscription();\n            var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n            if (refCountSubscription && !refCountSubscription.closed) {\n                subscription.add(new InnerRefCountSubscription(refCountSubscription));\n            }\n            subscription.add(groupSubject.subscribe(subscriber));\n            return subscription;\n        };\n        return GroupedObservable;\n    }(Observable_1.Observable));\n    exports.GroupedObservable = GroupedObservable;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var InnerRefCountSubscription = /** @class */ (function (_super) {\n        tslib_1.__extends(InnerRefCountSubscription, _super);\n        function InnerRefCountSubscription(parent) {\n            var _this = _super.call(this) || this;\n            _this.parent = parent;\n            parent.count++;\n            return _this;\n        }\n        InnerRefCountSubscription.prototype.unsubscribe = function () {\n            var parent = this.parent;\n            if (!parent.closed && !this.closed) {\n                _super.prototype.unsubscribe.call(this);\n                parent.count -= 1;\n                if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                    parent.unsubscribe();\n                }\n            }\n        };\n        return InnerRefCountSubscription;\n    }(Subscription_1.Subscription));\n});\n\ndefine('rxjs/operators/ignoreElements',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/noop\"], function (require, exports, tslib_1, Subscriber_1, noop_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n     *\n     * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n     *\n     * @return {Observable} An empty Observable that only calls `complete`\n     * or `error`, based on which one is called by the source Observable.\n     * @method ignoreElements\n     * @owner Observable\n     */\n    function ignoreElements() {\n        return function ignoreElementsOperatorFunction(source) {\n            return source.lift(new IgnoreElementsOperator());\n        };\n    }\n    exports.ignoreElements = ignoreElements;\n    var IgnoreElementsOperator = /** @class */ (function () {\n        function IgnoreElementsOperator() {\n        }\n        IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n        };\n        return IgnoreElementsOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var IgnoreElementsSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(IgnoreElementsSubscriber, _super);\n        function IgnoreElementsSubscriber() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        IgnoreElementsSubscriber.prototype._next = function (unused) {\n            noop_1.noop();\n        };\n        return IgnoreElementsSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/isEmpty',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isEmpty() {\n        return function (source) { return source.lift(new IsEmptyOperator()); };\n    }\n    exports.isEmpty = isEmpty;\n    var IsEmptyOperator = /** @class */ (function () {\n        function IsEmptyOperator() {\n        }\n        IsEmptyOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new IsEmptySubscriber(observer));\n        };\n        return IsEmptyOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var IsEmptySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(IsEmptySubscriber, _super);\n        function IsEmptySubscriber(destination) {\n            return _super.call(this, destination) || this;\n        }\n        IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n            var destination = this.destination;\n            destination.next(isEmpty);\n            destination.complete();\n        };\n        IsEmptySubscriber.prototype._next = function (value) {\n            this.notifyComplete(false);\n        };\n        IsEmptySubscriber.prototype._complete = function () {\n            this.notifyComplete(true);\n        };\n        return IsEmptySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/last',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/EmptyError\"], function (require, exports, tslib_1, Subscriber_1, EmptyError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits only the last item emitted by the source Observable.\n     * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n     * the last item from the source Observable, the resulting Observable will emit the last item\n     * from the source Observable that satisfies the predicate.\n     *\n     * <img src=\"./img/last.png\" width=\"100%\">\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     * @param {function} predicate - The condition any source emitted item has to satisfy.\n     * @return {Observable} An Observable that emits only the last item satisfying the given condition\n     * from the source, or an NoSuchElementException if no such items are emitted.\n     * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n     * @method last\n     * @owner Observable\n     */\n    function last(predicate, resultSelector, defaultValue) {\n        return function (source) { return source.lift(new LastOperator(predicate, resultSelector, defaultValue, source)); };\n    }\n    exports.last = last;\n    var LastOperator = /** @class */ (function () {\n        function LastOperator(predicate, resultSelector, defaultValue, source) {\n            this.predicate = predicate;\n            this.resultSelector = resultSelector;\n            this.defaultValue = defaultValue;\n            this.source = source;\n        }\n        LastOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n        };\n        return LastOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var LastSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(LastSubscriber, _super);\n        function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.resultSelector = resultSelector;\n            _this.defaultValue = defaultValue;\n            _this.source = source;\n            _this.hasValue = false;\n            _this.index = 0;\n            if (typeof defaultValue !== 'undefined') {\n                _this.lastValue = defaultValue;\n                _this.hasValue = true;\n            }\n            return _this;\n        }\n        LastSubscriber.prototype._next = function (value) {\n            var index = this.index++;\n            if (this.predicate) {\n                this._tryPredicate(value, index);\n            }\n            else {\n                if (this.resultSelector) {\n                    this._tryResultSelector(value, index);\n                    return;\n                }\n                this.lastValue = value;\n                this.hasValue = true;\n            }\n        };\n        LastSubscriber.prototype._tryPredicate = function (value, index) {\n            var result;\n            try {\n                result = this.predicate(value, index, this.source);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (result) {\n                if (this.resultSelector) {\n                    this._tryResultSelector(value, index);\n                    return;\n                }\n                this.lastValue = value;\n                this.hasValue = true;\n            }\n        };\n        LastSubscriber.prototype._tryResultSelector = function (value, index) {\n            var result;\n            try {\n                result = this.resultSelector(value, index);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.lastValue = result;\n            this.hasValue = true;\n        };\n        LastSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            if (this.hasValue) {\n                destination.next(this.lastValue);\n                destination.complete();\n            }\n            else {\n                destination.error(new EmptyError_1.EmptyError);\n            }\n        };\n        return LastSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/mapTo',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the given constant value on the output Observable every time the source\n     * Observable emits a value.\n     *\n     * <span class=\"informal\">Like {@link map}, but it maps every source value to\n     * the same output value every time.</span>\n     *\n     * <img src=\"./img/mapTo.png\" width=\"100%\">\n     *\n     * Takes a constant `value` as argument, and emits that whenever the source\n     * Observable emits a value. In other words, ignores the actual source value,\n     * and simply uses the emission moment to know when to emit the given `value`.\n     *\n     * @example <caption>Map every click to the string 'Hi'</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var greetings = clicks.mapTo('Hi');\n     * greetings.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     *\n     * @param {any} value The value to map each source value to.\n     * @return {Observable} An Observable that emits the given `value` every time\n     * the source Observable emits something.\n     * @method mapTo\n     * @owner Observable\n     */\n    function mapTo(value) {\n        return function (source) { return source.lift(new MapToOperator(value)); };\n    }\n    exports.mapTo = mapTo;\n    var MapToOperator = /** @class */ (function () {\n        function MapToOperator(value) {\n            this.value = value;\n        }\n        MapToOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new MapToSubscriber(subscriber, this.value));\n        };\n        return MapToOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MapToSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MapToSubscriber, _super);\n        function MapToSubscriber(destination, value) {\n            var _this = _super.call(this, destination) || this;\n            _this.value = value;\n            return _this;\n        }\n        MapToSubscriber.prototype._next = function (x) {\n            this.destination.next(this.value);\n        };\n        return MapToSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/materialize',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Notification\"], function (require, exports, tslib_1, Subscriber_1, Notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represents all of the notifications from the source Observable as `next`\n     * emissions marked with their original types within {@link Notification}\n     * objects.\n     *\n     * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n     * {@link Notification} objects, emitted as `next` on the output Observable.\n     * </span>\n     *\n     * <img src=\"./img/materialize.png\" width=\"100%\">\n     *\n     * `materialize` returns an Observable that emits a `next` notification for each\n     * `next`, `error`, or `complete` emission of the source Observable. When the\n     * source Observable emits `complete`, the output Observable will emit `next` as\n     * a Notification of type \"complete\", and then it will emit `complete` as well.\n     * When the source Observable emits `error`, the output will emit `next` as a\n     * Notification of type \"error\", and then `complete`.\n     *\n     * This operator is useful for producing metadata of the source Observable, to\n     * be consumed as `next` emissions. Use it in conjunction with\n     * {@link dematerialize}.\n     *\n     * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n     * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n     * var upperCase = letters.map(x => x.toUpperCase());\n     * var materialized = upperCase.materialize();\n     * materialized.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n     * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n     * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n     * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n     * //   [as project] (http://1, hasValue: false}\n     *\n     * @see {@link Notification}\n     * @see {@link dematerialize}\n     *\n     * @return {Observable<Notification<T>>} An Observable that emits\n     * {@link Notification} objects that wrap the original emissions from the source\n     * Observable with metadata.\n     * @method materialize\n     * @owner Observable\n     */\n    function materialize() {\n        return function materializeOperatorFunction(source) {\n            return source.lift(new MaterializeOperator());\n        };\n    }\n    exports.materialize = materialize;\n    var MaterializeOperator = /** @class */ (function () {\n        function MaterializeOperator() {\n        }\n        MaterializeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new MaterializeSubscriber(subscriber));\n        };\n        return MaterializeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MaterializeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MaterializeSubscriber, _super);\n        function MaterializeSubscriber(destination) {\n            return _super.call(this, destination) || this;\n        }\n        MaterializeSubscriber.prototype._next = function (value) {\n            this.destination.next(Notification_1.Notification.createNext(value));\n        };\n        MaterializeSubscriber.prototype._error = function (err) {\n            var destination = this.destination;\n            destination.next(Notification_1.Notification.createError(err));\n            destination.complete();\n        };\n        MaterializeSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            destination.next(Notification_1.Notification.createComplete());\n            destination.complete();\n        };\n        return MaterializeSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/scan',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Applies an accumulator function over the source Observable, and returns each\n     * intermediate result, with an optional seed value.\n     *\n     * <span class=\"informal\">It's like {@link reduce}, but emits the current\n     * accumulation whenever the source emits a value.</span>\n     *\n     * <img src=\"./img/scan.png\" width=\"100%\">\n     *\n     * Combines together all values emitted on the source, using an accumulator\n     * function that knows how to join a new source value into the accumulation from\n     * the past. Is similar to {@link reduce}, but emits the intermediate\n     * accumulations.\n     *\n     * Returns an Observable that applies a specified `accumulator` function to each\n     * item emitted by the source Observable. If a `seed` value is specified, then\n     * that value will be used as the initial value for the accumulator. If no seed\n     * value is specified, the first item of the source is used as the seed.\n     *\n     * @example <caption>Count the number of click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var ones = clicks.mapTo(1);\n     * var seed = 0;\n     * var count = ones.scan((acc, one) => acc + one, seed);\n     * count.subscribe(x => console.log(x));\n     *\n     * @see {@link expand}\n     * @see {@link mergeScan}\n     * @see {@link reduce}\n     *\n     * @param {function(acc: R, value: T, index: number): R} accumulator\n     * The accumulator function called on each source value.\n     * @param {T|R} [seed] The initial accumulation value.\n     * @return {Observable<R>} An observable of the accumulated values.\n     * @method scan\n     * @owner Observable\n     */\n    function scan(accumulator, seed) {\n        var hasSeed = false;\n        // providing a seed of `undefined` *should* be valid and trigger\n        // hasSeed! so don't use `seed !== undefined` checks!\n        // For this reason, we have to check it here at the original call site\n        // otherwise inside Operator/Subscriber we won't know if `undefined`\n        // means they didn't provide anything or if they literally provided `undefined`\n        if (arguments.length >= 2) {\n            hasSeed = true;\n        }\n        return function scanOperatorFunction(source) {\n            return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n        };\n    }\n    exports.scan = scan;\n    var ScanOperator = /** @class */ (function () {\n        function ScanOperator(accumulator, seed, hasSeed) {\n            if (hasSeed === void 0) { hasSeed = false; }\n            this.accumulator = accumulator;\n            this.seed = seed;\n            this.hasSeed = hasSeed;\n        }\n        ScanOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n        };\n        return ScanOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ScanSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ScanSubscriber, _super);\n        function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n            var _this = _super.call(this, destination) || this;\n            _this.accumulator = accumulator;\n            _this._seed = _seed;\n            _this.hasSeed = hasSeed;\n            _this.index = 0;\n            return _this;\n        }\n        Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n            get: function () {\n                return this._seed;\n            },\n            set: function (value) {\n                this.hasSeed = true;\n                this._seed = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ScanSubscriber.prototype._next = function (value) {\n            if (!this.hasSeed) {\n                this.seed = value;\n                this.destination.next(value);\n            }\n            else {\n                return this._tryNext(value);\n            }\n        };\n        ScanSubscriber.prototype._tryNext = function (value) {\n            var index = this.index++;\n            var result;\n            try {\n                result = this.accumulator(this.seed, value, index);\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n            this.seed = result;\n            this.destination.next(result);\n        };\n        return ScanSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/takeLast',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/ArgumentOutOfRangeError\", \"../observable/EmptyObservable\"], function (require, exports, tslib_1, Subscriber_1, ArgumentOutOfRangeError_1, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the last `count` values emitted by the source Observable.\n     *\n     * <span class=\"informal\">Remembers the latest `count` values, then emits those\n     * only when the source completes.</span>\n     *\n     * <img src=\"./img/takeLast.png\" width=\"100%\">\n     *\n     * `takeLast` returns an Observable that emits at most the last `count` values\n     * emitted by the source Observable. If the source emits fewer than `count`\n     * values then all of its values are emitted. This operator must wait until the\n     * `complete` notification emission from the source in order to emit the `next`\n     * values on the output Observable, because otherwise it is impossible to know\n     * whether or not more values will be emitted on the source. For this reason,\n     * all values are emitted synchronously, followed by the complete notification.\n     *\n     * @example <caption>Take the last 3 values of an Observable with many values</caption>\n     * var many = Rx.Observable.range(1, 100);\n     * var lastThree = many.takeLast(3);\n     * lastThree.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeUntil}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n     *\n     * @param {number} count The maximum number of values to emit from the end of\n     * the sequence of values emitted by the source Observable.\n     * @return {Observable<T>} An Observable that emits at most the last count\n     * values emitted by the source Observable.\n     * @method takeLast\n     * @owner Observable\n     */\n    function takeLast(count) {\n        return function takeLastOperatorFunction(source) {\n            if (count === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            else {\n                return source.lift(new TakeLastOperator(count));\n            }\n        };\n    }\n    exports.takeLast = takeLast;\n    var TakeLastOperator = /** @class */ (function () {\n        function TakeLastOperator(total) {\n            this.total = total;\n            if (this.total < 0) {\n                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n            }\n        }\n        TakeLastOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n        };\n        return TakeLastOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TakeLastSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TakeLastSubscriber, _super);\n        function TakeLastSubscriber(destination, total) {\n            var _this = _super.call(this, destination) || this;\n            _this.total = total;\n            _this.ring = new Array();\n            _this.count = 0;\n            return _this;\n        }\n        TakeLastSubscriber.prototype._next = function (value) {\n            var ring = this.ring;\n            var total = this.total;\n            var count = this.count++;\n            if (ring.length < total) {\n                ring.push(value);\n            }\n            else {\n                var index = count % total;\n                ring[index] = value;\n            }\n        };\n        TakeLastSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            var count = this.count;\n            if (count > 0) {\n                var total = this.count >= this.total ? this.total : this.count;\n                var ring = this.ring;\n                for (var i = 0; i < total; i++) {\n                    var idx = (count++) % total;\n                    destination.next(ring[idx]);\n                }\n            }\n            destination.complete();\n        };\n        return TakeLastSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/reduce',[\"require\", \"exports\", \"./scan\", \"./takeLast\", \"./defaultIfEmpty\", \"../util/pipe\"], function (require, exports, scan_1, takeLast_1, defaultIfEmpty_1, pipe_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Applies an accumulator function over the source Observable, and returns the\n     * accumulated result when the source completes, given an optional seed value.\n     *\n     * <span class=\"informal\">Combines together all values emitted on the source,\n     * using an accumulator function that knows how to join a new source value into\n     * the accumulation from the past.</span>\n     *\n     * <img src=\"./img/reduce.png\" width=\"100%\">\n     *\n     * Like\n     * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n     * `reduce` applies an `accumulator` function against an accumulation and each\n     * value of the source Observable (from the past) to reduce it to a single\n     * value, emitted on the output Observable. Note that `reduce` will only emit\n     * one value, only when the source Observable completes. It is equivalent to\n     * applying operator {@link scan} followed by operator {@link last}.\n     *\n     * Returns an Observable that applies a specified `accumulator` function to each\n     * item emitted by the source Observable. If a `seed` value is specified, then\n     * that value will be used as the initial value for the accumulator. If no seed\n     * value is specified, the first item of the source is used as the seed.\n     *\n     * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n     * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n     *   .takeUntil(Rx.Observable.interval(5000));\n     * var ones = clicksInFiveSeconds.mapTo(1);\n     * var seed = 0;\n     * var count = ones.reduce((acc, one) => acc + one, seed);\n     * count.subscribe(x => console.log(x));\n     *\n     * @see {@link count}\n     * @see {@link expand}\n     * @see {@link mergeScan}\n     * @see {@link scan}\n     *\n     * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n     * called on each source value.\n     * @param {R} [seed] The initial accumulation value.\n     * @return {Observable<R>} An Observable that emits a single value that is the\n     * result of accumulating the values emitted by the source Observable.\n     * @method reduce\n     * @owner Observable\n     */\n    function reduce(accumulator, seed) {\n        // providing a seed of `undefined` *should* be valid and trigger\n        // hasSeed! so don't use `seed !== undefined` checks!\n        // For this reason, we have to check it here at the original call site\n        // otherwise inside Operator/Subscriber we won't know if `undefined`\n        // means they didn't provide anything or if they literally provided `undefined`\n        if (arguments.length >= 2) {\n            return function reduceOperatorFunctionWithSeed(source) {\n                return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);\n            };\n        }\n        return function reduceOperatorFunction(source) {\n            return pipe_1.pipe(scan_1.scan(function (acc, value, index) {\n                return accumulator(acc, value, index + 1);\n            }), takeLast_1.takeLast(1))(source);\n        };\n    }\n    exports.reduce = reduce;\n});\n\ndefine('rxjs/operators/max',[\"require\", \"exports\", \"./reduce\"], function (require, exports, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n     * and when source Observable completes it emits a single item: the item with the largest value.\n     *\n     * <img src=\"./img/max.png\" width=\"100%\">\n     *\n     * @example <caption>Get the maximal value of a series of numbers</caption>\n     * Rx.Observable.of(5, 4, 7, 2, 8)\n     *   .max()\n     *   .subscribe(x => console.log(x)); // -> 8\n     *\n     * @example <caption>Use a comparer function to get the maximal item</caption>\n     * interface Person {\n     *   age: number,\n     *   name: string\n     * }\n     * Observable.of<Person>({age: 7, name: 'Foo'},\n     *                       {age: 5, name: 'Bar'},\n     *                       {age: 9, name: 'Beer'})\n     *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n     * }\n     *\n     * @see {@link min}\n     *\n     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n     * value of two items.\n     * @return {Observable} An Observable that emits item with the largest value.\n     * @method max\n     * @owner Observable\n     */\n    function max(comparer) {\n        var max = (typeof comparer === 'function')\n            ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n            : function (x, y) { return x > y ? x : y; };\n        return reduce_1.reduce(max);\n    }\n    exports.max = max;\n});\n\ndefine('rxjs/operators/merge',[\"require\", \"exports\", \"../Observable\", \"../observable/ArrayObservable\", \"./mergeAll\", \"../util/isScheduler\"], function (require, exports, Observable_1, ArrayObservable_1, mergeAll_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    function merge() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return function (source) { return source.lift.call(mergeStatic.apply(void 0, [source].concat(observables))); };\n    }\n    exports.merge = merge;\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which concurrently emits all values from every\n     * given input Observable.\n     *\n     * <span class=\"informal\">Flattens multiple Observables together by blending\n     * their values into one Observable.</span>\n     *\n     * <img src=\"./img/merge.png\" width=\"100%\">\n     *\n     * `merge` subscribes to each given input Observable (as arguments), and simply\n     * forwards (without doing any transformation) all the values from all the input\n     * Observables to the output Observable. The output Observable only completes\n     * once all input Observables have completed. Any error delivered by an input\n     * Observable will be immediately emitted on the output Observable.\n     *\n     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n     * clicksOrTimer.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // timer will emit ascending values, one every second(1000ms) to console\n     * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n     * // Since the two streams are merged you see these happening\n     * // as they occur.\n     *\n     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var concurrent = 2; // the argument\n     * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n     * merged.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // - First timer1 and timer2 will run concurrently\n     * // - timer1 will emit a value every 1000ms for 10 iterations\n     * // - timer2 will emit a value every 2000ms for 6 iterations\n     * // - after timer1 hits it's max iteration, timer2 will\n     * //   continue, and timer3 will start to run concurrently with timer2\n     * // - when timer2 hits it's max iteration it terminates, and\n     * //   timer3 will continue to emit a value every 500ms until it is complete\n     *\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     *\n     * @param {...ObservableInput} observables Input Observables to merge together.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n     * concurrency of input Observables.\n     * @return {Observable} an Observable that emits items that are the result of\n     * every input Observable.\n     * @static true\n     * @name merge\n     * @owner Observable\n     */\n    function mergeStatic() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        var concurrent = Number.POSITIVE_INFINITY;\n        var scheduler = null;\n        var last = observables[observables.length - 1];\n        if (isScheduler_1.isScheduler(last)) {\n            scheduler = observables.pop();\n            if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n                concurrent = observables.pop();\n            }\n        }\n        else if (typeof last === 'number') {\n            concurrent = observables.pop();\n        }\n        if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n            return observables[0];\n        }\n        return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));\n    }\n    exports.mergeStatic = mergeStatic;\n});\n\ndefine('rxjs/operators/mergeMapTo',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is merged multiple\n     * times in the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n     * to the same inner Observable.</span>\n     *\n     * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then merges those resulting Observables into one\n     * single Observable, which is the output Observable.\n     *\n     * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMapTo}\n     * @see {@link merge}\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeScan}\n     * @see {@link switchMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits items from the given\n     * `innerObservable` (and optionally transformed through `resultSelector`) every\n     * time a value is emitted on the source Observable.\n     * @method mergeMapTo\n     * @owner Observable\n     */\n    function mergeMapTo(innerObservable, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        if (typeof resultSelector === 'number') {\n            concurrent = resultSelector;\n            resultSelector = null;\n        }\n        return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };\n    }\n    exports.mergeMapTo = mergeMapTo;\n    // TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n    //       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\n    var MergeMapToOperator = /** @class */ (function () {\n        function MergeMapToOperator(ish, resultSelector, concurrent) {\n            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n            this.ish = ish;\n            this.resultSelector = resultSelector;\n            this.concurrent = concurrent;\n        }\n        MergeMapToOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n        };\n        return MergeMapToOperator;\n    }());\n    exports.MergeMapToOperator = MergeMapToOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MergeMapToSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MergeMapToSubscriber, _super);\n        function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n            var _this = _super.call(this, destination) || this;\n            _this.ish = ish;\n            _this.resultSelector = resultSelector;\n            _this.concurrent = concurrent;\n            _this.hasCompleted = false;\n            _this.buffer = [];\n            _this.active = 0;\n            _this.index = 0;\n            return _this;\n        }\n        MergeMapToSubscriber.prototype._next = function (value) {\n            if (this.active < this.concurrent) {\n                var resultSelector = this.resultSelector;\n                var index = this.index++;\n                var ish = this.ish;\n                var destination = this.destination;\n                this.active++;\n                this._innerSub(ish, destination, resultSelector, value, index);\n            }\n            else {\n                this.buffer.push(value);\n            }\n        };\n        MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n        };\n        MergeMapToSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (this.active === 0 && this.buffer.length === 0) {\n                this.destination.complete();\n            }\n        };\n        MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            if (resultSelector) {\n                this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                destination.next(innerValue);\n            }\n        };\n        MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            var result;\n            try {\n                result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            catch (err) {\n                destination.error(err);\n                return;\n            }\n            destination.next(result);\n        };\n        MergeMapToSubscriber.prototype.notifyError = function (err) {\n            this.destination.error(err);\n        };\n        MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n            var buffer = this.buffer;\n            this.remove(innerSub);\n            this.active--;\n            if (buffer.length > 0) {\n                this._next(buffer.shift());\n            }\n            else if (this.active === 0 && this.hasCompleted) {\n                this.destination.complete();\n            }\n        };\n        return MergeMapToSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.MergeMapToSubscriber = MergeMapToSubscriber;\n});\n\ndefine('rxjs/operators/mergeScan',[\"require\", \"exports\", \"tslib\", \"../util/tryCatch\", \"../util/errorObject\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, tryCatch_1, errorObject_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Applies an accumulator function over the source Observable where the\n     * accumulator function itself returns an Observable, then each intermediate\n     * Observable returned is merged into the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n     * by the accumulator are merged into the outer Observable.</span>\n     *\n     * @example <caption>Count the number of click events</caption>\n     * const click$ = Rx.Observable.fromEvent(document, 'click');\n     * const one$ = click$.mapTo(1);\n     * const seed = 0;\n     * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n     * count$.subscribe(x => console.log(x));\n     *\n     * // Results:\n     * 1\n     * 2\n     * 3\n     * 4\n     * // ...and so on for each click\n     *\n     * @param {function(acc: R, value: T): Observable<R>} accumulator\n     * The accumulator function called on each source value.\n     * @param seed The initial accumulation value.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n     * input Observables being subscribed to concurrently.\n     * @return {Observable<R>} An observable of the accumulated values.\n     * @method mergeScan\n     * @owner Observable\n     */\n    function mergeScan(accumulator, seed, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };\n    }\n    exports.mergeScan = mergeScan;\n    var MergeScanOperator = /** @class */ (function () {\n        function MergeScanOperator(accumulator, seed, concurrent) {\n            this.accumulator = accumulator;\n            this.seed = seed;\n            this.concurrent = concurrent;\n        }\n        MergeScanOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n        };\n        return MergeScanOperator;\n    }());\n    exports.MergeScanOperator = MergeScanOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MergeScanSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MergeScanSubscriber, _super);\n        function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n            var _this = _super.call(this, destination) || this;\n            _this.accumulator = accumulator;\n            _this.acc = acc;\n            _this.concurrent = concurrent;\n            _this.hasValue = false;\n            _this.hasCompleted = false;\n            _this.buffer = [];\n            _this.active = 0;\n            _this.index = 0;\n            return _this;\n        }\n        MergeScanSubscriber.prototype._next = function (value) {\n            if (this.active < this.concurrent) {\n                var index = this.index++;\n                var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n                var destination = this.destination;\n                if (ish === errorObject_1.errorObject) {\n                    destination.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    this.active++;\n                    this._innerSub(ish, value, index);\n                }\n            }\n            else {\n                this.buffer.push(value);\n            }\n        };\n        MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n        };\n        MergeScanSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (this.active === 0 && this.buffer.length === 0) {\n                if (this.hasValue === false) {\n                    this.destination.next(this.acc);\n                }\n                this.destination.complete();\n            }\n        };\n        MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var destination = this.destination;\n            this.acc = innerValue;\n            this.hasValue = true;\n            destination.next(innerValue);\n        };\n        MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n            var buffer = this.buffer;\n            this.remove(innerSub);\n            this.active--;\n            if (buffer.length > 0) {\n                this._next(buffer.shift());\n            }\n            else if (this.active === 0 && this.hasCompleted) {\n                if (this.hasValue === false) {\n                    this.destination.next(this.acc);\n                }\n                this.destination.complete();\n            }\n        };\n        return MergeScanSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.MergeScanSubscriber = MergeScanSubscriber;\n});\n\ndefine('rxjs/operators/min',[\"require\", \"exports\", \"./reduce\"], function (require, exports, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n     * and when source Observable completes it emits a single item: the item with the smallest value.\n     *\n     * <img src=\"./img/min.png\" width=\"100%\">\n     *\n     * @example <caption>Get the minimal value of a series of numbers</caption>\n     * Rx.Observable.of(5, 4, 7, 2, 8)\n     *   .min()\n     *   .subscribe(x => console.log(x)); // -> 2\n     *\n     * @example <caption>Use a comparer function to get the minimal item</caption>\n     * interface Person {\n     *   age: number,\n     *   name: string\n     * }\n     * Observable.of<Person>({age: 7, name: 'Foo'},\n     *                       {age: 5, name: 'Bar'},\n     *                       {age: 9, name: 'Beer'})\n     *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n     * }\n     *\n     * @see {@link max}\n     *\n     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n     * value of two items.\n     * @return {Observable<R>} An Observable that emits item with the smallest value.\n     * @method min\n     * @owner Observable\n     */\n    function min(comparer) {\n        var min = (typeof comparer === 'function')\n            ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n            : function (x, y) { return x < y ? x : y; };\n        return reduce_1.reduce(min);\n    }\n    exports.min = min;\n});\n\ndefine('rxjs/operators/multicast',[\"require\", \"exports\", \"../observable/ConnectableObservable\"], function (require, exports, ConnectableObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits the results of invoking a specified selector on items\n     * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n     *\n     * <img src=\"./img/multicast.png\" width=\"100%\">\n     *\n     * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n     * which the source sequence's elements will be multicast to the selector function\n     * or Subject to push source elements into.\n     * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n     * as many times as needed, without causing multiple subscriptions to the source stream.\n     * Subscribers to the given source will receive all notifications of the source from the\n     * time of the subscription forward.\n     * @return {Observable} An Observable that emits the results of invoking the selector\n     * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n     * the underlying stream.\n     * @method multicast\n     * @owner Observable\n     */\n    function multicast(subjectOrSubjectFactory, selector) {\n        return function multicastOperatorFunction(source) {\n            var subjectFactory;\n            if (typeof subjectOrSubjectFactory === 'function') {\n                subjectFactory = subjectOrSubjectFactory;\n            }\n            else {\n                subjectFactory = function subjectFactory() {\n                    return subjectOrSubjectFactory;\n                };\n            }\n            if (typeof selector === 'function') {\n                return source.lift(new MulticastOperator(subjectFactory, selector));\n            }\n            var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);\n            connectable.source = source;\n            connectable.subjectFactory = subjectFactory;\n            return connectable;\n        };\n    }\n    exports.multicast = multicast;\n    var MulticastOperator = /** @class */ (function () {\n        function MulticastOperator(subjectFactory, selector) {\n            this.subjectFactory = subjectFactory;\n            this.selector = selector;\n        }\n        MulticastOperator.prototype.call = function (subscriber, source) {\n            var selector = this.selector;\n            var subject = this.subjectFactory();\n            var subscription = selector(subject).subscribe(subscriber);\n            subscription.add(source.subscribe(subject));\n            return subscription;\n        };\n        return MulticastOperator;\n    }());\n    exports.MulticastOperator = MulticastOperator;\n});\n\ndefine('rxjs/operators/onErrorResumeNext',[\"require\", \"exports\", \"tslib\", \"../observable/FromObservable\", \"../util/isArray\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, FromObservable_1, isArray_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n     * that was passed.\n     *\n     * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n     *\n     * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n     *\n     * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n     * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n     * as the source.\n     *\n     * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n     * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n     * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n     * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n     * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n     * be happening until there is no more Observables left in the series, at which point returned Observable will\n     * complete - even if the last subscribed stream ended with an error.\n     *\n     * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n     * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n     * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n     * an error.\n     *\n     * Note that you do not get any access to errors emitted by the Observables. In particular do not\n     * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n     * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n     *\n     *\n     * @example <caption>Subscribe to the next Observable after map fails</caption>\n     * Rx.Observable.of(1, 2, 3, 0)\n     *   .map(x => {\n     *       if (x === 0) { throw Error(); }\n             return 10 / x;\n     *   })\n     *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n     *   .subscribe(\n     *     val => console.log(val),\n     *     err => console.log(err),          // Will never be called.\n     *     () => console.log('that\\'s it!')\n     *   );\n     *\n     * // Logs:\n     * // 10\n     * // 5\n     * // 3.3333333333333335\n     * // 1\n     * // 2\n     * // 3\n     * // \"that's it!\"\n     *\n     * @see {@link concat}\n     * @see {@link catch}\n     *\n     * @param {...ObservableInput} observables Observables passed either directly or as an array.\n     * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n     * to the next passed Observable and so on, until it completes or runs out of Observables.\n     * @method onErrorResumeNext\n     * @owner Observable\n     */\n    function onErrorResumeNext() {\n        var nextSources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nextSources[_i] = arguments[_i];\n        }\n        if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n            nextSources = nextSources[0];\n        }\n        return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };\n    }\n    exports.onErrorResumeNext = onErrorResumeNext;\n    /* tslint:enable:max-line-length */\n    function onErrorResumeNextStatic() {\n        var nextSources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nextSources[_i] = arguments[_i];\n        }\n        var source = null;\n        if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n            nextSources = nextSources[0];\n        }\n        source = nextSources.shift();\n        return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n    }\n    exports.onErrorResumeNextStatic = onErrorResumeNextStatic;\n    var OnErrorResumeNextOperator = /** @class */ (function () {\n        function OnErrorResumeNextOperator(nextSources) {\n            this.nextSources = nextSources;\n        }\n        OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n        };\n        return OnErrorResumeNextOperator;\n    }());\n    var OnErrorResumeNextSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(OnErrorResumeNextSubscriber, _super);\n        function OnErrorResumeNextSubscriber(destination, nextSources) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.nextSources = nextSources;\n            return _this;\n        }\n        OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n            this.subscribeToNextSource();\n        };\n        OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.subscribeToNextSource();\n        };\n        OnErrorResumeNextSubscriber.prototype._error = function (err) {\n            this.subscribeToNextSource();\n        };\n        OnErrorResumeNextSubscriber.prototype._complete = function () {\n            this.subscribeToNextSource();\n        };\n        OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n            var next = this.nextSources.shift();\n            if (next) {\n                this.add(subscribeToResult_1.subscribeToResult(this, next));\n            }\n            else {\n                this.destination.complete();\n            }\n        };\n        return OnErrorResumeNextSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/pairwise',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Groups pairs of consecutive emissions together and emits them as an array of\n     * two values.\n     *\n     * <span class=\"informal\">Puts the current value and previous value together as\n     * an array, and emits that.</span>\n     *\n     * <img src=\"./img/pairwise.png\" width=\"100%\">\n     *\n     * The Nth emission from the source Observable will cause the output Observable\n     * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n     * pair. For this reason, `pairwise` emits on the second and subsequent\n     * emissions from the source Observable, but not on the first emission, because\n     * there is no previous value in that case.\n     *\n     * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var pairs = clicks.pairwise();\n     * var distance = pairs.map(pair => {\n     *   var x0 = pair[0].clientX;\n     *   var y0 = pair[0].clientY;\n     *   var x1 = pair[1].clientX;\n     *   var y1 = pair[1].clientY;\n     *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n     * });\n     * distance.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     *\n     * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n     * consecutive values from the source Observable.\n     * @method pairwise\n     * @owner Observable\n     */\n    function pairwise() {\n        return function (source) { return source.lift(new PairwiseOperator()); };\n    }\n    exports.pairwise = pairwise;\n    var PairwiseOperator = /** @class */ (function () {\n        function PairwiseOperator() {\n        }\n        PairwiseOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new PairwiseSubscriber(subscriber));\n        };\n        return PairwiseOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var PairwiseSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(PairwiseSubscriber, _super);\n        function PairwiseSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.hasPrev = false;\n            return _this;\n        }\n        PairwiseSubscriber.prototype._next = function (value) {\n            if (this.hasPrev) {\n                this.destination.next([this.prev, value]);\n            }\n            else {\n                this.hasPrev = true;\n            }\n            this.prev = value;\n        };\n        return PairwiseSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/util/not',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function not(pred, thisArg) {\n        function notPred() {\n            return !(notPred.pred.apply(notPred.thisArg, arguments));\n        }\n        notPred.pred = pred;\n        notPred.thisArg = thisArg;\n        return notPred;\n    }\n    exports.not = not;\n});\n\ndefine('rxjs/operators/partition',[\"require\", \"exports\", \"../util/not\", \"./filter\"], function (require, exports, not_1, filter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Splits the source Observable into two, one with values that satisfy a\n     * predicate, and another with values that don't satisfy the predicate.\n     *\n     * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n     * one like the output of {@link filter}, and the other with values that did not\n     * pass the condition.</span>\n     *\n     * <img src=\"./img/partition.png\" width=\"100%\">\n     *\n     * `partition` outputs an array with two Observables that partition the values\n     * from the source Observable through the given `predicate` function. The first\n     * Observable in that array emits source values for which the predicate argument\n     * returns true. The second Observable emits source values for which the\n     * predicate returns false. The first behaves like {@link filter} and the second\n     * behaves like {@link filter} with the predicate negated.\n     *\n     * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n     * var clicksOnDivs = parts[0];\n     * var clicksElsewhere = parts[1];\n     * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n     * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n     *\n     * @see {@link filter}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates each value emitted by the source Observable. If it returns `true`,\n     * the value is emitted on the first Observable in the returned array, if\n     * `false` the value is emitted on the second Observable in the array. The\n     * `index` parameter is the number `i` for the i-th source emission that has\n     * happened since the subscription, starting from the number `0`.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n     * with values that passed the predicate, and another with values that did not\n     * pass the predicate.\n     * @method partition\n     * @owner Observable\n     */\n    function partition(predicate, thisArg) {\n        return function (source) { return [\n            filter_1.filter(predicate, thisArg)(source),\n            filter_1.filter(not_1.not(predicate, thisArg))(source)\n        ]; };\n    }\n    exports.partition = partition;\n});\n\ndefine('rxjs/operators/pluck',[\"require\", \"exports\", \"./map\"], function (require, exports, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Maps each source value (an object) to its specified nested property.\n     *\n     * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n     * the nested properties of every emitted object.</span>\n     *\n     * <img src=\"./img/pluck.png\" width=\"100%\">\n     *\n     * Given a list of strings describing a path to an object property, retrieves\n     * the value of a specified nested property from all values in the source\n     * Observable. If a property can't be resolved, it will return `undefined` for\n     * that value.\n     *\n     * @example <caption>Map every click to the tagName of the clicked target element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var tagNames = clicks.pluck('target', 'tagName');\n     * tagNames.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     *\n     * @param {...string} properties The nested properties to pluck from each source\n     * value (an object).\n     * @return {Observable} A new Observable of property values from the source values.\n     * @method pluck\n     * @owner Observable\n     */\n    function pluck() {\n        var properties = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            properties[_i] = arguments[_i];\n        }\n        var length = properties.length;\n        if (length === 0) {\n            throw new Error('list of properties cannot be empty.');\n        }\n        return function (source) { return map_1.map(plucker(properties, length))(source); };\n    }\n    exports.pluck = pluck;\n    function plucker(props, length) {\n        var mapper = function (x) {\n            var currentProp = x;\n            for (var i = 0; i < length; i++) {\n                var p = currentProp[props[i]];\n                if (typeof p !== 'undefined') {\n                    currentProp = p;\n                }\n                else {\n                    return undefined;\n                }\n            }\n            return currentProp;\n        };\n        return mapper;\n    }\n});\n\ndefine('rxjs/operators/publish',[\"require\", \"exports\", \"../Subject\", \"./multicast\"], function (require, exports, Subject_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n     * before it begins emitting items to those Observers that have subscribed to it.\n     *\n     * <img src=\"./img/publish.png\" width=\"100%\">\n     *\n     * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n     * as needed, without causing multiple subscriptions to the source sequence.\n     * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n     * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n     * @method publish\n     * @owner Observable\n     */\n    function publish(selector) {\n        return selector ?\n            multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :\n            multicast_1.multicast(new Subject_1.Subject());\n    }\n    exports.publish = publish;\n});\n\ndefine('rxjs/operators/publishBehavior',[\"require\", \"exports\", \"../BehaviorSubject\", \"./multicast\"], function (require, exports, BehaviorSubject_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param value\n     * @return {ConnectableObservable<T>}\n     * @method publishBehavior\n     * @owner Observable\n     */\n    function publishBehavior(value) {\n        return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };\n    }\n    exports.publishBehavior = publishBehavior;\n});\n\ndefine('rxjs/operators/publishLast',[\"require\", \"exports\", \"../AsyncSubject\", \"./multicast\"], function (require, exports, AsyncSubject_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function publishLast() {\n        return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };\n    }\n    exports.publishLast = publishLast;\n});\n\ndefine('rxjs/operators/publishReplay',[\"require\", \"exports\", \"../ReplaySubject\", \"./multicast\"], function (require, exports, ReplaySubject_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n        if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n            scheduler = selectorOrScheduler;\n        }\n        var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n        var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n        return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };\n    }\n    exports.publishReplay = publishReplay;\n});\n\ndefine('rxjs/observable/race',[\"require\", \"exports\", \"tslib\", \"../util/isArray\", \"../observable/ArrayObservable\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, isArray_1, ArrayObservable_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function race() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        // if the only argument is an array, it was most likely called with\n        // `race([obs1, obs2, ...])`\n        if (observables.length === 1) {\n            if (isArray_1.isArray(observables[0])) {\n                observables = observables[0];\n            }\n            else {\n                return observables[0];\n            }\n        }\n        return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n    }\n    exports.race = race;\n    var RaceOperator = /** @class */ (function () {\n        function RaceOperator() {\n        }\n        RaceOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RaceSubscriber(subscriber));\n        };\n        return RaceOperator;\n    }());\n    exports.RaceOperator = RaceOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RaceSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RaceSubscriber, _super);\n        function RaceSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.hasFirst = false;\n            _this.observables = [];\n            _this.subscriptions = [];\n            return _this;\n        }\n        RaceSubscriber.prototype._next = function (observable) {\n            this.observables.push(observable);\n        };\n        RaceSubscriber.prototype._complete = function () {\n            var observables = this.observables;\n            var len = observables.length;\n            if (len === 0) {\n                this.destination.complete();\n            }\n            else {\n                for (var i = 0; i < len && !this.hasFirst; i++) {\n                    var observable = observables[i];\n                    var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                    if (this.subscriptions) {\n                        this.subscriptions.push(subscription);\n                    }\n                    this.add(subscription);\n                }\n                this.observables = null;\n            }\n        };\n        RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            if (!this.hasFirst) {\n                this.hasFirst = true;\n                for (var i = 0; i < this.subscriptions.length; i++) {\n                    if (i !== outerIndex) {\n                        var subscription = this.subscriptions[i];\n                        subscription.unsubscribe();\n                        this.remove(subscription);\n                    }\n                }\n                this.subscriptions = null;\n            }\n            this.destination.next(innerValue);\n        };\n        return RaceSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.RaceSubscriber = RaceSubscriber;\n});\n\ndefine('rxjs/operators/race',[\"require\", \"exports\", \"../util/isArray\", \"../observable/race\"], function (require, exports, isArray_1, race_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that mirrors the first source Observable to emit an item\n     * from the combination of this Observable and supplied Observables.\n     * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n     * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n     * @method race\n     * @owner Observable\n     */\n    function race() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return function raceOperatorFunction(source) {\n            // if the only argument is an array, it was most likely called with\n            // `pair([obs1, obs2, ...])`\n            if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n                observables = observables[0];\n            }\n            return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n        };\n    }\n    exports.race = race;\n});\n\ndefine('rxjs/operators/repeat',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../observable/EmptyObservable\"], function (require, exports, tslib_1, Subscriber_1, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n     *\n     * <img src=\"./img/repeat.png\" width=\"100%\">\n     *\n     * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n     * an empty Observable.\n     * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n     * count times.\n     * @method repeat\n     * @owner Observable\n     */\n    function repeat(count) {\n        if (count === void 0) { count = -1; }\n        return function (source) {\n            if (count === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            else if (count < 0) {\n                return source.lift(new RepeatOperator(-1, source));\n            }\n            else {\n                return source.lift(new RepeatOperator(count - 1, source));\n            }\n        };\n    }\n    exports.repeat = repeat;\n    var RepeatOperator = /** @class */ (function () {\n        function RepeatOperator(count, source) {\n            this.count = count;\n            this.source = source;\n        }\n        RepeatOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n        };\n        return RepeatOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RepeatSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RepeatSubscriber, _super);\n        function RepeatSubscriber(destination, count, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.count = count;\n            _this.source = source;\n            return _this;\n        }\n        RepeatSubscriber.prototype.complete = function () {\n            if (!this.isStopped) {\n                var _a = this, source = _a.source, count = _a.count;\n                if (count === 0) {\n                    return _super.prototype.complete.call(this);\n                }\n                else if (count > -1) {\n                    this.count = count - 1;\n                }\n                source.subscribe(this._unsubscribeAndRecycle());\n            }\n        };\n        return RepeatSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/repeatWhen',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n     * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n     * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n     * this method will resubscribe to the source Observable.\n     *\n     * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n     *\n     * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n     * which a user can `complete` or `error`, aborting the repetition.\n     * @return {Observable} The source Observable modified with repeat logic.\n     * @method repeatWhen\n     * @owner Observable\n     */\n    function repeatWhen(notifier) {\n        return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };\n    }\n    exports.repeatWhen = repeatWhen;\n    var RepeatWhenOperator = /** @class */ (function () {\n        function RepeatWhenOperator(notifier) {\n            this.notifier = notifier;\n        }\n        RepeatWhenOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n        };\n        return RepeatWhenOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RepeatWhenSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RepeatWhenSubscriber, _super);\n        function RepeatWhenSubscriber(destination, notifier, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.notifier = notifier;\n            _this.source = source;\n            _this.sourceIsBeingSubscribedTo = true;\n            return _this;\n        }\n        RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.sourceIsBeingSubscribedTo = true;\n            this.source.subscribe(this);\n        };\n        RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n            if (this.sourceIsBeingSubscribedTo === false) {\n                return _super.prototype.complete.call(this);\n            }\n        };\n        RepeatWhenSubscriber.prototype.complete = function () {\n            this.sourceIsBeingSubscribedTo = false;\n            if (!this.isStopped) {\n                if (!this.retries) {\n                    this.subscribeToRetries();\n                }\n                else if (this.retriesSubscription.closed) {\n                    return _super.prototype.complete.call(this);\n                }\n                this._unsubscribeAndRecycle();\n                this.notifications.next();\n            }\n        };\n        RepeatWhenSubscriber.prototype._unsubscribe = function () {\n            var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n            if (notifications) {\n                notifications.unsubscribe();\n                this.notifications = null;\n            }\n            if (retriesSubscription) {\n                retriesSubscription.unsubscribe();\n                this.retriesSubscription = null;\n            }\n            this.retries = null;\n        };\n        RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n            var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n            this.notifications = null;\n            this.retries = null;\n            this.retriesSubscription = null;\n            _super.prototype._unsubscribeAndRecycle.call(this);\n            this.notifications = notifications;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            return this;\n        };\n        RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n            this.notifications = new Subject_1.Subject();\n            var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n            if (retries === errorObject_1.errorObject) {\n                return _super.prototype.complete.call(this);\n            }\n            this.retries = retries;\n            this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n        };\n        return RepeatWhenSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/retry',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n     * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n     * as a number parameter) rather than propagating the `error` call.\n     *\n     * <img src=\"./img/retry.png\" width=\"100%\">\n     *\n     * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n     * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n     * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n     * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n     * @param {number} count - Number of retry attempts before failing.\n     * @return {Observable} The source Observable modified with the retry logic.\n     * @method retry\n     * @owner Observable\n     */\n    function retry(count) {\n        if (count === void 0) { count = -1; }\n        return function (source) { return source.lift(new RetryOperator(count, source)); };\n    }\n    exports.retry = retry;\n    var RetryOperator = /** @class */ (function () {\n        function RetryOperator(count, source) {\n            this.count = count;\n            this.source = source;\n        }\n        RetryOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n        };\n        return RetryOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RetrySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RetrySubscriber, _super);\n        function RetrySubscriber(destination, count, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.count = count;\n            _this.source = source;\n            return _this;\n        }\n        RetrySubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var _a = this, source = _a.source, count = _a.count;\n                if (count === 0) {\n                    return _super.prototype.error.call(this, err);\n                }\n                else if (count > -1) {\n                    this.count = count - 1;\n                }\n                source.subscribe(this._unsubscribeAndRecycle());\n            }\n        };\n        return RetrySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/retryWhen',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n     * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n     * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n     * subscription. Otherwise this method will resubscribe to the source Observable.\n     *\n     * <img src=\"./img/retryWhen.png\" width=\"100%\">\n     *\n     * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n     * user can `complete` or `error`, aborting the retry.\n     * @return {Observable} The source Observable modified with retry logic.\n     * @method retryWhen\n     * @owner Observable\n     */\n    function retryWhen(notifier) {\n        return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };\n    }\n    exports.retryWhen = retryWhen;\n    var RetryWhenOperator = /** @class */ (function () {\n        function RetryWhenOperator(notifier, source) {\n            this.notifier = notifier;\n            this.source = source;\n        }\n        RetryWhenOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n        };\n        return RetryWhenOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RetryWhenSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RetryWhenSubscriber, _super);\n        function RetryWhenSubscriber(destination, notifier, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.notifier = notifier;\n            _this.source = source;\n            return _this;\n        }\n        RetryWhenSubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var errors = this.errors;\n                var retries = this.retries;\n                var retriesSubscription = this.retriesSubscription;\n                if (!retries) {\n                    errors = new Subject_1.Subject();\n                    retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                    if (retries === errorObject_1.errorObject) {\n                        return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                    }\n                    retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n                }\n                else {\n                    this.errors = null;\n                    this.retriesSubscription = null;\n                }\n                this._unsubscribeAndRecycle();\n                this.errors = errors;\n                this.retries = retries;\n                this.retriesSubscription = retriesSubscription;\n                errors.next(err);\n            }\n        };\n        RetryWhenSubscriber.prototype._unsubscribe = function () {\n            var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n            if (errors) {\n                errors.unsubscribe();\n                this.errors = null;\n            }\n            if (retriesSubscription) {\n                retriesSubscription.unsubscribe();\n                this.retriesSubscription = null;\n            }\n            this.retries = null;\n        };\n        RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n            this.errors = null;\n            this.retries = null;\n            this.retriesSubscription = null;\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            this.source.subscribe(this);\n        };\n        return RetryWhenSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/sample',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the most recently emitted value from the source Observable whenever\n     * another Observable, the `notifier`, emits.\n     *\n     * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n     * the `notifier` Observable emits something.</span>\n     *\n     * <img src=\"./img/sample.png\" width=\"100%\">\n     *\n     * Whenever the `notifier` Observable emits a value or completes, `sample`\n     * looks at the source Observable and emits whichever value it has most recently\n     * emitted since the previous sampling, unless the source has not emitted\n     * anything since the previous sampling. The `notifier` is subscribed to as soon\n     * as the output Observable is subscribed.\n     *\n     * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n     * var seconds = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = seconds.sample(clicks);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounce}\n     * @see {@link sampleTime}\n     * @see {@link throttle}\n     *\n     * @param {Observable<any>} notifier The Observable to use for sampling the\n     * source Observable.\n     * @return {Observable<T>} An Observable that emits the results of sampling the\n     * values emitted by the source Observable whenever the notifier Observable\n     * emits value or completes.\n     * @method sample\n     * @owner Observable\n     */\n    function sample(notifier) {\n        return function (source) { return source.lift(new SampleOperator(notifier)); };\n    }\n    exports.sample = sample;\n    var SampleOperator = /** @class */ (function () {\n        function SampleOperator(notifier) {\n            this.notifier = notifier;\n        }\n        SampleOperator.prototype.call = function (subscriber, source) {\n            var sampleSubscriber = new SampleSubscriber(subscriber);\n            var subscription = source.subscribe(sampleSubscriber);\n            subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n            return subscription;\n        };\n        return SampleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SampleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SampleSubscriber, _super);\n        function SampleSubscriber() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.hasValue = false;\n            return _this;\n        }\n        SampleSubscriber.prototype._next = function (value) {\n            this.value = value;\n            this.hasValue = true;\n        };\n        SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.emitValue();\n        };\n        SampleSubscriber.prototype.notifyComplete = function () {\n            this.emitValue();\n        };\n        SampleSubscriber.prototype.emitValue = function () {\n            if (this.hasValue) {\n                this.hasValue = false;\n                this.destination.next(this.value);\n            }\n        };\n        return SampleSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/sampleTime',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../scheduler/async\"], function (require, exports, tslib_1, Subscriber_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the most recently emitted value from the source Observable within\n     * periodic time intervals.\n     *\n     * <span class=\"informal\">Samples the source Observable at periodic time\n     * intervals, emitting what it samples.</span>\n     *\n     * <img src=\"./img/sampleTime.png\" width=\"100%\">\n     *\n     * `sampleTime` periodically looks at the source Observable and emits whichever\n     * value it has most recently emitted since the previous sampling, unless the\n     * source has not emitted anything since the previous sampling. The sampling\n     * happens periodically in time every `period` milliseconds (or the time unit\n     * defined by the optional `scheduler` argument). The sampling starts as soon as\n     * the output Observable is subscribed.\n     *\n     * @example <caption>Every second, emit the most recent click at most once</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.sampleTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sample}\n     * @see {@link throttleTime}\n     *\n     * @param {number} period The sampling period expressed in milliseconds or the\n     * time unit determined internally by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the sampling.\n     * @return {Observable<T>} An Observable that emits the results of sampling the\n     * values emitted by the source Observable at the specified time interval.\n     * @method sampleTime\n     * @owner Observable\n     */\n    function sampleTime(period, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };\n    }\n    exports.sampleTime = sampleTime;\n    var SampleTimeOperator = /** @class */ (function () {\n        function SampleTimeOperator(period, scheduler) {\n            this.period = period;\n            this.scheduler = scheduler;\n        }\n        SampleTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n        };\n        return SampleTimeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SampleTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SampleTimeSubscriber, _super);\n        function SampleTimeSubscriber(destination, period, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.period = period;\n            _this.scheduler = scheduler;\n            _this.hasValue = false;\n            _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));\n            return _this;\n        }\n        SampleTimeSubscriber.prototype._next = function (value) {\n            this.lastValue = value;\n            this.hasValue = true;\n        };\n        SampleTimeSubscriber.prototype.notifyNext = function () {\n            if (this.hasValue) {\n                this.hasValue = false;\n                this.destination.next(this.lastValue);\n            }\n        };\n        return SampleTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchNotification(state) {\n        var subscriber = state.subscriber, period = state.period;\n        subscriber.notifyNext();\n        this.schedule(state, period);\n    }\n});\n\ndefine('rxjs/operators/sequenceEqual',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/tryCatch\", \"../util/errorObject\"], function (require, exports, tslib_1, Subscriber_1, tryCatch_1, errorObject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Compares all values of two observables in sequence using an optional comparor function\n     * and returns an observable of a single boolean value representing whether or not the two sequences\n     * are equal.\n     *\n     * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n     *\n     * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n     *\n     * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n     * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n     * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n     * observables completes, the operator will wait for the other observable to complete; If the other\n     * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n     * completes or emits after the other complets, the returned observable will never complete.\n     *\n     * @example <caption>figure out if the Konami code matches</caption>\n     * var code = Rx.Observable.from([\n     *  \"ArrowUp\",\n     *  \"ArrowUp\",\n     *  \"ArrowDown\",\n     *  \"ArrowDown\",\n     *  \"ArrowLeft\",\n     *  \"ArrowRight\",\n     *  \"ArrowLeft\",\n     *  \"ArrowRight\",\n     *  \"KeyB\",\n     *  \"KeyA\",\n     *  \"Enter\" // no start key, clearly.\n     * ]);\n     *\n     * var keys = Rx.Observable.fromEvent(document, 'keyup')\n     *  .map(e => e.code);\n     * var matches = keys.bufferCount(11, 1)\n     *  .mergeMap(\n     *    last11 =>\n     *      Rx.Observable.from(last11)\n     *        .sequenceEqual(code)\n     *   );\n     * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n     *\n     * @see {@link combineLatest}\n     * @see {@link zip}\n     * @see {@link withLatestFrom}\n     *\n     * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n     * @param {function} [comparor] An optional function to compare each value pair\n     * @return {Observable} An Observable of a single boolean value representing whether or not\n     * the values emitted by both observables were equal in sequence.\n     * @method sequenceEqual\n     * @owner Observable\n     */\n    function sequenceEqual(compareTo, comparor) {\n        return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };\n    }\n    exports.sequenceEqual = sequenceEqual;\n    var SequenceEqualOperator = /** @class */ (function () {\n        function SequenceEqualOperator(compareTo, comparor) {\n            this.compareTo = compareTo;\n            this.comparor = comparor;\n        }\n        SequenceEqualOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n        };\n        return SequenceEqualOperator;\n    }());\n    exports.SequenceEqualOperator = SequenceEqualOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SequenceEqualSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SequenceEqualSubscriber, _super);\n        function SequenceEqualSubscriber(destination, compareTo, comparor) {\n            var _this = _super.call(this, destination) || this;\n            _this.compareTo = compareTo;\n            _this.comparor = comparor;\n            _this._a = [];\n            _this._b = [];\n            _this._oneComplete = false;\n            _this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));\n            return _this;\n        }\n        SequenceEqualSubscriber.prototype._next = function (value) {\n            if (this._oneComplete && this._b.length === 0) {\n                this.emit(false);\n            }\n            else {\n                this._a.push(value);\n                this.checkValues();\n            }\n        };\n        SequenceEqualSubscriber.prototype._complete = function () {\n            if (this._oneComplete) {\n                this.emit(this._a.length === 0 && this._b.length === 0);\n            }\n            else {\n                this._oneComplete = true;\n            }\n        };\n        SequenceEqualSubscriber.prototype.checkValues = function () {\n            var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n            while (_a.length > 0 && _b.length > 0) {\n                var a = _a.shift();\n                var b = _b.shift();\n                var areEqual = false;\n                if (comparor) {\n                    areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                    if (areEqual === errorObject_1.errorObject) {\n                        this.destination.error(errorObject_1.errorObject.e);\n                    }\n                }\n                else {\n                    areEqual = a === b;\n                }\n                if (!areEqual) {\n                    this.emit(false);\n                }\n            }\n        };\n        SequenceEqualSubscriber.prototype.emit = function (value) {\n            var destination = this.destination;\n            destination.next(value);\n            destination.complete();\n        };\n        SequenceEqualSubscriber.prototype.nextB = function (value) {\n            if (this._oneComplete && this._a.length === 0) {\n                this.emit(false);\n            }\n            else {\n                this._b.push(value);\n                this.checkValues();\n            }\n        };\n        return SequenceEqualSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.SequenceEqualSubscriber = SequenceEqualSubscriber;\n    var SequenceEqualCompareToSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SequenceEqualCompareToSubscriber, _super);\n        function SequenceEqualCompareToSubscriber(destination, parent) {\n            var _this = _super.call(this, destination) || this;\n            _this.parent = parent;\n            return _this;\n        }\n        SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n            this.parent.nextB(value);\n        };\n        SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n            this.parent.error(err);\n        };\n        SequenceEqualCompareToSubscriber.prototype._complete = function () {\n            this.parent._complete();\n        };\n        return SequenceEqualCompareToSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/share',[\"require\", \"exports\", \"./multicast\", \"./refCount\", \"../Subject\"], function (require, exports, multicast_1, refCount_1, Subject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function shareSubjectFactory() {\n        return new Subject_1.Subject();\n    }\n    /**\n     * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n     * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n     * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n     * This is an alias for .multicast(() => new Subject()).refCount().\n     *\n     * <img src=\"./img/share.png\" width=\"100%\">\n     *\n     * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n     * @method share\n     * @owner Observable\n     */\n    function share() {\n        return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };\n    }\n    exports.share = share;\n    ;\n});\n\ndefine('rxjs/operators/shareReplay',[\"require\", \"exports\", \"../ReplaySubject\"], function (require, exports, ReplaySubject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @method shareReplay\n     * @owner Observable\n     */\n    function shareReplay(bufferSize, windowTime, scheduler) {\n        return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };\n    }\n    exports.shareReplay = shareReplay;\n    function shareReplayOperator(bufferSize, windowTime, scheduler) {\n        var subject;\n        var refCount = 0;\n        var subscription;\n        var hasError = false;\n        var isComplete = false;\n        return function shareReplayOperation(source) {\n            refCount++;\n            if (!subject || hasError) {\n                hasError = false;\n                subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n                subscription = source.subscribe({\n                    next: function (value) { subject.next(value); },\n                    error: function (err) {\n                        hasError = true;\n                        subject.error(err);\n                    },\n                    complete: function () {\n                        isComplete = true;\n                        subject.complete();\n                    },\n                });\n            }\n            var innerSub = subject.subscribe(this);\n            return function () {\n                refCount--;\n                innerSub.unsubscribe();\n                if (subscription && refCount === 0 && isComplete) {\n                    subscription.unsubscribe();\n                }\n            };\n        };\n    }\n    ;\n});\n\ndefine('rxjs/operators/single',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/EmptyError\"], function (require, exports, tslib_1, Subscriber_1, EmptyError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n     * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n     * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n     *\n     * <img src=\"./img/single.png\" width=\"100%\">\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n     * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n     * the predicate.\n     .\n     * @method single\n     * @owner Observable\n     */\n    function single(predicate) {\n        return function (source) { return source.lift(new SingleOperator(predicate, source)); };\n    }\n    exports.single = single;\n    var SingleOperator = /** @class */ (function () {\n        function SingleOperator(predicate, source) {\n            this.predicate = predicate;\n            this.source = source;\n        }\n        SingleOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n        };\n        return SingleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SingleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SingleSubscriber, _super);\n        function SingleSubscriber(destination, predicate, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.source = source;\n            _this.seenValue = false;\n            _this.index = 0;\n            return _this;\n        }\n        SingleSubscriber.prototype.applySingleValue = function (value) {\n            if (this.seenValue) {\n                this.destination.error('Sequence contains more than one element');\n            }\n            else {\n                this.seenValue = true;\n                this.singleValue = value;\n            }\n        };\n        SingleSubscriber.prototype._next = function (value) {\n            var index = this.index++;\n            if (this.predicate) {\n                this.tryNext(value, index);\n            }\n            else {\n                this.applySingleValue(value);\n            }\n        };\n        SingleSubscriber.prototype.tryNext = function (value, index) {\n            try {\n                if (this.predicate(value, index, this.source)) {\n                    this.applySingleValue(value);\n                }\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        SingleSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            if (this.index > 0) {\n                destination.next(this.seenValue ? this.singleValue : undefined);\n                destination.complete();\n            }\n            else {\n                destination.error(new EmptyError_1.EmptyError);\n            }\n        };\n        return SingleSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/skip',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips the first `count` items emitted by the source Observable.\n     *\n     * <img src=\"./img/skip.png\" width=\"100%\">\n     *\n     * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n     * @return {Observable} An Observable that skips values emitted by the source Observable.\n     *\n     * @method skip\n     * @owner Observable\n     */\n    function skip(count) {\n        return function (source) { return source.lift(new SkipOperator(count)); };\n    }\n    exports.skip = skip;\n    var SkipOperator = /** @class */ (function () {\n        function SkipOperator(total) {\n            this.total = total;\n        }\n        SkipOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SkipSubscriber(subscriber, this.total));\n        };\n        return SkipOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SkipSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SkipSubscriber, _super);\n        function SkipSubscriber(destination, total) {\n            var _this = _super.call(this, destination) || this;\n            _this.total = total;\n            _this.count = 0;\n            return _this;\n        }\n        SkipSubscriber.prototype._next = function (x) {\n            if (++this.count > this.total) {\n                this.destination.next(x);\n            }\n        };\n        return SkipSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/skipLast',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/ArgumentOutOfRangeError\"], function (require, exports, tslib_1, Subscriber_1, ArgumentOutOfRangeError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Skip the last `count` values emitted by the source Observable.\n     *\n     * <img src=\"./img/skipLast.png\" width=\"100%\">\n     *\n     * `skipLast` returns an Observable that accumulates a queue with a length\n     * enough to store the first `count` values. As more values are received,\n     * values are taken from the front of the queue and produced on the result\n     * sequence. This causes values to be delayed.\n     *\n     * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n     * var many = Rx.Observable.range(1, 5);\n     * var skipLastTwo = many.skipLast(2);\n     * skipLastTwo.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // 1 2 3\n     *\n     * @see {@link skip}\n     * @see {@link skipUntil}\n     * @see {@link skipWhile}\n     * @see {@link take}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n     * ArgumentOutOrRangeError if `i < 0`.\n     *\n     * @param {number} count Number of elements to skip from the end of the source Observable.\n     * @returns {Observable<T>} An Observable that skips the last count values\n     * emitted by the source Observable.\n     * @method skipLast\n     * @owner Observable\n     */\n    function skipLast(count) {\n        return function (source) { return source.lift(new SkipLastOperator(count)); };\n    }\n    exports.skipLast = skipLast;\n    var SkipLastOperator = /** @class */ (function () {\n        function SkipLastOperator(_skipCount) {\n            this._skipCount = _skipCount;\n            if (this._skipCount < 0) {\n                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n            }\n        }\n        SkipLastOperator.prototype.call = function (subscriber, source) {\n            if (this._skipCount === 0) {\n                // If we don't want to skip any values then just subscribe\n                // to Subscriber without any further logic.\n                return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n            }\n            else {\n                return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n            }\n        };\n        return SkipLastOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SkipLastSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SkipLastSubscriber, _super);\n        function SkipLastSubscriber(destination, _skipCount) {\n            var _this = _super.call(this, destination) || this;\n            _this._skipCount = _skipCount;\n            _this._count = 0;\n            _this._ring = new Array(_skipCount);\n            return _this;\n        }\n        SkipLastSubscriber.prototype._next = function (value) {\n            var skipCount = this._skipCount;\n            var count = this._count++;\n            if (count < skipCount) {\n                this._ring[count] = value;\n            }\n            else {\n                var currentIndex = count % skipCount;\n                var ring = this._ring;\n                var oldValue = ring[currentIndex];\n                ring[currentIndex] = value;\n                this.destination.next(oldValue);\n            }\n        };\n        return SkipLastSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/skipUntil',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n     *\n     * <img src=\"./img/skipUntil.png\" width=\"100%\">\n     *\n     * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n     * be mirrored by the resulting Observable.\n     * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n     * an item, then emits the remaining items.\n     * @method skipUntil\n     * @owner Observable\n     */\n    function skipUntil(notifier) {\n        return function (source) { return source.lift(new SkipUntilOperator(notifier)); };\n    }\n    exports.skipUntil = skipUntil;\n    var SkipUntilOperator = /** @class */ (function () {\n        function SkipUntilOperator(notifier) {\n            this.notifier = notifier;\n        }\n        SkipUntilOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n        };\n        return SkipUntilOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SkipUntilSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SkipUntilSubscriber, _super);\n        function SkipUntilSubscriber(destination, notifier) {\n            var _this = _super.call(this, destination) || this;\n            _this.hasValue = false;\n            _this.isInnerStopped = false;\n            _this.add(subscribeToResult_1.subscribeToResult(_this, notifier));\n            return _this;\n        }\n        SkipUntilSubscriber.prototype._next = function (value) {\n            if (this.hasValue) {\n                _super.prototype._next.call(this, value);\n            }\n        };\n        SkipUntilSubscriber.prototype._complete = function () {\n            if (this.isInnerStopped) {\n                _super.prototype._complete.call(this);\n            }\n            else {\n                this.unsubscribe();\n            }\n        };\n        SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.hasValue = true;\n        };\n        SkipUntilSubscriber.prototype.notifyComplete = function () {\n            this.isInnerStopped = true;\n            if (this.isStopped) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        return SkipUntilSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/skipWhile',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n     * true, but emits all further source items as soon as the condition becomes false.\n     *\n     * <img src=\"./img/skipWhile.png\" width=\"100%\">\n     *\n     * @param {Function} predicate - A function to test each item emitted from the source Observable.\n     * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n     * specified predicate becomes false.\n     * @method skipWhile\n     * @owner Observable\n     */\n    function skipWhile(predicate) {\n        return function (source) { return source.lift(new SkipWhileOperator(predicate)); };\n    }\n    exports.skipWhile = skipWhile;\n    var SkipWhileOperator = /** @class */ (function () {\n        function SkipWhileOperator(predicate) {\n            this.predicate = predicate;\n        }\n        SkipWhileOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n        };\n        return SkipWhileOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SkipWhileSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SkipWhileSubscriber, _super);\n        function SkipWhileSubscriber(destination, predicate) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.skipping = true;\n            _this.index = 0;\n            return _this;\n        }\n        SkipWhileSubscriber.prototype._next = function (value) {\n            var destination = this.destination;\n            if (this.skipping) {\n                this.tryCallPredicate(value);\n            }\n            if (!this.skipping) {\n                destination.next(value);\n            }\n        };\n        SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n            try {\n                var result = this.predicate(value, this.index++);\n                this.skipping = Boolean(result);\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        return SkipWhileSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/startWith',[\"require\", \"exports\", \"../observable/ArrayObservable\", \"../observable/ScalarObservable\", \"../observable/EmptyObservable\", \"../observable/concat\", \"../util/isScheduler\"], function (require, exports, ArrayObservable_1, ScalarObservable_1, EmptyObservable_1, concat_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits the items you specify as arguments before it begins to emit\n     * items emitted by the source Observable.\n     *\n     * <img src=\"./img/startWith.png\" width=\"100%\">\n     *\n     * @param {...T} values - Items you want the modified Observable to emit first.\n     * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n     * emitted by the source Observable.\n     * @method startWith\n     * @owner Observable\n     */\n    function startWith() {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i] = arguments[_i];\n        }\n        return function (source) {\n            var scheduler = array[array.length - 1];\n            if (isScheduler_1.isScheduler(scheduler)) {\n                array.pop();\n            }\n            else {\n                scheduler = null;\n            }\n            var len = array.length;\n            if (len === 1) {\n                return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n            }\n            else if (len > 1) {\n                return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n            }\n            else {\n                return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n            }\n        };\n    }\n    exports.startWith = startWith;\n});\n\ndefine('rxjs/operators/switchMap',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable, emitting values only from the most recently projected Observable.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link switch}.</span>\n     *\n     * <img src=\"./img/switchMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. Each time it observes one of these\n     * inner Observables, the output Observable begins emitting the items emitted by\n     * that inner Observable. When a new inner Observable is emitted, `switchMap`\n     * stops emitting items from the earlier-emitted inner Observable and begins\n     * emitting items from the new one. It continues to behave like this for\n     * subsequent inner Observables.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaustMap}\n     * @see {@link mergeMap}\n     * @see {@link switch}\n     * @see {@link switchMapTo}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and taking only the values from the most recently\n     * projected inner Observable.\n     * @method switchMap\n     * @owner Observable\n     */\n    function switchMap(project, resultSelector) {\n        return function switchMapOperatorFunction(source) {\n            return source.lift(new SwitchMapOperator(project, resultSelector));\n        };\n    }\n    exports.switchMap = switchMap;\n    var SwitchMapOperator = /** @class */ (function () {\n        function SwitchMapOperator(project, resultSelector) {\n            this.project = project;\n            this.resultSelector = resultSelector;\n        }\n        SwitchMapOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n        };\n        return SwitchMapOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SwitchMapSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SwitchMapSubscriber, _super);\n        function SwitchMapSubscriber(destination, project, resultSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.resultSelector = resultSelector;\n            _this.index = 0;\n            return _this;\n        }\n        SwitchMapSubscriber.prototype._next = function (value) {\n            var result;\n            var index = this.index++;\n            try {\n                result = this.project(value, index);\n            }\n            catch (error) {\n                this.destination.error(error);\n                return;\n            }\n            this._innerSub(result, value, index);\n        };\n        SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n            var innerSubscription = this.innerSubscription;\n            if (innerSubscription) {\n                innerSubscription.unsubscribe();\n            }\n            this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n        };\n        SwitchMapSubscriber.prototype._complete = function () {\n            var innerSubscription = this.innerSubscription;\n            if (!innerSubscription || innerSubscription.closed) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        SwitchMapSubscriber.prototype._unsubscribe = function () {\n            this.innerSubscription = null;\n        };\n        SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.remove(innerSub);\n            this.innerSubscription = null;\n            if (this.isStopped) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            if (this.resultSelector) {\n                this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                this.destination.next(innerValue);\n            }\n        };\n        SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var result;\n            try {\n                result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return SwitchMapSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/switchAll',[\"require\", \"exports\", \"./switchMap\", \"../util/identity\"], function (require, exports, switchMap_1, identity_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function switchAll() {\n        return switchMap_1.switchMap(identity_1.identity);\n    }\n    exports.switchAll = switchAll;\n});\n\ndefine('rxjs/operators/switchMapTo',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is flattened multiple\n     * times with {@link switch} in the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n     * always to the same inner Observable.</span>\n     *\n     * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then flattens those resulting Observables into one\n     * single Observable, which is the output Observable. The output Observables\n     * emits values only from the most recently emitted instance of\n     * `innerObservable`.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMapTo}\n     * @see {@link switch}\n     * @see {@link switchMap}\n     * @see {@link mergeMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits items from the given\n     * `innerObservable` (and optionally transformed through `resultSelector`) every\n     * time a value is emitted on the source Observable, and taking only the values\n     * from the most recently projected inner Observable.\n     * @method switchMapTo\n     * @owner Observable\n     */\n    function switchMapTo(innerObservable, resultSelector) {\n        return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };\n    }\n    exports.switchMapTo = switchMapTo;\n    var SwitchMapToOperator = /** @class */ (function () {\n        function SwitchMapToOperator(observable, resultSelector) {\n            this.observable = observable;\n            this.resultSelector = resultSelector;\n        }\n        SwitchMapToOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n        };\n        return SwitchMapToOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SwitchMapToSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SwitchMapToSubscriber, _super);\n        function SwitchMapToSubscriber(destination, inner, resultSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.inner = inner;\n            _this.resultSelector = resultSelector;\n            _this.index = 0;\n            return _this;\n        }\n        SwitchMapToSubscriber.prototype._next = function (value) {\n            var innerSubscription = this.innerSubscription;\n            if (innerSubscription) {\n                innerSubscription.unsubscribe();\n            }\n            this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n        };\n        SwitchMapToSubscriber.prototype._complete = function () {\n            var innerSubscription = this.innerSubscription;\n            if (!innerSubscription || innerSubscription.closed) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        SwitchMapToSubscriber.prototype._unsubscribe = function () {\n            this.innerSubscription = null;\n        };\n        SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.remove(innerSub);\n            this.innerSubscription = null;\n            if (this.isStopped) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            if (resultSelector) {\n                this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                destination.next(innerValue);\n            }\n        };\n        SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            var result;\n            try {\n                result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            catch (err) {\n                destination.error(err);\n                return;\n            }\n            destination.next(result);\n        };\n        return SwitchMapToSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/take',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/ArgumentOutOfRangeError\", \"../observable/EmptyObservable\"], function (require, exports, tslib_1, Subscriber_1, ArgumentOutOfRangeError_1, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first `count` values emitted by the source Observable.\n     *\n     * <span class=\"informal\">Takes the first `count` values from the source, then\n     * completes.</span>\n     *\n     * <img src=\"./img/take.png\" width=\"100%\">\n     *\n     * `take` returns an Observable that emits only the first `count` values emitted\n     * by the source Observable. If the source emits fewer than `count` values then\n     * all of its values are emitted. After that, it completes, regardless if the\n     * source completes.\n     *\n     * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var five = interval.take(5);\n     * five.subscribe(x => console.log(x));\n     *\n     * @see {@link takeLast}\n     * @see {@link takeUntil}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n     *\n     * @param {number} count The maximum number of `next` values to emit.\n     * @return {Observable<T>} An Observable that emits only the first `count`\n     * values emitted by the source Observable, or all of the values from the source\n     * if the source emits fewer than `count` values.\n     * @method take\n     * @owner Observable\n     */\n    function take(count) {\n        return function (source) {\n            if (count === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            else {\n                return source.lift(new TakeOperator(count));\n            }\n        };\n    }\n    exports.take = take;\n    var TakeOperator = /** @class */ (function () {\n        function TakeOperator(total) {\n            this.total = total;\n            if (this.total < 0) {\n                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n            }\n        }\n        TakeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TakeSubscriber(subscriber, this.total));\n        };\n        return TakeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TakeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TakeSubscriber, _super);\n        function TakeSubscriber(destination, total) {\n            var _this = _super.call(this, destination) || this;\n            _this.total = total;\n            _this.count = 0;\n            return _this;\n        }\n        TakeSubscriber.prototype._next = function (value) {\n            var total = this.total;\n            var count = ++this.count;\n            if (count <= total) {\n                this.destination.next(value);\n                if (count === total) {\n                    this.destination.complete();\n                    this.unsubscribe();\n                }\n            }\n        };\n        return TakeSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/takeUntil',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the values emitted by the source Observable until a `notifier`\n     * Observable emits a value.\n     *\n     * <span class=\"informal\">Lets values pass until a second Observable,\n     * `notifier`, emits something. Then, it completes.</span>\n     *\n     * <img src=\"./img/takeUntil.png\" width=\"100%\">\n     *\n     * `takeUntil` subscribes and begins mirroring the source Observable. It also\n     * monitors a second Observable, `notifier` that you provide. If the `notifier`\n     * emits a value or a complete notification, the output Observable stops\n     * mirroring the source Observable and completes.\n     *\n     * @example <caption>Tick every second until the first click happens</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = interval.takeUntil(clicks);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeLast}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @param {Observable} notifier The Observable whose first emitted value will\n     * cause the output Observable of `takeUntil` to stop emitting values from the\n     * source Observable.\n     * @return {Observable<T>} An Observable that emits the values from the source\n     * Observable until such time as `notifier` emits its first value.\n     * @method takeUntil\n     * @owner Observable\n     */\n    function takeUntil(notifier) {\n        return function (source) { return source.lift(new TakeUntilOperator(notifier)); };\n    }\n    exports.takeUntil = takeUntil;\n    var TakeUntilOperator = /** @class */ (function () {\n        function TakeUntilOperator(notifier) {\n            this.notifier = notifier;\n        }\n        TakeUntilOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n        };\n        return TakeUntilOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TakeUntilSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TakeUntilSubscriber, _super);\n        function TakeUntilSubscriber(destination, notifier) {\n            var _this = _super.call(this, destination) || this;\n            _this.notifier = notifier;\n            _this.add(subscribeToResult_1.subscribeToResult(_this, notifier));\n            return _this;\n        }\n        TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.complete();\n        };\n        TakeUntilSubscriber.prototype.notifyComplete = function () {\n            // noop\n        };\n        return TakeUntilSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/takeWhile',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits values emitted by the source Observable so long as each value satisfies\n     * the given `predicate`, and then completes as soon as this `predicate` is not\n     * satisfied.\n     *\n     * <span class=\"informal\">Takes values from the source only while they pass the\n     * condition given. When the first value does not satisfy, it completes.</span>\n     *\n     * <img src=\"./img/takeWhile.png\" width=\"100%\">\n     *\n     * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n     * emitted on the source is given to the `predicate` function which returns a\n     * boolean, representing a condition to be satisfied by the source values. The\n     * output Observable emits the source values until such time as the `predicate`\n     * returns false, at which point `takeWhile` stops mirroring the source\n     * Observable and completes the output Observable.\n     *\n     * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.takeWhile(ev => ev.clientX > 200);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeLast}\n     * @see {@link takeUntil}\n     * @see {@link skip}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates a value emitted by the source Observable and returns a boolean.\n     * Also takes the (zero-based) index as the second argument.\n     * @return {Observable<T>} An Observable that emits the values from the source\n     * Observable so long as each value satisfies the condition defined by the\n     * `predicate`, then completes.\n     * @method takeWhile\n     * @owner Observable\n     */\n    function takeWhile(predicate) {\n        return function (source) { return source.lift(new TakeWhileOperator(predicate)); };\n    }\n    exports.takeWhile = takeWhile;\n    var TakeWhileOperator = /** @class */ (function () {\n        function TakeWhileOperator(predicate) {\n            this.predicate = predicate;\n        }\n        TakeWhileOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n        };\n        return TakeWhileOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TakeWhileSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TakeWhileSubscriber, _super);\n        function TakeWhileSubscriber(destination, predicate) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.index = 0;\n            return _this;\n        }\n        TakeWhileSubscriber.prototype._next = function (value) {\n            var destination = this.destination;\n            var result;\n            try {\n                result = this.predicate(value, this.index++);\n            }\n            catch (err) {\n                destination.error(err);\n                return;\n            }\n            this.nextOrComplete(value, result);\n        };\n        TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n            var destination = this.destination;\n            if (Boolean(predicateResult)) {\n                destination.next(value);\n            }\n            else {\n                destination.complete();\n            }\n        };\n        return TakeWhileSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/tap',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Perform a side effect for every emission on the source Observable, but return\n     * an Observable that is identical to the source.\n     *\n     * <span class=\"informal\">Intercepts each emission on the source and runs a\n     * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n     *\n     * <img src=\"./img/do.png\" width=\"100%\">\n     *\n     * Returns a mirrored Observable of the source Observable, but modified so that\n     * the provided Observer is called to perform a side effect for every value,\n     * error, and completion emitted by the source. Any errors that are thrown in\n     * the aforementioned Observer or handlers are safely sent down the error path\n     * of the output Observable.\n     *\n     * This operator is useful for debugging your Observables for the correct values\n     * or performing other side effects.\n     *\n     * Note: this is different to a `subscribe` on the Observable. If the Observable\n     * returned by `do` is not subscribed, the side effects specified by the\n     * Observer will never happen. `do` therefore simply spies on existing\n     * execution, it does not trigger an execution to happen like `subscribe` does.\n     *\n     * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var positions = clicks\n     *   .do(ev => console.log(ev))\n     *   .map(ev => ev.clientX);\n     * positions.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     * @see {@link subscribe}\n     *\n     * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n     * callback for `next`.\n     * @param {function} [error] Callback for errors in the source.\n     * @param {function} [complete] Callback for the completion of the source.\n     * @return {Observable} An Observable identical to the source, but runs the\n     * specified Observer or callback(s) for each item.\n     * @name tap\n     */\n    function tap(nextOrObserver, error, complete) {\n        return function tapOperatorFunction(source) {\n            return source.lift(new DoOperator(nextOrObserver, error, complete));\n        };\n    }\n    exports.tap = tap;\n    var DoOperator = /** @class */ (function () {\n        function DoOperator(nextOrObserver, error, complete) {\n            this.nextOrObserver = nextOrObserver;\n            this.error = error;\n            this.complete = complete;\n        }\n        DoOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n        };\n        return DoOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DoSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DoSubscriber, _super);\n        function DoSubscriber(destination, nextOrObserver, error, complete) {\n            var _this = _super.call(this, destination) || this;\n            var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n            safeSubscriber.syncErrorThrowable = true;\n            _this.add(safeSubscriber);\n            _this.safeSubscriber = safeSubscriber;\n            return _this;\n        }\n        DoSubscriber.prototype._next = function (value) {\n            var safeSubscriber = this.safeSubscriber;\n            safeSubscriber.next(value);\n            if (safeSubscriber.syncErrorThrown) {\n                this.destination.error(safeSubscriber.syncErrorValue);\n            }\n            else {\n                this.destination.next(value);\n            }\n        };\n        DoSubscriber.prototype._error = function (err) {\n            var safeSubscriber = this.safeSubscriber;\n            safeSubscriber.error(err);\n            if (safeSubscriber.syncErrorThrown) {\n                this.destination.error(safeSubscriber.syncErrorValue);\n            }\n            else {\n                this.destination.error(err);\n            }\n        };\n        DoSubscriber.prototype._complete = function () {\n            var safeSubscriber = this.safeSubscriber;\n            safeSubscriber.complete();\n            if (safeSubscriber.syncErrorThrown) {\n                this.destination.error(safeSubscriber.syncErrorValue);\n            }\n            else {\n                this.destination.complete();\n            }\n        };\n        return DoSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/throttle',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.defaultThrottleConfig = {\n        leading: true,\n        trailing: false\n    };\n    /**\n     * Emits a value from the source Observable, then ignores subsequent source\n     * values for a duration determined by another Observable, then repeats this\n     * process.\n     *\n     * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n     * duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/throttle.png\" width=\"100%\">\n     *\n     * `throttle` emits the source Observable values on the output Observable\n     * when its internal timer is disabled, and ignores source values when the timer\n     * is enabled. Initially, the timer is disabled. As soon as the first source\n     * value arrives, it is forwarded to the output Observable, and then the timer\n     * is enabled by calling the `durationSelector` function with the source value,\n     * which returns the \"duration\" Observable. When the duration Observable emits a\n     * value or completes, the timer is disabled, and this process repeats for the\n     * next source value.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounce}\n     * @see {@link delayWhen}\n     * @see {@link sample}\n     * @see {@link throttleTime}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the silencing\n     * duration for each source value, returned as an Observable or a Promise.\n     * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n     * to `{ leading: true, trailing: false }`.\n     * @return {Observable<T>} An Observable that performs the throttle operation to\n     * limit the rate of emissions from the source.\n     * @method throttle\n     * @owner Observable\n     */\n    function throttle(durationSelector, config) {\n        if (config === void 0) { config = exports.defaultThrottleConfig; }\n        return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };\n    }\n    exports.throttle = throttle;\n    var ThrottleOperator = /** @class */ (function () {\n        function ThrottleOperator(durationSelector, leading, trailing) {\n            this.durationSelector = durationSelector;\n            this.leading = leading;\n            this.trailing = trailing;\n        }\n        ThrottleOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));\n        };\n        return ThrottleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ThrottleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ThrottleSubscriber, _super);\n        function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.durationSelector = durationSelector;\n            _this._leading = _leading;\n            _this._trailing = _trailing;\n            _this._hasTrailingValue = false;\n            return _this;\n        }\n        ThrottleSubscriber.prototype._next = function (value) {\n            if (this.throttled) {\n                if (this._trailing) {\n                    this._hasTrailingValue = true;\n                    this._trailingValue = value;\n                }\n            }\n            else {\n                var duration = this.tryDurationSelector(value);\n                if (duration) {\n                    this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));\n                }\n                if (this._leading) {\n                    this.destination.next(value);\n                    if (this._trailing) {\n                        this._hasTrailingValue = true;\n                        this._trailingValue = value;\n                    }\n                }\n            }\n        };\n        ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n            try {\n                return this.durationSelector(value);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return null;\n            }\n        };\n        ThrottleSubscriber.prototype._unsubscribe = function () {\n            var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;\n            this._trailingValue = null;\n            this._hasTrailingValue = false;\n            if (throttled) {\n                this.remove(throttled);\n                this.throttled = null;\n                throttled.unsubscribe();\n            }\n        };\n        ThrottleSubscriber.prototype._sendTrailing = function () {\n            var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;\n            if (throttled && _trailing && _hasTrailingValue) {\n                destination.next(_trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n        };\n        ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this._sendTrailing();\n            this._unsubscribe();\n        };\n        ThrottleSubscriber.prototype.notifyComplete = function () {\n            this._sendTrailing();\n            this._unsubscribe();\n        };\n        return ThrottleSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/throttleTime',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../scheduler/async\", \"./throttle\"], function (require, exports, tslib_1, Subscriber_1, async_1, throttle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable, then ignores subsequent source\n     * values for `duration` milliseconds, then repeats this process.\n     *\n     * <span class=\"informal\">Lets a value pass, then ignores source values for the\n     * next `duration` milliseconds.</span>\n     *\n     * <img src=\"./img/throttleTime.png\" width=\"100%\">\n     *\n     * `throttleTime` emits the source Observable values on the output Observable\n     * when its internal timer is disabled, and ignores source values when the timer\n     * is enabled. Initially, the timer is disabled. As soon as the first source\n     * value arrives, it is forwarded to the output Observable, and then the timer\n     * is enabled. After `duration` milliseconds (or the time unit determined\n     * internally by the optional `scheduler`) has passed, the timer is disabled,\n     * and this process repeats for the next source value. Optionally takes a\n     * {@link IScheduler} for managing timers.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.throttleTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttle}\n     *\n     * @param {number} duration Time to wait before emitting another value after\n     * emitting the last value, measured in milliseconds or the time unit determined\n     * internally by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the throttling.\n     * @return {Observable<T>} An Observable that performs the throttle operation to\n     * limit the rate of emissions from the source.\n     * @method throttleTime\n     * @owner Observable\n     */\n    function throttleTime(duration, scheduler, config) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n        return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n    }\n    exports.throttleTime = throttleTime;\n    var ThrottleTimeOperator = /** @class */ (function () {\n        function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n            this.duration = duration;\n            this.scheduler = scheduler;\n            this.leading = leading;\n            this.trailing = trailing;\n        }\n        ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n        };\n        return ThrottleTimeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ThrottleTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ThrottleTimeSubscriber, _super);\n        function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n            var _this = _super.call(this, destination) || this;\n            _this.duration = duration;\n            _this.scheduler = scheduler;\n            _this.leading = leading;\n            _this.trailing = trailing;\n            _this._hasTrailingValue = false;\n            _this._trailingValue = null;\n            return _this;\n        }\n        ThrottleTimeSubscriber.prototype._next = function (value) {\n            if (this.throttled) {\n                if (this.trailing) {\n                    this._trailingValue = value;\n                    this._hasTrailingValue = true;\n                }\n            }\n            else {\n                this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n                if (this.leading) {\n                    this.destination.next(value);\n                }\n            }\n        };\n        ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n            var throttled = this.throttled;\n            if (throttled) {\n                if (this.trailing && this._hasTrailingValue) {\n                    this.destination.next(this._trailingValue);\n                    this._trailingValue = null;\n                    this._hasTrailingValue = false;\n                }\n                throttled.unsubscribe();\n                this.remove(throttled);\n                this.throttled = null;\n            }\n        };\n        return ThrottleTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchNext(arg) {\n        var subscriber = arg.subscriber;\n        subscriber.clearThrottle();\n    }\n});\n\ndefine('rxjs/operators/timeout',[\"require\", \"exports\", \"tslib\", \"../scheduler/async\", \"../util/isDate\", \"../Subscriber\", \"../util/TimeoutError\"], function (require, exports, tslib_1, async_1, isDate_1, Subscriber_1, TimeoutError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Errors if Observable does not emit a value in given time span.\n     *\n     * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n     *\n     * <img src=\"./img/timeout.png\" width=\"100%\">\n     *\n     * `timeout` operator accepts as an argument either a number or a Date.\n     *\n     * If number was provided, it returns an Observable that behaves like a source\n     * Observable, unless there is a period of time where there is no value emitted.\n     * So if you provide `100` as argument and first value comes after 50ms from\n     * the moment of subscription, this value will be simply re-emitted by the resulting\n     * Observable. If however after that 100ms passes without a second value being emitted,\n     * stream will end with an error and source Observable will be unsubscribed.\n     * These checks are performed throughout whole lifecycle of Observable - from the moment\n     * it was subscribed to, until it completes or errors itself. Thus every value must be\n     * emitted within specified period since previous value.\n     *\n     * If provided argument was Date, returned Observable behaves differently. It throws\n     * if Observable did not complete before provided Date. This means that periods between\n     * emission of particular values do not matter in this case. If Observable did not complete\n     * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n     * stream behaves just as source Observable.\n     *\n     * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n     * when returned Observable will check if source stream emitted value or completed.\n     *\n     * @example <caption>Check if ticks are emitted within certain timespan</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n     *                       // since `interval` might fire a bit later then scheduled.\n     * .subscribe(\n     *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n     *     err => console.log(err) // Will never be called.\n     * );\n     *\n     * seconds.timeout(900).subscribe(\n     *     value => console.log(value), // Will never be called.\n     *     err => console.log(err) // Will emit error before even first value is emitted,\n     *                             // since it did not arrive within 900ms period.\n     * );\n     *\n     * @example <caption>Use Date to check if Observable completed</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n     * .subscribe(\n     *     value => console.log(value), // Will emit values as regular `interval` would\n     *                                  // until December 17, 2020 at 03:24:00.\n     *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n     *                             // since Observable did not complete by then.\n     * );\n     *\n     * @see {@link timeoutWith}\n     *\n     * @param {number|Date} due Number specifying period within which Observable must emit values\n     *                          or Date specifying before when Observable should complete\n     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n     * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n     * @method timeout\n     * @owner Observable\n     */\n    function timeout(due, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        var absoluteTimeout = isDate_1.isDate(due);\n        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n    }\n    exports.timeout = timeout;\n    var TimeoutOperator = /** @class */ (function () {\n        function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n            this.waitFor = waitFor;\n            this.absoluteTimeout = absoluteTimeout;\n            this.scheduler = scheduler;\n            this.errorInstance = errorInstance;\n        }\n        TimeoutOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n        };\n        return TimeoutOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TimeoutSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeoutSubscriber, _super);\n        function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n            var _this = _super.call(this, destination) || this;\n            _this.absoluteTimeout = absoluteTimeout;\n            _this.waitFor = waitFor;\n            _this.scheduler = scheduler;\n            _this.errorInstance = errorInstance;\n            _this.action = null;\n            _this.scheduleTimeout();\n            return _this;\n        }\n        TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n            subscriber.error(subscriber.errorInstance);\n        };\n        TimeoutSubscriber.prototype.scheduleTimeout = function () {\n            var action = this.action;\n            if (action) {\n                // Recycle the action if we've already scheduled one. All the production\n                // Scheduler Actions mutate their state/delay time and return themeselves.\n                // VirtualActions are immutable, so they create and return a clone. In this\n                // case, we need to set the action reference to the most recent VirtualAction,\n                // to ensure that's the one we clone from next time.\n                this.action = action.schedule(this, this.waitFor);\n            }\n            else {\n                this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n            }\n        };\n        TimeoutSubscriber.prototype._next = function (value) {\n            if (!this.absoluteTimeout) {\n                this.scheduleTimeout();\n            }\n            _super.prototype._next.call(this, value);\n        };\n        TimeoutSubscriber.prototype._unsubscribe = function () {\n            this.action = null;\n            this.scheduler = null;\n            this.errorInstance = null;\n        };\n        return TimeoutSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/timeoutWith',[\"require\", \"exports\", \"tslib\", \"../scheduler/async\", \"../util/isDate\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, async_1, isDate_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     *\n     * Errors if Observable does not emit a value in given time span, in case of which\n     * subscribes to the second Observable.\n     *\n     * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n     *\n     * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n     *\n     * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n     * still accepting as a first argument either a number or a Date, which control - respectively -\n     * when values of source Observable should be emitted or when it should complete.\n     *\n     * The only difference is that it accepts a second, required parameter. This parameter\n     * should be an Observable which will be subscribed when source Observable fails any timeout check.\n     * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n     * values from second Observable. Note that this fallback Observable is not checked for timeouts\n     * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n     * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n     * stream completes, it completes as well.\n     *\n     * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n     * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n     * as a consequence - when second Observable will be subscribed, since subscription happens\n     * immediately after failing check.\n     *\n     * @example <caption>Add fallback observable</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     * const minutes = Rx.Observable.interval(60 * 1000);\n     *\n     * seconds.timeoutWith(900, minutes)\n     *     .subscribe(\n     *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n     *                                      // since first value of `seconds` will not arrive fast enough.\n     *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n     *                                 // but here will never be called.\n     *     );\n     *\n     * @param {number|Date} due Number specifying period within which Observable must emit values\n     *                          or Date specifying before when Observable should complete\n     * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n     * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n     *                          passed as a second parameter.\n     * @method timeoutWith\n     * @owner Observable\n     */\n    function timeoutWith(due, withObservable, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return function (source) {\n            var absoluteTimeout = isDate_1.isDate(due);\n            var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n            return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n        };\n    }\n    exports.timeoutWith = timeoutWith;\n    var TimeoutWithOperator = /** @class */ (function () {\n        function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n            this.waitFor = waitFor;\n            this.absoluteTimeout = absoluteTimeout;\n            this.withObservable = withObservable;\n            this.scheduler = scheduler;\n        }\n        TimeoutWithOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n        };\n        return TimeoutWithOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TimeoutWithSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeoutWithSubscriber, _super);\n        function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.absoluteTimeout = absoluteTimeout;\n            _this.waitFor = waitFor;\n            _this.withObservable = withObservable;\n            _this.scheduler = scheduler;\n            _this.action = null;\n            _this.scheduleTimeout();\n            return _this;\n        }\n        TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n            var withObservable = subscriber.withObservable;\n            subscriber._unsubscribeAndRecycle();\n            subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n        };\n        TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n            var action = this.action;\n            if (action) {\n                // Recycle the action if we've already scheduled one. All the production\n                // Scheduler Actions mutate their state/delay time and return themeselves.\n                // VirtualActions are immutable, so they create and return a clone. In this\n                // case, we need to set the action reference to the most recent VirtualAction,\n                // to ensure that's the one we clone from next time.\n                this.action = action.schedule(this, this.waitFor);\n            }\n            else {\n                this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n            }\n        };\n        TimeoutWithSubscriber.prototype._next = function (value) {\n            if (!this.absoluteTimeout) {\n                this.scheduleTimeout();\n            }\n            _super.prototype._next.call(this, value);\n        };\n        TimeoutWithSubscriber.prototype._unsubscribe = function () {\n            this.action = null;\n            this.scheduler = null;\n            this.withObservable = null;\n        };\n        return TimeoutWithSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/toArray',[\"require\", \"exports\", \"./reduce\"], function (require, exports, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function toArrayReducer(arr, item, index) {\n        arr.push(item);\n        return arr;\n    }\n    function toArray() {\n        return reduce_1.reduce(toArrayReducer, []);\n    }\n    exports.toArray = toArray;\n});\n\ndefine('rxjs/operators/window',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable whenever\n     * `windowBoundaries` emits.\n     *\n     * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n     * instead of an array.</span>\n     *\n     * <img src=\"./img/window.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits connected, non-overlapping\n     * windows. It emits the current window and opens a new one whenever the\n     * Observable `windowBoundaries` emits an item. Because each window is an\n     * Observable, the output is a higher-order Observable.\n     *\n     * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = clicks.window(interval)\n     *   .map(win => win.take(2)) // each window has at most 2 emissions\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link windowWhen}\n     * @see {@link buffer}\n     *\n     * @param {Observable<any>} windowBoundaries An Observable that completes the\n     * previous window and starts a new window.\n     * @return {Observable<Observable<T>>} An Observable of windows, which are\n     * Observables emitting values of the source Observable.\n     * @method window\n     * @owner Observable\n     */\n    function window(windowBoundaries) {\n        return function windowOperatorFunction(source) {\n            return source.lift(new WindowOperator(windowBoundaries));\n        };\n    }\n    exports.window = window;\n    var WindowOperator = /** @class */ (function () {\n        function WindowOperator(windowBoundaries) {\n            this.windowBoundaries = windowBoundaries;\n        }\n        WindowOperator.prototype.call = function (subscriber, source) {\n            var windowSubscriber = new WindowSubscriber(subscriber);\n            var sourceSubscription = source.subscribe(windowSubscriber);\n            if (!sourceSubscription.closed) {\n                windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n            }\n            return sourceSubscription;\n        };\n        return WindowOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowSubscriber, _super);\n        function WindowSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.window = new Subject_1.Subject();\n            destination.next(_this.window);\n            return _this;\n        }\n        WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.openWindow();\n        };\n        WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n            this._error(error);\n        };\n        WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n            this._complete();\n        };\n        WindowSubscriber.prototype._next = function (value) {\n            this.window.next(value);\n        };\n        WindowSubscriber.prototype._error = function (err) {\n            this.window.error(err);\n            this.destination.error(err);\n        };\n        WindowSubscriber.prototype._complete = function () {\n            this.window.complete();\n            this.destination.complete();\n        };\n        WindowSubscriber.prototype._unsubscribe = function () {\n            this.window = null;\n        };\n        WindowSubscriber.prototype.openWindow = function () {\n            var prevWindow = this.window;\n            if (prevWindow) {\n                prevWindow.complete();\n            }\n            var destination = this.destination;\n            var newWindow = this.window = new Subject_1.Subject();\n            destination.next(newWindow);\n        };\n        return WindowSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/windowCount',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Subject\"], function (require, exports, tslib_1, Subscriber_1, Subject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable with each\n     * nested Observable emitting at most `windowSize` values.\n     *\n     * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowCount.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits windows every `startWindowEvery`\n     * items, each containing no more than `windowSize` items. When the source\n     * Observable completes or encounters an error, the output Observable emits\n     * the current window and propagates the notification from the source\n     * Observable. If `startWindowEvery` is not provided, then new windows are\n     * started immediately at the start of the source and when each window completes\n     * with size `windowSize`.\n     *\n     * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.windowCount(3)\n     *   .map(win => win.skip(1)) // skip first of every 3 clicks\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.windowCount(2, 3)\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link windowWhen}\n     * @see {@link bufferCount}\n     *\n     * @param {number} windowSize The maximum number of values emitted by each\n     * window.\n     * @param {number} [startWindowEvery] Interval at which to start a new window.\n     * For example if `startWindowEvery` is `2`, then a new window will be started\n     * on every other value from the source. A new window is started at the\n     * beginning of the source by default.\n     * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n     * are Observable of values.\n     * @method windowCount\n     * @owner Observable\n     */\n    function windowCount(windowSize, startWindowEvery) {\n        if (startWindowEvery === void 0) { startWindowEvery = 0; }\n        return function windowCountOperatorFunction(source) {\n            return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n        };\n    }\n    exports.windowCount = windowCount;\n    var WindowCountOperator = /** @class */ (function () {\n        function WindowCountOperator(windowSize, startWindowEvery) {\n            this.windowSize = windowSize;\n            this.startWindowEvery = startWindowEvery;\n        }\n        WindowCountOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n        };\n        return WindowCountOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowCountSubscriber, _super);\n        function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.windowSize = windowSize;\n            _this.startWindowEvery = startWindowEvery;\n            _this.windows = [new Subject_1.Subject()];\n            _this.count = 0;\n            destination.next(_this.windows[0]);\n            return _this;\n        }\n        WindowCountSubscriber.prototype._next = function (value) {\n            var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n            var destination = this.destination;\n            var windowSize = this.windowSize;\n            var windows = this.windows;\n            var len = windows.length;\n            for (var i = 0; i < len && !this.closed; i++) {\n                windows[i].next(value);\n            }\n            var c = this.count - windowSize + 1;\n            if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n                windows.shift().complete();\n            }\n            if (++this.count % startWindowEvery === 0 && !this.closed) {\n                var window_1 = new Subject_1.Subject();\n                windows.push(window_1);\n                destination.next(window_1);\n            }\n        };\n        WindowCountSubscriber.prototype._error = function (err) {\n            var windows = this.windows;\n            if (windows) {\n                while (windows.length > 0 && !this.closed) {\n                    windows.shift().error(err);\n                }\n            }\n            this.destination.error(err);\n        };\n        WindowCountSubscriber.prototype._complete = function () {\n            var windows = this.windows;\n            if (windows) {\n                while (windows.length > 0 && !this.closed) {\n                    windows.shift().complete();\n                }\n            }\n            this.destination.complete();\n        };\n        WindowCountSubscriber.prototype._unsubscribe = function () {\n            this.count = 0;\n            this.windows = null;\n        };\n        return WindowCountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/windowTime',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../scheduler/async\", \"../Subscriber\", \"../util/isNumeric\", \"../util/isScheduler\"], function (require, exports, tslib_1, Subject_1, async_1, Subscriber_1, isNumeric_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function windowTime(windowTimeSpan) {\n        var scheduler = async_1.async;\n        var windowCreationInterval = null;\n        var maxWindowSize = Number.POSITIVE_INFINITY;\n        if (isScheduler_1.isScheduler(arguments[3])) {\n            scheduler = arguments[3];\n        }\n        if (isScheduler_1.isScheduler(arguments[2])) {\n            scheduler = arguments[2];\n        }\n        else if (isNumeric_1.isNumeric(arguments[2])) {\n            maxWindowSize = arguments[2];\n        }\n        if (isScheduler_1.isScheduler(arguments[1])) {\n            scheduler = arguments[1];\n        }\n        else if (isNumeric_1.isNumeric(arguments[1])) {\n            windowCreationInterval = arguments[1];\n        }\n        return function windowTimeOperatorFunction(source) {\n            return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n        };\n    }\n    exports.windowTime = windowTime;\n    var WindowTimeOperator = /** @class */ (function () {\n        function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n            this.windowTimeSpan = windowTimeSpan;\n            this.windowCreationInterval = windowCreationInterval;\n            this.maxWindowSize = maxWindowSize;\n            this.scheduler = scheduler;\n        }\n        WindowTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n        };\n        return WindowTimeOperator;\n    }());\n    var CountedSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(CountedSubject, _super);\n        function CountedSubject() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._numberOfNextedValues = 0;\n            return _this;\n        }\n        CountedSubject.prototype.next = function (value) {\n            this._numberOfNextedValues++;\n            _super.prototype.next.call(this, value);\n        };\n        Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n            get: function () {\n                return this._numberOfNextedValues;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return CountedSubject;\n    }(Subject_1.Subject));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowTimeSubscriber, _super);\n        function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.windowTimeSpan = windowTimeSpan;\n            _this.windowCreationInterval = windowCreationInterval;\n            _this.maxWindowSize = maxWindowSize;\n            _this.scheduler = scheduler;\n            _this.windows = [];\n            var window = _this.openWindow();\n            if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n                var closeState = { subscriber: _this, window: window, context: null };\n                var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };\n                _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n                _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n            }\n            else {\n                var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };\n                _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n            }\n            return _this;\n        }\n        WindowTimeSubscriber.prototype._next = function (value) {\n            var windows = this.windows;\n            var len = windows.length;\n            for (var i = 0; i < len; i++) {\n                var window_1 = windows[i];\n                if (!window_1.closed) {\n                    window_1.next(value);\n                    if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                        this.closeWindow(window_1);\n                    }\n                }\n            }\n        };\n        WindowTimeSubscriber.prototype._error = function (err) {\n            var windows = this.windows;\n            while (windows.length > 0) {\n                windows.shift().error(err);\n            }\n            this.destination.error(err);\n        };\n        WindowTimeSubscriber.prototype._complete = function () {\n            var windows = this.windows;\n            while (windows.length > 0) {\n                var window_2 = windows.shift();\n                if (!window_2.closed) {\n                    window_2.complete();\n                }\n            }\n            this.destination.complete();\n        };\n        WindowTimeSubscriber.prototype.openWindow = function () {\n            var window = new CountedSubject();\n            this.windows.push(window);\n            var destination = this.destination;\n            destination.next(window);\n            return window;\n        };\n        WindowTimeSubscriber.prototype.closeWindow = function (window) {\n            window.complete();\n            var windows = this.windows;\n            windows.splice(windows.indexOf(window), 1);\n        };\n        return WindowTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchWindowTimeSpanOnly(state) {\n        var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n        if (window) {\n            subscriber.closeWindow(window);\n        }\n        state.window = subscriber.openWindow();\n        this.schedule(state, windowTimeSpan);\n    }\n    function dispatchWindowCreation(state) {\n        var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n        var window = subscriber.openWindow();\n        var action = this;\n        var context = { action: action, subscription: null };\n        var timeSpanState = { subscriber: subscriber, window: window, context: context };\n        context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n        action.add(context.subscription);\n        action.schedule(state, windowCreationInterval);\n    }\n    function dispatchWindowClose(state) {\n        var subscriber = state.subscriber, window = state.window, context = state.context;\n        if (context && context.action && context.subscription) {\n            context.action.remove(context.subscription);\n        }\n        subscriber.closeWindow(window);\n    }\n});\n\ndefine('rxjs/operators/windowToggle',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../Subscription\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, Subscription_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable starting from\n     * an emission from `openings` and ending when the output of `closingSelector`\n     * emits.\n     *\n     * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowToggle.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits windows that contain those items\n     * emitted by the source Observable between the time when the `openings`\n     * Observable emits an item and when the Observable returned by\n     * `closingSelector` emits an item.\n     *\n     * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var openings = Rx.Observable.interval(1000);\n     * var result = clicks.windowToggle(openings, i =>\n     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n     * ).mergeAll();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowWhen}\n     * @see {@link bufferToggle}\n     *\n     * @param {Observable<O>} openings An observable of notifications to start new\n     * windows.\n     * @param {function(value: O): Observable} closingSelector A function that takes\n     * the value emitted by the `openings` observable and returns an Observable,\n     * which, when it emits (either `next` or `complete`), signals that the\n     * associated window should complete.\n     * @return {Observable<Observable<T>>} An observable of windows, which in turn\n     * are Observables.\n     * @method windowToggle\n     * @owner Observable\n     */\n    function windowToggle(openings, closingSelector) {\n        return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };\n    }\n    exports.windowToggle = windowToggle;\n    var WindowToggleOperator = /** @class */ (function () {\n        function WindowToggleOperator(openings, closingSelector) {\n            this.openings = openings;\n            this.closingSelector = closingSelector;\n        }\n        WindowToggleOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n        };\n        return WindowToggleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowToggleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowToggleSubscriber, _super);\n        function WindowToggleSubscriber(destination, openings, closingSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.openings = openings;\n            _this.closingSelector = closingSelector;\n            _this.contexts = [];\n            _this.add(_this.openSubscription = subscribeToResult_1.subscribeToResult(_this, openings, openings));\n            return _this;\n        }\n        WindowToggleSubscriber.prototype._next = function (value) {\n            var contexts = this.contexts;\n            if (contexts) {\n                var len = contexts.length;\n                for (var i = 0; i < len; i++) {\n                    contexts[i].window.next(value);\n                }\n            }\n        };\n        WindowToggleSubscriber.prototype._error = function (err) {\n            var contexts = this.contexts;\n            this.contexts = null;\n            if (contexts) {\n                var len = contexts.length;\n                var index = -1;\n                while (++index < len) {\n                    var context = contexts[index];\n                    context.window.error(err);\n                    context.subscription.unsubscribe();\n                }\n            }\n            _super.prototype._error.call(this, err);\n        };\n        WindowToggleSubscriber.prototype._complete = function () {\n            var contexts = this.contexts;\n            this.contexts = null;\n            if (contexts) {\n                var len = contexts.length;\n                var index = -1;\n                while (++index < len) {\n                    var context = contexts[index];\n                    context.window.complete();\n                    context.subscription.unsubscribe();\n                }\n            }\n            _super.prototype._complete.call(this);\n        };\n        WindowToggleSubscriber.prototype._unsubscribe = function () {\n            var contexts = this.contexts;\n            this.contexts = null;\n            if (contexts) {\n                var len = contexts.length;\n                var index = -1;\n                while (++index < len) {\n                    var context = contexts[index];\n                    context.window.unsubscribe();\n                    context.subscription.unsubscribe();\n                }\n            }\n        };\n        WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            if (outerValue === this.openings) {\n                var closingSelector = this.closingSelector;\n                var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n                if (closingNotifier === errorObject_1.errorObject) {\n                    return this.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    var window_1 = new Subject_1.Subject();\n                    var subscription = new Subscription_1.Subscription();\n                    var context = { window: window_1, subscription: subscription };\n                    this.contexts.push(context);\n                    var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                    if (innerSubscription.closed) {\n                        this.closeWindow(this.contexts.length - 1);\n                    }\n                    else {\n                        innerSubscription.context = context;\n                        subscription.add(innerSubscription);\n                    }\n                    this.destination.next(window_1);\n                }\n            }\n            else {\n                this.closeWindow(this.contexts.indexOf(outerValue));\n            }\n        };\n        WindowToggleSubscriber.prototype.notifyError = function (err) {\n            this.error(err);\n        };\n        WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n            if (inner !== this.openSubscription) {\n                this.closeWindow(this.contexts.indexOf(inner.context));\n            }\n        };\n        WindowToggleSubscriber.prototype.closeWindow = function (index) {\n            if (index === -1) {\n                return;\n            }\n            var contexts = this.contexts;\n            var context = contexts[index];\n            var window = context.window, subscription = context.subscription;\n            contexts.splice(index, 1);\n            window.complete();\n            subscription.unsubscribe();\n        };\n        return WindowToggleSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/windowWhen',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable using a\n     * factory function of closing Observables to determine when to start a new\n     * window.\n     *\n     * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowWhen.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits connected, non-overlapping windows.\n     * It emits the current window and opens a new one whenever the Observable\n     * produced by the specified `closingSelector` function emits an item. The first\n     * window is opened immediately when subscribing to the output Observable.\n     *\n     * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks\n     *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n     *   .map(win => win.take(2)) // each window has at most 2 emissions\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link bufferWhen}\n     *\n     * @param {function(): Observable} closingSelector A function that takes no\n     * arguments and returns an Observable that signals (on either `next` or\n     * `complete`) when to close the previous window and start a new one.\n     * @return {Observable<Observable<T>>} An observable of windows, which in turn\n     * are Observables.\n     * @method windowWhen\n     * @owner Observable\n     */\n    function windowWhen(closingSelector) {\n        return function windowWhenOperatorFunction(source) {\n            return source.lift(new WindowOperator(closingSelector));\n        };\n    }\n    exports.windowWhen = windowWhen;\n    var WindowOperator = /** @class */ (function () {\n        function WindowOperator(closingSelector) {\n            this.closingSelector = closingSelector;\n        }\n        WindowOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n        };\n        return WindowOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowSubscriber, _super);\n        function WindowSubscriber(destination, closingSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.closingSelector = closingSelector;\n            _this.openWindow();\n            return _this;\n        }\n        WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.openWindow(innerSub);\n        };\n        WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n            this._error(error);\n        };\n        WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.openWindow(innerSub);\n        };\n        WindowSubscriber.prototype._next = function (value) {\n            this.window.next(value);\n        };\n        WindowSubscriber.prototype._error = function (err) {\n            this.window.error(err);\n            this.destination.error(err);\n            this.unsubscribeClosingNotification();\n        };\n        WindowSubscriber.prototype._complete = function () {\n            this.window.complete();\n            this.destination.complete();\n            this.unsubscribeClosingNotification();\n        };\n        WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n            if (this.closingNotification) {\n                this.closingNotification.unsubscribe();\n            }\n        };\n        WindowSubscriber.prototype.openWindow = function (innerSub) {\n            if (innerSub === void 0) { innerSub = null; }\n            if (innerSub) {\n                this.remove(innerSub);\n                innerSub.unsubscribe();\n            }\n            var prevWindow = this.window;\n            if (prevWindow) {\n                prevWindow.complete();\n            }\n            var window = this.window = new Subject_1.Subject();\n            this.destination.next(window);\n            var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n            if (closingNotifier === errorObject_1.errorObject) {\n                var err = errorObject_1.errorObject.e;\n                this.destination.error(err);\n                this.window.error(err);\n            }\n            else {\n                this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            }\n        };\n        return WindowSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/withLatestFrom',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines the source Observable with other Observables to create an Observable\n     * whose values are calculated from the latest values of each, only when the\n     * source emits.\n     *\n     * <span class=\"informal\">Whenever the source Observable emits a value, it\n     * computes a formula using that value plus the latest values from other input\n     * Observables, then emits the output of that formula.</span>\n     *\n     * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n     *\n     * `withLatestFrom` combines each value from the source Observable (the\n     * instance) with the latest values from the other input Observables only when\n     * the source emits a value, optionally using a `project` function to determine\n     * the value to be emitted on the output Observable. All input Observables must\n     * emit at least one value before the output Observable will emit a value.\n     *\n     * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var result = clicks.withLatestFrom(timer);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineLatest}\n     *\n     * @param {ObservableInput} other An input Observable to combine with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {Function} [project] Projection function for combining values\n     * together. Receives all values in order of the Observables passed, where the\n     * first parameter is a value from the source Observable. (e.g.\n     * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n     * passed, arrays will be emitted on the output Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @method withLatestFrom\n     * @owner Observable\n     */\n    function withLatestFrom() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return function (source) {\n            var project;\n            if (typeof args[args.length - 1] === 'function') {\n                project = args.pop();\n            }\n            var observables = args;\n            return source.lift(new WithLatestFromOperator(observables, project));\n        };\n    }\n    exports.withLatestFrom = withLatestFrom;\n    var WithLatestFromOperator = /** @class */ (function () {\n        function WithLatestFromOperator(observables, project) {\n            this.observables = observables;\n            this.project = project;\n        }\n        WithLatestFromOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n        };\n        return WithLatestFromOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WithLatestFromSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WithLatestFromSubscriber, _super);\n        function WithLatestFromSubscriber(destination, observables, project) {\n            var _this = _super.call(this, destination) || this;\n            _this.observables = observables;\n            _this.project = project;\n            _this.toRespond = [];\n            var len = observables.length;\n            _this.values = new Array(len);\n            for (var i = 0; i < len; i++) {\n                _this.toRespond.push(i);\n            }\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                _this.add(subscribeToResult_1.subscribeToResult(_this, observable, observable, i));\n            }\n            return _this;\n        }\n        WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.values[outerIndex] = innerValue;\n            var toRespond = this.toRespond;\n            if (toRespond.length > 0) {\n                var found = toRespond.indexOf(outerIndex);\n                if (found !== -1) {\n                    toRespond.splice(found, 1);\n                }\n            }\n        };\n        WithLatestFromSubscriber.prototype.notifyComplete = function () {\n            // noop\n        };\n        WithLatestFromSubscriber.prototype._next = function (value) {\n            if (this.toRespond.length === 0) {\n                var args = [value].concat(this.values);\n                if (this.project) {\n                    this._tryProject(args);\n                }\n                else {\n                    this.destination.next(args);\n                }\n            }\n        };\n        WithLatestFromSubscriber.prototype._tryProject = function (args) {\n            var result;\n            try {\n                result = this.project.apply(this, args);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return WithLatestFromSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/zip',[\"require\", \"exports\", \"tslib\", \"../observable/ArrayObservable\", \"../util/isArray\", \"../Subscriber\", \"../OuterSubscriber\", \"../util/subscribeToResult\", \"../symbol/iterator\"], function (require, exports, tslib_1, ArrayObservable_1, isArray_1, Subscriber_1, OuterSubscriber_1, subscribeToResult_1, iterator_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * @param observables\n     * @return {Observable<R>}\n     * @method zip\n     * @owner Observable\n     */\n    function zip() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return function zipOperatorFunction(source) {\n            return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n        };\n    }\n    exports.zip = zip;\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n     * of its input Observables.\n     *\n     * If the latest parameter is a function, this function is used to compute the created value from the input values.\n     * Otherwise, an array of the input values is returned.\n     *\n     * @example <caption>Combine age and name from different sources</caption>\n     *\n     * let age$ = Observable.of<number>(27, 25, 29);\n     * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n     * let isDev$ = Observable.of<boolean>(true, true, false);\n     *\n     * Observable\n     *     .zip(age$,\n     *          name$,\n     *          isDev$,\n     *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n     *     .subscribe(x => console.log(x));\n     *\n     * // outputs\n     * // { age: 27, name: 'Foo', isDev: true }\n     * // { age: 25, name: 'Bar', isDev: true }\n     * // { age: 29, name: 'Beer', isDev: false }\n     *\n     * @param observables\n     * @return {Observable<R>}\n     * @static true\n     * @name zip\n     * @owner Observable\n     */\n    function zipStatic() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        var project = observables[observables.length - 1];\n        if (typeof project === 'function') {\n            observables.pop();\n        }\n        return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n    }\n    exports.zipStatic = zipStatic;\n    var ZipOperator = /** @class */ (function () {\n        function ZipOperator(project) {\n            this.project = project;\n        }\n        ZipOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ZipSubscriber(subscriber, this.project));\n        };\n        return ZipOperator;\n    }());\n    exports.ZipOperator = ZipOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ZipSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ZipSubscriber, _super);\n        function ZipSubscriber(destination, project, values) {\n            if (values === void 0) { values = Object.create(null); }\n            var _this = _super.call(this, destination) || this;\n            _this.iterators = [];\n            _this.active = 0;\n            _this.project = (typeof project === 'function') ? project : null;\n            _this.values = values;\n            return _this;\n        }\n        ZipSubscriber.prototype._next = function (value) {\n            var iterators = this.iterators;\n            if (isArray_1.isArray(value)) {\n                iterators.push(new StaticArrayIterator(value));\n            }\n            else if (typeof value[iterator_1.iterator] === 'function') {\n                iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n            }\n            else {\n                iterators.push(new ZipBufferIterator(this.destination, this, value));\n            }\n        };\n        ZipSubscriber.prototype._complete = function () {\n            var iterators = this.iterators;\n            var len = iterators.length;\n            if (len === 0) {\n                this.destination.complete();\n                return;\n            }\n            this.active = len;\n            for (var i = 0; i < len; i++) {\n                var iterator = iterators[i];\n                if (iterator.stillUnsubscribed) {\n                    this.add(iterator.subscribe(iterator, i));\n                }\n                else {\n                    this.active--; // not an observable\n                }\n            }\n        };\n        ZipSubscriber.prototype.notifyInactive = function () {\n            this.active--;\n            if (this.active === 0) {\n                this.destination.complete();\n            }\n        };\n        ZipSubscriber.prototype.checkIterators = function () {\n            var iterators = this.iterators;\n            var len = iterators.length;\n            var destination = this.destination;\n            // abort if not all of them have values\n            for (var i = 0; i < len; i++) {\n                var iterator = iterators[i];\n                if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                    return;\n                }\n            }\n            var shouldComplete = false;\n            var args = [];\n            for (var i = 0; i < len; i++) {\n                var iterator = iterators[i];\n                var result = iterator.next();\n                // check to see if it's completed now that you've gotten\n                // the next value.\n                if (iterator.hasCompleted()) {\n                    shouldComplete = true;\n                }\n                if (result.done) {\n                    destination.complete();\n                    return;\n                }\n                args.push(result.value);\n            }\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                destination.next(args);\n            }\n            if (shouldComplete) {\n                destination.complete();\n            }\n        };\n        ZipSubscriber.prototype._tryProject = function (args) {\n            var result;\n            try {\n                result = this.project.apply(this, args);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return ZipSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.ZipSubscriber = ZipSubscriber;\n    var StaticIterator = /** @class */ (function () {\n        function StaticIterator(iterator) {\n            this.iterator = iterator;\n            this.nextResult = iterator.next();\n        }\n        StaticIterator.prototype.hasValue = function () {\n            return true;\n        };\n        StaticIterator.prototype.next = function () {\n            var result = this.nextResult;\n            this.nextResult = this.iterator.next();\n            return result;\n        };\n        StaticIterator.prototype.hasCompleted = function () {\n            var nextResult = this.nextResult;\n            return nextResult && nextResult.done;\n        };\n        return StaticIterator;\n    }());\n    var StaticArrayIterator = /** @class */ (function () {\n        function StaticArrayIterator(array) {\n            this.array = array;\n            this.index = 0;\n            this.length = 0;\n            this.length = array.length;\n        }\n        StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n            return this;\n        };\n        StaticArrayIterator.prototype.next = function (value) {\n            var i = this.index++;\n            var array = this.array;\n            return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n        };\n        StaticArrayIterator.prototype.hasValue = function () {\n            return this.array.length > this.index;\n        };\n        StaticArrayIterator.prototype.hasCompleted = function () {\n            return this.array.length === this.index;\n        };\n        return StaticArrayIterator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ZipBufferIterator = /** @class */ (function (_super) {\n        tslib_1.__extends(ZipBufferIterator, _super);\n        function ZipBufferIterator(destination, parent, observable) {\n            var _this = _super.call(this, destination) || this;\n            _this.parent = parent;\n            _this.observable = observable;\n            _this.stillUnsubscribed = true;\n            _this.buffer = [];\n            _this.isComplete = false;\n            return _this;\n        }\n        ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n            return this;\n        };\n        // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n        //    this is legit because `next()` will never be called by a subscription in this case.\n        ZipBufferIterator.prototype.next = function () {\n            var buffer = this.buffer;\n            if (buffer.length === 0 && this.isComplete) {\n                return { value: null, done: true };\n            }\n            else {\n                return { value: buffer.shift(), done: false };\n            }\n        };\n        ZipBufferIterator.prototype.hasValue = function () {\n            return this.buffer.length > 0;\n        };\n        ZipBufferIterator.prototype.hasCompleted = function () {\n            return this.buffer.length === 0 && this.isComplete;\n        };\n        ZipBufferIterator.prototype.notifyComplete = function () {\n            if (this.buffer.length > 0) {\n                this.isComplete = true;\n                this.parent.notifyInactive();\n            }\n            else {\n                this.destination.complete();\n            }\n        };\n        ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.buffer.push(innerValue);\n            this.parent.checkIterators();\n        };\n        ZipBufferIterator.prototype.subscribe = function (value, index) {\n            return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n        };\n        return ZipBufferIterator;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/zipAll',[\"require\", \"exports\", \"./zip\"], function (require, exports, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function zipAll(project) {\n        return function (source) { return source.lift(new zip_1.ZipOperator(project)); };\n    }\n    exports.zipAll = zipAll;\n});\n\ndefine('rxjs/operators/index',[\"require\", \"exports\", \"./audit\", \"./auditTime\", \"./buffer\", \"./bufferCount\", \"./bufferTime\", \"./bufferToggle\", \"./bufferWhen\", \"./catchError\", \"./combineAll\", \"./combineLatest\", \"./concat\", \"./concatAll\", \"./concatMap\", \"./concatMapTo\", \"./count\", \"./debounce\", \"./debounceTime\", \"./defaultIfEmpty\", \"./delay\", \"./delayWhen\", \"./dematerialize\", \"./distinct\", \"./distinctUntilChanged\", \"./distinctUntilKeyChanged\", \"./elementAt\", \"./every\", \"./exhaust\", \"./exhaustMap\", \"./expand\", \"./filter\", \"./finalize\", \"./find\", \"./findIndex\", \"./first\", \"./groupBy\", \"./ignoreElements\", \"./isEmpty\", \"./last\", \"./map\", \"./mapTo\", \"./materialize\", \"./max\", \"./merge\", \"./mergeAll\", \"./mergeMap\", \"./mergeMap\", \"./mergeMapTo\", \"./mergeScan\", \"./min\", \"./multicast\", \"./observeOn\", \"./onErrorResumeNext\", \"./pairwise\", \"./partition\", \"./pluck\", \"./publish\", \"./publishBehavior\", \"./publishLast\", \"./publishReplay\", \"./race\", \"./reduce\", \"./repeat\", \"./repeatWhen\", \"./retry\", \"./retryWhen\", \"./refCount\", \"./sample\", \"./sampleTime\", \"./scan\", \"./sequenceEqual\", \"./share\", \"./shareReplay\", \"./single\", \"./skip\", \"./skipLast\", \"./skipUntil\", \"./skipWhile\", \"./startWith\", \"./switchAll\", \"./switchMap\", \"./switchMapTo\", \"./take\", \"./takeLast\", \"./takeUntil\", \"./takeWhile\", \"./tap\", \"./throttle\", \"./throttleTime\", \"./timeInterval\", \"./timeout\", \"./timeoutWith\", \"./timestamp\", \"./toArray\", \"./window\", \"./windowCount\", \"./windowTime\", \"./windowToggle\", \"./windowWhen\", \"./withLatestFrom\", \"./zip\", \"./zipAll\"], function (require, exports, audit_1, auditTime_1, buffer_1, bufferCount_1, bufferTime_1, bufferToggle_1, bufferWhen_1, catchError_1, combineAll_1, combineLatest_1, concat_1, concatAll_1, concatMap_1, concatMapTo_1, count_1, debounce_1, debounceTime_1, defaultIfEmpty_1, delay_1, delayWhen_1, dematerialize_1, distinct_1, distinctUntilChanged_1, distinctUntilKeyChanged_1, elementAt_1, every_1, exhaust_1, exhaustMap_1, expand_1, filter_1, finalize_1, find_1, findIndex_1, first_1, groupBy_1, ignoreElements_1, isEmpty_1, last_1, map_1, mapTo_1, materialize_1, max_1, merge_1, mergeAll_1, mergeMap_1, mergeMap_2, mergeMapTo_1, mergeScan_1, min_1, multicast_1, observeOn_1, onErrorResumeNext_1, pairwise_1, partition_1, pluck_1, publish_1, publishBehavior_1, publishLast_1, publishReplay_1, race_1, reduce_1, repeat_1, repeatWhen_1, retry_1, retryWhen_1, refCount_1, sample_1, sampleTime_1, scan_1, sequenceEqual_1, share_1, shareReplay_1, single_1, skip_1, skipLast_1, skipUntil_1, skipWhile_1, startWith_1, switchAll_1, switchMap_1, switchMapTo_1, take_1, takeLast_1, takeUntil_1, takeWhile_1, tap_1, throttle_1, throttleTime_1, timeInterval_1, timeout_1, timeoutWith_1, timestamp_1, toArray_1, window_1, windowCount_1, windowTime_1, windowToggle_1, windowWhen_1, withLatestFrom_1, zip_1, zipAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.audit = audit_1.audit;\n    exports.auditTime = auditTime_1.auditTime;\n    exports.buffer = buffer_1.buffer;\n    exports.bufferCount = bufferCount_1.bufferCount;\n    exports.bufferTime = bufferTime_1.bufferTime;\n    exports.bufferToggle = bufferToggle_1.bufferToggle;\n    exports.bufferWhen = bufferWhen_1.bufferWhen;\n    exports.catchError = catchError_1.catchError;\n    exports.combineAll = combineAll_1.combineAll;\n    exports.combineLatest = combineLatest_1.combineLatest;\n    exports.concat = concat_1.concat;\n    exports.concatAll = concatAll_1.concatAll;\n    exports.concatMap = concatMap_1.concatMap;\n    exports.concatMapTo = concatMapTo_1.concatMapTo;\n    exports.count = count_1.count;\n    exports.debounce = debounce_1.debounce;\n    exports.debounceTime = debounceTime_1.debounceTime;\n    exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n    exports.delay = delay_1.delay;\n    exports.delayWhen = delayWhen_1.delayWhen;\n    exports.dematerialize = dematerialize_1.dematerialize;\n    exports.distinct = distinct_1.distinct;\n    exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n    exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n    exports.elementAt = elementAt_1.elementAt;\n    exports.every = every_1.every;\n    exports.exhaust = exhaust_1.exhaust;\n    exports.exhaustMap = exhaustMap_1.exhaustMap;\n    exports.expand = expand_1.expand;\n    exports.filter = filter_1.filter;\n    exports.finalize = finalize_1.finalize;\n    exports.find = find_1.find;\n    exports.findIndex = findIndex_1.findIndex;\n    exports.first = first_1.first;\n    exports.groupBy = groupBy_1.groupBy;\n    exports.ignoreElements = ignoreElements_1.ignoreElements;\n    exports.isEmpty = isEmpty_1.isEmpty;\n    exports.last = last_1.last;\n    exports.map = map_1.map;\n    exports.mapTo = mapTo_1.mapTo;\n    exports.materialize = materialize_1.materialize;\n    exports.max = max_1.max;\n    exports.merge = merge_1.merge;\n    exports.mergeAll = mergeAll_1.mergeAll;\n    exports.mergeMap = mergeMap_1.mergeMap;\n    exports.flatMap = mergeMap_2.mergeMap;\n    exports.mergeMapTo = mergeMapTo_1.mergeMapTo;\n    exports.mergeScan = mergeScan_1.mergeScan;\n    exports.min = min_1.min;\n    exports.multicast = multicast_1.multicast;\n    exports.observeOn = observeOn_1.observeOn;\n    exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n    exports.pairwise = pairwise_1.pairwise;\n    exports.partition = partition_1.partition;\n    exports.pluck = pluck_1.pluck;\n    exports.publish = publish_1.publish;\n    exports.publishBehavior = publishBehavior_1.publishBehavior;\n    exports.publishLast = publishLast_1.publishLast;\n    exports.publishReplay = publishReplay_1.publishReplay;\n    exports.race = race_1.race;\n    exports.reduce = reduce_1.reduce;\n    exports.repeat = repeat_1.repeat;\n    exports.repeatWhen = repeatWhen_1.repeatWhen;\n    exports.retry = retry_1.retry;\n    exports.retryWhen = retryWhen_1.retryWhen;\n    exports.refCount = refCount_1.refCount;\n    exports.sample = sample_1.sample;\n    exports.sampleTime = sampleTime_1.sampleTime;\n    exports.scan = scan_1.scan;\n    exports.sequenceEqual = sequenceEqual_1.sequenceEqual;\n    exports.share = share_1.share;\n    exports.shareReplay = shareReplay_1.shareReplay;\n    exports.single = single_1.single;\n    exports.skip = skip_1.skip;\n    exports.skipLast = skipLast_1.skipLast;\n    exports.skipUntil = skipUntil_1.skipUntil;\n    exports.skipWhile = skipWhile_1.skipWhile;\n    exports.startWith = startWith_1.startWith;\n    exports.switchAll = switchAll_1.switchAll;\n    exports.switchMap = switchMap_1.switchMap;\n    exports.switchMapTo = switchMapTo_1.switchMapTo;\n    exports.take = take_1.take;\n    exports.takeLast = takeLast_1.takeLast;\n    exports.takeUntil = takeUntil_1.takeUntil;\n    exports.takeWhile = takeWhile_1.takeWhile;\n    exports.tap = tap_1.tap;\n    exports.throttle = throttle_1.throttle;\n    exports.throttleTime = throttleTime_1.throttleTime;\n    exports.timeInterval = timeInterval_1.timeInterval;\n    exports.timeout = timeout_1.timeout;\n    exports.timeoutWith = timeoutWith_1.timeoutWith;\n    exports.timestamp = timestamp_1.timestamp;\n    exports.toArray = toArray_1.toArray;\n    exports.window = window_1.window;\n    exports.windowCount = windowCount_1.windowCount;\n    exports.windowTime = windowTime_1.windowTime;\n    exports.windowToggle = windowToggle_1.windowToggle;\n    exports.windowWhen = windowWhen_1.windowWhen;\n    exports.withLatestFrom = withLatestFrom_1.withLatestFrom;\n    exports.zip = zip_1.zip;\n    exports.zipAll = zipAll_1.zipAll;\n});\n\ndefine('rxjs/operators', ['rxjs/operators/index'], function (main) { return main; });\n\ndefine('rxjs/observable/BoundCallbackObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/tryCatch\", \"../util/errorObject\", \"../AsyncSubject\"], function (require, exports, tslib_1, Observable_1, tryCatch_1, errorObject_1, AsyncSubject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var BoundCallbackObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(BoundCallbackObservable, _super);\n        function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.callbackFunc = callbackFunc;\n            _this.selector = selector;\n            _this.args = args;\n            _this.context = context;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /* tslint:enable:max-line-length */\n        /**\n         * Converts a callback API to a function that returns an Observable.\n         *\n         * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n         * it will return a function `g` that when called as `g(x)` will output an\n         * Observable.</span>\n         *\n         * `bindCallback` is not an operator because its input and output are not\n         * Observables. The input is a function `func` with some parameters, but the\n         * last parameter must be a callback function that `func` calls when it is\n         * done.\n         *\n         * The output of `bindCallback` is a function that takes the same parameters\n         * as `func`, except the last one (the callback). When the output function\n         * is called with arguments, it will return an Observable. If `func` function\n         * calls its callback with one argument, the Observable will emit that value.\n         * If on the other hand callback is called with multiple values, resulting\n         * Observable will emit an array with these arguments.\n         *\n         * It is very important to remember, that input function `func` is not called\n         * when output function is, but rather when Observable returned by output\n         * function is subscribed. This means if `func` makes AJAX request, that request\n         * will be made every time someone subscribes to resulting Observable, but not before.\n         *\n         * Optionally, selector function can be passed to `bindObservable`. That function\n         * takes the same arguments as callback, and returns value\n         * that will be emitted by Observable instead of callback parameters themselves.\n         * Even though by default multiple arguments passed to callback appear in the stream as array,\n         * selector function will be called with arguments directly, just as callback would.\n         * This means you can imagine default selector (when one is not provided explicitly)\n         * as function that aggregates all its arguments into array, or simply returns first argument,\n         * if there is only one.\n         *\n         * Last optional parameter - {@link Scheduler} - can be used to control when call\n         * to `func` happens after someone subscribes to Observable, as well as when results\n         * passed to callback will be emitted. By default subscription to Observable calls `func`\n         * synchronously, but using `Scheduler.async` as last parameter will defer call to input function,\n         * just like wrapping that call in `setTimeout` with time `0` would. So if you use async Scheduler\n         * and call `subscribe` on output Observable, all function calls that are currently executing,\n         * will end before `func` is invoked.\n         *\n         * When it comes to emitting results passed to callback, by default they are emitted\n         * immediately after `func` invokes callback. In particular, if callback is called synchronously,\n         * then subscription to resulting Observable will call `next` function synchronously as well.\n         * If you want to defer that call, using `Scheduler.async` will, again, do the job.\n         * This means that by using `Scheduler.async` you can, in a sense, ensure that `func`\n         * always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n         *\n         * Note that Observable created by output function will always emit only one value\n         * and then complete right after. Even if `func` calls callback multiple times, values from\n         * second and following calls will never appear in the stream. If you need to\n         * listen for multiple calls, you probably want to use {@link fromEvent} or\n         * {@link fromEventPattern} instead.\n         *\n         * If `func` depends on some context (`this` property), that context will be set\n         * to the same context that output function has at call time. In particular, if `func`\n         * is called as method of some object, in order to preserve proper behaviour,\n         * it is recommended to set context of output function to that object as well,\n         * provided `func` is not already bound.\n         *\n         * If input function calls its callback in \"node style\" (i.e. first argument to callback is\n         * optional error parameter signaling whether call failed or not), {@link bindNodeCallback}\n         * provides convenient error handling and probably is a better choice.\n         * `bindCallback` will treat such functions without any difference and error parameter\n         * (whether passed or not) will always be interpreted as regular callback argument.\n         *\n         *\n         * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n         * // Suppose we have jQuery.getJSON('/my/url', callback)\n         * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n         * var result = getJSONAsObservable('/my/url');\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         *\n         * @example <caption>Receive array of arguments passed to callback</caption>\n         * someFunction((a, b, c) => {\n         *   console.log(a); // 5\n         *   console.log(b); // 'some string'\n         *   console.log(c); // {someProperty: 'someValue'}\n         * });\n         *\n         * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n         * boundSomeFunction().subscribe(values => {\n         *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n         * });\n         *\n         *\n         * @example <caption>Use bindCallback with selector function</caption>\n         * someFunction((a, b, c) => {\n         *   console.log(a); // 'a'\n         *   console.log(b); // 'b'\n         *   console.log(c); // 'c'\n         * });\n         *\n         * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n         * boundSomeFunction().subscribe(value => {\n         *   console.log(value) // 'abc'\n         * });\n         *\n         *\n         * @example <caption>Compare behaviour with and without async Scheduler</caption>\n         * function iCallMyCallbackSynchronously(cb) {\n         *   cb();\n         * }\n         *\n         * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n         * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n         *\n         * boundSyncFn().subscribe(() => console.log('I was sync!'));\n         * boundAsyncFn().subscribe(() => console.log('I was async!'));\n         * console.log('This happened...');\n         *\n         * // Logs:\n         * // I was sync!\n         * // This happened...\n         * // I was async!\n         *\n         *\n         * @example <caption>Use bindCallback on object method</caption>\n         * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n         * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n         * .subscribe(subscriber);\n         *\n         *\n         * @see {@link bindNodeCallback}\n         * @see {@link from}\n         * @see {@link fromPromise}\n         *\n         * @param {function} func Function with a callback as the last parameter.\n         * @param {function} [selector] A function which takes the arguments from the\n         * callback and maps those to a value to emit on the output Observable.\n         * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n         * callbacks.\n         * @return {function(...params: *): Observable} A function which returns the\n         * Observable that delivers the same values the callback would deliver.\n         * @static true\n         * @name bindCallback\n         * @owner Observable\n         */\n        BoundCallbackObservable.create = function (func, selector, scheduler) {\n            if (selector === void 0) { selector = undefined; }\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return new BoundCallbackObservable(func, selector, args, this, scheduler);\n            };\n        };\n        BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n            var callbackFunc = this.callbackFunc;\n            var args = this.args;\n            var scheduler = this.scheduler;\n            var subject = this.subject;\n            if (!scheduler) {\n                if (!subject) {\n                    subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                    var handler = function handlerFn() {\n                        var innerArgs = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            innerArgs[_i] = arguments[_i];\n                        }\n                        var source = handlerFn.source;\n                        var selector = source.selector, subject = source.subject;\n                        if (selector) {\n                            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                            if (result_1 === errorObject_1.errorObject) {\n                                subject.error(errorObject_1.errorObject.e);\n                            }\n                            else {\n                                subject.next(result_1);\n                                subject.complete();\n                            }\n                        }\n                        else {\n                            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                            subject.complete();\n                        }\n                    };\n                    // use named function instance to avoid closure.\n                    handler.source = this;\n                    var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                    if (result === errorObject_1.errorObject) {\n                        subject.error(errorObject_1.errorObject.e);\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n            }\n        };\n        BoundCallbackObservable.dispatch = function (state) {\n            var self = this;\n            var source = state.source, subscriber = state.subscriber, context = state.context;\n            var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\n            var subject = source.subject;\n            if (!subject) {\n                subject = source.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    if (selector) {\n                        var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_2 === errorObject_1.errorObject) {\n                            self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                        }\n                        else {\n                            self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                        }\n                    }\n                    else {\n                        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                    }\n                };\n                // use named function to pass values in without closure\n                handler.source = source;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            self.add(subject.subscribe(subscriber));\n        };\n        return BoundCallbackObservable;\n    }(Observable_1.Observable));\n    exports.BoundCallbackObservable = BoundCallbackObservable;\n    function dispatchNext(arg) {\n        var value = arg.value, subject = arg.subject;\n        subject.next(value);\n        subject.complete();\n    }\n    function dispatchError(arg) {\n        var err = arg.err, subject = arg.subject;\n        subject.error(err);\n    }\n});\n\ndefine('rxjs/observable/bindCallback',[\"require\", \"exports\", \"./BoundCallbackObservable\"], function (require, exports, BoundCallbackObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;\n});\n\ndefine('rxjs/add/observable/bindCallback',[\"require\", \"exports\", \"../../Observable\", \"../../observable/bindCallback\"], function (require, exports, Observable_1, bindCallback_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.bindCallback = bindCallback_1.bindCallback;\n});\n\ndefine('rxjs/observable/BoundNodeCallbackObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/tryCatch\", \"../util/errorObject\", \"../AsyncSubject\"], function (require, exports, tslib_1, Observable_1, tryCatch_1, errorObject_1, AsyncSubject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var BoundNodeCallbackObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(BoundNodeCallbackObservable, _super);\n        function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.callbackFunc = callbackFunc;\n            _this.selector = selector;\n            _this.args = args;\n            _this.context = context;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /* tslint:enable:max-line-length */\n        /**\n         * Converts a Node.js-style callback API to a function that returns an\n         * Observable.\n         *\n         * <span class=\"informal\">It's just like {@link bindCallback}, but the\n         * callback is expected to be of type `callback(error, result)`.</span>\n         *\n         * `bindNodeCallback` is not an operator because its input and output are not\n         * Observables. The input is a function `func` with some parameters, but the\n         * last parameter must be a callback function that `func` calls when it is\n         * done. The callback function is expected to follow Node.js conventions,\n         * where the first argument to the callback is an error object, signaling\n         * whether call was successful. If that object is passed to callback, it means\n         * something went wrong.\n         *\n         * The output of `bindNodeCallback` is a function that takes the same\n         * parameters as `func`, except the last one (the callback). When the output\n         * function is called with arguments, it will return an Observable.\n         * If `func` calls its callback with error parameter present, Observable will\n         * error with that value as well. If error parameter is not passed, Observable will emit\n         * second parameter. If there are more parameters (third and so on),\n         * Observable will emit an array with all arguments, except first error argument.\n         *\n         * Optionally `bindNodeCallback` accepts selector function, which allows you to\n         * make resulting Observable emit value computed by selector, instead of regular\n         * callback arguments. It works similarly to {@link bindCallback} selector, but\n         * Node.js-style error argument will never be passed to that function.\n         *\n         * Note that `func` will not be called at the same time output function is,\n         * but rather whenever resulting Observable is subscribed. By default call to\n         * `func` will happen synchronously after subscription, but that can be changed\n         * with proper {@link Scheduler} provided as optional third parameter. Scheduler\n         * can also control when values from callback will be emitted by Observable.\n         * To find out more, check out documentation for {@link bindCallback}, where\n         * Scheduler works exactly the same.\n         *\n         * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n         * of returned function, when it is called.\n         *\n         * After Observable emits value, it will complete immediately. This means\n         * even if `func` calls callback again, values from second and consecutive\n         * calls will never appear on the stream. If you need to handle functions\n         * that call callbacks multiple times, check out {@link fromEvent} or\n         * {@link fromEventPattern} instead.\n         *\n         * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n         * \"Node.js-style\" callbacks are just a convention, so if you write for\n         * browsers or any other environment and API you use implements that callback style,\n         * `bindNodeCallback` can be safely used on that API functions as well.\n         *\n         * Remember that Error object passed to callback does not have to be an instance\n         * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n         * Error parameter of callback function is interpreted as \"present\", when value\n         * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n         * string or boolean `true`. In all of these cases resulting Observable would error\n         * with that value. This means usually regular style callbacks will fail very often when\n         * `bindNodeCallback` is used. If your Observable errors much more often then you\n         * would expect, check if callback really is called in Node.js-style and, if not,\n         * switch to {@link bindCallback} instead.\n         *\n         * Note that even if error parameter is technically present in callback, but its value\n         * is falsy, it still won't appear in array emitted by Observable or in selector function.\n         *\n         *\n         * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n         * import * as fs from 'fs';\n         * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n         * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         *\n         * @example <caption>Use on function calling callback with multiple arguments</caption>\n         * someFunction((err, a, b) => {\n         *   console.log(err); // null\n         *   console.log(a); // 5\n         *   console.log(b); // \"some string\"\n         * });\n         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n         * boundSomeFunction()\n         * .subscribe(value => {\n         *   console.log(value); // [5, \"some string\"]\n         * });\n         *\n         *\n         * @example <caption>Use with selector function</caption>\n         * someFunction((err, a, b) => {\n         *   console.log(err); // undefined\n         *   console.log(a); // \"abc\"\n         *   console.log(b); // \"DEF\"\n         * });\n         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);\n         * boundSomeFunction()\n         * .subscribe(value => {\n         *   console.log(value); // \"abcDEF\"\n         * });\n         *\n         *\n         * @example <caption>Use on function calling callback in regular style</caption>\n         * someFunction(a => {\n         *   console.log(a); // 5\n         * });\n         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n         * boundSomeFunction()\n         * .subscribe(\n         *   value => {}             // never gets called\n         *   err => console.log(err) // 5\n         *);\n         *\n         *\n         * @see {@link bindCallback}\n         * @see {@link from}\n         * @see {@link fromPromise}\n         *\n         * @param {function} func Function with a Node.js-style callback as the last parameter.\n         * @param {function} [selector] A function which takes the arguments from the\n         * callback and maps those to a value to emit on the output Observable.\n         * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n         * callbacks.\n         * @return {function(...params: *): Observable} A function which returns the\n         * Observable that delivers the same values the Node.js callback would\n         * deliver.\n         * @static true\n         * @name bindNodeCallback\n         * @owner Observable\n         */\n        BoundNodeCallbackObservable.create = function (func, selector, scheduler) {\n            if (selector === void 0) { selector = undefined; }\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);\n            };\n        };\n        BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {\n            var callbackFunc = this.callbackFunc;\n            var args = this.args;\n            var scheduler = this.scheduler;\n            var subject = this.subject;\n            if (!scheduler) {\n                if (!subject) {\n                    subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                    var handler = function handlerFn() {\n                        var innerArgs = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            innerArgs[_i] = arguments[_i];\n                        }\n                        var source = handlerFn.source;\n                        var selector = source.selector, subject = source.subject;\n                        var err = innerArgs.shift();\n                        if (err) {\n                            subject.error(err);\n                        }\n                        else if (selector) {\n                            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                            if (result_1 === errorObject_1.errorObject) {\n                                subject.error(errorObject_1.errorObject.e);\n                            }\n                            else {\n                                subject.next(result_1);\n                                subject.complete();\n                            }\n                        }\n                        else {\n                            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                            subject.complete();\n                        }\n                    };\n                    // use named function instance to avoid closure.\n                    handler.source = this;\n                    var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                    if (result === errorObject_1.errorObject) {\n                        subject.error(errorObject_1.errorObject.e);\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n            }\n        };\n        return BoundNodeCallbackObservable;\n    }(Observable_1.Observable));\n    exports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;\n    function dispatch(state) {\n        var self = this;\n        var source = state.source, subscriber = state.subscriber, context = state.context;\n        // XXX: cast to `any` to access to the private field in `source`.\n        var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;\n        var subject = source.subject;\n        if (!subject) {\n            subject = source.subject = new AsyncSubject_1.AsyncSubject();\n            var handler = function handlerFn() {\n                var innerArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    innerArgs[_i] = arguments[_i];\n                }\n                var source = handlerFn.source;\n                var selector = source.selector, subject = source.subject;\n                var err = innerArgs.shift();\n                if (err) {\n                    self.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\n                }\n                else if (selector) {\n                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                    if (result_2 === errorObject_1.errorObject) {\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                    }\n                    else {\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                    }\n                }\n                else {\n                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                }\n            };\n            // use named function to pass values in without closure\n            handler.source = source;\n            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n            if (result === errorObject_1.errorObject) {\n                self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n            }\n        }\n        self.add(subject.subscribe(subscriber));\n    }\n    function dispatchNext(arg) {\n        var value = arg.value, subject = arg.subject;\n        subject.next(value);\n        subject.complete();\n    }\n    function dispatchError(arg) {\n        var err = arg.err, subject = arg.subject;\n        subject.error(err);\n    }\n});\n\ndefine('rxjs/observable/bindNodeCallback',[\"require\", \"exports\", \"./BoundNodeCallbackObservable\"], function (require, exports, BoundNodeCallbackObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;\n});\n\ndefine('rxjs/add/observable/bindNodeCallback',[\"require\", \"exports\", \"../../Observable\", \"../../observable/bindNodeCallback\"], function (require, exports, Observable_1, bindNodeCallback_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;\n});\n\ndefine('rxjs/observable/combineLatest',[\"require\", \"exports\", \"../util/isScheduler\", \"../util/isArray\", \"./ArrayObservable\", \"../operators/combineLatest\"], function (require, exports, isScheduler_1, isArray_1, ArrayObservable_1, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines multiple Observables to create an Observable whose values are\n     * calculated from the latest values of each of its input Observables.\n     *\n     * <span class=\"informal\">Whenever any input Observable emits a value, it\n     * computes a formula using the latest values from all the inputs, then emits\n     * the output of that formula.</span>\n     *\n     * <img src=\"./img/combineLatest.png\" width=\"100%\">\n     *\n     * `combineLatest` combines the values from all the Observables passed as\n     * arguments. This is done by subscribing to each Observable in order and,\n     * whenever any Observable emits, collecting an array of the most recent\n     * values from each Observable. So if you pass `n` Observables to operator,\n     * returned Observable will always emit an array of `n` values, in order\n     * corresponding to order of passed Observables (value from the first Observable\n     * on the first place and so on).\n     *\n     * Static version of `combineLatest` accepts either an array of Observables\n     * or each Observable can be put directly as an argument. Note that array of\n     * Observables is good choice, if you don't know beforehand how many Observables\n     * you will combine. Passing empty array will result in Observable that\n     * completes immediately.\n     *\n     * To ensure output array has always the same length, `combineLatest` will\n     * actually wait for all input Observables to emit at least once,\n     * before it starts emitting results. This means if some Observable emits\n     * values before other Observables started emitting, all that values but last\n     * will be lost. On the other hand, is some Observable does not emit value but\n     * completes, resulting Observable will complete at the same moment without\n     * emitting anything, since it will be now impossible to include value from\n     * completed Observable in resulting array. Also, if some input Observable does\n     * not emit any value and never completes, `combineLatest` will also never emit\n     * and never complete, since, again, it will wait for all streams to emit some\n     * value.\n     *\n     * If at least one Observable was passed to `combineLatest` and all passed Observables\n     * emitted something, resulting Observable will complete when all combined\n     * streams complete. So even if some Observable completes, result of\n     * `combineLatest` will still emit values when other Observables do. In case\n     * of completed Observable, its value from now on will always be the last\n     * emitted value. On the other hand, if any Observable errors, `combineLatest`\n     * will error immediately as well, and all other Observables will be unsubscribed.\n     *\n     * `combineLatest` accepts as optional parameter `project` function, which takes\n     * as arguments all values that would normally be emitted by resulting Observable.\n     * `project` can return any kind of value, which will be then emitted by Observable\n     * instead of default array. Note that `project` does not take as argument that array\n     * of values, but values themselves. That means default `project` can be imagined\n     * as function that takes all its arguments and puts them into an array.\n     *\n     *\n     * @example <caption>Combine two timer Observables</caption>\n     * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n     * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n     * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\n     * combinedTimers.subscribe(value => console.log(value));\n     * // Logs\n     * // [0, 0] after 0.5s\n     * // [1, 0] after 1s\n     * // [1, 1] after 1.5s\n     * // [2, 1] after 2s\n     *\n     *\n     * @example <caption>Combine an array of Observables</caption>\n     * const observables = [1, 5, 10].map(\n     *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds\n     * );\n     * const combined = Rx.Observable.combineLatest(observables);\n     * combined.subscribe(value => console.log(value));\n     * // Logs\n     * // [0, 0, 0] immediately\n     * // [1, 0, 0] after 1s\n     * // [1, 5, 0] after 5s\n     * // [1, 5, 10] after 10s\n     *\n     *\n     * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>\n     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n     * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n     * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\n     * bmi.subscribe(x => console.log('BMI is ' + x));\n     *\n     * // With output to console:\n     * // BMI is 24.212293388429753\n     * // BMI is 23.93948099205209\n     * // BMI is 23.671253629592222\n     *\n     *\n     * @see {@link combineAll}\n     * @see {@link merge}\n     * @see {@link withLatestFrom}\n     *\n     * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n     * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n     * More than one input Observables may be given as arguments\n     * or an array of Observables may be given as the first argument.\n     * @param {function} [project] An optional function to project the values from\n     * the combined latest values into a new value on the output Observable.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n     * each input Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @static true\n     * @name combineLatest\n     * @owner Observable\n     */\n    function combineLatest() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        var project = null;\n        var scheduler = null;\n        if (isScheduler_1.isScheduler(observables[observables.length - 1])) {\n            scheduler = observables.pop();\n        }\n        if (typeof observables[observables.length - 1] === 'function') {\n            project = observables.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));\n    }\n    exports.combineLatest = combineLatest;\n});\n\ndefine('rxjs/add/observable/combineLatest',[\"require\", \"exports\", \"../../Observable\", \"../../observable/combineLatest\"], function (require, exports, Observable_1, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;\n});\n\ndefine('rxjs/add/observable/concat',[\"require\", \"exports\", \"../../Observable\", \"../../observable/concat\"], function (require, exports, Observable_1, concat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.concat = concat_1.concat;\n});\n\ndefine('rxjs/observable/DeferObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Observable_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var DeferObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(DeferObservable, _super);\n        function DeferObservable(observableFactory) {\n            var _this = _super.call(this) || this;\n            _this.observableFactory = observableFactory;\n            return _this;\n        }\n        /**\n         * Creates an Observable that, on subscribe, calls an Observable factory to\n         * make an Observable for each new Observer.\n         *\n         * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n         * is subscribed.\n         * </span>\n         *\n         * <img src=\"./img/defer.png\" width=\"100%\">\n         *\n         * `defer` allows you to create the Observable only when the Observer\n         * subscribes, and create a fresh Observable for each Observer. It waits until\n         * an Observer subscribes to it, and then it generates an Observable,\n         * typically with an Observable factory function. It does this afresh for each\n         * subscriber, so although each subscriber may think it is subscribing to the\n         * same Observable, in fact each subscriber gets its own individual\n         * Observable.\n         *\n         * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n         * var clicksOrInterval = Rx.Observable.defer(function () {\n         *   if (Math.random() > 0.5) {\n         *     return Rx.Observable.fromEvent(document, 'click');\n         *   } else {\n         *     return Rx.Observable.interval(1000);\n         *   }\n         * });\n         * clicksOrInterval.subscribe(x => console.log(x));\n         *\n         * // Results in the following behavior:\n         * // If the result of Math.random() is greater than 0.5 it will listen\n         * // for clicks anywhere on the \"document\"; when document is clicked it\n         * // will log a MouseEvent object to the console. If the result is less\n         * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n         *\n         * @see {@link create}\n         *\n         * @param {function(): SubscribableOrPromise} observableFactory The Observable\n         * factory function to invoke for each Observer that subscribes to the output\n         * Observable. May also return a Promise, which will be converted on the fly\n         * to an Observable.\n         * @return {Observable} An Observable whose Observers' subscriptions trigger\n         * an invocation of the given Observable factory function.\n         * @static true\n         * @name defer\n         * @owner Observable\n         */\n        DeferObservable.create = function (observableFactory) {\n            return new DeferObservable(observableFactory);\n        };\n        DeferObservable.prototype._subscribe = function (subscriber) {\n            return new DeferSubscriber(subscriber, this.observableFactory);\n        };\n        return DeferObservable;\n    }(Observable_1.Observable));\n    exports.DeferObservable = DeferObservable;\n    var DeferSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DeferSubscriber, _super);\n        function DeferSubscriber(destination, factory) {\n            var _this = _super.call(this, destination) || this;\n            _this.factory = factory;\n            _this.tryDefer();\n            return _this;\n        }\n        DeferSubscriber.prototype.tryDefer = function () {\n            try {\n                this._callFactory();\n            }\n            catch (err) {\n                this._error(err);\n            }\n        };\n        DeferSubscriber.prototype._callFactory = function () {\n            var result = this.factory();\n            if (result) {\n                this.add(subscribeToResult_1.subscribeToResult(this, result));\n            }\n        };\n        return DeferSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/defer',[\"require\", \"exports\", \"./DeferObservable\"], function (require, exports, DeferObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.defer = DeferObservable_1.DeferObservable.create;\n});\n\ndefine('rxjs/add/observable/defer',[\"require\", \"exports\", \"../../Observable\", \"../../observable/defer\"], function (require, exports, Observable_1, defer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.defer = defer_1.defer;\n});\n\ndefine('rxjs/observable/empty',[\"require\", \"exports\", \"./EmptyObservable\"], function (require, exports, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.empty = EmptyObservable_1.EmptyObservable.create;\n});\n\ndefine('rxjs/add/observable/empty',[\"require\", \"exports\", \"../../Observable\", \"../../observable/empty\"], function (require, exports, Observable_1, empty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.empty = empty_1.empty;\n});\n\ndefine('rxjs/observable/ForkJoinObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"./EmptyObservable\", \"../util/isArray\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Observable_1, EmptyObservable_1, isArray_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ForkJoinObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ForkJoinObservable, _super);\n        function ForkJoinObservable(sources, resultSelector) {\n            var _this = _super.call(this) || this;\n            _this.sources = sources;\n            _this.resultSelector = resultSelector;\n            return _this;\n        }\n        /* tslint:enable:max-line-length */\n        /**\n         * Joins last values emitted by passed Observables.\n         *\n         * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n         *\n         * <img src=\"./img/forkJoin.png\" width=\"100%\">\n         *\n         * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n         * or directly as arguments. If no input Observables are provided, resulting stream will complete\n         * immediately.\n         *\n         * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n         * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n         * array will have `n` values, where first value is the last thing emitted by the first Observable,\n         * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n         * not emit more than once and it will complete after that. If you need to emit combined values not only\n         * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n         * or {@link zip} instead.\n         *\n         * In order for resulting array to have the same length as the number of input Observables, whenever any of\n         * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n         * and it will not emit anything either, even if it already has some last values from other Observables.\n         * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n         * unless at any point some other Observable completes without emitting value, which brings us back to\n         * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n         * have to emit something at least once and complete.\n         *\n         * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n         * will be immediately unsubscribed.\n         *\n         * Optionally `forkJoin` accepts project function, that will be called with values which normally\n         * would land in emitted array. Whatever is returned by project function, will appear in output\n         * Observable instead. This means that default project can be thought of as a function that takes\n         * all its arguments and puts them into an array. Note that project function will be called only\n         * when output Observable is supposed to emit a result.\n         *\n         * @example <caption>Use forkJoin with operator emitting immediately</caption>\n         * const observable = Rx.Observable.forkJoin(\n         *   Rx.Observable.of(1, 2, 3, 4),\n         *   Rx.Observable.of(5, 6, 7, 8)\n         * );\n         * observable.subscribe(\n         *   value => console.log(value),\n         *   err => {},\n         *   () => console.log('This is how it ends!')\n         * );\n         *\n         * // Logs:\n         * // [4, 8]\n         * // \"This is how it ends!\"\n         *\n         *\n         * @example <caption>Use forkJoin with operator emitting after some time</caption>\n         * const observable = Rx.Observable.forkJoin(\n         *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n         *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n         * );\n         * observable.subscribe(\n         *   value => console.log(value),\n         *   err => {},\n         *   () => console.log('This is how it ends!')\n         * );\n         *\n         * // Logs:\n         * // [2, 3] after 3 seconds\n         * // \"This is how it ends!\" immediately after\n         *\n         *\n         * @example <caption>Use forkJoin with project function</caption>\n         * const observable = Rx.Observable.forkJoin(\n         *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n         *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n         *   (n, m) => n + m\n         * );\n         * observable.subscribe(\n         *   value => console.log(value),\n         *   err => {},\n         *   () => console.log('This is how it ends!')\n         * );\n         *\n         * // Logs:\n         * // 5 after 3 seconds\n         * // \"This is how it ends!\" immediately after\n         *\n         * @see {@link combineLatest}\n         * @see {@link zip}\n         *\n         * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n         * passed directly to the operator.\n         * @param {function} [project] Function that takes values emitted by input Observables and returns value\n         * that will appear in resulting Observable instead of default array.\n         * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n         * or value from project function.\n         * @static true\n         * @name forkJoin\n         * @owner Observable\n         */\n        ForkJoinObservable.create = function () {\n            var sources = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                sources[_i] = arguments[_i];\n            }\n            if (sources === null || arguments.length === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            var resultSelector = null;\n            if (typeof sources[sources.length - 1] === 'function') {\n                resultSelector = sources.pop();\n            }\n            // if the first and only other argument besides the resultSelector is an array\n            // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n            if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n                sources = sources[0];\n            }\n            if (sources.length === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            return new ForkJoinObservable(sources, resultSelector);\n        };\n        ForkJoinObservable.prototype._subscribe = function (subscriber) {\n            return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n        };\n        return ForkJoinObservable;\n    }(Observable_1.Observable));\n    exports.ForkJoinObservable = ForkJoinObservable;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ForkJoinSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ForkJoinSubscriber, _super);\n        function ForkJoinSubscriber(destination, sources, resultSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.sources = sources;\n            _this.resultSelector = resultSelector;\n            _this.completed = 0;\n            _this.haveValues = 0;\n            var len = sources.length;\n            _this.total = len;\n            _this.values = new Array(len);\n            for (var i = 0; i < len; i++) {\n                var source = sources[i];\n                var innerSubscription = subscribeToResult_1.subscribeToResult(_this, source, null, i);\n                if (innerSubscription) {\n                    innerSubscription.outerIndex = i;\n                    _this.add(innerSubscription);\n                }\n            }\n            return _this;\n        }\n        ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.values[outerIndex] = innerValue;\n            if (!innerSub._hasValue) {\n                innerSub._hasValue = true;\n                this.haveValues++;\n            }\n        };\n        ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n            var destination = this.destination;\n            var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n            var len = values.length;\n            if (!innerSub._hasValue) {\n                destination.complete();\n                return;\n            }\n            this.completed++;\n            if (this.completed !== len) {\n                return;\n            }\n            if (haveValues === len) {\n                var value = resultSelector ? resultSelector.apply(this, values) : values;\n                destination.next(value);\n            }\n            destination.complete();\n        };\n        return ForkJoinSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/forkJoin',[\"require\", \"exports\", \"./ForkJoinObservable\"], function (require, exports, ForkJoinObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n});\n\ndefine('rxjs/add/observable/forkJoin',[\"require\", \"exports\", \"../../Observable\", \"../../observable/forkJoin\"], function (require, exports, Observable_1, forkJoin_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n});\n\ndefine('rxjs/add/observable/from',[\"require\", \"exports\", \"../../Observable\", \"../../observable/from\"], function (require, exports, Observable_1, from_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.from = from_1.from;\n});\n\ndefine('rxjs/observable/FromEventObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/tryCatch\", \"../util/isFunction\", \"../util/errorObject\", \"../Subscription\"], function (require, exports, tslib_1, Observable_1, tryCatch_1, isFunction_1, errorObject_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var toString = Object.prototype.toString;\n    function isNodeStyleEventEmitter(sourceObj) {\n        return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n    }\n    function isJQueryStyleEventEmitter(sourceObj) {\n        return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n    }\n    function isNodeList(sourceObj) {\n        return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n    }\n    function isHTMLCollection(sourceObj) {\n        return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n    }\n    function isEventTarget(sourceObj) {\n        return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n    }\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var FromEventObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(FromEventObservable, _super);\n        function FromEventObservable(sourceObj, eventName, selector, options) {\n            var _this = _super.call(this) || this;\n            _this.sourceObj = sourceObj;\n            _this.eventName = eventName;\n            _this.selector = selector;\n            _this.options = options;\n            return _this;\n        }\n        /* tslint:enable:max-line-length */\n        /**\n         * Creates an Observable that emits events of a specific type coming from the\n         * given event target.\n         *\n         * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n         * EventEmitter events or others.</span>\n         *\n         * <img src=\"./img/fromEvent.png\" width=\"100%\">\n         *\n         * `fromEvent` accepts as a first argument event target, which is an object with methods\n         * for registering event handler functions. As a second argument it takes string that indicates\n         * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n         * which are described in detail below. If your event target does not match any of the ones listed,\n         * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n         * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n         * handler functions have different names, but they all accept a string describing event type\n         * and function itself, which will be called whenever said event happens.\n         *\n         * Every time resulting Observable is subscribed, event handler function will be registered\n         * to event target on given event type. When that event fires, value\n         * passed as a first argument to registered function will be emitted by output Observable.\n         * When Observable is unsubscribed, function will be unregistered from event target.\n         *\n         * Note that if event target calls registered function with more than one argument, second\n         * and following arguments will not appear in resulting stream. In order to get access to them,\n         * you can pass to `fromEvent` optional project function, which will be called with all arguments\n         * passed to event handler. Output Observable will then emit value returned by project function,\n         * instead of the usual value.\n         *\n         * Remember that event targets listed below are checked via duck typing. It means that\n         * no matter what kind of object you have and no matter what environment you work in,\n         * you can safely use `fromEvent` on that object if it exposes described methods (provided\n         * of course they behave as was described above). So for example if Node.js library exposes\n         * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n         * a good choice.\n         *\n         * If the API you use is more callback then event handler oriented (subscribed\n         * callback function fires only once and thus there is no need to manually\n         * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n         * instead.\n         *\n         * `fromEvent` supports following types of event targets:\n         *\n         * **DOM EventTarget**\n         *\n         * This is an object with `addEventListener` and `removeEventListener` methods.\n         *\n         * In the browser, `addEventListener` accepts - apart from event type string and event\n         * handler function arguments - optional third parameter, which is either an object or boolean,\n         * both used for additional configuration how and when passed function will be called. When\n         * `fromEvent` is used with event target of that type, you can provide this values\n         * as third parameter as well.\n         *\n         * **Node.js EventEmitter**\n         *\n         * An object with `addListener` and `removeListener` methods.\n         *\n         * **JQuery-style event target**\n         *\n         * An object with `on` and `off` methods\n         *\n         * **DOM NodeList**\n         *\n         * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n         *\n         * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n         * it contains and install event handler function in every of them. When returned Observable\n         * is unsubscribed, function will be removed from all Nodes.\n         *\n         * **DOM HtmlCollection**\n         *\n         * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n         * installed and removed in each of elements.\n         *\n         *\n         * @example <caption>Emits clicks happening on the DOM document</caption>\n         * var clicks = Rx.Observable.fromEvent(document, 'click');\n         * clicks.subscribe(x => console.log(x));\n         *\n         * // Results in:\n         * // MouseEvent object logged to console every time a click\n         * // occurs on the document.\n         *\n         *\n         * @example <caption>Use addEventListener with capture option</caption>\n         * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n         *                                                                          // which will be passed to addEventListener\n         * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n         *\n         * clicksInDocument.subscribe(() => console.log('document'));\n         * clicksInDiv.subscribe(() => console.log('div'));\n         *\n         * // By default events bubble UP in DOM tree, so normally\n         * // when we would click on div in document\n         * // \"div\" would be logged first and then \"document\".\n         * // Since we specified optional `capture` option, document\n         * // will catch event when it goes DOWN DOM tree, so console\n         * // will log \"document\" and then \"div\".\n         *\n         * @see {@link bindCallback}\n         * @see {@link bindNodeCallback}\n         * @see {@link fromEventPattern}\n         *\n         * @param {EventTargetLike} target The DOM EventTarget, Node.js\n         * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n         * @param {string} eventName The event name of interest, being emitted by the\n         * `target`.\n         * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n         * @param {SelectorMethodSignature<T>} [selector] An optional function to\n         * post-process results. It takes the arguments from the event handler and\n         * should return a single value.\n         * @return {Observable<T>}\n         * @static true\n         * @name fromEvent\n         * @owner Observable\n         */\n        FromEventObservable.create = function (target, eventName, options, selector) {\n            if (isFunction_1.isFunction(options)) {\n                selector = options;\n                options = undefined;\n            }\n            return new FromEventObservable(target, eventName, selector, options);\n        };\n        FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n            var unsubscribe;\n            if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n                for (var i = 0, len = sourceObj.length; i < len; i++) {\n                    FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n                }\n            }\n            else if (isEventTarget(sourceObj)) {\n                var source_1 = sourceObj;\n                sourceObj.addEventListener(eventName, handler, options);\n                unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n            }\n            else if (isJQueryStyleEventEmitter(sourceObj)) {\n                var source_2 = sourceObj;\n                sourceObj.on(eventName, handler);\n                unsubscribe = function () { return source_2.off(eventName, handler); };\n            }\n            else if (isNodeStyleEventEmitter(sourceObj)) {\n                var source_3 = sourceObj;\n                sourceObj.addListener(eventName, handler);\n                unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n            }\n            else {\n                throw new TypeError('Invalid event target');\n            }\n            subscriber.add(new Subscription_1.Subscription(unsubscribe));\n        };\n        FromEventObservable.prototype._subscribe = function (subscriber) {\n            var sourceObj = this.sourceObj;\n            var eventName = this.eventName;\n            var options = this.options;\n            var selector = this.selector;\n            var handler = selector ? function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n                if (result === errorObject_1.errorObject) {\n                    subscriber.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    subscriber.next(result);\n                }\n            } : function (e) { return subscriber.next(e); };\n            FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n        };\n        return FromEventObservable;\n    }(Observable_1.Observable));\n    exports.FromEventObservable = FromEventObservable;\n});\n\ndefine('rxjs/observable/fromEvent',[\"require\", \"exports\", \"./FromEventObservable\"], function (require, exports, FromEventObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n});\n\ndefine('rxjs/add/observable/fromEvent',[\"require\", \"exports\", \"../../Observable\", \"../../observable/fromEvent\"], function (require, exports, Observable_1, fromEvent_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n});\n\ndefine('rxjs/observable/FromEventPatternObservable',[\"require\", \"exports\", \"tslib\", \"../util/isFunction\", \"../Observable\", \"../Subscription\"], function (require, exports, tslib_1, isFunction_1, Observable_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var FromEventPatternObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(FromEventPatternObservable, _super);\n        function FromEventPatternObservable(addHandler, removeHandler, selector) {\n            var _this = _super.call(this) || this;\n            _this.addHandler = addHandler;\n            _this.removeHandler = removeHandler;\n            _this.selector = selector;\n            return _this;\n        }\n        /**\n         * Creates an Observable from an API based on addHandler/removeHandler\n         * functions.\n         *\n         * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n         * Observable.</span>\n         *\n         * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n         *\n         * Creates an Observable by using the `addHandler` and `removeHandler`\n         * functions to add and remove the handlers, with an optional selector\n         * function to project the event arguments to a result. The `addHandler` is\n         * called when the output Observable is subscribed, and `removeHandler` is\n         * called when the Subscription is unsubscribed.\n         *\n         * @example <caption>Emits clicks happening on the DOM document</caption>\n         * function addClickHandler(handler) {\n         *   document.addEventListener('click', handler);\n         * }\n         *\n         * function removeClickHandler(handler) {\n         *   document.removeEventListener('click', handler);\n         * }\n         *\n         * var clicks = Rx.Observable.fromEventPattern(\n         *   addClickHandler,\n         *   removeClickHandler\n         * );\n         * clicks.subscribe(x => console.log(x));\n         *\n         * @see {@link from}\n         * @see {@link fromEvent}\n         *\n         * @param {function(handler: Function): any} addHandler A function that takes\n         * a `handler` function as argument and attaches it somehow to the actual\n         * source of events.\n         * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n         * takes a `handler` function as argument and removes it in case it was\n         * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n         * removeHandler function will forward it.\n         * @param {function(...args: any): T} [selector] An optional function to\n         * post-process results. It takes the arguments from the event handler and\n         * should return a single value.\n         * @return {Observable<T>}\n         * @static true\n         * @name fromEventPattern\n         * @owner Observable\n         */\n        FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {\n            return new FromEventPatternObservable(addHandler, removeHandler, selector);\n        };\n        FromEventPatternObservable.prototype._subscribe = function (subscriber) {\n            var _this = this;\n            var removeHandler = this.removeHandler;\n            var handler = !!this.selector ? function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                _this._callSelector(subscriber, args);\n            } : function (e) { subscriber.next(e); };\n            var retValue = this._callAddHandler(handler, subscriber);\n            if (!isFunction_1.isFunction(removeHandler)) {\n                return;\n            }\n            subscriber.add(new Subscription_1.Subscription(function () {\n                //TODO: determine whether or not to forward to error handler\n                removeHandler(handler, retValue);\n            }));\n        };\n        FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {\n            try {\n                var result = this.selector.apply(this, args);\n                subscriber.next(result);\n            }\n            catch (e) {\n                subscriber.error(e);\n            }\n        };\n        FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {\n            try {\n                return this.addHandler(handler) || null;\n            }\n            catch (e) {\n                errorSubscriber.error(e);\n            }\n        };\n        return FromEventPatternObservable;\n    }(Observable_1.Observable));\n    exports.FromEventPatternObservable = FromEventPatternObservable;\n});\n\ndefine('rxjs/observable/fromEventPattern',[\"require\", \"exports\", \"./FromEventPatternObservable\"], function (require, exports, FromEventPatternObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;\n});\n\ndefine('rxjs/add/observable/fromEventPattern',[\"require\", \"exports\", \"../../Observable\", \"../../observable/fromEventPattern\"], function (require, exports, Observable_1, fromEventPattern_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;\n});\n\ndefine('rxjs/observable/fromPromise',[\"require\", \"exports\", \"./PromiseObservable\"], function (require, exports, PromiseObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n});\n\ndefine('rxjs/add/observable/fromPromise',[\"require\", \"exports\", \"../../Observable\", \"../../observable/fromPromise\"], function (require, exports, Observable_1, fromPromise_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;\n});\n\ndefine('rxjs/observable/GenerateObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/isScheduler\"], function (require, exports, tslib_1, Observable_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var selfSelector = function (value) { return value; };\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var GenerateObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(GenerateObservable, _super);\n        function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.initialState = initialState;\n            _this.condition = condition;\n            _this.iterate = iterate;\n            _this.resultSelector = resultSelector;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n            if (arguments.length == 1) {\n                return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);\n            }\n            if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {\n                return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);\n            }\n            return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);\n        };\n        GenerateObservable.prototype._subscribe = function (subscriber) {\n            var state = this.initialState;\n            if (this.scheduler) {\n                return this.scheduler.schedule(GenerateObservable.dispatch, 0, {\n                    subscriber: subscriber,\n                    iterate: this.iterate,\n                    condition: this.condition,\n                    resultSelector: this.resultSelector,\n                    state: state\n                });\n            }\n            var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;\n            do {\n                if (condition) {\n                    var conditionResult = void 0;\n                    try {\n                        conditionResult = condition(state);\n                    }\n                    catch (err) {\n                        subscriber.error(err);\n                        return;\n                    }\n                    if (!conditionResult) {\n                        subscriber.complete();\n                        break;\n                    }\n                }\n                var value = void 0;\n                try {\n                    value = resultSelector(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    break;\n                }\n                try {\n                    state = iterate(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n            } while (true);\n        };\n        GenerateObservable.dispatch = function (state) {\n            var subscriber = state.subscriber, condition = state.condition;\n            if (subscriber.closed) {\n                return;\n            }\n            if (state.needIterate) {\n                try {\n                    state.state = state.iterate(state.state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n            }\n            else {\n                state.needIterate = true;\n            }\n            if (condition) {\n                var conditionResult = void 0;\n                try {\n                    conditionResult = condition(state.state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    return;\n                }\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n            var value;\n            try {\n                value = state.resultSelector(state.state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n            if (subscriber.closed) {\n                return;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                return;\n            }\n            return this.schedule(state);\n        };\n        return GenerateObservable;\n    }(Observable_1.Observable));\n    exports.GenerateObservable = GenerateObservable;\n});\n\ndefine('rxjs/observable/generate',[\"require\", \"exports\", \"./GenerateObservable\"], function (require, exports, GenerateObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.generate = GenerateObservable_1.GenerateObservable.create;\n});\n\ndefine('rxjs/add/observable/generate',[\"require\", \"exports\", \"../../Observable\", \"../../observable/generate\"], function (require, exports, Observable_1, generate_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.generate = generate_1.generate;\n});\n\ndefine('rxjs/observable/IfObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Observable_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var IfObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(IfObservable, _super);\n        function IfObservable(condition, thenSource, elseSource) {\n            var _this = _super.call(this) || this;\n            _this.condition = condition;\n            _this.thenSource = thenSource;\n            _this.elseSource = elseSource;\n            return _this;\n        }\n        IfObservable.create = function (condition, thenSource, elseSource) {\n            return new IfObservable(condition, thenSource, elseSource);\n        };\n        IfObservable.prototype._subscribe = function (subscriber) {\n            var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n            return new IfSubscriber(subscriber, condition, thenSource, elseSource);\n        };\n        return IfObservable;\n    }(Observable_1.Observable));\n    exports.IfObservable = IfObservable;\n    var IfSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(IfSubscriber, _super);\n        function IfSubscriber(destination, condition, thenSource, elseSource) {\n            var _this = _super.call(this, destination) || this;\n            _this.condition = condition;\n            _this.thenSource = thenSource;\n            _this.elseSource = elseSource;\n            _this.tryIf();\n            return _this;\n        }\n        IfSubscriber.prototype.tryIf = function () {\n            var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n            var result;\n            try {\n                result = condition();\n                var source = result ? thenSource : elseSource;\n                if (source) {\n                    this.add(subscribeToResult_1.subscribeToResult(this, source));\n                }\n                else {\n                    this._complete();\n                }\n            }\n            catch (err) {\n                this._error(err);\n            }\n        };\n        return IfSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/if',[\"require\", \"exports\", \"./IfObservable\"], function (require, exports, IfObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports._if = IfObservable_1.IfObservable.create;\n});\n\ndefine('rxjs/add/observable/if',[\"require\", \"exports\", \"../../Observable\", \"../../observable/if\"], function (require, exports, Observable_1, if_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.if = if_1._if;\n});\n\ndefine('rxjs/observable/IntervalObservable',[\"require\", \"exports\", \"tslib\", \"../util/isNumeric\", \"../Observable\", \"../scheduler/async\"], function (require, exports, tslib_1, isNumeric_1, Observable_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var IntervalObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(IntervalObservable, _super);\n        function IntervalObservable(period, scheduler) {\n            if (period === void 0) { period = 0; }\n            if (scheduler === void 0) { scheduler = async_1.async; }\n            var _this = _super.call(this) || this;\n            _this.period = period;\n            _this.scheduler = scheduler;\n            if (!isNumeric_1.isNumeric(period) || period < 0) {\n                _this.period = 0;\n            }\n            if (!scheduler || typeof scheduler.schedule !== 'function') {\n                _this.scheduler = async_1.async;\n            }\n            return _this;\n        }\n        /**\n         * Creates an Observable that emits sequential numbers every specified\n         * interval of time, on a specified IScheduler.\n         *\n         * <span class=\"informal\">Emits incremental numbers periodically in time.\n         * </span>\n         *\n         * <img src=\"./img/interval.png\" width=\"100%\">\n         *\n         * `interval` returns an Observable that emits an infinite sequence of\n         * ascending integers, with a constant interval of time of your choosing\n         * between those emissions. The first emission is not sent immediately, but\n         * only after the first period has passed. By default, this operator uses the\n         * `async` IScheduler to provide a notion of time, but you may pass any\n         * IScheduler to it.\n         *\n         * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n         * var numbers = Rx.Observable.interval(1000);\n         * numbers.subscribe(x => console.log(x));\n         *\n         * @see {@link timer}\n         * @see {@link delay}\n         *\n         * @param {number} [period=0] The interval size in milliseconds (by default)\n         * or the time unit determined by the scheduler's clock.\n         * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n         * the emission of values, and providing a notion of \"time\".\n         * @return {Observable} An Observable that emits a sequential number each time\n         * interval.\n         * @static true\n         * @name interval\n         * @owner Observable\n         */\n        IntervalObservable.create = function (period, scheduler) {\n            if (period === void 0) { period = 0; }\n            if (scheduler === void 0) { scheduler = async_1.async; }\n            return new IntervalObservable(period, scheduler);\n        };\n        IntervalObservable.dispatch = function (state) {\n            var index = state.index, subscriber = state.subscriber, period = state.period;\n            subscriber.next(index);\n            if (subscriber.closed) {\n                return;\n            }\n            state.index += 1;\n            this.schedule(state, period);\n        };\n        IntervalObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var period = this.period;\n            var scheduler = this.scheduler;\n            subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\n                index: index, subscriber: subscriber, period: period\n            }));\n        };\n        return IntervalObservable;\n    }(Observable_1.Observable));\n    exports.IntervalObservable = IntervalObservable;\n});\n\ndefine('rxjs/observable/interval',[\"require\", \"exports\", \"./IntervalObservable\"], function (require, exports, IntervalObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.interval = IntervalObservable_1.IntervalObservable.create;\n});\n\ndefine('rxjs/add/observable/interval',[\"require\", \"exports\", \"../../Observable\", \"../../observable/interval\"], function (require, exports, Observable_1, interval_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.interval = interval_1.interval;\n});\n\ndefine('rxjs/operator/merge',[\"require\", \"exports\", \"../operators/merge\", \"../operators/merge\"], function (require, exports, merge_1, merge_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.mergeStatic = merge_2.mergeStatic;\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which concurrently emits all values from every\n     * given input Observable.\n     *\n     * <span class=\"informal\">Flattens multiple Observables together by blending\n     * their values into one Observable.</span>\n     *\n     * <img src=\"./img/merge.png\" width=\"100%\">\n     *\n     * `merge` subscribes to each given input Observable (either the source or an\n     * Observable given as argument), and simply forwards (without doing any\n     * transformation) all the values from all the input Observables to the output\n     * Observable. The output Observable only completes once all input Observables\n     * have completed. Any error delivered by an input Observable will be immediately\n     * emitted on the output Observable.\n     *\n     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var clicksOrTimer = clicks.merge(timer);\n     * clicksOrTimer.subscribe(x => console.log(x));\n     *\n     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var concurrent = 2; // the argument\n     * var merged = timer1.merge(timer2, timer3, concurrent);\n     * merged.subscribe(x => console.log(x));\n     *\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     *\n     * @param {ObservableInput} other An input Observable to merge with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n     * concurrency of input Observables.\n     * @return {Observable} An Observable that emits items that are the result of\n     * every input Observable.\n     * @method merge\n     * @owner Observable\n     */\n    function merge() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return merge_1.merge.apply(void 0, observables)(this);\n    }\n    exports.merge = merge;\n});\n\ndefine('rxjs/observable/merge',[\"require\", \"exports\", \"../operator/merge\"], function (require, exports, merge_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.merge = merge_1.mergeStatic;\n});\n\ndefine('rxjs/add/observable/merge',[\"require\", \"exports\", \"../../Observable\", \"../../observable/merge\"], function (require, exports, Observable_1, merge_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.merge = merge_1.merge;\n});\n\ndefine('rxjs/add/observable/race',[\"require\", \"exports\", \"../../Observable\", \"../../observable/race\"], function (require, exports, Observable_1, race_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.race = race_1.race;\n});\n\ndefine('rxjs/observable/NeverObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/noop\"], function (require, exports, tslib_1, Observable_1, noop_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var NeverObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(NeverObservable, _super);\n        function NeverObservable() {\n            return _super.call(this) || this;\n        }\n        /**\n         * Creates an Observable that emits no items to the Observer.\n         *\n         * <span class=\"informal\">An Observable that never emits anything.</span>\n         *\n         * <img src=\"./img/never.png\" width=\"100%\">\n         *\n         * This static operator is useful for creating a simple Observable that emits\n         * neither values nor errors nor the completion notification. It can be used\n         * for testing purposes or for composing with other Observables. Please note\n         * that by never emitting a complete notification, this Observable keeps the\n         * subscription from being disposed automatically. Subscriptions need to be\n         * manually disposed.\n         *\n         * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>\n         * function info() {\n         *   console.log('Will not be called');\n         * }\n         * var result = Rx.Observable.never().startWith(7);\n         * result.subscribe(x => console.log(x), info, info);\n         *\n         * @see {@link create}\n         * @see {@link empty}\n         * @see {@link of}\n         * @see {@link throw}\n         *\n         * @return {Observable} A \"never\" Observable: never emits anything.\n         * @static true\n         * @name never\n         * @owner Observable\n         */\n        NeverObservable.create = function () {\n            return new NeverObservable();\n        };\n        NeverObservable.prototype._subscribe = function (subscriber) {\n            noop_1.noop();\n        };\n        return NeverObservable;\n    }(Observable_1.Observable));\n    exports.NeverObservable = NeverObservable;\n});\n\ndefine('rxjs/observable/never',[\"require\", \"exports\", \"./NeverObservable\"], function (require, exports, NeverObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.never = NeverObservable_1.NeverObservable.create;\n});\n\ndefine('rxjs/add/observable/never',[\"require\", \"exports\", \"../../Observable\", \"../../observable/never\"], function (require, exports, Observable_1, never_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.never = never_1.never;\n});\n\ndefine('rxjs/add/observable/of',[\"require\", \"exports\", \"../../Observable\", \"../../observable/of\"], function (require, exports, Observable_1, of_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.of = of_1.of;\n});\n\ndefine('rxjs/observable/onErrorResumeNext',[\"require\", \"exports\", \"../operators/onErrorResumeNext\"], function (require, exports, onErrorResumeNext_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;\n});\n\ndefine('rxjs/add/observable/onErrorResumeNext',[\"require\", \"exports\", \"../../Observable\", \"../../observable/onErrorResumeNext\"], function (require, exports, Observable_1, onErrorResumeNext_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n});\n\ndefine('rxjs/observable/PairsObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function dispatch(state) {\n        var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;\n        if (index === length) {\n            subscriber.complete();\n            return;\n        }\n        var key = keys[index];\n        subscriber.next([key, obj[key]]);\n        state.index = index + 1;\n        this.schedule(state);\n    }\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var PairsObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(PairsObservable, _super);\n        function PairsObservable(obj, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.obj = obj;\n            _this.scheduler = scheduler;\n            _this.keys = Object.keys(obj);\n            return _this;\n        }\n        /**\n         * Convert an object into an observable sequence of [key, value] pairs\n         * using an optional IScheduler to enumerate the object.\n         *\n         * @example <caption>Converts a javascript object to an Observable</caption>\n         * var obj = {\n         *   foo: 42,\n         *   bar: 56,\n         *   baz: 78\n         * };\n         *\n         * var source = Rx.Observable.pairs(obj);\n         *\n         * var subscription = source.subscribe(\n         *   function (x) {\n         *     console.log('Next: %s', x);\n         *   },\n         *   function (err) {\n         *     console.log('Error: %s', err);\n         *   },\n         *   function () {\n         *     console.log('Completed');\n         *   });\n         *\n         * @param {Object} obj The object to inspect and turn into an\n         * Observable sequence.\n         * @param {Scheduler} [scheduler] An optional IScheduler to run the\n         * enumeration of the input sequence on.\n         * @returns {(Observable<Array<string | T>>)} An observable sequence of\n         * [key, value] pairs from the object.\n         */\n        PairsObservable.create = function (obj, scheduler) {\n            return new PairsObservable(obj, scheduler);\n        };\n        PairsObservable.prototype._subscribe = function (subscriber) {\n            var _a = this, keys = _a.keys, scheduler = _a.scheduler;\n            var length = keys.length;\n            if (scheduler) {\n                return scheduler.schedule(dispatch, 0, {\n                    obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber\n                });\n            }\n            else {\n                for (var idx = 0; idx < length; idx++) {\n                    var key = keys[idx];\n                    subscriber.next([key, this.obj[key]]);\n                }\n                subscriber.complete();\n            }\n        };\n        return PairsObservable;\n    }(Observable_1.Observable));\n    exports.PairsObservable = PairsObservable;\n});\n\ndefine('rxjs/observable/pairs',[\"require\", \"exports\", \"./PairsObservable\"], function (require, exports, PairsObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.pairs = PairsObservable_1.PairsObservable.create;\n});\n\ndefine('rxjs/add/observable/pairs',[\"require\", \"exports\", \"../../Observable\", \"../../observable/pairs\"], function (require, exports, Observable_1, pairs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.pairs = pairs_1.pairs;\n});\n\ndefine('rxjs/observable/RangeObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var RangeObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(RangeObservable, _super);\n        function RangeObservable(start, count, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.start = start;\n            _this._count = count;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Creates an Observable that emits a sequence of numbers within a specified\n         * range.\n         *\n         * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n         *\n         * <img src=\"./img/range.png\" width=\"100%\">\n         *\n         * `range` operator emits a range of sequential integers, in order, where you\n         * select the `start` of the range and its `length`. By default, uses no\n         * IScheduler and just delivers the notifications synchronously, but may use\n         * an optional IScheduler to regulate those deliveries.\n         *\n         * @example <caption>Emits the numbers 1 to 10</caption>\n         * var numbers = Rx.Observable.range(1, 10);\n         * numbers.subscribe(x => console.log(x));\n         *\n         * @see {@link timer}\n         * @see {@link interval}\n         *\n         * @param {number} [start=0] The value of the first integer in the sequence.\n         * @param {number} [count=0] The number of sequential integers to generate.\n         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n         * the emissions of the notifications.\n         * @return {Observable} An Observable of numbers that emits a finite range of\n         * sequential integers.\n         * @static true\n         * @name range\n         * @owner Observable\n         */\n        RangeObservable.create = function (start, count, scheduler) {\n            if (start === void 0) { start = 0; }\n            if (count === void 0) { count = 0; }\n            return new RangeObservable(start, count, scheduler);\n        };\n        RangeObservable.dispatch = function (state) {\n            var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\n            if (index >= count) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(start);\n            if (subscriber.closed) {\n                return;\n            }\n            state.index = index + 1;\n            state.start = start + 1;\n            this.schedule(state);\n        };\n        RangeObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var start = this.start;\n            var count = this._count;\n            var scheduler = this.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(RangeObservable.dispatch, 0, {\n                    index: index, count: count, start: start, subscriber: subscriber\n                });\n            }\n            else {\n                do {\n                    if (index++ >= count) {\n                        subscriber.complete();\n                        break;\n                    }\n                    subscriber.next(start++);\n                    if (subscriber.closed) {\n                        break;\n                    }\n                } while (true);\n            }\n        };\n        return RangeObservable;\n    }(Observable_1.Observable));\n    exports.RangeObservable = RangeObservable;\n});\n\ndefine('rxjs/observable/range',[\"require\", \"exports\", \"./RangeObservable\"], function (require, exports, RangeObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.range = RangeObservable_1.RangeObservable.create;\n});\n\ndefine('rxjs/add/observable/range',[\"require\", \"exports\", \"../../Observable\", \"../../observable/range\"], function (require, exports, Observable_1, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.range = range_1.range;\n});\n\ndefine('rxjs/observable/UsingObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Observable_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var UsingObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(UsingObservable, _super);\n        function UsingObservable(resourceFactory, observableFactory) {\n            var _this = _super.call(this) || this;\n            _this.resourceFactory = resourceFactory;\n            _this.observableFactory = observableFactory;\n            return _this;\n        }\n        UsingObservable.create = function (resourceFactory, observableFactory) {\n            return new UsingObservable(resourceFactory, observableFactory);\n        };\n        UsingObservable.prototype._subscribe = function (subscriber) {\n            var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;\n            var resource;\n            try {\n                resource = resourceFactory();\n                return new UsingSubscriber(subscriber, resource, observableFactory);\n            }\n            catch (err) {\n                subscriber.error(err);\n            }\n        };\n        return UsingObservable;\n    }(Observable_1.Observable));\n    exports.UsingObservable = UsingObservable;\n    var UsingSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(UsingSubscriber, _super);\n        function UsingSubscriber(destination, resource, observableFactory) {\n            var _this = _super.call(this, destination) || this;\n            _this.resource = resource;\n            _this.observableFactory = observableFactory;\n            destination.add(resource);\n            _this.tryUse();\n            return _this;\n        }\n        UsingSubscriber.prototype.tryUse = function () {\n            try {\n                var source = this.observableFactory.call(this, this.resource);\n                if (source) {\n                    this.add(subscribeToResult_1.subscribeToResult(this, source));\n                }\n            }\n            catch (err) {\n                this._error(err);\n            }\n        };\n        return UsingSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/using',[\"require\", \"exports\", \"./UsingObservable\"], function (require, exports, UsingObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.using = UsingObservable_1.UsingObservable.create;\n});\n\ndefine('rxjs/add/observable/using',[\"require\", \"exports\", \"../../Observable\", \"../../observable/using\"], function (require, exports, Observable_1, using_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.using = using_1.using;\n});\n\ndefine('rxjs/observable/ErrorObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ErrorObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ErrorObservable, _super);\n        function ErrorObservable(error, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.error = error;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Creates an Observable that emits no items to the Observer and immediately\n         * emits an error notification.\n         *\n         * <span class=\"informal\">Just emits 'error', and nothing else.\n         * </span>\n         *\n         * <img src=\"./img/throw.png\" width=\"100%\">\n         *\n         * This static operator is useful for creating a simple Observable that only\n         * emits the error notification. It can be used for composing with other\n         * Observables, such as in a {@link mergeMap}.\n         *\n         * @example <caption>Emit the number 7, then emit an error.</caption>\n         * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n         * var interval = Rx.Observable.interval(1000);\n         * var result = interval.mergeMap(x =>\n         *   x === 13 ?\n         *     Rx.Observable.throw('Thirteens are bad') :\n         *     Rx.Observable.of('a', 'b', 'c')\n         * );\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         * @see {@link create}\n         * @see {@link empty}\n         * @see {@link never}\n         * @see {@link of}\n         *\n         * @param {any} error The particular Error to pass to the error notification.\n         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n         * the emission of the error notification.\n         * @return {Observable} An error Observable: emits only the error notification\n         * using the given error argument.\n         * @static true\n         * @name throw\n         * @owner Observable\n         */\n        ErrorObservable.create = function (error, scheduler) {\n            return new ErrorObservable(error, scheduler);\n        };\n        ErrorObservable.dispatch = function (arg) {\n            var error = arg.error, subscriber = arg.subscriber;\n            subscriber.error(error);\n        };\n        ErrorObservable.prototype._subscribe = function (subscriber) {\n            var error = this.error;\n            var scheduler = this.scheduler;\n            subscriber.syncErrorThrowable = true;\n            if (scheduler) {\n                return scheduler.schedule(ErrorObservable.dispatch, 0, {\n                    error: error, subscriber: subscriber\n                });\n            }\n            else {\n                subscriber.error(error);\n            }\n        };\n        return ErrorObservable;\n    }(Observable_1.Observable));\n    exports.ErrorObservable = ErrorObservable;\n});\n\ndefine('rxjs/observable/throw',[\"require\", \"exports\", \"./ErrorObservable\"], function (require, exports, ErrorObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports._throw = ErrorObservable_1.ErrorObservable.create;\n});\n\ndefine('rxjs/add/observable/throw',[\"require\", \"exports\", \"../../Observable\", \"../../observable/throw\"], function (require, exports, Observable_1, throw_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.throw = throw_1._throw;\n});\n\ndefine('rxjs/add/observable/timer',[\"require\", \"exports\", \"../../Observable\", \"../../observable/timer\"], function (require, exports, Observable_1, timer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.timer = timer_1.timer;\n});\n\ndefine('rxjs/observable/zip',[\"require\", \"exports\", \"../operators/zip\"], function (require, exports, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.zip = zip_1.zipStatic;\n});\n\ndefine('rxjs/add/observable/zip',[\"require\", \"exports\", \"../../Observable\", \"../../observable/zip\"], function (require, exports, Observable_1, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.zip = zip_1.zip;\n});\n\ndefine('rxjs/observable/dom/ajax',[\"require\", \"exports\", \"./AjaxObservable\"], function (require, exports, AjaxObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ajax = AjaxObservable_1.AjaxObservable.create;\n});\n\ndefine('rxjs/add/observable/dom/ajax',[\"require\", \"exports\", \"../../../Observable\", \"../../../observable/dom/ajax\"], function (require, exports, Observable_1, ajax_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.ajax = ajax_1.ajax;\n});\n\ndefine('rxjs/util/assign',[\"require\", \"exports\", \"./root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function assignImpl(target) {\n        var sources = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            sources[_i - 1] = arguments[_i];\n        }\n        var len = sources.length;\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            for (var k in source) {\n                if (source.hasOwnProperty(k)) {\n                    target[k] = source[k];\n                }\n            }\n        }\n        return target;\n    }\n    exports.assignImpl = assignImpl;\n    ;\n    function getAssign(root) {\n        return root.Object.assign || assignImpl;\n    }\n    exports.getAssign = getAssign;\n    exports.assign = getAssign(root_1.root);\n});\n\ndefine('rxjs/observable/dom/WebSocketSubject',[\"require\", \"exports\", \"tslib\", \"../../Subject\", \"../../Subscriber\", \"../../Observable\", \"../../Subscription\", \"../../util/root\", \"../../ReplaySubject\", \"../../util/tryCatch\", \"../../util/errorObject\", \"../../util/assign\"], function (require, exports, tslib_1, Subject_1, Subscriber_1, Observable_1, Subscription_1, root_1, ReplaySubject_1, tryCatch_1, errorObject_1, assign_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var WebSocketSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(WebSocketSubject, _super);\n        function WebSocketSubject(urlConfigOrSource, destination) {\n            var _this = this;\n            if (urlConfigOrSource instanceof Observable_1.Observable) {\n                _this = _super.call(this, destination, urlConfigOrSource) || this;\n            }\n            else {\n                _this = _super.call(this) || this;\n                _this.WebSocketCtor = root_1.root.WebSocket;\n                _this._output = new Subject_1.Subject();\n                if (typeof urlConfigOrSource === 'string') {\n                    _this.url = urlConfigOrSource;\n                }\n                else {\n                    // WARNING: config object could override important members here.\n                    assign_1.assign(_this, urlConfigOrSource);\n                }\n                if (!_this.WebSocketCtor) {\n                    throw new Error('no WebSocket constructor can be found');\n                }\n                _this.destination = new ReplaySubject_1.ReplaySubject();\n            }\n            return _this;\n        }\n        WebSocketSubject.prototype.resultSelector = function (e) {\n            return JSON.parse(e.data);\n        };\n        /**\n         * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n         *\n         * @example <caption>Wraps browser WebSocket</caption>\n         *\n         * let socket$ = Observable.webSocket('ws://localhost:8081');\n         *\n         * socket$.subscribe(\n         *    (msg) => console.log('message received: ' + msg),\n         *    (err) => console.log(err),\n         *    () => console.log('complete')\n         *  );\n         *\n         * socket$.next(JSON.stringify({ op: 'hello' }));\n         *\n         * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>\n         *\n         * import { w3cwebsocket } from 'websocket';\n         *\n         * let socket$ = Observable.webSocket({\n         *   url: 'ws://localhost:8081',\n         *   WebSocketCtor: w3cwebsocket\n         * });\n         *\n         * socket$.subscribe(\n         *    (msg) => console.log('message received: ' + msg),\n         *    (err) => console.log(err),\n         *    () => console.log('complete')\n         *  );\n         *\n         * socket$.next(JSON.stringify({ op: 'hello' }));\n         *\n         * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object\n         * @return {WebSocketSubject}\n         * @static true\n         * @name webSocket\n         * @owner Observable\n         */\n        WebSocketSubject.create = function (urlConfigOrSource) {\n            return new WebSocketSubject(urlConfigOrSource);\n        };\n        WebSocketSubject.prototype.lift = function (operator) {\n            var sock = new WebSocketSubject(this, this.destination);\n            sock.operator = operator;\n            return sock;\n        };\n        WebSocketSubject.prototype._resetState = function () {\n            this.socket = null;\n            if (!this.source) {\n                this.destination = new ReplaySubject_1.ReplaySubject();\n            }\n            this._output = new Subject_1.Subject();\n        };\n        // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n        WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n            var self = this;\n            return new Observable_1.Observable(function (observer) {\n                var result = tryCatch_1.tryCatch(subMsg)();\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    self.next(result);\n                }\n                var subscription = self.subscribe(function (x) {\n                    var result = tryCatch_1.tryCatch(messageFilter)(x);\n                    if (result === errorObject_1.errorObject) {\n                        observer.error(errorObject_1.errorObject.e);\n                    }\n                    else if (result) {\n                        observer.next(x);\n                    }\n                }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n                return function () {\n                    var result = tryCatch_1.tryCatch(unsubMsg)();\n                    if (result === errorObject_1.errorObject) {\n                        observer.error(errorObject_1.errorObject.e);\n                    }\n                    else {\n                        self.next(result);\n                    }\n                    subscription.unsubscribe();\n                };\n            });\n        };\n        WebSocketSubject.prototype._connectSocket = function () {\n            var _this = this;\n            var WebSocketCtor = this.WebSocketCtor;\n            var observer = this._output;\n            var socket = null;\n            try {\n                socket = this.protocol ?\n                    new WebSocketCtor(this.url, this.protocol) :\n                    new WebSocketCtor(this.url);\n                this.socket = socket;\n                if (this.binaryType) {\n                    this.socket.binaryType = this.binaryType;\n                }\n            }\n            catch (e) {\n                observer.error(e);\n                return;\n            }\n            var subscription = new Subscription_1.Subscription(function () {\n                _this.socket = null;\n                if (socket && socket.readyState === 1) {\n                    socket.close();\n                }\n            });\n            socket.onopen = function (e) {\n                var openObserver = _this.openObserver;\n                if (openObserver) {\n                    openObserver.next(e);\n                }\n                var queue = _this.destination;\n                _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {\n                    var closingObserver = _this.closingObserver;\n                    if (closingObserver) {\n                        closingObserver.next(undefined);\n                    }\n                    if (e && e.code) {\n                        socket.close(e.code, e.reason);\n                    }\n                    else {\n                        observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +\n                            'and an optional reason: { code: number, reason: string }'));\n                    }\n                    _this._resetState();\n                }, function () {\n                    var closingObserver = _this.closingObserver;\n                    if (closingObserver) {\n                        closingObserver.next(undefined);\n                    }\n                    socket.close();\n                    _this._resetState();\n                });\n                if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {\n                    subscription.add(queue.subscribe(_this.destination));\n                }\n            };\n            socket.onerror = function (e) {\n                _this._resetState();\n                observer.error(e);\n            };\n            socket.onclose = function (e) {\n                _this._resetState();\n                var closeObserver = _this.closeObserver;\n                if (closeObserver) {\n                    closeObserver.next(e);\n                }\n                if (e.wasClean) {\n                    observer.complete();\n                }\n                else {\n                    observer.error(e);\n                }\n            };\n            socket.onmessage = function (e) {\n                var result = tryCatch_1.tryCatch(_this.resultSelector)(e);\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    observer.next(result);\n                }\n            };\n        };\n        WebSocketSubject.prototype._subscribe = function (subscriber) {\n            var _this = this;\n            var source = this.source;\n            if (source) {\n                return source.subscribe(subscriber);\n            }\n            if (!this.socket) {\n                this._connectSocket();\n            }\n            var subscription = new Subscription_1.Subscription();\n            subscription.add(this._output.subscribe(subscriber));\n            subscription.add(function () {\n                var socket = _this.socket;\n                if (_this._output.observers.length === 0) {\n                    if (socket && socket.readyState === 1) {\n                        socket.close();\n                    }\n                    _this._resetState();\n                }\n            });\n            return subscription;\n        };\n        WebSocketSubject.prototype.unsubscribe = function () {\n            var _a = this, source = _a.source, socket = _a.socket;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n                this._resetState();\n            }\n            _super.prototype.unsubscribe.call(this);\n            if (!source) {\n                this.destination = new ReplaySubject_1.ReplaySubject();\n            }\n        };\n        return WebSocketSubject;\n    }(Subject_1.AnonymousSubject));\n    exports.WebSocketSubject = WebSocketSubject;\n});\n\ndefine('rxjs/observable/dom/webSocket',[\"require\", \"exports\", \"./WebSocketSubject\"], function (require, exports, WebSocketSubject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.webSocket = WebSocketSubject_1.WebSocketSubject.create;\n});\n\ndefine('rxjs/add/observable/dom/webSocket',[\"require\", \"exports\", \"../../../Observable\", \"../../../observable/dom/webSocket\"], function (require, exports, Observable_1, webSocket_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.webSocket = webSocket_1.webSocket;\n});\n\ndefine('rxjs/operator/buffer',[\"require\", \"exports\", \"../operators/buffer\"], function (require, exports, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values until `closingNotifier` emits.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * that array only when another Observable emits.</span>\n     *\n     * <img src=\"./img/buffer.png\" width=\"100%\">\n     *\n     * Buffers the incoming Observable values until the given `closingNotifier`\n     * Observable emits a value, at which point it emits the buffer on the output\n     * Observable and starts a new buffer internally, awaiting the next time\n     * `closingNotifier` emits.\n     *\n     * @example <caption>On every click, emit array of most recent interval events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var interval = Rx.Observable.interval(1000);\n     * var buffered = interval.buffer(clicks);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link window}\n     *\n     * @param {Observable<any>} closingNotifier An Observable that signals the\n     * buffer to be emitted on the output Observable.\n     * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n     * values.\n     * @method buffer\n     * @owner Observable\n     */\n    function buffer(closingNotifier) {\n        return buffer_1.buffer(closingNotifier)(this);\n    }\n    exports.buffer = buffer;\n});\n\ndefine('rxjs/add/operator/buffer',[\"require\", \"exports\", \"../../Observable\", \"../../operator/buffer\"], function (require, exports, Observable_1, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.buffer = buffer_1.buffer;\n});\n\ndefine('rxjs/operator/bufferCount',[\"require\", \"exports\", \"../operators/bufferCount\"], function (require, exports, bufferCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values until the size hits the maximum\n     * `bufferSize` given.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * that array only when its size reaches `bufferSize`.</span>\n     *\n     * <img src=\"./img/bufferCount.png\" width=\"100%\">\n     *\n     * Buffers a number of values from the source Observable by `bufferSize` then\n     * emits the buffer and clears it, and starts a new buffer each\n     * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n     * `null`, then new buffers are started immediately at the start of the source\n     * and when each buffer closes and is emitted.\n     *\n     * @example <caption>Emit the last two click events as an array</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferCount(2);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @example <caption>On every click, emit the last two click events as an array</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferCount(2, 1);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link pairwise}\n     * @see {@link windowCount}\n     *\n     * @param {number} bufferSize The maximum size of the buffer emitted.\n     * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n     * For example if `startBufferEvery` is `2`, then a new buffer will be started\n     * on every other value from the source. A new buffer is started at the\n     * beginning of the source by default.\n     * @return {Observable<T[]>} An Observable of arrays of buffered values.\n     * @method bufferCount\n     * @owner Observable\n     */\n    function bufferCount(bufferSize, startBufferEvery) {\n        if (startBufferEvery === void 0) { startBufferEvery = null; }\n        return bufferCount_1.bufferCount(bufferSize, startBufferEvery)(this);\n    }\n    exports.bufferCount = bufferCount;\n});\n\ndefine('rxjs/add/operator/bufferCount',[\"require\", \"exports\", \"../../Observable\", \"../../operator/bufferCount\"], function (require, exports, Observable_1, bufferCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;\n});\n\ndefine('rxjs/operator/bufferTime',[\"require\", \"exports\", \"../scheduler/async\", \"../util/isScheduler\", \"../operators/bufferTime\"], function (require, exports, async_1, isScheduler_1, bufferTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Buffers the source Observable values for a specific time period.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * those arrays periodically in time.</span>\n     *\n     * <img src=\"./img/bufferTime.png\" width=\"100%\">\n     *\n     * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n     * Unless the optional argument `bufferCreationInterval` is given, it emits and\n     * resets the buffer every `bufferTimeSpan` milliseconds. If\n     * `bufferCreationInterval` is given, this operator opens the buffer every\n     * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n     * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n     * `maxBufferSize` is specified, the buffer will be closed either after\n     * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n     *\n     * @example <caption>Every second, emit an array of the recent click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferTime(1000);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferTime(2000, 5000);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link windowTime}\n     *\n     * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n     * @param {number} [bufferCreationInterval] The interval at which to start new\n     * buffers.\n     * @param {number} [maxBufferSize] The maximum buffer size.\n     * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n     * intervals that determine buffer boundaries.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferTime\n     * @owner Observable\n     */\n    function bufferTime(bufferTimeSpan) {\n        var length = arguments.length;\n        var scheduler = async_1.async;\n        if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n            scheduler = arguments[arguments.length - 1];\n            length--;\n        }\n        var bufferCreationInterval = null;\n        if (length >= 2) {\n            bufferCreationInterval = arguments[1];\n        }\n        var maxBufferSize = Number.POSITIVE_INFINITY;\n        if (length >= 3) {\n            maxBufferSize = arguments[2];\n        }\n        return bufferTime_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);\n    }\n    exports.bufferTime = bufferTime;\n});\n\ndefine('rxjs/add/operator/bufferTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/bufferTime\"], function (require, exports, Observable_1, bufferTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;\n});\n\ndefine('rxjs/operator/bufferToggle',[\"require\", \"exports\", \"../operators/bufferToggle\"], function (require, exports, bufferToggle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values starting from an emission from\n     * `openings` and ending when the output of `closingSelector` emits.\n     *\n     * <span class=\"informal\">Collects values from the past as an array. Starts\n     * collecting only when `opening` emits, and calls the `closingSelector`\n     * function to get an Observable that tells when to close the buffer.</span>\n     *\n     * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n     *\n     * Buffers values from the source by opening the buffer via signals from an\n     * Observable provided to `openings`, and closing and sending the buffers when\n     * a Subscribable or Promise returned by the `closingSelector` function emits.\n     *\n     * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var openings = Rx.Observable.interval(1000);\n     * var buffered = clicks.bufferToggle(openings, i =>\n     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n     * );\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferWhen}\n     * @see {@link windowToggle}\n     *\n     * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n     * buffers.\n     * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n     * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n     * which, when it emits, signals that the associated buffer should be emitted\n     * and cleared.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferToggle\n     * @owner Observable\n     */\n    function bufferToggle(openings, closingSelector) {\n        return bufferToggle_1.bufferToggle(openings, closingSelector)(this);\n    }\n    exports.bufferToggle = bufferToggle;\n});\n\ndefine('rxjs/add/operator/bufferToggle',[\"require\", \"exports\", \"../../Observable\", \"../../operator/bufferToggle\"], function (require, exports, Observable_1, bufferToggle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;\n});\n\ndefine('rxjs/operator/bufferWhen',[\"require\", \"exports\", \"../operators/bufferWhen\"], function (require, exports, bufferWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values, using a factory function of closing\n     * Observables to determine when to close, emit, and reset the buffer.\n     *\n     * <span class=\"informal\">Collects values from the past as an array. When it\n     * starts collecting values, it calls a function that returns an Observable that\n     * tells when to close the buffer and restart collecting.</span>\n     *\n     * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n     *\n     * Opens a buffer immediately, then closes the buffer when the observable\n     * returned by calling `closingSelector` function emits a value. When it closes\n     * the buffer, it immediately opens a new buffer and repeats the process.\n     *\n     * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferWhen(() =>\n     *   Rx.Observable.interval(1000 + Math.random() * 4000)\n     * );\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link windowWhen}\n     *\n     * @param {function(): Observable} closingSelector A function that takes no\n     * arguments and returns an Observable that signals buffer closure.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferWhen\n     * @owner Observable\n     */\n    function bufferWhen(closingSelector) {\n        return bufferWhen_1.bufferWhen(closingSelector)(this);\n    }\n    exports.bufferWhen = bufferWhen;\n});\n\ndefine('rxjs/add/operator/bufferWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/bufferWhen\"], function (require, exports, Observable_1, bufferWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;\n});\n\ndefine('rxjs/operator/catch',[\"require\", \"exports\", \"../operators/catchError\"], function (require, exports, catchError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n     *\n     * <img src=\"./img/catch.png\" width=\"100%\">\n     *\n     * @example <caption>Continues with a different Observable when there's an error</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     * \t   if (n == 4) {\n     * \t     throw 'four!';\n     *     }\n     *\t   return n;\n     *   })\n     *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n     *   .subscribe(x => console.log(x));\n     *   // 1, 2, 3, I, II, III, IV, V\n     *\n     * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     * \t   if (n === 4) {\n     * \t     throw 'four!';\n     *     }\n     * \t   return n;\n     *   })\n     *   .catch((err, caught) => caught)\n     *   .take(30)\n     *   .subscribe(x => console.log(x));\n     *   // 1, 2, 3, 1, 2, 3, ...\n     *\n     * @example <caption>Throws a new error when the source Observable throws an error</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     *     if (n == 4) {\n     *       throw 'four!';\n     *     }\n     *     return n;\n     *   })\n     *   .catch(err => {\n     *     throw 'error in source. Details: ' + err;\n     *   })\n     *   .subscribe(\n     *     x => console.log(x),\n     *     err => console.log(err)\n     *   );\n     *   // 1, 2, 3, error in source. Details: four!\n     *\n     * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n     *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n     *  is returned by the `selector` will be used to continue the observable chain.\n     * @return {Observable} An observable that originates from either the source or the observable returned by the\n     *  catch `selector` function.\n     * @method catch\n     * @name catch\n     * @owner Observable\n     */\n    function _catch(selector) {\n        return catchError_1.catchError(selector)(this);\n    }\n    exports._catch = _catch;\n});\n\ndefine('rxjs/add/operator/catch',[\"require\", \"exports\", \"../../Observable\", \"../../operator/catch\"], function (require, exports, Observable_1, catch_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.catch = catch_1._catch;\n    Observable_1.Observable.prototype._catch = catch_1._catch;\n});\n\ndefine('rxjs/operator/combineAll',[\"require\", \"exports\", \"../operators/combineAll\"], function (require, exports, combineAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by waiting\n     * for the outer Observable to complete, then applying {@link combineLatest}.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by applying\n     * {@link combineLatest} when the Observable-of-Observables completes.</span>\n     *\n     * <img src=\"./img/combineAll.png\" width=\"100%\">\n     *\n     * Takes an Observable of Observables, and collects all Observables from it.\n     * Once the outer Observable completes, it subscribes to all collected\n     * Observables and combines their values using the {@link combineLatest}\n     * strategy, such that:\n     * - Every time an inner Observable emits, the output Observable emits.\n     * - When the returned observable emits, it emits all of the latest values by:\n     *   - If a `project` function is provided, it is called with each recent value\n     *     from each inner Observable in whatever order they arrived, and the result\n     *     of the `project` function is what is emitted by the output Observable.\n     *   - If there is no `project` function, an array of all of the most recent\n     *     values is emitted by the output Observable.\n     *\n     * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map(ev =>\n     *   Rx.Observable.interval(Math.random()*2000).take(3)\n     * ).take(2);\n     * var result = higherOrder.combineAll();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineLatest}\n     * @see {@link mergeAll}\n     *\n     * @param {function} [project] An optional function to map the most recent\n     * values from each inner Observable into a new result. Takes each of the most\n     * recent values from each collected inner Observable as arguments, in order.\n     * @return {Observable} An Observable of projected results or arrays of recent\n     * values.\n     * @method combineAll\n     * @owner Observable\n     */\n    function combineAll(project) {\n        return combineAll_1.combineAll(project)(this);\n    }\n    exports.combineAll = combineAll;\n});\n\ndefine('rxjs/add/operator/combineAll',[\"require\", \"exports\", \"../../Observable\", \"../../operator/combineAll\"], function (require, exports, Observable_1, combineAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.combineAll = combineAll_1.combineAll;\n});\n\ndefine('rxjs/operator/combineLatest',[\"require\", \"exports\", \"../operators/combineLatest\"], function (require, exports, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines multiple Observables to create an Observable whose values are\n     * calculated from the latest values of each of its input Observables.\n     *\n     * <span class=\"informal\">Whenever any input Observable emits a value, it\n     * computes a formula using the latest values from all the inputs, then emits\n     * the output of that formula.</span>\n     *\n     * <img src=\"./img/combineLatest.png\" width=\"100%\">\n     *\n     * `combineLatest` combines the values from this Observable with values from\n     * Observables passed as arguments. This is done by subscribing to each\n     * Observable, in order, and collecting an array of each of the most recent\n     * values any time any of the input Observables emits, then either taking that\n     * array and passing it as arguments to an optional `project` function and\n     * emitting the return value of that, or just emitting the array of recent\n     * values directly if there is no `project` function.\n     *\n     * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n     * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n     * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n     * bmi.subscribe(x => console.log('BMI is ' + x));\n     *\n     * // With output to console:\n     * // BMI is 24.212293388429753\n     * // BMI is 23.93948099205209\n     * // BMI is 23.671253629592222\n     *\n     * @see {@link combineAll}\n     * @see {@link merge}\n     * @see {@link withLatestFrom}\n     *\n     * @param {ObservableInput} other An input Observable to combine with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {function} [project] An optional function to project the values from\n     * the combined latest values into a new value on the output Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @method combineLatest\n     * @owner Observable\n     */\n    function combineLatest() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return combineLatest_1.combineLatest.apply(void 0, observables)(this);\n    }\n    exports.combineLatest = combineLatest;\n});\n\ndefine('rxjs/add/operator/combineLatest',[\"require\", \"exports\", \"../../Observable\", \"../../operator/combineLatest\"], function (require, exports, Observable_1, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;\n});\n\ndefine('rxjs/operator/concat',[\"require\", \"exports\", \"../operators/concat\"], function (require, exports, concat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which sequentially emits all values from every\n     * given input Observable after the current Observable.\n     *\n     * <span class=\"informal\">Concatenates multiple Observables together by\n     * sequentially emitting their values, one Observable after the other.</span>\n     *\n     * <img src=\"./img/concat.png\" width=\"100%\">\n     *\n     * Joins this Observable with multiple other Observables by subscribing to them\n     * one at a time, starting with the source, and merging their results into the\n     * output Observable. Will wait for each Observable to complete before moving\n     * on to the next.\n     *\n     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n     * var timer = Rx.Observable.interval(1000).take(4);\n     * var sequence = Rx.Observable.range(1, 10);\n     * var result = timer.concat(sequence);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in:\n     * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n     *\n     * @example <caption>Concatenate 3 Observables</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var result = timer1.concat(timer2, timer3);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in the following:\n     * // (Prints to console sequentially)\n     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n     *\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     *\n     * @param {ObservableInput} other An input Observable to concatenate after the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n     * Observable subscription on.\n     * @return {Observable} All values of each passed Observable merged into a\n     * single Observable, in order, in serial fashion.\n     * @method concat\n     * @owner Observable\n     */\n    function concat() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return concat_1.concat.apply(void 0, observables)(this);\n    }\n    exports.concat = concat;\n});\n\ndefine('rxjs/add/operator/concat',[\"require\", \"exports\", \"../../Observable\", \"../../operator/concat\"], function (require, exports, Observable_1, concat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.concat = concat_1.concat;\n});\n\ndefine('rxjs/operator/concatAll',[\"require\", \"exports\", \"../operators/concatAll\"], function (require, exports, concatAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a higher-order Observable into a first-order Observable by\n     * concatenating the inner Observables in order.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n     * inner Observable after the other.</span>\n     *\n     * <img src=\"./img/concatAll.png\" width=\"100%\">\n     *\n     * Joins every Observable emitted by the source (a higher-order Observable), in\n     * a serial fashion. It subscribes to each inner Observable only after the\n     * previous inner Observable has completed, and merges all of their values into\n     * the returned observable.\n     *\n     * __Warning:__ If the source Observable emits Observables quickly and\n     * endlessly, and the inner Observables it emits generally complete slower than\n     * the source emits, you can run into memory issues as the incoming Observables\n     * collect in an unbounded buffer.\n     *\n     * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n     * to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n     * var firstOrder = higherOrder.concatAll();\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link combineAll}\n     * @see {@link concat}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     * @see {@link exhaust}\n     * @see {@link mergeAll}\n     * @see {@link switch}\n     * @see {@link zipAll}\n     *\n     * @return {Observable} An Observable emitting values from all the inner\n     * Observables concatenated.\n     * @method concatAll\n     * @owner Observable\n     */\n    function concatAll() {\n        return concatAll_1.concatAll()(this);\n    }\n    exports.concatAll = concatAll;\n});\n\ndefine('rxjs/add/operator/concatAll',[\"require\", \"exports\", \"../../Observable\", \"../../operator/concatAll\"], function (require, exports, Observable_1, concatAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;\n});\n\ndefine('rxjs/operator/concatMap',[\"require\", \"exports\", \"../operators/concatMap\"], function (require, exports, concatMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable, in a serialized fashion waiting for each one to complete before\n     * merging the next.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link concatAll}.</span>\n     *\n     * <img src=\"./img/concatMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. Each new inner Observable is\n     * concatenated with the previous inner Observable.\n     *\n     * __Warning:__ if source values arrive endlessly and faster than their\n     * corresponding inner Observables can complete, it will result in memory issues\n     * as inner Observables amass in an unbounded buffer waiting for their turn to\n     * be subscribed to.\n     *\n     * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n     * to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link concat}\n     * @see {@link concatAll}\n     * @see {@link concatMapTo}\n     * @see {@link exhaustMap}\n     * @see {@link mergeMap}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and taking values from each projected inner\n     * Observable sequentially.\n     * @method concatMap\n     * @owner Observable\n     */\n    function concatMap(project, resultSelector) {\n        return concatMap_1.concatMap(project, resultSelector)(this);\n    }\n    exports.concatMap = concatMap;\n});\n\ndefine('rxjs/add/operator/concatMap',[\"require\", \"exports\", \"../../Observable\", \"../../operator/concatMap\"], function (require, exports, Observable_1, concatMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;\n});\n\ndefine('rxjs/operator/concatMapTo',[\"require\", \"exports\", \"../operators/concatMapTo\"], function (require, exports, concatMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is merged multiple\n     * times in a serialized fashion on the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n     * always to the same inner Observable.</span>\n     *\n     * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then flattens those resulting Observables into one\n     * single Observable, which is the output Observable. Each new `innerObservable`\n     * instance emitted on the output Observable is concatenated with the previous\n     * `innerObservable` instance.\n     *\n     * __Warning:__ if source values arrive endlessly and faster than their\n     * corresponding inner Observables can complete, it will result in memory issues\n     * as inner Observables amass in an unbounded buffer waiting for their turn to\n     * be subscribed to.\n     *\n     * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n     * set to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link concat}\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link mergeMapTo}\n     * @see {@link switchMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An observable of values merged together by joining the\n     * passed observable with itself, one after the other, for each value emitted\n     * from the source.\n     * @method concatMapTo\n     * @owner Observable\n     */\n    function concatMapTo(innerObservable, resultSelector) {\n        return concatMapTo_1.concatMapTo(innerObservable, resultSelector)(this);\n    }\n    exports.concatMapTo = concatMapTo;\n});\n\ndefine('rxjs/add/operator/concatMapTo',[\"require\", \"exports\", \"../../Observable\", \"../../operator/concatMapTo\"], function (require, exports, Observable_1, concatMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;\n});\n\ndefine('rxjs/operator/count',[\"require\", \"exports\", \"../operators/count\"], function (require, exports, count_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Counts the number of emissions on the source and emits that number when the\n     * source completes.\n     *\n     * <span class=\"informal\">Tells how many values were emitted, when the source\n     * completes.</span>\n     *\n     * <img src=\"./img/count.png\" width=\"100%\">\n     *\n     * `count` transforms an Observable that emits values into an Observable that\n     * emits a single value that represents the number of values emitted by the\n     * source Observable. If the source Observable terminates with an error, `count`\n     * will pass this error notification along without emitting a value first. If\n     * the source Observable does not terminate at all, `count` will neither emit\n     * a value nor terminate. This operator takes an optional `predicate` function\n     * as argument, in which case the output emission will represent the number of\n     * source values that matched `true` with the `predicate`.\n     *\n     * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n     * var seconds = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var secondsBeforeClick = seconds.takeUntil(clicks);\n     * var result = secondsBeforeClick.count();\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n     * var numbers = Rx.Observable.range(1, 7);\n     * var result = numbers.count(i => i % 2 === 1);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // 4\n     *\n     * @see {@link max}\n     * @see {@link min}\n     * @see {@link reduce}\n     *\n     * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n     * boolean function to select what values are to be counted. It is provided with\n     * arguments of:\n     * - `value`: the value from the source Observable.\n     * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n     * - `source`: the source Observable instance itself.\n     * @return {Observable} An Observable of one number that represents the count as\n     * described above.\n     * @method count\n     * @owner Observable\n     */\n    function count(predicate) {\n        return count_1.count(predicate)(this);\n    }\n    exports.count = count;\n});\n\ndefine('rxjs/add/operator/count',[\"require\", \"exports\", \"../../Observable\", \"../../operator/count\"], function (require, exports, Observable_1, count_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.count = count_1.count;\n});\n\ndefine('rxjs/operator/dematerialize',[\"require\", \"exports\", \"../operators/dematerialize\"], function (require, exports, dematerialize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts an Observable of {@link Notification} objects into the emissions\n     * that they represent.\n     *\n     * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n     * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n     *\n     * <img src=\"./img/dematerialize.png\" width=\"100%\">\n     *\n     * `dematerialize` is assumed to operate an Observable that only emits\n     * {@link Notification} objects as `next` emissions, and does not emit any\n     * `error`. Such Observable is the output of a `materialize` operation. Those\n     * notifications are then unwrapped using the metadata they contain, and emitted\n     * as `next`, `error`, and `complete` on the output Observable.\n     *\n     * Use this operator in conjunction with {@link materialize}.\n     *\n     * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n     * var notifA = new Rx.Notification('N', 'A');\n     * var notifB = new Rx.Notification('N', 'B');\n     * var notifE = new Rx.Notification('E', void 0,\n     *   new TypeError('x.toUpperCase is not a function')\n     * );\n     * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n     * var upperCase = materialized.dematerialize();\n     * upperCase.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * // Results in:\n     * // A\n     * // B\n     * // TypeError: x.toUpperCase is not a function\n     *\n     * @see {@link Notification}\n     * @see {@link materialize}\n     *\n     * @return {Observable} An Observable that emits items and notifications\n     * embedded in Notification objects emitted by the source Observable.\n     * @method dematerialize\n     * @owner Observable\n     */\n    function dematerialize() {\n        return dematerialize_1.dematerialize()(this);\n    }\n    exports.dematerialize = dematerialize;\n});\n\ndefine('rxjs/add/operator/dematerialize',[\"require\", \"exports\", \"../../Observable\", \"../../operator/dematerialize\"], function (require, exports, Observable_1, dematerialize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;\n});\n\ndefine('rxjs/operator/debounce',[\"require\", \"exports\", \"../operators/debounce\"], function (require, exports, debounce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable only after a particular time span\n     * determined by another Observable has passed without another source emission.\n     *\n     * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n     * emission silence is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/debounce.png\" width=\"100%\">\n     *\n     * `debounce` delays values emitted by the source Observable, but drops previous\n     * pending delayed emissions if a new value arrives on the source Observable.\n     * This operator keeps track of the most recent value from the source\n     * Observable, and spawns a duration Observable by calling the\n     * `durationSelector` function. The value is emitted only when the duration\n     * Observable emits a value or completes, and if no other value was emitted on\n     * the source Observable since the duration Observable was spawned. If a new\n     * value appears before the duration Observable emits, the previous value will\n     * be dropped and will not be emitted on the output Observable.\n     *\n     * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n     * delay-like operator since output emissions do not necessarily occur at the\n     * same time as they did on the source Observable.\n     *\n     * @example <caption>Emit the most recent click after a burst of clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounceTime}\n     * @see {@link delayWhen}\n     * @see {@link throttle}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the timeout\n     * duration for each source value, returned as an Observable or a Promise.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified duration Observable returned by\n     * `durationSelector`, and may drop some values if they occur too frequently.\n     * @method debounce\n     * @owner Observable\n     */\n    function debounce(durationSelector) {\n        return debounce_1.debounce(durationSelector)(this);\n    }\n    exports.debounce = debounce;\n});\n\ndefine('rxjs/add/operator/debounce',[\"require\", \"exports\", \"../../Observable\", \"../../operator/debounce\"], function (require, exports, Observable_1, debounce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.debounce = debounce_1.debounce;\n});\n\ndefine('rxjs/operator/debounceTime',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/debounceTime\"], function (require, exports, async_1, debounceTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable only after a particular time span\n     * has passed without another source emission.\n     *\n     * <span class=\"informal\">It's like {@link delay}, but passes only the most\n     * recent value from each burst of emissions.</span>\n     *\n     * <img src=\"./img/debounceTime.png\" width=\"100%\">\n     *\n     * `debounceTime` delays values emitted by the source Observable, but drops\n     * previous pending delayed emissions if a new value arrives on the source\n     * Observable. This operator keeps track of the most recent value from the\n     * source Observable, and emits that only when `dueTime` enough time has passed\n     * without any other value appearing on the source Observable. If a new value\n     * appears before `dueTime` silence occurs, the previous value will be dropped\n     * and will not be emitted on the output Observable.\n     *\n     * This is a rate-limiting operator, because it is impossible for more than one\n     * value to be emitted in any time window of duration `dueTime`, but it is also\n     * a delay-like operator since output emissions do not occur at the same time as\n     * they did on the source Observable. Optionally takes a {@link IScheduler} for\n     * managing timers.\n     *\n     * @example <caption>Emit the most recent click after a burst of clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.debounceTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounce}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttleTime}\n     *\n     * @param {number} dueTime The timeout duration in milliseconds (or the time\n     * unit determined internally by the optional `scheduler`) for the window of\n     * time required to wait for emission silence before emitting the most recent\n     * source value.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the timeout for each value.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified `dueTime`, and may drop some values if they occur\n     * too frequently.\n     * @method debounceTime\n     * @owner Observable\n     */\n    function debounceTime(dueTime, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return debounceTime_1.debounceTime(dueTime, scheduler)(this);\n    }\n    exports.debounceTime = debounceTime;\n});\n\ndefine('rxjs/add/operator/debounceTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/debounceTime\"], function (require, exports, Observable_1, debounceTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n});\n\ndefine('rxjs/operator/defaultIfEmpty',[\"require\", \"exports\", \"../operators/defaultIfEmpty\"], function (require, exports, defaultIfEmpty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Emits a given value if the source Observable completes without emitting any\n     * `next` value, otherwise mirrors the source Observable.\n     *\n     * <span class=\"informal\">If the source Observable turns out to be empty, then\n     * this operator will emit a default value.</span>\n     *\n     * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n     *\n     * `defaultIfEmpty` emits the values emitted by the source Observable or a\n     * specified default value if the source Observable is empty (completes without\n     * having emitted any `next` value).\n     *\n     * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n     * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link empty}\n     * @see {@link last}\n     *\n     * @param {any} [defaultValue=null] The default value used if the source\n     * Observable is empty.\n     * @return {Observable} An Observable that emits either the specified\n     * `defaultValue` if the source Observable emits no items, or the values emitted\n     * by the source Observable.\n     * @method defaultIfEmpty\n     * @owner Observable\n     */\n    function defaultIfEmpty(defaultValue) {\n        if (defaultValue === void 0) { defaultValue = null; }\n        return defaultIfEmpty_1.defaultIfEmpty(defaultValue)(this);\n    }\n    exports.defaultIfEmpty = defaultIfEmpty;\n});\n\ndefine('rxjs/add/operator/defaultIfEmpty',[\"require\", \"exports\", \"../../Observable\", \"../../operator/defaultIfEmpty\"], function (require, exports, Observable_1, defaultIfEmpty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n});\n\ndefine('rxjs/operator/delay',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/delay\"], function (require, exports, async_1, delay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Delays the emission of items from the source Observable by a given timeout or\n     * until a given Date.\n     *\n     * <span class=\"informal\">Time shifts each item by some specified amount of\n     * milliseconds.</span>\n     *\n     * <img src=\"./img/delay.png\" width=\"100%\">\n     *\n     * If the delay argument is a Number, this operator time shifts the source\n     * Observable by that amount of time expressed in milliseconds. The relative\n     * time intervals between the values are preserved.\n     *\n     * If the delay argument is a Date, this operator time shifts the start of the\n     * Observable execution until the given date occurs.\n     *\n     * @example <caption>Delay each click by one second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @example <caption>Delay all clicks until a future date happens</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var date = new Date('March 15, 2050 12:00:00'); // in the future\n     * var delayedClicks = clicks.delay(date); // click emitted only after that date\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @see {@link debounceTime}\n     * @see {@link delayWhen}\n     *\n     * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n     * a `Date` until which the emission of the source items is delayed.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for\n     * managing the timers that handle the time-shift for each item.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified timeout or Date.\n     * @method delay\n     * @owner Observable\n     */\n    function delay(delay, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return delay_1.delay(delay, scheduler)(this);\n    }\n    exports.delay = delay;\n});\n\ndefine('rxjs/add/operator/delay',[\"require\", \"exports\", \"../../Observable\", \"../../operator/delay\"], function (require, exports, Observable_1, delay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.delay = delay_1.delay;\n});\n\ndefine('rxjs/operator/delayWhen',[\"require\", \"exports\", \"../operators/delayWhen\"], function (require, exports, delayWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Delays the emission of items from the source Observable by a given time span\n     * determined by the emissions of another Observable.\n     *\n     * <span class=\"informal\">It's like {@link delay}, but the time span of the\n     * delay duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/delayWhen.png\" width=\"100%\">\n     *\n     * `delayWhen` time shifts each emitted value from the source Observable by a\n     * time span determined by another Observable. When the source emits a value,\n     * the `delayDurationSelector` function is called with the source value as\n     * argument, and should return an Observable, called the \"duration\" Observable.\n     * The source value is emitted on the output Observable only when the duration\n     * Observable emits a value or completes.\n     *\n     * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n     * is an Observable. When `subscriptionDelay` emits its first value or\n     * completes, the source Observable is subscribed to and starts behaving like\n     * described in the previous paragraph. If `subscriptionDelay` is not provided,\n     * `delayWhen` will subscribe to the source Observable as soon as the output\n     * Observable is subscribed.\n     *\n     * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var delayedClicks = clicks.delayWhen(event =>\n     *   Rx.Observable.interval(Math.random() * 5000)\n     * );\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @see {@link debounce}\n     * @see {@link delay}\n     *\n     * @param {function(value: T): Observable} delayDurationSelector A function that\n     * returns an Observable for each value emitted by the source Observable, which\n     * is then used to delay the emission of that item on the output Observable\n     * until the Observable returned from this function emits a value.\n     * @param {Observable} subscriptionDelay An Observable that triggers the\n     * subscription to the source Observable once it emits any value.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by an amount of time specified by the Observable returned by\n     * `delayDurationSelector`.\n     * @method delayWhen\n     * @owner Observable\n     */\n    function delayWhen(delayDurationSelector, subscriptionDelay) {\n        return delayWhen_1.delayWhen(delayDurationSelector, subscriptionDelay)(this);\n    }\n    exports.delayWhen = delayWhen;\n});\n\ndefine('rxjs/add/operator/delayWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/delayWhen\"], function (require, exports, Observable_1, delayWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;\n});\n\ndefine('rxjs/operator/distinct',[\"require\", \"exports\", \"../operators/distinct\"], function (require, exports, distinct_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n     *\n     * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n     * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n     * source observable directly with an equality check against previous values.\n     *\n     * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n     *\n     * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n     * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n     * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n     * that the internal `Set` can be \"flushed\", basically clearing it of values.\n     *\n     * @example <caption>A simple example with numbers</caption>\n     * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n     *   .distinct()\n     *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n     *\n     * @example <caption>An example using a keySelector function</caption>\n     * interface Person {\n     *    age: number,\n     *    name: string\n     * }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'})\n     *     .distinct((p: Person) => p.name)\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     *\n     * @see {@link distinctUntilChanged}\n     * @see {@link distinctUntilKeyChanged}\n     *\n     * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n     * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n     * @method distinct\n     * @owner Observable\n     */\n    function distinct(keySelector, flushes) {\n        return distinct_1.distinct(keySelector, flushes)(this);\n    }\n    exports.distinct = distinct;\n});\n\ndefine('rxjs/add/operator/distinct',[\"require\", \"exports\", \"../../Observable\", \"../../operator/distinct\"], function (require, exports, Observable_1, distinct_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.distinct = distinct_1.distinct;\n});\n\ndefine('rxjs/operator/distinctUntilChanged',[\"require\", \"exports\", \"../operators/distinctUntilChanged\"], function (require, exports, distinctUntilChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n     *\n     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n     *\n     * If a comparator function is not provided, an equality check is used by default.\n     *\n     * @example <caption>A simple example with numbers</caption>\n     * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n     *   .distinctUntilChanged()\n     *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n     *\n     * @example <caption>An example using a compare function</caption>\n     * interface Person {\n     *    age: number,\n     *    name: string\n     * }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'})\n     *     { age: 6, name: 'Foo'})\n     *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo' }\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilKeyChanged}\n     *\n     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n     * @method distinctUntilChanged\n     * @owner Observable\n     */\n    function distinctUntilChanged(compare, keySelector) {\n        return distinctUntilChanged_1.distinctUntilChanged(compare, keySelector)(this);\n    }\n    exports.distinctUntilChanged = distinctUntilChanged;\n});\n\ndefine('rxjs/add/operator/distinctUntilChanged',[\"require\", \"exports\", \"../../Observable\", \"../../operator/distinctUntilChanged\"], function (require, exports, Observable_1, distinctUntilChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n});\n\ndefine('rxjs/operator/distinctUntilKeyChanged',[\"require\", \"exports\", \"../operators/distinctUntilKeyChanged\"], function (require, exports, distinctUntilKeyChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n     * using a property accessed by using the key provided to check if the two items are distinct.\n     *\n     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n     *\n     * If a comparator function is not provided, an equality check is used by default.\n     *\n     * @example <caption>An example comparing the name of persons</caption>\n     *\n     *  interface Person {\n     *     age: number,\n     *     name: string\n     *  }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'},\n     *     { age: 6, name: 'Foo'})\n     *     .distinctUntilKeyChanged('name')\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo' }\n     *\n     * @example <caption>An example comparing the first letters of the name</caption>\n     *\n     * interface Person {\n     *     age: number,\n     *     name: string\n     *  }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo1'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo2'},\n     *     { age: 6, name: 'Foo3'})\n     *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo1' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo2' }\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilChanged}\n     *\n     * @param {string} key String key for object property lookup on each item.\n     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n     * @method distinctUntilKeyChanged\n     * @owner Observable\n     */\n    function distinctUntilKeyChanged(key, compare) {\n        return distinctUntilKeyChanged_1.distinctUntilKeyChanged(key, compare)(this);\n    }\n    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n});\n\ndefine('rxjs/add/operator/distinctUntilKeyChanged',[\"require\", \"exports\", \"../../Observable\", \"../../operator/distinctUntilKeyChanged\"], function (require, exports, Observable_1, distinctUntilKeyChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n});\n\ndefine('rxjs/operator/do',[\"require\", \"exports\", \"../operators/tap\"], function (require, exports, tap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Perform a side effect for every emission on the source Observable, but return\n     * an Observable that is identical to the source.\n     *\n     * <span class=\"informal\">Intercepts each emission on the source and runs a\n     * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n     *\n     * <img src=\"./img/do.png\" width=\"100%\">\n     *\n     * Returns a mirrored Observable of the source Observable, but modified so that\n     * the provided Observer is called to perform a side effect for every value,\n     * error, and completion emitted by the source. Any errors that are thrown in\n     * the aforementioned Observer or handlers are safely sent down the error path\n     * of the output Observable.\n     *\n     * This operator is useful for debugging your Observables for the correct values\n     * or performing other side effects.\n     *\n     * Note: this is different to a `subscribe` on the Observable. If the Observable\n     * returned by `do` is not subscribed, the side effects specified by the\n     * Observer will never happen. `do` therefore simply spies on existing\n     * execution, it does not trigger an execution to happen like `subscribe` does.\n     *\n     * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var positions = clicks\n     *   .do(ev => console.log(ev))\n     *   .map(ev => ev.clientX);\n     * positions.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     * @see {@link subscribe}\n     *\n     * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n     * callback for `next`.\n     * @param {function} [error] Callback for errors in the source.\n     * @param {function} [complete] Callback for the completion of the source.\n     * @return {Observable} An Observable identical to the source, but runs the\n     * specified Observer or callback(s) for each item.\n     * @method do\n     * @name do\n     * @owner Observable\n     */\n    function _do(nextOrObserver, error, complete) {\n        return tap_1.tap(nextOrObserver, error, complete)(this);\n    }\n    exports._do = _do;\n});\n\ndefine('rxjs/add/operator/do',[\"require\", \"exports\", \"../../Observable\", \"../../operator/do\"], function (require, exports, Observable_1, do_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.do = do_1._do;\n    Observable_1.Observable.prototype._do = do_1._do;\n});\n\ndefine('rxjs/operator/exhaust',[\"require\", \"exports\", \"../operators/exhaust\"], function (require, exports, exhaust_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by dropping\n     * inner Observables while the previous inner Observable has not yet completed.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n     * next inner Observables while the current inner is still executing.</span>\n     *\n     * <img src=\"./img/exhaust.png\" width=\"100%\">\n     *\n     * `exhaust` subscribes to an Observable that emits Observables, also known as a\n     * higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, the output Observable begins emitting the items emitted by that\n     * inner Observable. So far, it behaves like {@link mergeAll}. However,\n     * `exhaust` ignores every new inner Observable if the previous Observable has\n     * not yet completed. Once that one completes, it will accept and flatten the\n     * next inner Observable and repeat this process.\n     *\n     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n     * var result = higherOrder.exhaust();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link switch}\n     * @see {@link mergeAll}\n     * @see {@link exhaustMap}\n     * @see {@link zipAll}\n     *\n     * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n     * exclusively until it completes before subscribing to the next.\n     * @method exhaust\n     * @owner Observable\n     */\n    function exhaust() {\n        return exhaust_1.exhaust()(this);\n    }\n    exports.exhaust = exhaust;\n});\n\ndefine('rxjs/add/operator/exhaust',[\"require\", \"exports\", \"../../Observable\", \"../../operator/exhaust\"], function (require, exports, Observable_1, exhaust_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.exhaust = exhaust_1.exhaust;\n});\n\ndefine('rxjs/operator/exhaustMap',[\"require\", \"exports\", \"../operators/exhaustMap\"], function (require, exports, exhaustMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable only if the previous projected Observable has completed.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link exhaust}.</span>\n     *\n     * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. When it projects a source value to\n     * an Observable, the output Observable begins emitting the items emitted by\n     * that projected Observable. However, `exhaustMap` ignores every new projected\n     * Observable if the previous projected Observable has not yet completed. Once\n     * that one completes, it will accept and flatten the next projected Observable\n     * and repeat this process.\n     *\n     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaust}\n     * @see {@link mergeMap}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable containing projected Observables\n     * of each item of the source, ignoring projected Observables that start before\n     * their preceding Observable has completed.\n     * @method exhaustMap\n     * @owner Observable\n     */\n    function exhaustMap(project, resultSelector) {\n        return exhaustMap_1.exhaustMap(project, resultSelector)(this);\n    }\n    exports.exhaustMap = exhaustMap;\n});\n\ndefine('rxjs/add/operator/exhaustMap',[\"require\", \"exports\", \"../../Observable\", \"../../operator/exhaustMap\"], function (require, exports, Observable_1, exhaustMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;\n});\n\ndefine('rxjs/operator/expand',[\"require\", \"exports\", \"../operators/expand\"], function (require, exports, expand_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Recursively projects each source value to an Observable which is merged in\n     * the output Observable.\n     *\n     * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n     * projection function to every source value as well as every output value.\n     * It's recursive.</span>\n     *\n     * <img src=\"./img/expand.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an Observable, and then merging those resulting Observables and\n     * emitting the results of this merger. *Expand* will re-emit on the output\n     * Observable every source value. Then, each output value is given to the\n     * `project` function which returns an inner Observable to be merged on the\n     * output Observable. Those output values resulting from the projection are also\n     * given to the `project` function to produce new output values. This is how\n     * *expand* behaves recursively.\n     *\n     * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var powersOfTwo = clicks\n     *   .mapTo(1)\n     *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n     *   .take(10);\n     * powersOfTwo.subscribe(x => console.log(x));\n     *\n     * @see {@link mergeMap}\n     * @see {@link mergeScan}\n     *\n     * @param {function(value: T, index: number) => Observable} project A function\n     * that, when applied to an item emitted by the source or the output Observable,\n     * returns an Observable.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n     * each projected inner Observable.\n     * @return {Observable} An Observable that emits the source values and also\n     * result of applying the projection function to each value emitted on the\n     * output Observable and and merging the results of the Observables obtained\n     * from this transformation.\n     * @method expand\n     * @owner Observable\n     */\n    function expand(project, concurrent, scheduler) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        if (scheduler === void 0) { scheduler = undefined; }\n        concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n        return expand_1.expand(project, concurrent, scheduler)(this);\n    }\n    exports.expand = expand;\n});\n\ndefine('rxjs/add/operator/expand',[\"require\", \"exports\", \"../../Observable\", \"../../operator/expand\"], function (require, exports, Observable_1, expand_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.expand = expand_1.expand;\n});\n\ndefine('rxjs/operator/elementAt',[\"require\", \"exports\", \"../operators/elementAt\"], function (require, exports, elementAt_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the single value at the specified `index` in a sequence of emissions\n     * from the source Observable.\n     *\n     * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n     *\n     * <img src=\"./img/elementAt.png\" width=\"100%\">\n     *\n     * `elementAt` returns an Observable that emits the item at the specified\n     * `index` in the source Observable, or a default value if that `index` is out\n     * of range and the `default` argument is provided. If the `default` argument is\n     * not given and the `index` is out of range, the output Observable will emit an\n     * `ArgumentOutOfRangeError` error.\n     *\n     * @example <caption>Emit only the third click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.elementAt(2);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // click 1 = nothing\n     * // click 2 = nothing\n     * // click 3 = MouseEvent object logged to console\n     *\n     * @see {@link first}\n     * @see {@link last}\n     * @see {@link skip}\n     * @see {@link single}\n     * @see {@link take}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n     * Observable has completed before emitting the i-th `next` notification.\n     *\n     * @param {number} index Is the number `i` for the i-th source emission that has\n     * happened since the subscription, starting from the number `0`.\n     * @param {T} [defaultValue] The default value returned for missing indices.\n     * @return {Observable} An Observable that emits a single item, if it is found.\n     * Otherwise, will emit the default value if given. If not, then emits an error.\n     * @method elementAt\n     * @owner Observable\n     */\n    function elementAt(index, defaultValue) {\n        return elementAt_1.elementAt(index, defaultValue)(this);\n    }\n    exports.elementAt = elementAt;\n});\n\ndefine('rxjs/add/operator/elementAt',[\"require\", \"exports\", \"../../Observable\", \"../../operator/elementAt\"], function (require, exports, Observable_1, elementAt_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.elementAt = elementAt_1.elementAt;\n});\n\ndefine('rxjs/operator/filter',[\"require\", \"exports\", \"../operators/filter\"], function (require, exports, filter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Filter items emitted by the source Observable by only emitting those that\n     * satisfy a specified predicate.\n     *\n     * <span class=\"informal\">Like\n     * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n     * it only emits a value from the source if it passes a criterion function.</span>\n     *\n     * <img src=\"./img/filter.png\" width=\"100%\">\n     *\n     * Similar to the well-known `Array.prototype.filter` method, this operator\n     * takes values from the source Observable, passes them through a `predicate`\n     * function and only emits those values that yielded `true`.\n     *\n     * @example <caption>Emit only click events whose target was a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n     * clicksOnDivs.subscribe(x => console.log(x));\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilChanged}\n     * @see {@link distinctUntilKeyChanged}\n     * @see {@link ignoreElements}\n     * @see {@link partition}\n     * @see {@link skip}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates each value emitted by the source Observable. If it returns `true`,\n     * the value is emitted, if `false` the value is not passed to the output\n     * Observable. The `index` parameter is the number `i` for the i-th source\n     * emission that has happened since the subscription, starting from the number\n     * `0`.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable} An Observable of values from the source that were\n     * allowed by the `predicate` function.\n     * @method filter\n     * @owner Observable\n     */\n    function filter(predicate, thisArg) {\n        return filter_1.filter(predicate, thisArg)(this);\n    }\n    exports.filter = filter;\n});\n\ndefine('rxjs/add/operator/filter',[\"require\", \"exports\", \"../../Observable\", \"../../operator/filter\"], function (require, exports, Observable_1, filter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.filter = filter_1.filter;\n});\n\ndefine('rxjs/operator/finally',[\"require\", \"exports\", \"../operators/finalize\"], function (require, exports, finalize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable, but will call a specified function when\n     * the source terminates on complete or error.\n     * @param {function} callback Function to be called when source terminates.\n     * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n     * @method finally\n     * @owner Observable\n     */\n    function _finally(callback) {\n        return finalize_1.finalize(callback)(this);\n    }\n    exports._finally = _finally;\n});\n\ndefine('rxjs/add/operator/finally',[\"require\", \"exports\", \"../../Observable\", \"../../operator/finally\"], function (require, exports, Observable_1, finally_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.finally = finally_1._finally;\n    Observable_1.Observable.prototype._finally = finally_1._finally;\n});\n\ndefine('rxjs/operator/find',[\"require\", \"exports\", \"../operators/find\"], function (require, exports, find_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Emits only the first value emitted by the source Observable that meets some\n     * condition.\n     *\n     * <span class=\"informal\">Finds the first value that passes some test and emits\n     * that.</span>\n     *\n     * <img src=\"./img/find.png\" width=\"100%\">\n     *\n     * `find` searches for the first item in the source Observable that matches the\n     * specified condition embodied by the `predicate`, and returns the first\n     * occurrence in the source. Unlike {@link first}, the `predicate` is required\n     * in `find`, and does not emit an error if a valid value is not found.\n     *\n     * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link first}\n     * @see {@link findIndex}\n     * @see {@link take}\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n     * A function called with each item to test for condition matching.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable<T>} An Observable of the first item that matches the\n     * condition.\n     * @method find\n     * @owner Observable\n     */\n    function find(predicate, thisArg) {\n        return find_1.find(predicate, thisArg)(this);\n    }\n    exports.find = find;\n});\n\ndefine('rxjs/add/operator/find',[\"require\", \"exports\", \"../../Observable\", \"../../operator/find\"], function (require, exports, Observable_1, find_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.find = find_1.find;\n});\n\ndefine('rxjs/operator/findIndex',[\"require\", \"exports\", \"../operators/findIndex\"], function (require, exports, findIndex_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the index of the first value emitted by the source Observable that\n     * meets some condition.\n     *\n     * <span class=\"informal\">It's like {@link find}, but emits the index of the\n     * found value, not the value itself.</span>\n     *\n     * <img src=\"./img/findIndex.png\" width=\"100%\">\n     *\n     * `findIndex` searches for the first item in the source Observable that matches\n     * the specified condition embodied by the `predicate`, and returns the\n     * (zero-based) index of the first occurrence in the source. Unlike\n     * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n     * an error if a valid value is not found.\n     *\n     * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link find}\n     * @see {@link first}\n     * @see {@link take}\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n     * A function called with each item to test for condition matching.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable} An Observable of the index of the first item that\n     * matches the condition.\n     * @method find\n     * @owner Observable\n     */\n    function findIndex(predicate, thisArg) {\n        return findIndex_1.findIndex(predicate, thisArg)(this);\n    }\n    exports.findIndex = findIndex;\n});\n\ndefine('rxjs/add/operator/findIndex',[\"require\", \"exports\", \"../../Observable\", \"../../operator/findIndex\"], function (require, exports, Observable_1, findIndex_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.findIndex = findIndex_1.findIndex;\n});\n\ndefine('rxjs/operator/first',[\"require\", \"exports\", \"../operators/first\"], function (require, exports, first_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first value (or the first value that meets some condition)\n     * emitted by the source Observable.\n     *\n     * <span class=\"informal\">Emits only the first value. Or emits only the first\n     * value that passes some test.</span>\n     *\n     * <img src=\"./img/first.png\" width=\"100%\">\n     *\n     * If called with no arguments, `first` emits the first value of the source\n     * Observable, then completes. If called with a `predicate` function, `first`\n     * emits the first value of the source that matches the specified condition. It\n     * may also take a `resultSelector` function to produce the output value from\n     * the input value, and a `defaultValue` to emit in case the source completes\n     * before it is able to emit a valid value. Throws an error if `defaultValue`\n     * was not provided and a matching element is not found.\n     *\n     * @example <caption>Emit only the first click that happens on the DOM</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.first();\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits the first click that happens on a DIV</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link find}\n     * @see {@link take}\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n     * An optional function called with each item to test for condition matching.\n     * @param {function(value: T, index: number): R} [resultSelector] A function to\n     * produce the value on the output Observable based on the values\n     * and the indices of the source Observable. The arguments passed to this\n     * function are:\n     * - `value`: the value that was emitted on the source.\n     * - `index`: the \"index\" of the value from the source.\n     * @param {R} [defaultValue] The default value emitted in case no valid value\n     * was found on the source.\n     * @return {Observable<T|R>} An Observable of the first item that matches the\n     * condition.\n     * @method first\n     * @owner Observable\n     */\n    function first(predicate, resultSelector, defaultValue) {\n        return first_1.first(predicate, resultSelector, defaultValue)(this);\n    }\n    exports.first = first;\n});\n\ndefine('rxjs/add/operator/first',[\"require\", \"exports\", \"../../Observable\", \"../../operator/first\"], function (require, exports, Observable_1, first_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.first = first_1.first;\n});\n\ndefine('rxjs/operator/groupBy',[\"require\", \"exports\", \"../operators/groupBy\"], function (require, exports, groupBy_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.GroupedObservable = groupBy_1.GroupedObservable;\n    /* tslint:enable:max-line-length */\n    /**\n     * Groups the items emitted by an Observable according to a specified criterion,\n     * and emits these grouped items as `GroupedObservables`, one\n     * {@link GroupedObservable} per group.\n     *\n     * <img src=\"./img/groupBy.png\" width=\"100%\">\n     *\n     * @example <caption>Group objects by id and return as array</caption>\n     * Observable.of<Obj>({id: 1, name: 'aze1'},\n     *                    {id: 2, name: 'sf2'},\n     *                    {id: 2, name: 'dg2'},\n     *                    {id: 1, name: 'erg1'},\n     *                    {id: 1, name: 'df1'},\n     *                    {id: 2, name: 'sfqfb2'},\n     *                    {id: 3, name: 'qfs3'},\n     *                    {id: 2, name: 'qsgqsfg2'}\n     *     )\n     *     .groupBy(p => p.id)\n     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n     *     .subscribe(p => console.log(p));\n     *\n     * // displays:\n     * // [ { id: 1, name: 'aze1' },\n     * //   { id: 1, name: 'erg1' },\n     * //   { id: 1, name: 'df1' } ]\n     * //\n     * // [ { id: 2, name: 'sf2' },\n     * //   { id: 2, name: 'dg2' },\n     * //   { id: 2, name: 'sfqfb2' },\n     * //   { id: 2, name: 'qsgqsfg2' } ]\n     * //\n     * // [ { id: 3, name: 'qfs3' } ]\n     *\n     * @example <caption>Pivot data on the id field</caption>\n     * Observable.of<Obj>({id: 1, name: 'aze1'},\n     *                    {id: 2, name: 'sf2'},\n     *                    {id: 2, name: 'dg2'},\n     *                    {id: 1, name: 'erg1'},\n     *                    {id: 1, name: 'df1'},\n     *                    {id: 2, name: 'sfqfb2'},\n     *                    {id: 3, name: 'qfs1'},\n     *                    {id: 2, name: 'qsgqsfg2'}\n     *                   )\n     *     .groupBy(p => p.id, p => p.name)\n     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n     *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n     *     .subscribe(p => console.log(p));\n     *\n     * // displays:\n     * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n     * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n     * // { id: 3, values: [ 'qfs1' ] }\n     *\n     * @param {function(value: T): K} keySelector A function that extracts the key\n     * for each item.\n     * @param {function(value: T): R} [elementSelector] A function that extracts the\n     * return element for each item.\n     * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n     * A function that returns an Observable to determine how long each group should\n     * exist.\n     * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n     * GroupedObservables, each of which corresponds to a unique key value and each\n     * of which emits those items from the source Observable that share that key\n     * value.\n     * @method groupBy\n     * @owner Observable\n     */\n    function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n        return groupBy_1.groupBy(keySelector, elementSelector, durationSelector, subjectSelector)(this);\n    }\n    exports.groupBy = groupBy;\n});\n\ndefine('rxjs/add/operator/groupBy',[\"require\", \"exports\", \"../../Observable\", \"../../operator/groupBy\"], function (require, exports, Observable_1, groupBy_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.groupBy = groupBy_1.groupBy;\n});\n\ndefine('rxjs/operator/ignoreElements',[\"require\", \"exports\", \"../operators/ignoreElements\"], function (require, exports, ignoreElements_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n     *\n     * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n     *\n     * @return {Observable} An empty Observable that only calls `complete`\n     * or `error`, based on which one is called by the source Observable.\n     * @method ignoreElements\n     * @owner Observable\n     */\n    function ignoreElements() {\n        return ignoreElements_1.ignoreElements()(this);\n    }\n    exports.ignoreElements = ignoreElements;\n    ;\n});\n\ndefine('rxjs/add/operator/ignoreElements',[\"require\", \"exports\", \"../../Observable\", \"../../operator/ignoreElements\"], function (require, exports, Observable_1, ignoreElements_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;\n});\n\ndefine('rxjs/operator/isEmpty',[\"require\", \"exports\", \"../operators/isEmpty\"], function (require, exports, isEmpty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.\n     *\n     * <img src=\"./img/isEmpty.png\" width=\"100%\">\n     *\n     * @return {Observable} An Observable that emits a Boolean.\n     * @method isEmpty\n     * @owner Observable\n     */\n    function isEmpty() {\n        return isEmpty_1.isEmpty()(this);\n    }\n    exports.isEmpty = isEmpty;\n});\n\ndefine('rxjs/add/operator/isEmpty',[\"require\", \"exports\", \"../../Observable\", \"../../operator/isEmpty\"], function (require, exports, Observable_1, isEmpty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;\n});\n\ndefine('rxjs/operator/audit',[\"require\", \"exports\", \"../operators/audit\"], function (require, exports, audit_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores source values for a duration determined by another Observable, then\n     * emits the most recent value from the source Observable, then repeats this\n     * process.\n     *\n     * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n     * duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/audit.png\" width=\"100%\">\n     *\n     * `audit` is similar to `throttle`, but emits the last value from the silenced\n     * time window, instead of the first value. `audit` emits the most recent value\n     * from the source Observable on the output Observable as soon as its internal\n     * timer becomes disabled, and ignores source values while the timer is enabled.\n     * Initially, the timer is disabled. As soon as the first source value arrives,\n     * the timer is enabled by calling the `durationSelector` function with the\n     * source value, which returns the \"duration\" Observable. When the duration\n     * Observable emits a value or completes, the timer is disabled, then the most\n     * recent source value is emitted on the output Observable, and this process\n     * repeats for the next source value.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounce}\n     * @see {@link delayWhen}\n     * @see {@link sample}\n     * @see {@link throttle}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the silencing\n     * duration, returned as an Observable or a Promise.\n     * @return {Observable<T>} An Observable that performs rate-limiting of\n     * emissions from the source Observable.\n     * @method audit\n     * @owner Observable\n     */\n    function audit(durationSelector) {\n        return audit_1.audit(durationSelector)(this);\n    }\n    exports.audit = audit;\n});\n\ndefine('rxjs/add/operator/audit',[\"require\", \"exports\", \"../../Observable\", \"../../operator/audit\"], function (require, exports, Observable_1, audit_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.audit = audit_1.audit;\n});\n\ndefine('rxjs/operator/auditTime',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/auditTime\"], function (require, exports, async_1, auditTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores source values for `duration` milliseconds, then emits the most recent\n     * value from the source Observable, then repeats this process.\n     *\n     * <span class=\"informal\">When it sees a source values, it ignores that plus\n     * the next ones for `duration` milliseconds, and then it emits the most recent\n     * value from the source.</span>\n     *\n     * <img src=\"./img/auditTime.png\" width=\"100%\">\n     *\n     * `auditTime` is similar to `throttleTime`, but emits the last value from the\n     * silenced time window, instead of the first value. `auditTime` emits the most\n     * recent value from the source Observable on the output Observable as soon as\n     * its internal timer becomes disabled, and ignores source values while the\n     * timer is enabled. Initially, the timer is disabled. As soon as the first\n     * source value arrives, the timer is enabled. After `duration` milliseconds (or\n     * the time unit determined internally by the optional `scheduler`) has passed,\n     * the timer is disabled, then the most recent source value is emitted on the\n     * output Observable, and this process repeats for the next source value.\n     * Optionally takes a {@link IScheduler} for managing timers.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.auditTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttleTime}\n     *\n     * @param {number} duration Time to wait before emitting the most recent source\n     * value, measured in milliseconds or the time unit determined internally\n     * by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the rate-limiting behavior.\n     * @return {Observable<T>} An Observable that performs rate-limiting of\n     * emissions from the source Observable.\n     * @method auditTime\n     * @owner Observable\n     */\n    function auditTime(duration, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return auditTime_1.auditTime(duration, scheduler)(this);\n    }\n    exports.auditTime = auditTime;\n});\n\ndefine('rxjs/add/operator/auditTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/auditTime\"], function (require, exports, Observable_1, auditTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.auditTime = auditTime_1.auditTime;\n});\n\ndefine('rxjs/operator/last',[\"require\", \"exports\", \"../operators/last\"], function (require, exports, last_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits only the last item emitted by the source Observable.\n     * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n     * the last item from the source Observable, the resulting Observable will emit the last item\n     * from the source Observable that satisfies the predicate.\n     *\n     * <img src=\"./img/last.png\" width=\"100%\">\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     * @param {function} predicate - The condition any source emitted item has to satisfy.\n     * @return {Observable} An Observable that emits only the last item satisfying the given condition\n     * from the source, or an NoSuchElementException if no such items are emitted.\n     * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n     * @method last\n     * @owner Observable\n     */\n    function last(predicate, resultSelector, defaultValue) {\n        return last_1.last(predicate, resultSelector, defaultValue)(this);\n    }\n    exports.last = last;\n});\n\ndefine('rxjs/add/operator/last',[\"require\", \"exports\", \"../../Observable\", \"../../operator/last\"], function (require, exports, Observable_1, last_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.last = last_1.last;\n});\n\ndefine('rxjs/operator/let',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param func\n     * @return {Observable<R>}\n     * @method let\n     * @owner Observable\n     */\n    function letProto(func) {\n        return func(this);\n    }\n    exports.letProto = letProto;\n});\n\ndefine('rxjs/add/operator/let',[\"require\", \"exports\", \"../../Observable\", \"../../operator/let\"], function (require, exports, Observable_1, let_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.let = let_1.letProto;\n    Observable_1.Observable.prototype.letBind = let_1.letProto;\n});\n\ndefine('rxjs/operator/every',[\"require\", \"exports\", \"../operators/every\"], function (require, exports, every_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n     *\n     * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n     *  Observable.of(1, 2, 3, 4, 5, 6)\n     *     .every(x => x < 5)\n     *     .subscribe(x => console.log(x)); // -> false\n     *\n     * @param {function} predicate A function for determining if an item meets a specified condition.\n     * @param {any} [thisArg] Optional object to use for `this` in the callback.\n     * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n     * @method every\n     * @owner Observable\n     */\n    function every(predicate, thisArg) {\n        return every_1.every(predicate, thisArg)(this);\n    }\n    exports.every = every;\n});\n\ndefine('rxjs/add/operator/every',[\"require\", \"exports\", \"../../Observable\", \"../../operator/every\"], function (require, exports, Observable_1, every_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.every = every_1.every;\n});\n\ndefine('rxjs/operator/map',[\"require\", \"exports\", \"../operators/map\"], function (require, exports, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Applies a given `project` function to each value emitted by the source\n     * Observable, and emits the resulting values as an Observable.\n     *\n     * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n     * it passes each source value through a transformation function to get\n     * corresponding output values.</span>\n     *\n     * <img src=\"./img/map.png\" width=\"100%\">\n     *\n     * Similar to the well known `Array.prototype.map` function, this operator\n     * applies a projection to each value and emits that projection in the output\n     * Observable.\n     *\n     * @example <caption>Map every click to the clientX position of that click</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var positions = clicks.map(ev => ev.clientX);\n     * positions.subscribe(x => console.log(x));\n     *\n     * @see {@link mapTo}\n     * @see {@link pluck}\n     *\n     * @param {function(value: T, index: number): R} project The function to apply\n     * to each `value` emitted by the source Observable. The `index` parameter is\n     * the number `i` for the i-th emission that has happened since the\n     * subscription, starting from the number `0`.\n     * @param {any} [thisArg] An optional argument to define what `this` is in the\n     * `project` function.\n     * @return {Observable<R>} An Observable that emits the values from the source\n     * Observable transformed by the given `project` function.\n     * @method map\n     * @owner Observable\n     */\n    function map(project, thisArg) {\n        return map_1.map(project, thisArg)(this);\n    }\n    exports.map = map;\n});\n\ndefine('rxjs/add/operator/map',[\"require\", \"exports\", \"../../Observable\", \"../../operator/map\"], function (require, exports, Observable_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.map = map_1.map;\n});\n\ndefine('rxjs/operator/mapTo',[\"require\", \"exports\", \"../operators/mapTo\"], function (require, exports, mapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the given constant value on the output Observable every time the source\n     * Observable emits a value.\n     *\n     * <span class=\"informal\">Like {@link map}, but it maps every source value to\n     * the same output value every time.</span>\n     *\n     * <img src=\"./img/mapTo.png\" width=\"100%\">\n     *\n     * Takes a constant `value` as argument, and emits that whenever the source\n     * Observable emits a value. In other words, ignores the actual source value,\n     * and simply uses the emission moment to know when to emit the given `value`.\n     *\n     * @example <caption>Map every click to the string 'Hi'</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var greetings = clicks.mapTo('Hi');\n     * greetings.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     *\n     * @param {any} value The value to map each source value to.\n     * @return {Observable} An Observable that emits the given `value` every time\n     * the source Observable emits something.\n     * @method mapTo\n     * @owner Observable\n     */\n    function mapTo(value) {\n        return mapTo_1.mapTo(value)(this);\n    }\n    exports.mapTo = mapTo;\n});\n\ndefine('rxjs/add/operator/mapTo',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mapTo\"], function (require, exports, Observable_1, mapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;\n});\n\ndefine('rxjs/operator/materialize',[\"require\", \"exports\", \"../operators/materialize\"], function (require, exports, materialize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represents all of the notifications from the source Observable as `next`\n     * emissions marked with their original types within {@link Notification}\n     * objects.\n     *\n     * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n     * {@link Notification} objects, emitted as `next` on the output Observable.\n     * </span>\n     *\n     * <img src=\"./img/materialize.png\" width=\"100%\">\n     *\n     * `materialize` returns an Observable that emits a `next` notification for each\n     * `next`, `error`, or `complete` emission of the source Observable. When the\n     * source Observable emits `complete`, the output Observable will emit `next` as\n     * a Notification of type \"complete\", and then it will emit `complete` as well.\n     * When the source Observable emits `error`, the output will emit `next` as a\n     * Notification of type \"error\", and then `complete`.\n     *\n     * This operator is useful for producing metadata of the source Observable, to\n     * be consumed as `next` emissions. Use it in conjunction with\n     * {@link dematerialize}.\n     *\n     * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n     * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n     * var upperCase = letters.map(x => x.toUpperCase());\n     * var materialized = upperCase.materialize();\n     * materialized.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n     * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n     * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n     * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n     * //   [as project] (http://1, hasValue: false}\n     *\n     * @see {@link Notification}\n     * @see {@link dematerialize}\n     *\n     * @return {Observable<Notification<T>>} An Observable that emits\n     * {@link Notification} objects that wrap the original emissions from the source\n     * Observable with metadata.\n     * @method materialize\n     * @owner Observable\n     */\n    function materialize() {\n        return materialize_1.materialize()(this);\n    }\n    exports.materialize = materialize;\n});\n\ndefine('rxjs/add/operator/materialize',[\"require\", \"exports\", \"../../Observable\", \"../../operator/materialize\"], function (require, exports, Observable_1, materialize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.materialize = materialize_1.materialize;\n});\n\ndefine('rxjs/operator/max',[\"require\", \"exports\", \"../operators/max\"], function (require, exports, max_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n     * and when source Observable completes it emits a single item: the item with the largest value.\n     *\n     * <img src=\"./img/max.png\" width=\"100%\">\n     *\n     * @example <caption>Get the maximal value of a series of numbers</caption>\n     * Rx.Observable.of(5, 4, 7, 2, 8)\n     *   .max()\n     *   .subscribe(x => console.log(x)); // -> 8\n     *\n     * @example <caption>Use a comparer function to get the maximal item</caption>\n     * interface Person {\n     *   age: number,\n     *   name: string\n     * }\n     * Observable.of<Person>({age: 7, name: 'Foo'},\n     *                       {age: 5, name: 'Bar'},\n     *                       {age: 9, name: 'Beer'})\n     *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n     * }\n     *\n     * @see {@link min}\n     *\n     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n     * value of two items.\n     * @return {Observable} An Observable that emits item with the largest value.\n     * @method max\n     * @owner Observable\n     */\n    function max(comparer) {\n        return max_1.max(comparer)(this);\n    }\n    exports.max = max;\n});\n\ndefine('rxjs/add/operator/max',[\"require\", \"exports\", \"../../Observable\", \"../../operator/max\"], function (require, exports, Observable_1, max_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.max = max_1.max;\n});\n\ndefine('rxjs/add/operator/merge',[\"require\", \"exports\", \"../../Observable\", \"../../operator/merge\"], function (require, exports, Observable_1, merge_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.merge = merge_1.merge;\n});\n\ndefine('rxjs/operator/mergeAll',[\"require\", \"exports\", \"../operators/mergeAll\"], function (require, exports, mergeAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable which\n     * concurrently delivers all values that are emitted on the inner Observables.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n     *\n     * <img src=\"./img/mergeAll.png\" width=\"100%\">\n     *\n     * `mergeAll` subscribes to an Observable that emits Observables, also known as\n     * a higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, it subscribes to that and delivers all the values from the\n     * inner Observable on the output Observable. The output Observable only\n     * completes once all inner Observables have completed. Any error delivered by\n     * a inner Observable will be immediately emitted on the output Observable.\n     *\n     * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n     * var firstOrder = higherOrder.mergeAll();\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n     * var firstOrder = higherOrder.mergeAll(2);\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link exhaust}\n     * @see {@link merge}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     * @see {@link switch}\n     * @see {@link zipAll}\n     *\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits values coming from all the\n     * inner Observables emitted by the source Observable.\n     * @method mergeAll\n     * @owner Observable\n     */\n    function mergeAll(concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeAll_1.mergeAll(concurrent)(this);\n    }\n    exports.mergeAll = mergeAll;\n});\n\ndefine('rxjs/add/operator/mergeAll',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mergeAll\"], function (require, exports, Observable_1, mergeAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;\n});\n\ndefine('rxjs/operator/mergeMap',[\"require\", \"exports\", \"../operators/mergeMap\"], function (require, exports, mergeMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link mergeAll}.</span>\n     *\n     * <img src=\"./img/mergeMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an Observable, and then merging those resulting Observables and\n     * emitting the results of this merger.\n     *\n     * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var result = letters.mergeMap(x =>\n     *   Rx.Observable.interval(1000).map(i => x+i)\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // a0\n     * // b0\n     * // c0\n     * // a1\n     * // b1\n     * // c1\n     * // continues to list a,b,c with respective ascending integers\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaustMap}\n     * @see {@link merge}\n     * @see {@link mergeAll}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and merging the results of the Observables obtained\n     * from this transformation.\n     * @method mergeMap\n     * @owner Observable\n     */\n    function mergeMap(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);\n    }\n    exports.mergeMap = mergeMap;\n});\n\ndefine('rxjs/add/operator/mergeMap',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mergeMap\"], function (require, exports, Observable_1, mergeMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\n    Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n});\n\ndefine('rxjs/operator/mergeMapTo',[\"require\", \"exports\", \"../operators/mergeMapTo\"], function (require, exports, mergeMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is merged multiple\n     * times in the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n     * to the same inner Observable.</span>\n     *\n     * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then merges those resulting Observables into one\n     * single Observable, which is the output Observable.\n     *\n     * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMapTo}\n     * @see {@link merge}\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeScan}\n     * @see {@link switchMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits items from the given\n     * `innerObservable` (and optionally transformed through `resultSelector`) every\n     * time a value is emitted on the source Observable.\n     * @method mergeMapTo\n     * @owner Observable\n     */\n    function mergeMapTo(innerObservable, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeMapTo_1.mergeMapTo(innerObservable, resultSelector, concurrent)(this);\n    }\n    exports.mergeMapTo = mergeMapTo;\n});\n\ndefine('rxjs/add/operator/mergeMapTo',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mergeMapTo\"], function (require, exports, Observable_1, mergeMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;\n    Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;\n});\n\ndefine('rxjs/operator/mergeScan',[\"require\", \"exports\", \"../operators/mergeScan\"], function (require, exports, mergeScan_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Applies an accumulator function over the source Observable where the\n     * accumulator function itself returns an Observable, then each intermediate\n     * Observable returned is merged into the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n     * by the accumulator are merged into the outer Observable.</span>\n     *\n     * @example <caption>Count the number of click events</caption>\n     * const click$ = Rx.Observable.fromEvent(document, 'click');\n     * const one$ = click$.mapTo(1);\n     * const seed = 0;\n     * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n     * count$.subscribe(x => console.log(x));\n     *\n     * // Results:\n     * 1\n     * 2\n     * 3\n     * 4\n     * // ...and so on for each click\n     *\n     * @param {function(acc: R, value: T): Observable<R>} accumulator\n     * The accumulator function called on each source value.\n     * @param seed The initial accumulation value.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n     * input Observables being subscribed to concurrently.\n     * @return {Observable<R>} An observable of the accumulated values.\n     * @method mergeScan\n     * @owner Observable\n     */\n    function mergeScan(accumulator, seed, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeScan_1.mergeScan(accumulator, seed, concurrent)(this);\n    }\n    exports.mergeScan = mergeScan;\n});\n\ndefine('rxjs/add/operator/mergeScan',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mergeScan\"], function (require, exports, Observable_1, mergeScan_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;\n});\n\ndefine('rxjs/operator/min',[\"require\", \"exports\", \"../operators/min\"], function (require, exports, min_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n     * and when source Observable completes it emits a single item: the item with the smallest value.\n     *\n     * <img src=\"./img/min.png\" width=\"100%\">\n     *\n     * @example <caption>Get the minimal value of a series of numbers</caption>\n     * Rx.Observable.of(5, 4, 7, 2, 8)\n     *   .min()\n     *   .subscribe(x => console.log(x)); // -> 2\n     *\n     * @example <caption>Use a comparer function to get the minimal item</caption>\n     * interface Person {\n     *   age: number,\n     *   name: string\n     * }\n     * Observable.of<Person>({age: 7, name: 'Foo'},\n     *                       {age: 5, name: 'Bar'},\n     *                       {age: 9, name: 'Beer'})\n     *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n     * }\n     *\n     * @see {@link max}\n     *\n     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n     * value of two items.\n     * @return {Observable<R>} An Observable that emits item with the smallest value.\n     * @method min\n     * @owner Observable\n     */\n    function min(comparer) {\n        return min_1.min(comparer)(this);\n    }\n    exports.min = min;\n});\n\ndefine('rxjs/add/operator/min',[\"require\", \"exports\", \"../../Observable\", \"../../operator/min\"], function (require, exports, Observable_1, min_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.min = min_1.min;\n});\n\ndefine('rxjs/operator/multicast',[\"require\", \"exports\", \"../operators/multicast\"], function (require, exports, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Allows source Observable to be subscribed only once with a Subject of choice,\n     * while still sharing its values between multiple subscribers.\n     *\n     * <span class=\"informal\">Subscribe to Observable once, but send its values to multiple subscribers.</span>\n     *\n     * <img src=\"./img/multicast.png\" width=\"100%\">\n     *\n     * `multicast` is an operator that works in two modes.\n     *\n     * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject\n     * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be\n     * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that\n     * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when\n     * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription\n     * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,\n     * even though usually it would send a request per every subscriber. Since it sends a request at the moment of\n     * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.\n     *\n     * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,\n     * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source\n     * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,\n     * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count\n     * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least\n     * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a\n     * ConnectableObservable, use `refCount`.\n     *\n     * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.\n     * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable\n     * as well, which should be the input stream modified by any operators you want. Note that in this\n     * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If\n     * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.\n     * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,\n     * if inside the selector function you subscribe to the input Observable multiple times, actual source stream\n     * will be subscribed only once. So if you have a chain of operators that use some Observable many times,\n     * but you want to subscribe to that Observable only once, this is the mode you would use.\n     *\n     * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the\n     * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject\n     * has some special properties, Observable returned by `multicast` will have them as well. If you want to use\n     * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},\n     * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},\n     * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually\n     * just wrappers around `multicast`, with a specific Subject hardcoded inside.\n     *\n     * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,\n     * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.\n     *\n     * @example <caption>Use ConnectableObservable</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     * const connectableSeconds = seconds.multicast(new Subject());\n     *\n     * connectableSeconds.subscribe(value => console.log('first: ' + value));\n     * connectableSeconds.subscribe(value => console.log('second: ' + value));\n     *\n     * // At this point still nothing happens, even though we subscribed twice.\n     *\n     * connectableSeconds.connect();\n     *\n     * // From now on `seconds` are being logged to the console,\n     * // twice per every second. `seconds` Observable was however only subscribed once,\n     * // so under the hood Observable.interval had only one clock started.\n     *\n     * @example <caption>Use selector</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds\n     *     .multicast(\n     *         () => new Subject(),\n     *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.\n     *                                         // Because we are inside selector, `seconds` is subscribed once,\n     *     )                                   // thus starting only one clock used internally by Observable.interval.\n     *     .subscribe();\n     *\n     * @see {@link publish}\n     * @see {@link publishLast}\n     * @see {@link publishBehavior}\n     * @see {@link publishReplay}\n     * @see {@link share}\n     * @see {@link shareReplay}\n     *\n     * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through\n     * which the source sequence's elements will be multicast to the selector function input Observable or\n     * ConnectableObservable returned by the operator.\n     * @param {Function} [selector] - Optional selector function that can use the input stream\n     * as many times as needed, without causing multiple subscriptions to the source stream.\n     * Subscribers to the input source will receive all notifications of the source from the\n     * time of the subscription forward.\n     * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector\n     * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.\n     *\n     * @method multicast\n     * @owner Observable\n     */\n    function multicast(subjectOrSubjectFactory, selector) {\n        return multicast_1.multicast(subjectOrSubjectFactory, selector)(this);\n    }\n    exports.multicast = multicast;\n});\n\ndefine('rxjs/add/operator/multicast',[\"require\", \"exports\", \"../../Observable\", \"../../operator/multicast\"], function (require, exports, Observable_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.multicast = multicast_1.multicast;\n});\n\ndefine('rxjs/operator/observeOn',[\"require\", \"exports\", \"../operators/observeOn\"], function (require, exports, observeOn_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Re-emits all notifications from source Observable with specified scheduler.\n     *\n     * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n     *\n     * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n     * notifications emitted by the source Observable. It might be useful, if you do not have control over\n     * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n     *\n     * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n     * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n     * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n     * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n     * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n     * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n     * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n     * little bit more, to ensure that they are emitted at expected moments.\n     *\n     * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n     * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n     * will delay all notifications - including error notifications - while `delay` will pass through error\n     * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n     * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n     * for notification emissions in general.\n     *\n     * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n     * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n     *                                               // with async scheduler by default...\n     *\n     * intervals\n     * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n     * .subscribe(val => {                           // scheduler to ensure smooth animation.\n     *   someDiv.style.height = val + 'px';\n     * });\n     *\n     * @see {@link delay}\n     *\n     * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n     * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n     * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n     * but with provided scheduler.\n     *\n     * @method observeOn\n     * @owner Observable\n     */\n    function observeOn(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        return observeOn_1.observeOn(scheduler, delay)(this);\n    }\n    exports.observeOn = observeOn;\n});\n\ndefine('rxjs/add/operator/observeOn',[\"require\", \"exports\", \"../../Observable\", \"../../operator/observeOn\"], function (require, exports, Observable_1, observeOn_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.observeOn = observeOn_1.observeOn;\n});\n\ndefine('rxjs/operator/onErrorResumeNext',[\"require\", \"exports\", \"../operators/onErrorResumeNext\"], function (require, exports, onErrorResumeNext_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n     * that was passed.\n     *\n     * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n     *\n     * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n     *\n     * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n     * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n     * as the source.\n     *\n     * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n     * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n     * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n     * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n     * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n     * be happening until there is no more Observables left in the series, at which point returned Observable will\n     * complete - even if the last subscribed stream ended with an error.\n     *\n     * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n     * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n     * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n     * an error.\n     *\n     * Note that you do not get any access to errors emitted by the Observables. In particular do not\n     * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n     * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n     *\n     *\n     * @example <caption>Subscribe to the next Observable after map fails</caption>\n     * Rx.Observable.of(1, 2, 3, 0)\n     *   .map(x => {\n     *       if (x === 0) { throw Error(); }\n             return 10 / x;\n     *   })\n     *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n     *   .subscribe(\n     *     val => console.log(val),\n     *     err => console.log(err),          // Will never be called.\n     *     () => console.log('that\\'s it!')\n     *   );\n     *\n     * // Logs:\n     * // 10\n     * // 5\n     * // 3.3333333333333335\n     * // 1\n     * // 2\n     * // 3\n     * // \"that's it!\"\n     *\n     * @see {@link concat}\n     * @see {@link catch}\n     *\n     * @param {...ObservableInput} observables Observables passed either directly or as an array.\n     * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n     * to the next passed Observable and so on, until it completes or runs out of Observables.\n     * @method onErrorResumeNext\n     * @owner Observable\n     */\n    function onErrorResumeNext() {\n        var nextSources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nextSources[_i] = arguments[_i];\n        }\n        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, nextSources)(this);\n    }\n    exports.onErrorResumeNext = onErrorResumeNext;\n});\n\ndefine('rxjs/add/operator/onErrorResumeNext',[\"require\", \"exports\", \"../../Observable\", \"../../operator/onErrorResumeNext\"], function (require, exports, Observable_1, onErrorResumeNext_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n});\n\ndefine('rxjs/operator/pairwise',[\"require\", \"exports\", \"../operators/pairwise\"], function (require, exports, pairwise_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Groups pairs of consecutive emissions together and emits them as an array of\n     * two values.\n     *\n     * <span class=\"informal\">Puts the current value and previous value together as\n     * an array, and emits that.</span>\n     *\n     * <img src=\"./img/pairwise.png\" width=\"100%\">\n     *\n     * The Nth emission from the source Observable will cause the output Observable\n     * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n     * pair. For this reason, `pairwise` emits on the second and subsequent\n     * emissions from the source Observable, but not on the first emission, because\n     * there is no previous value in that case.\n     *\n     * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var pairs = clicks.pairwise();\n     * var distance = pairs.map(pair => {\n     *   var x0 = pair[0].clientX;\n     *   var y0 = pair[0].clientY;\n     *   var x1 = pair[1].clientX;\n     *   var y1 = pair[1].clientY;\n     *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n     * });\n     * distance.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     *\n     * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n     * consecutive values from the source Observable.\n     * @method pairwise\n     * @owner Observable\n     */\n    function pairwise() {\n        return pairwise_1.pairwise()(this);\n    }\n    exports.pairwise = pairwise;\n});\n\ndefine('rxjs/add/operator/pairwise',[\"require\", \"exports\", \"../../Observable\", \"../../operator/pairwise\"], function (require, exports, Observable_1, pairwise_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;\n});\n\ndefine('rxjs/operator/partition',[\"require\", \"exports\", \"../operators/partition\"], function (require, exports, partition_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Splits the source Observable into two, one with values that satisfy a\n     * predicate, and another with values that don't satisfy the predicate.\n     *\n     * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n     * one like the output of {@link filter}, and the other with values that did not\n     * pass the condition.</span>\n     *\n     * <img src=\"./img/partition.png\" width=\"100%\">\n     *\n     * `partition` outputs an array with two Observables that partition the values\n     * from the source Observable through the given `predicate` function. The first\n     * Observable in that array emits source values for which the predicate argument\n     * returns true. The second Observable emits source values for which the\n     * predicate returns false. The first behaves like {@link filter} and the second\n     * behaves like {@link filter} with the predicate negated.\n     *\n     * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n     * var clicksOnDivs = parts[0];\n     * var clicksElsewhere = parts[1];\n     * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n     * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n     *\n     * @see {@link filter}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates each value emitted by the source Observable. If it returns `true`,\n     * the value is emitted on the first Observable in the returned array, if\n     * `false` the value is emitted on the second Observable in the array. The\n     * `index` parameter is the number `i` for the i-th source emission that has\n     * happened since the subscription, starting from the number `0`.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n     * with values that passed the predicate, and another with values that did not\n     * pass the predicate.\n     * @method partition\n     * @owner Observable\n     */\n    function partition(predicate, thisArg) {\n        return partition_1.partition(predicate, thisArg)(this);\n    }\n    exports.partition = partition;\n});\n\ndefine('rxjs/add/operator/partition',[\"require\", \"exports\", \"../../Observable\", \"../../operator/partition\"], function (require, exports, Observable_1, partition_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.partition = partition_1.partition;\n});\n\ndefine('rxjs/operator/pluck',[\"require\", \"exports\", \"../operators/pluck\"], function (require, exports, pluck_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Maps each source value (an object) to its specified nested property.\n     *\n     * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n     * the nested properties of every emitted object.</span>\n     *\n     * <img src=\"./img/pluck.png\" width=\"100%\">\n     *\n     * Given a list of strings describing a path to an object property, retrieves\n     * the value of a specified nested property from all values in the source\n     * Observable. If a property can't be resolved, it will return `undefined` for\n     * that value.\n     *\n     * @example <caption>Map every click to the tagName of the clicked target element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var tagNames = clicks.pluck('target', 'tagName');\n     * tagNames.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     *\n     * @param {...string} properties The nested properties to pluck from each source\n     * value (an object).\n     * @return {Observable} A new Observable of property values from the source values.\n     * @method pluck\n     * @owner Observable\n     */\n    function pluck() {\n        var properties = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            properties[_i] = arguments[_i];\n        }\n        return pluck_1.pluck.apply(void 0, properties)(this);\n    }\n    exports.pluck = pluck;\n});\n\ndefine('rxjs/add/operator/pluck',[\"require\", \"exports\", \"../../Observable\", \"../../operator/pluck\"], function (require, exports, Observable_1, pluck_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.pluck = pluck_1.pluck;\n});\n\ndefine('rxjs/operator/publish',[\"require\", \"exports\", \"../operators/publish\"], function (require, exports, publish_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n     * before it begins emitting items to those Observers that have subscribed to it.\n     *\n     * <img src=\"./img/publish.png\" width=\"100%\">\n     *\n     * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n     * as needed, without causing multiple subscriptions to the source sequence.\n     * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n     * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n     * @method publish\n     * @owner Observable\n     */\n    function publish(selector) {\n        return publish_1.publish(selector)(this);\n    }\n    exports.publish = publish;\n});\n\ndefine('rxjs/add/operator/publish',[\"require\", \"exports\", \"../../Observable\", \"../../operator/publish\"], function (require, exports, Observable_1, publish_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.publish = publish_1.publish;\n});\n\ndefine('rxjs/operator/publishBehavior',[\"require\", \"exports\", \"../operators/publishBehavior\"], function (require, exports, publishBehavior_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param value\n     * @return {ConnectableObservable<T>}\n     * @method publishBehavior\n     * @owner Observable\n     */\n    function publishBehavior(value) {\n        return publishBehavior_1.publishBehavior(value)(this);\n    }\n    exports.publishBehavior = publishBehavior;\n});\n\ndefine('rxjs/add/operator/publishBehavior',[\"require\", \"exports\", \"../../Observable\", \"../../operator/publishBehavior\"], function (require, exports, Observable_1, publishBehavior_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;\n});\n\ndefine('rxjs/operator/publishReplay',[\"require\", \"exports\", \"../operators/publishReplay\"], function (require, exports, publishReplay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * @param bufferSize\n     * @param windowTime\n     * @param selectorOrScheduler\n     * @param scheduler\n     * @return {Observable<T> | ConnectableObservable<T>}\n     * @method publishReplay\n     * @owner Observable\n     */\n    function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n        return publishReplay_1.publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler)(this);\n    }\n    exports.publishReplay = publishReplay;\n});\n\ndefine('rxjs/add/operator/publishReplay',[\"require\", \"exports\", \"../../Observable\", \"../../operator/publishReplay\"], function (require, exports, Observable_1, publishReplay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;\n});\n\ndefine('rxjs/operator/publishLast',[\"require\", \"exports\", \"../operators/publishLast\"], function (require, exports, publishLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @return {ConnectableObservable<T>}\n     * @method publishLast\n     * @owner Observable\n     */\n    function publishLast() {\n        //TODO(benlesh): correct type-flow through here.\n        return publishLast_1.publishLast()(this);\n    }\n    exports.publishLast = publishLast;\n});\n\ndefine('rxjs/add/operator/publishLast',[\"require\", \"exports\", \"../../Observable\", \"../../operator/publishLast\"], function (require, exports, Observable_1, publishLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.publishLast = publishLast_1.publishLast;\n});\n\ndefine('rxjs/operator/race',[\"require\", \"exports\", \"../operators/race\", \"../observable/race\"], function (require, exports, race_1, race_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.raceStatic = race_2.race;\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that mirrors the first source Observable to emit an item\n     * from the combination of this Observable and supplied Observables.\n     * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n     * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n     * @method race\n     * @owner Observable\n     */\n    function race() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return race_1.race.apply(void 0, observables)(this);\n    }\n    exports.race = race;\n});\n\ndefine('rxjs/add/operator/race',[\"require\", \"exports\", \"../../Observable\", \"../../operator/race\"], function (require, exports, Observable_1, race_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.race = race_1.race;\n});\n\ndefine('rxjs/operator/reduce',[\"require\", \"exports\", \"../operators/reduce\"], function (require, exports, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Applies an accumulator function over the source Observable, and returns the\n     * accumulated result when the source completes, given an optional seed value.\n     *\n     * <span class=\"informal\">Combines together all values emitted on the source,\n     * using an accumulator function that knows how to join a new source value into\n     * the accumulation from the past.</span>\n     *\n     * <img src=\"./img/reduce.png\" width=\"100%\">\n     *\n     * Like\n     * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n     * `reduce` applies an `accumulator` function against an accumulation and each\n     * value of the source Observable (from the past) to reduce it to a single\n     * value, emitted on the output Observable. Note that `reduce` will only emit\n     * one value, only when the source Observable completes. It is equivalent to\n     * applying operator {@link scan} followed by operator {@link last}.\n     *\n     * Returns an Observable that applies a specified `accumulator` function to each\n     * item emitted by the source Observable. If a `seed` value is specified, then\n     * that value will be used as the initial value for the accumulator. If no seed\n     * value is specified, the first item of the source is used as the seed.\n     *\n     * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n     * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n     *   .takeUntil(Rx.Observable.interval(5000));\n     * var ones = clicksInFiveSeconds.mapTo(1);\n     * var seed = 0;\n     * var count = ones.reduce((acc, one) => acc + one, seed);\n     * count.subscribe(x => console.log(x));\n     *\n     * @see {@link count}\n     * @see {@link expand}\n     * @see {@link mergeScan}\n     * @see {@link scan}\n     *\n     * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n     * called on each source value.\n     * @param {R} [seed] The initial accumulation value.\n     * @return {Observable<R>} An Observable that emits a single value that is the\n     * result of accumulating the values emitted by the source Observable.\n     * @method reduce\n     * @owner Observable\n     */\n    function reduce(accumulator, seed) {\n        // providing a seed of `undefined` *should* be valid and trigger\n        // hasSeed! so don't use `seed !== undefined` checks!\n        // For this reason, we have to check it here at the original call site\n        // otherwise inside Operator/Subscriber we won't know if `undefined`\n        // means they didn't provide anything or if they literally provided `undefined`\n        if (arguments.length >= 2) {\n            return reduce_1.reduce(accumulator, seed)(this);\n        }\n        return reduce_1.reduce(accumulator)(this);\n    }\n    exports.reduce = reduce;\n});\n\ndefine('rxjs/add/operator/reduce',[\"require\", \"exports\", \"../../Observable\", \"../../operator/reduce\"], function (require, exports, Observable_1, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.reduce = reduce_1.reduce;\n});\n\ndefine('rxjs/operator/repeat',[\"require\", \"exports\", \"../operators/repeat\"], function (require, exports, repeat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n     *\n     * <img src=\"./img/repeat.png\" width=\"100%\">\n     *\n     * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n     * an empty Observable.\n     * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n     * count times.\n     * @method repeat\n     * @owner Observable\n     */\n    function repeat(count) {\n        if (count === void 0) { count = -1; }\n        return repeat_1.repeat(count)(this);\n    }\n    exports.repeat = repeat;\n});\n\ndefine('rxjs/add/operator/repeat',[\"require\", \"exports\", \"../../Observable\", \"../../operator/repeat\"], function (require, exports, Observable_1, repeat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.repeat = repeat_1.repeat;\n});\n\ndefine('rxjs/operator/repeatWhen',[\"require\", \"exports\", \"../operators/repeatWhen\"], function (require, exports, repeatWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n     * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n     * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n     * this method will resubscribe to the source Observable.\n     *\n     * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n     *\n     * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n     * which a user can `complete` or `error`, aborting the repetition.\n     * @return {Observable} The source Observable modified with repeat logic.\n     * @method repeatWhen\n     * @owner Observable\n     */\n    function repeatWhen(notifier) {\n        return repeatWhen_1.repeatWhen(notifier)(this);\n    }\n    exports.repeatWhen = repeatWhen;\n});\n\ndefine('rxjs/add/operator/repeatWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/repeatWhen\"], function (require, exports, Observable_1, repeatWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;\n});\n\ndefine('rxjs/operator/retry',[\"require\", \"exports\", \"../operators/retry\"], function (require, exports, retry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n     * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n     * as a number parameter) rather than propagating the `error` call.\n     *\n     * <img src=\"./img/retry.png\" width=\"100%\">\n     *\n     * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n     * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n     * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n     * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n     * @param {number} count - Number of retry attempts before failing.\n     * @return {Observable} The source Observable modified with the retry logic.\n     * @method retry\n     * @owner Observable\n     */\n    function retry(count) {\n        if (count === void 0) { count = -1; }\n        return retry_1.retry(count)(this);\n    }\n    exports.retry = retry;\n});\n\ndefine('rxjs/add/operator/retry',[\"require\", \"exports\", \"../../Observable\", \"../../operator/retry\"], function (require, exports, Observable_1, retry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.retry = retry_1.retry;\n});\n\ndefine('rxjs/operator/retryWhen',[\"require\", \"exports\", \"../operators/retryWhen\"], function (require, exports, retryWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n     * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n     * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n     * subscription. Otherwise this method will resubscribe to the source Observable.\n     *\n     * <img src=\"./img/retryWhen.png\" width=\"100%\">\n     *\n     * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n     * user can `complete` or `error`, aborting the retry.\n     * @return {Observable} The source Observable modified with retry logic.\n     * @method retryWhen\n     * @owner Observable\n     */\n    function retryWhen(notifier) {\n        return retryWhen_1.retryWhen(notifier)(this);\n    }\n    exports.retryWhen = retryWhen;\n});\n\ndefine('rxjs/add/operator/retryWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/retryWhen\"], function (require, exports, Observable_1, retryWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;\n});\n\ndefine('rxjs/operator/sample',[\"require\", \"exports\", \"../operators/sample\"], function (require, exports, sample_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the most recently emitted value from the source Observable whenever\n     * another Observable, the `notifier`, emits.\n     *\n     * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n     * the `notifier` Observable emits something.</span>\n     *\n     * <img src=\"./img/sample.png\" width=\"100%\">\n     *\n     * Whenever the `notifier` Observable emits a value or completes, `sample`\n     * looks at the source Observable and emits whichever value it has most recently\n     * emitted since the previous sampling, unless the source has not emitted\n     * anything since the previous sampling. The `notifier` is subscribed to as soon\n     * as the output Observable is subscribed.\n     *\n     * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n     * var seconds = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = seconds.sample(clicks);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounce}\n     * @see {@link sampleTime}\n     * @see {@link throttle}\n     *\n     * @param {Observable<any>} notifier The Observable to use for sampling the\n     * source Observable.\n     * @return {Observable<T>} An Observable that emits the results of sampling the\n     * values emitted by the source Observable whenever the notifier Observable\n     * emits value or completes.\n     * @method sample\n     * @owner Observable\n     */\n    function sample(notifier) {\n        return sample_1.sample(notifier)(this);\n    }\n    exports.sample = sample;\n});\n\ndefine('rxjs/add/operator/sample',[\"require\", \"exports\", \"../../Observable\", \"../../operator/sample\"], function (require, exports, Observable_1, sample_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.sample = sample_1.sample;\n});\n\ndefine('rxjs/operator/sampleTime',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/sampleTime\"], function (require, exports, async_1, sampleTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the most recently emitted value from the source Observable within\n     * periodic time intervals.\n     *\n     * <span class=\"informal\">Samples the source Observable at periodic time\n     * intervals, emitting what it samples.</span>\n     *\n     * <img src=\"./img/sampleTime.png\" width=\"100%\">\n     *\n     * `sampleTime` periodically looks at the source Observable and emits whichever\n     * value it has most recently emitted since the previous sampling, unless the\n     * source has not emitted anything since the previous sampling. The sampling\n     * happens periodically in time every `period` milliseconds (or the time unit\n     * defined by the optional `scheduler` argument). The sampling starts as soon as\n     * the output Observable is subscribed.\n     *\n     * @example <caption>Every second, emit the most recent click at most once</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.sampleTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sample}\n     * @see {@link throttleTime}\n     *\n     * @param {number} period The sampling period expressed in milliseconds or the\n     * time unit determined internally by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the sampling.\n     * @return {Observable<T>} An Observable that emits the results of sampling the\n     * values emitted by the source Observable at the specified time interval.\n     * @method sampleTime\n     * @owner Observable\n     */\n    function sampleTime(period, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return sampleTime_1.sampleTime(period, scheduler)(this);\n    }\n    exports.sampleTime = sampleTime;\n});\n\ndefine('rxjs/add/operator/sampleTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/sampleTime\"], function (require, exports, Observable_1, sampleTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;\n});\n\ndefine('rxjs/operator/scan',[\"require\", \"exports\", \"../operators/scan\"], function (require, exports, scan_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Applies an accumulator function over the source Observable, and returns each\n     * intermediate result, with an optional seed value.\n     *\n     * <span class=\"informal\">It's like {@link reduce}, but emits the current\n     * accumulation whenever the source emits a value.</span>\n     *\n     * <img src=\"./img/scan.png\" width=\"100%\">\n     *\n     * Combines together all values emitted on the source, using an accumulator\n     * function that knows how to join a new source value into the accumulation from\n     * the past. Is similar to {@link reduce}, but emits the intermediate\n     * accumulations.\n     *\n     * Returns an Observable that applies a specified `accumulator` function to each\n     * item emitted by the source Observable. If a `seed` value is specified, then\n     * that value will be used as the initial value for the accumulator. If no seed\n     * value is specified, the first item of the source is used as the seed.\n     *\n     * @example <caption>Count the number of click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var ones = clicks.mapTo(1);\n     * var seed = 0;\n     * var count = ones.scan((acc, one) => acc + one, seed);\n     * count.subscribe(x => console.log(x));\n     *\n     * @see {@link expand}\n     * @see {@link mergeScan}\n     * @see {@link reduce}\n     *\n     * @param {function(acc: R, value: T, index: number): R} accumulator\n     * The accumulator function called on each source value.\n     * @param {T|R} [seed] The initial accumulation value.\n     * @return {Observable<R>} An observable of the accumulated values.\n     * @method scan\n     * @owner Observable\n     */\n    function scan(accumulator, seed) {\n        if (arguments.length >= 2) {\n            return scan_1.scan(accumulator, seed)(this);\n        }\n        return scan_1.scan(accumulator)(this);\n    }\n    exports.scan = scan;\n});\n\ndefine('rxjs/add/operator/scan',[\"require\", \"exports\", \"../../Observable\", \"../../operator/scan\"], function (require, exports, Observable_1, scan_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.scan = scan_1.scan;\n});\n\ndefine('rxjs/operator/sequenceEqual',[\"require\", \"exports\", \"../operators/sequenceEqual\"], function (require, exports, sequenceEqual_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Compares all values of two observables in sequence using an optional comparor function\n     * and returns an observable of a single boolean value representing whether or not the two sequences\n     * are equal.\n     *\n     * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n     *\n     * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n     *\n     * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n     * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n     * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n     * observables completes, the operator will wait for the other observable to complete; If the other\n     * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n     * completes or emits after the other complets, the returned observable will never complete.\n     *\n     * @example <caption>figure out if the Konami code matches</caption>\n     * var code = Rx.Observable.from([\n     *  \"ArrowUp\",\n     *  \"ArrowUp\",\n     *  \"ArrowDown\",\n     *  \"ArrowDown\",\n     *  \"ArrowLeft\",\n     *  \"ArrowRight\",\n     *  \"ArrowLeft\",\n     *  \"ArrowRight\",\n     *  \"KeyB\",\n     *  \"KeyA\",\n     *  \"Enter\" // no start key, clearly.\n     * ]);\n     *\n     * var keys = Rx.Observable.fromEvent(document, 'keyup')\n     *  .map(e => e.code);\n     * var matches = keys.bufferCount(11, 1)\n     *  .mergeMap(\n     *    last11 =>\n     *      Rx.Observable.from(last11)\n     *        .sequenceEqual(code)\n     *   );\n     * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n     *\n     * @see {@link combineLatest}\n     * @see {@link zip}\n     * @see {@link withLatestFrom}\n     *\n     * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n     * @param {function} [comparor] An optional function to compare each value pair\n     * @return {Observable} An Observable of a single boolean value representing whether or not\n     * the values emitted by both observables were equal in sequence.\n     * @method sequenceEqual\n     * @owner Observable\n     */\n    function sequenceEqual(compareTo, comparor) {\n        return sequenceEqual_1.sequenceEqual(compareTo, comparor)(this);\n    }\n    exports.sequenceEqual = sequenceEqual;\n});\n\ndefine('rxjs/add/operator/sequenceEqual',[\"require\", \"exports\", \"../../Observable\", \"../../operator/sequenceEqual\"], function (require, exports, Observable_1, sequenceEqual_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;\n});\n\ndefine('rxjs/operator/share',[\"require\", \"exports\", \"../operators/share\"], function (require, exports, share_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n     * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n     * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n     *\n     * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.\n     * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.\n     * Observable.of(\"test\").publish().refCount() will not re-emit \"test\" on new subscriptions, Observable.of(\"test\").share() will\n     * re-emit \"test\" to new subscriptions.\n     *\n     * <img src=\"./img/share.png\" width=\"100%\">\n     *\n     * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n     * @method share\n     * @owner Observable\n     */\n    function share() {\n        return share_1.share()(this);\n    }\n    exports.share = share;\n    ;\n});\n\ndefine('rxjs/add/operator/share',[\"require\", \"exports\", \"../../Observable\", \"../../operator/share\"], function (require, exports, Observable_1, share_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.share = share_1.share;\n});\n\ndefine('rxjs/operator/shareReplay',[\"require\", \"exports\", \"../operators/shareReplay\"], function (require, exports, shareReplay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @method shareReplay\n     * @owner Observable\n     */\n    function shareReplay(bufferSize, windowTime, scheduler) {\n        return shareReplay_1.shareReplay(bufferSize, windowTime, scheduler)(this);\n    }\n    exports.shareReplay = shareReplay;\n    ;\n});\n\ndefine('rxjs/add/operator/shareReplay',[\"require\", \"exports\", \"../../Observable\", \"../../operator/shareReplay\"], function (require, exports, Observable_1, shareReplay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.shareReplay = shareReplay_1.shareReplay;\n});\n\ndefine('rxjs/operator/single',[\"require\", \"exports\", \"../operators/single\"], function (require, exports, single_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n     * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n     * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n     *\n     * <img src=\"./img/single.png\" width=\"100%\">\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n     * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n     * the predicate.\n     .\n     * @method single\n     * @owner Observable\n     */\n    function single(predicate) {\n        return single_1.single(predicate)(this);\n    }\n    exports.single = single;\n});\n\ndefine('rxjs/add/operator/single',[\"require\", \"exports\", \"../../Observable\", \"../../operator/single\"], function (require, exports, Observable_1, single_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.single = single_1.single;\n});\n\ndefine('rxjs/operator/skip',[\"require\", \"exports\", \"../operators/skip\"], function (require, exports, skip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips the first `count` items emitted by the source Observable.\n     *\n     * <img src=\"./img/skip.png\" width=\"100%\">\n     *\n     * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n     * @return {Observable} An Observable that skips values emitted by the source Observable.\n     *\n     * @method skip\n     * @owner Observable\n     */\n    function skip(count) {\n        return skip_1.skip(count)(this);\n    }\n    exports.skip = skip;\n});\n\ndefine('rxjs/add/operator/skip',[\"require\", \"exports\", \"../../Observable\", \"../../operator/skip\"], function (require, exports, Observable_1, skip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.skip = skip_1.skip;\n});\n\ndefine('rxjs/operator/skipLast',[\"require\", \"exports\", \"../operators/skipLast\"], function (require, exports, skipLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Skip the last `count` values emitted by the source Observable.\n     *\n     * <img src=\"./img/skipLast.png\" width=\"100%\">\n     *\n     * `skipLast` returns an Observable that accumulates a queue with a length\n     * enough to store the first `count` values. As more values are received,\n     * values are taken from the front of the queue and produced on the result\n     * sequence. This causes values to be delayed.\n     *\n     * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n     * var many = Rx.Observable.range(1, 5);\n     * var skipLastTwo = many.skipLast(2);\n     * skipLastTwo.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // 1 2 3\n     *\n     * @see {@link skip}\n     * @see {@link skipUntil}\n     * @see {@link skipWhile}\n     * @see {@link take}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n     * ArgumentOutOrRangeError if `i < 0`.\n     *\n     * @param {number} count Number of elements to skip from the end of the source Observable.\n     * @returns {Observable<T>} An Observable that skips the last count values\n     * emitted by the source Observable.\n     * @method skipLast\n     * @owner Observable\n     */\n    function skipLast(count) {\n        return skipLast_1.skipLast(count)(this);\n    }\n    exports.skipLast = skipLast;\n});\n\ndefine('rxjs/add/operator/skipLast',[\"require\", \"exports\", \"../../Observable\", \"../../operator/skipLast\"], function (require, exports, Observable_1, skipLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.skipLast = skipLast_1.skipLast;\n});\n\ndefine('rxjs/operator/skipUntil',[\"require\", \"exports\", \"../operators/skipUntil\"], function (require, exports, skipUntil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n     *\n     * <img src=\"./img/skipUntil.png\" width=\"100%\">\n     *\n     * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n     * be mirrored by the resulting Observable.\n     * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n     * an item, then emits the remaining items.\n     * @method skipUntil\n     * @owner Observable\n     */\n    function skipUntil(notifier) {\n        return skipUntil_1.skipUntil(notifier)(this);\n    }\n    exports.skipUntil = skipUntil;\n});\n\ndefine('rxjs/add/operator/skipUntil',[\"require\", \"exports\", \"../../Observable\", \"../../operator/skipUntil\"], function (require, exports, Observable_1, skipUntil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;\n});\n\ndefine('rxjs/operator/skipWhile',[\"require\", \"exports\", \"../operators/skipWhile\"], function (require, exports, skipWhile_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n     * true, but emits all further source items as soon as the condition becomes false.\n     *\n     * <img src=\"./img/skipWhile.png\" width=\"100%\">\n     *\n     * @param {Function} predicate - A function to test each item emitted from the source Observable.\n     * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n     * specified predicate becomes false.\n     * @method skipWhile\n     * @owner Observable\n     */\n    function skipWhile(predicate) {\n        return skipWhile_1.skipWhile(predicate)(this);\n    }\n    exports.skipWhile = skipWhile;\n});\n\ndefine('rxjs/add/operator/skipWhile',[\"require\", \"exports\", \"../../Observable\", \"../../operator/skipWhile\"], function (require, exports, Observable_1, skipWhile_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;\n});\n\ndefine('rxjs/operator/startWith',[\"require\", \"exports\", \"../operators/startWith\"], function (require, exports, startWith_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits the items you specify as arguments before it begins to emit\n     * items emitted by the source Observable.\n     *\n     * <img src=\"./img/startWith.png\" width=\"100%\">\n     *\n     * @param {...T} values - Items you want the modified Observable to emit first.\n     * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n     * emitted by the source Observable.\n     * @method startWith\n     * @owner Observable\n     */\n    function startWith() {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i] = arguments[_i];\n        }\n        return startWith_1.startWith.apply(void 0, array)(this);\n    }\n    exports.startWith = startWith;\n});\n\ndefine('rxjs/add/operator/startWith',[\"require\", \"exports\", \"../../Observable\", \"../../operator/startWith\"], function (require, exports, Observable_1, startWith_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.startWith = startWith_1.startWith;\n});\n\ndefine('rxjs/observable/SubscribeOnObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../scheduler/asap\", \"../util/isNumeric\"], function (require, exports, tslib_1, Observable_1, asap_1, isNumeric_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var SubscribeOnObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(SubscribeOnObservable, _super);\n        function SubscribeOnObservable(source, delayTime, scheduler) {\n            if (delayTime === void 0) { delayTime = 0; }\n            if (scheduler === void 0) { scheduler = asap_1.asap; }\n            var _this = _super.call(this) || this;\n            _this.source = source;\n            _this.delayTime = delayTime;\n            _this.scheduler = scheduler;\n            if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {\n                _this.delayTime = 0;\n            }\n            if (!scheduler || typeof scheduler.schedule !== 'function') {\n                _this.scheduler = asap_1.asap;\n            }\n            return _this;\n        }\n        SubscribeOnObservable.create = function (source, delay, scheduler) {\n            if (delay === void 0) { delay = 0; }\n            if (scheduler === void 0) { scheduler = asap_1.asap; }\n            return new SubscribeOnObservable(source, delay, scheduler);\n        };\n        SubscribeOnObservable.dispatch = function (arg) {\n            var source = arg.source, subscriber = arg.subscriber;\n            return this.add(source.subscribe(subscriber));\n        };\n        SubscribeOnObservable.prototype._subscribe = function (subscriber) {\n            var delay = this.delayTime;\n            var source = this.source;\n            var scheduler = this.scheduler;\n            return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n                source: source, subscriber: subscriber\n            });\n        };\n        return SubscribeOnObservable;\n    }(Observable_1.Observable));\n    exports.SubscribeOnObservable = SubscribeOnObservable;\n});\n\ndefine('rxjs/operators/subscribeOn',[\"require\", \"exports\", \"../observable/SubscribeOnObservable\"], function (require, exports, SubscribeOnObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n     *\n     * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n     *\n     * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n     * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n     .\n     * @method subscribeOn\n     * @owner Observable\n     */\n    function subscribeOn(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        return function subscribeOnOperatorFunction(source) {\n            return source.lift(new SubscribeOnOperator(scheduler, delay));\n        };\n    }\n    exports.subscribeOn = subscribeOn;\n    var SubscribeOnOperator = /** @class */ (function () {\n        function SubscribeOnOperator(scheduler, delay) {\n            this.scheduler = scheduler;\n            this.delay = delay;\n        }\n        SubscribeOnOperator.prototype.call = function (subscriber, source) {\n            return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);\n        };\n        return SubscribeOnOperator;\n    }());\n});\n\ndefine('rxjs/operator/subscribeOn',[\"require\", \"exports\", \"../operators/subscribeOn\"], function (require, exports, subscribeOn_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n     *\n     * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n     *\n     * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n     * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n     .\n     * @method subscribeOn\n     * @owner Observable\n     */\n    function subscribeOn(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        return subscribeOn_1.subscribeOn(scheduler, delay)(this);\n    }\n    exports.subscribeOn = subscribeOn;\n});\n\ndefine('rxjs/add/operator/subscribeOn',[\"require\", \"exports\", \"../../Observable\", \"../../operator/subscribeOn\"], function (require, exports, Observable_1, subscribeOn_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;\n});\n\ndefine('rxjs/operator/switch',[\"require\", \"exports\", \"../operators/switchAll\"], function (require, exports, switchAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by\n     * subscribing to only the most recently emitted of those inner Observables.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n     * previous inner Observable once a new one appears.</span>\n     *\n     * <img src=\"./img/switch.png\" width=\"100%\">\n     *\n     * `switch` subscribes to an Observable that emits Observables, also known as a\n     * higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, the output Observable subscribes to the inner Observable and\n     * begins emitting the items emitted by that. So far, it behaves\n     * like {@link mergeAll}. However, when a new inner Observable is emitted,\n     * `switch` unsubscribes from the earlier-emitted inner Observable and\n     * subscribes to the new inner Observable and begins emitting items from it. It\n     * continues to behave like this for subsequent inner Observables.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * // Each click event is mapped to an Observable that ticks every second\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n     * var switched = higherOrder.switch();\n     * // The outcome is that `switched` is essentially a timer that restarts\n     * // on every click. The interval Observables from older clicks do not merge\n     * // with the current interval Observable.\n     * switched.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link exhaust}\n     * @see {@link mergeAll}\n     * @see {@link switchMap}\n     * @see {@link switchMapTo}\n     * @see {@link zipAll}\n     *\n     * @return {Observable<T>} An Observable that emits the items emitted by the\n     * Observable most recently emitted by the source Observable.\n     * @method switch\n     * @name switch\n     * @owner Observable\n     */\n    function _switch() {\n        return switchAll_1.switchAll()(this);\n    }\n    exports._switch = _switch;\n});\n\ndefine('rxjs/add/operator/switch',[\"require\", \"exports\", \"../../Observable\", \"../../operator/switch\"], function (require, exports, Observable_1, switch_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.switch = switch_1._switch;\n    Observable_1.Observable.prototype._switch = switch_1._switch;\n});\n\ndefine('rxjs/operator/switchMap',[\"require\", \"exports\", \"../operators/switchMap\"], function (require, exports, switchMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable, emitting values only from the most recently projected Observable.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link switch}.</span>\n     *\n     * <img src=\"./img/switchMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. Each time it observes one of these\n     * inner Observables, the output Observable begins emitting the items emitted by\n     * that inner Observable. When a new inner Observable is emitted, `switchMap`\n     * stops emitting items from the earlier-emitted inner Observable and begins\n     * emitting items from the new one. It continues to behave like this for\n     * subsequent inner Observables.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaustMap}\n     * @see {@link mergeMap}\n     * @see {@link switch}\n     * @see {@link switchMapTo}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and taking only the values from the most recently\n     * projected inner Observable.\n     * @method switchMap\n     * @owner Observable\n     */\n    function switchMap(project, resultSelector) {\n        return switchMap_1.switchMap(project, resultSelector)(this);\n    }\n    exports.switchMap = switchMap;\n});\n\ndefine('rxjs/add/operator/switchMap',[\"require\", \"exports\", \"../../Observable\", \"../../operator/switchMap\"], function (require, exports, Observable_1, switchMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n});\n\ndefine('rxjs/operator/switchMapTo',[\"require\", \"exports\", \"../operators/switchMapTo\"], function (require, exports, switchMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is flattened multiple\n     * times with {@link switch} in the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n     * always to the same inner Observable.</span>\n     *\n     * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then flattens those resulting Observables into one\n     * single Observable, which is the output Observable. The output Observables\n     * emits values only from the most recently emitted instance of\n     * `innerObservable`.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMapTo}\n     * @see {@link switch}\n     * @see {@link switchMap}\n     * @see {@link mergeMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits items from the given\n     * `innerObservable` (and optionally transformed through `resultSelector`) every\n     * time a value is emitted on the source Observable, and taking only the values\n     * from the most recently projected inner Observable.\n     * @method switchMapTo\n     * @owner Observable\n     */\n    function switchMapTo(innerObservable, resultSelector) {\n        return switchMapTo_1.switchMapTo(innerObservable, resultSelector)(this);\n    }\n    exports.switchMapTo = switchMapTo;\n});\n\ndefine('rxjs/add/operator/switchMapTo',[\"require\", \"exports\", \"../../Observable\", \"../../operator/switchMapTo\"], function (require, exports, Observable_1, switchMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;\n});\n\ndefine('rxjs/operator/take',[\"require\", \"exports\", \"../operators/take\"], function (require, exports, take_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first `count` values emitted by the source Observable.\n     *\n     * <span class=\"informal\">Takes the first `count` values from the source, then\n     * completes.</span>\n     *\n     * <img src=\"./img/take.png\" width=\"100%\">\n     *\n     * `take` returns an Observable that emits only the first `count` values emitted\n     * by the source Observable. If the source emits fewer than `count` values then\n     * all of its values are emitted. After that, it completes, regardless if the\n     * source completes.\n     *\n     * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var five = interval.take(5);\n     * five.subscribe(x => console.log(x));\n     *\n     * @see {@link takeLast}\n     * @see {@link takeUntil}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n     *\n     * @param {number} count The maximum number of `next` values to emit.\n     * @return {Observable<T>} An Observable that emits only the first `count`\n     * values emitted by the source Observable, or all of the values from the source\n     * if the source emits fewer than `count` values.\n     * @method take\n     * @owner Observable\n     */\n    function take(count) {\n        return take_1.take(count)(this);\n    }\n    exports.take = take;\n});\n\ndefine('rxjs/add/operator/take',[\"require\", \"exports\", \"../../Observable\", \"../../operator/take\"], function (require, exports, Observable_1, take_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.take = take_1.take;\n});\n\ndefine('rxjs/operator/takeLast',[\"require\", \"exports\", \"../operators/takeLast\"], function (require, exports, takeLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the last `count` values emitted by the source Observable.\n     *\n     * <span class=\"informal\">Remembers the latest `count` values, then emits those\n     * only when the source completes.</span>\n     *\n     * <img src=\"./img/takeLast.png\" width=\"100%\">\n     *\n     * `takeLast` returns an Observable that emits at most the last `count` values\n     * emitted by the source Observable. If the source emits fewer than `count`\n     * values then all of its values are emitted. This operator must wait until the\n     * `complete` notification emission from the source in order to emit the `next`\n     * values on the output Observable, because otherwise it is impossible to know\n     * whether or not more values will be emitted on the source. For this reason,\n     * all values are emitted synchronously, followed by the complete notification.\n     *\n     * @example <caption>Take the last 3 values of an Observable with many values</caption>\n     * var many = Rx.Observable.range(1, 100);\n     * var lastThree = many.takeLast(3);\n     * lastThree.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeUntil}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n     *\n     * @param {number} count The maximum number of values to emit from the end of\n     * the sequence of values emitted by the source Observable.\n     * @return {Observable<T>} An Observable that emits at most the last count\n     * values emitted by the source Observable.\n     * @method takeLast\n     * @owner Observable\n     */\n    function takeLast(count) {\n        return takeLast_1.takeLast(count)(this);\n    }\n    exports.takeLast = takeLast;\n});\n\ndefine('rxjs/add/operator/takeLast',[\"require\", \"exports\", \"../../Observable\", \"../../operator/takeLast\"], function (require, exports, Observable_1, takeLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.takeLast = takeLast_1.takeLast;\n});\n\ndefine('rxjs/operator/takeUntil',[\"require\", \"exports\", \"../operators/takeUntil\"], function (require, exports, takeUntil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the values emitted by the source Observable until a `notifier`\n     * Observable emits a value.\n     *\n     * <span class=\"informal\">Lets values pass until a second Observable,\n     * `notifier`, emits something. Then, it completes.</span>\n     *\n     * <img src=\"./img/takeUntil.png\" width=\"100%\">\n     *\n     * `takeUntil` subscribes and begins mirroring the source Observable. It also\n     * monitors a second Observable, `notifier` that you provide. If the `notifier`\n     * emits a value, the output Observable stops mirroring the source Observable\n     * and completes.\n     *\n     * @example <caption>Tick every second until the first click happens</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = interval.takeUntil(clicks);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeLast}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @param {Observable} notifier The Observable whose first emitted value will\n     * cause the output Observable of `takeUntil` to stop emitting values from the\n     * source Observable.\n     * @return {Observable<T>} An Observable that emits the values from the source\n     * Observable until such time as `notifier` emits its first value.\n     * @method takeUntil\n     * @owner Observable\n     */\n    function takeUntil(notifier) {\n        return takeUntil_1.takeUntil(notifier)(this);\n    }\n    exports.takeUntil = takeUntil;\n});\n\ndefine('rxjs/add/operator/takeUntil',[\"require\", \"exports\", \"../../Observable\", \"../../operator/takeUntil\"], function (require, exports, Observable_1, takeUntil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n});\n\ndefine('rxjs/operator/takeWhile',[\"require\", \"exports\", \"../operators/takeWhile\"], function (require, exports, takeWhile_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits values emitted by the source Observable so long as each value satisfies\n     * the given `predicate`, and then completes as soon as this `predicate` is not\n     * satisfied.\n     *\n     * <span class=\"informal\">Takes values from the source only while they pass the\n     * condition given. When the first value does not satisfy, it completes.</span>\n     *\n     * <img src=\"./img/takeWhile.png\" width=\"100%\">\n     *\n     * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n     * emitted on the source is given to the `predicate` function which returns a\n     * boolean, representing a condition to be satisfied by the source values. The\n     * output Observable emits the source values until such time as the `predicate`\n     * returns false, at which point `takeWhile` stops mirroring the source\n     * Observable and completes the output Observable.\n     *\n     * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.takeWhile(ev => ev.clientX > 200);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeLast}\n     * @see {@link takeUntil}\n     * @see {@link skip}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates a value emitted by the source Observable and returns a boolean.\n     * Also takes the (zero-based) index as the second argument.\n     * @return {Observable<T>} An Observable that emits the values from the source\n     * Observable so long as each value satisfies the condition defined by the\n     * `predicate`, then completes.\n     * @method takeWhile\n     * @owner Observable\n     */\n    function takeWhile(predicate) {\n        return takeWhile_1.takeWhile(predicate)(this);\n    }\n    exports.takeWhile = takeWhile;\n});\n\ndefine('rxjs/add/operator/takeWhile',[\"require\", \"exports\", \"../../Observable\", \"../../operator/takeWhile\"], function (require, exports, Observable_1, takeWhile_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;\n});\n\ndefine('rxjs/operator/throttle',[\"require\", \"exports\", \"../operators/throttle\"], function (require, exports, throttle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable, then ignores subsequent source\n     * values for a duration determined by another Observable, then repeats this\n     * process.\n     *\n     * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n     * duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/throttle.png\" width=\"100%\">\n     *\n     * `throttle` emits the source Observable values on the output Observable\n     * when its internal timer is disabled, and ignores source values when the timer\n     * is enabled. Initially, the timer is disabled. As soon as the first source\n     * value arrives, it is forwarded to the output Observable, and then the timer\n     * is enabled by calling the `durationSelector` function with the source value,\n     * which returns the \"duration\" Observable. When the duration Observable emits a\n     * value or completes, the timer is disabled, and this process repeats for the\n     * next source value.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounce}\n     * @see {@link delayWhen}\n     * @see {@link sample}\n     * @see {@link throttleTime}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the silencing\n     * duration for each source value, returned as an Observable or a Promise.\n     * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n     * to `{ leading: true, trailing: false }`.\n     * @return {Observable<T>} An Observable that performs the throttle operation to\n     * limit the rate of emissions from the source.\n     * @method throttle\n     * @owner Observable\n     */\n    function throttle(durationSelector, config) {\n        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n        return throttle_1.throttle(durationSelector, config)(this);\n    }\n    exports.throttle = throttle;\n});\n\ndefine('rxjs/add/operator/throttle',[\"require\", \"exports\", \"../../Observable\", \"../../operator/throttle\"], function (require, exports, Observable_1, throttle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.throttle = throttle_1.throttle;\n});\n\ndefine('rxjs/operator/throttleTime',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/throttle\", \"../operators/throttleTime\"], function (require, exports, async_1, throttle_1, throttleTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable, then ignores subsequent source\n     * values for `duration` milliseconds, then repeats this process.\n     *\n     * <span class=\"informal\">Lets a value pass, then ignores source values for the\n     * next `duration` milliseconds.</span>\n     *\n     * <img src=\"./img/throttleTime.png\" width=\"100%\">\n     *\n     * `throttleTime` emits the source Observable values on the output Observable\n     * when its internal timer is disabled, and ignores source values when the timer\n     * is enabled. Initially, the timer is disabled. As soon as the first source\n     * value arrives, it is forwarded to the output Observable, and then the timer\n     * is enabled. After `duration` milliseconds (or the time unit determined\n     * internally by the optional `scheduler`) has passed, the timer is disabled,\n     * and this process repeats for the next source value. Optionally takes a\n     * {@link IScheduler} for managing timers.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.throttleTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttle}\n     *\n     * @param {number} duration Time to wait before emitting another value after\n     * emitting the last value, measured in milliseconds or the time unit determined\n     * internally by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the throttling.\n     * @return {Observable<T>} An Observable that performs the throttle operation to\n     * limit the rate of emissions from the source.\n     * @method throttleTime\n     * @owner Observable\n     */\n    function throttleTime(duration, scheduler, config) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n        return throttleTime_1.throttleTime(duration, scheduler, config)(this);\n    }\n    exports.throttleTime = throttleTime;\n});\n\ndefine('rxjs/add/operator/throttleTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/throttleTime\"], function (require, exports, Observable_1, throttleTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;\n});\n\ndefine('rxjs/add/operator/timeInterval',[\"require\", \"exports\", \"../../Observable\", \"../../operator/timeInterval\"], function (require, exports, Observable_1, timeInterval_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;\n});\n\ndefine('rxjs/operator/timeout',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/timeout\"], function (require, exports, async_1, timeout_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Errors if Observable does not emit a value in given time span.\n     *\n     * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n     *\n     * <img src=\"./img/timeout.png\" width=\"100%\">\n     *\n     * `timeout` operator accepts as an argument either a number or a Date.\n     *\n     * If number was provided, it returns an Observable that behaves like a source\n     * Observable, unless there is a period of time where there is no value emitted.\n     * So if you provide `100` as argument and first value comes after 50ms from\n     * the moment of subscription, this value will be simply re-emitted by the resulting\n     * Observable. If however after that 100ms passes without a second value being emitted,\n     * stream will end with an error and source Observable will be unsubscribed.\n     * These checks are performed throughout whole lifecycle of Observable - from the moment\n     * it was subscribed to, until it completes or errors itself. Thus every value must be\n     * emitted within specified period since previous value.\n     *\n     * If provided argument was Date, returned Observable behaves differently. It throws\n     * if Observable did not complete before provided Date. This means that periods between\n     * emission of particular values do not matter in this case. If Observable did not complete\n     * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n     * stream behaves just as source Observable.\n     *\n     * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n     * when returned Observable will check if source stream emitted value or completed.\n     *\n     * @example <caption>Check if ticks are emitted within certain timespan</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n     *                       // since `interval` might fire a bit later then scheduled.\n     * .subscribe(\n     *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n     *     err => console.log(err) // Will never be called.\n     * );\n     *\n     * seconds.timeout(900).subscribe(\n     *     value => console.log(value), // Will never be called.\n     *     err => console.log(err) // Will emit error before even first value is emitted,\n     *                             // since it did not arrive within 900ms period.\n     * );\n     *\n     * @example <caption>Use Date to check if Observable completed</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n     * .subscribe(\n     *     value => console.log(value), // Will emit values as regular `interval` would\n     *                                  // until December 17, 2020 at 03:24:00.\n     *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n     *                             // since Observable did not complete by then.\n     * );\n     *\n     * @see {@link timeoutWith}\n     *\n     * @param {number|Date} due Number specifying period within which Observable must emit values\n     *                          or Date specifying before when Observable should complete\n     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n     * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n     * @method timeout\n     * @owner Observable\n     */\n    function timeout(due, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return timeout_1.timeout(due, scheduler)(this);\n    }\n    exports.timeout = timeout;\n});\n\ndefine('rxjs/add/operator/timeout',[\"require\", \"exports\", \"../../Observable\", \"../../operator/timeout\"], function (require, exports, Observable_1, timeout_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.timeout = timeout_1.timeout;\n});\n\ndefine('rxjs/operator/timeoutWith',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/timeoutWith\"], function (require, exports, async_1, timeoutWith_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     *\n     * Errors if Observable does not emit a value in given time span, in case of which\n     * subscribes to the second Observable.\n     *\n     * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n     *\n     * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n     *\n     * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n     * still accepting as a first argument either a number or a Date, which control - respectively -\n     * when values of source Observable should be emitted or when it should complete.\n     *\n     * The only difference is that it accepts a second, required parameter. This parameter\n     * should be an Observable which will be subscribed when source Observable fails any timeout check.\n     * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n     * values from second Observable. Note that this fallback Observable is not checked for timeouts\n     * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n     * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n     * stream completes, it completes as well.\n     *\n     * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n     * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n     * as a consequence - when second Observable will be subscribed, since subscription happens\n     * immediately after failing check.\n     *\n     * @example <caption>Add fallback observable</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     * const minutes = Rx.Observable.interval(60 * 1000);\n     *\n     * seconds.timeoutWith(900, minutes)\n     *     .subscribe(\n     *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n     *                                      // since first value of `seconds` will not arrive fast enough.\n     *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n     *                                 // but here will never be called.\n     *     );\n     *\n     * @param {number|Date} due Number specifying period within which Observable must emit values\n     *                          or Date specifying before when Observable should complete\n     * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n     * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n     *                          passed as a second parameter.\n     * @method timeoutWith\n     * @owner Observable\n     */\n    function timeoutWith(due, withObservable, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return timeoutWith_1.timeoutWith(due, withObservable, scheduler)(this);\n    }\n    exports.timeoutWith = timeoutWith;\n});\n\ndefine('rxjs/add/operator/timeoutWith',[\"require\", \"exports\", \"../../Observable\", \"../../operator/timeoutWith\"], function (require, exports, Observable_1, timeoutWith_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;\n});\n\ndefine('rxjs/operator/timestamp',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/timestamp\"], function (require, exports, async_1, timestamp_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param scheduler\n     * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n     * @method timestamp\n     * @owner Observable\n     */\n    function timestamp(scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return timestamp_1.timestamp(scheduler)(this);\n    }\n    exports.timestamp = timestamp;\n});\n\ndefine('rxjs/add/operator/timestamp',[\"require\", \"exports\", \"../../Observable\", \"../../operator/timestamp\"], function (require, exports, Observable_1, timestamp_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.timestamp = timestamp_1.timestamp;\n});\n\ndefine('rxjs/operator/toArray',[\"require\", \"exports\", \"../operators/toArray\"], function (require, exports, toArray_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Collects all source emissions and emits them as an array when the source completes.\n     *\n     * <span class=\"informal\">Get all values inside an array when the source completes</span>\n     *\n     * <img src=\"./img/toArray.png\" width=\"100%\">\n     *\n     * `toArray` will wait until the source Observable completes\n     * before emitting the array containing all emissions.\n     * When the source Observable errors no array will be emitted.\n     *\n     * @example <caption>Create array from input</caption>\n     * const input = Rx.Observable.interval(100).take(4);\n     *\n     * input.toArray()\n     *   .subscribe(arr => console.log(arr)); // [0,1,2,3]\n     *\n     * @see {@link buffer}\n     *\n     * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n     * @method toArray\n     * @owner Observable\n     */\n    function toArray() {\n        return toArray_1.toArray()(this);\n    }\n    exports.toArray = toArray;\n});\n\ndefine('rxjs/add/operator/toArray',[\"require\", \"exports\", \"../../Observable\", \"../../operator/toArray\"], function (require, exports, Observable_1, toArray_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.toArray = toArray_1.toArray;\n});\n\n// HACK: does nothing, because `toPromise` now lives on the `Observable` itself.\n// leaving this module here to prevent breakage.\n;\ndefine(\"rxjs/add/operator/toPromise\", function(){});\n\ndefine('rxjs/operator/window',[\"require\", \"exports\", \"../operators/window\"], function (require, exports, window_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable whenever\n     * `windowBoundaries` emits.\n     *\n     * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n     * instead of an array.</span>\n     *\n     * <img src=\"./img/window.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits connected, non-overlapping\n     * windows. It emits the current window and opens a new one whenever the\n     * Observable `windowBoundaries` emits an item. Because each window is an\n     * Observable, the output is a higher-order Observable.\n     *\n     * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = clicks.window(interval)\n     *   .map(win => win.take(2)) // each window has at most 2 emissions\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link windowWhen}\n     * @see {@link buffer}\n     *\n     * @param {Observable<any>} windowBoundaries An Observable that completes the\n     * previous window and starts a new window.\n     * @return {Observable<Observable<T>>} An Observable of windows, which are\n     * Observables emitting values of the source Observable.\n     * @method window\n     * @owner Observable\n     */\n    function window(windowBoundaries) {\n        return window_1.window(windowBoundaries)(this);\n    }\n    exports.window = window;\n});\n\ndefine('rxjs/add/operator/window',[\"require\", \"exports\", \"../../Observable\", \"../../operator/window\"], function (require, exports, Observable_1, window_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.window = window_1.window;\n});\n\ndefine('rxjs/operator/windowCount',[\"require\", \"exports\", \"../operators/windowCount\"], function (require, exports, windowCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable with each\n     * nested Observable emitting at most `windowSize` values.\n     *\n     * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowCount.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits windows every `startWindowEvery`\n     * items, each containing no more than `windowSize` items. When the source\n     * Observable completes or encounters an error, the output Observable emits\n     * the current window and propagates the notification from the source\n     * Observable. If `startWindowEvery` is not provided, then new windows are\n     * started immediately at the start of the source and when each window completes\n     * with size `windowSize`.\n     *\n     * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.windowCount(3)\n     *   .map(win => win.skip(1)) // skip first of every 3 clicks\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.windowCount(2, 3)\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link windowWhen}\n     * @see {@link bufferCount}\n     *\n     * @param {number} windowSize The maximum number of values emitted by each\n     * window.\n     * @param {number} [startWindowEvery] Interval at which to start a new window.\n     * For example if `startWindowEvery` is `2`, then a new window will be started\n     * on every other value from the source. A new window is started at the\n     * beginning of the source by default.\n     * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n     * are Observable of values.\n     * @method windowCount\n     * @owner Observable\n     */\n    function windowCount(windowSize, startWindowEvery) {\n        if (startWindowEvery === void 0) { startWindowEvery = 0; }\n        return windowCount_1.windowCount(windowSize, startWindowEvery)(this);\n    }\n    exports.windowCount = windowCount;\n});\n\ndefine('rxjs/add/operator/windowCount',[\"require\", \"exports\", \"../../Observable\", \"../../operator/windowCount\"], function (require, exports, Observable_1, windowCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.windowCount = windowCount_1.windowCount;\n});\n\ndefine('rxjs/operator/windowTime',[\"require\", \"exports\", \"../scheduler/async\", \"../util/isNumeric\", \"../util/isScheduler\", \"../operators/windowTime\"], function (require, exports, async_1, isNumeric_1, isScheduler_1, windowTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function windowTime(windowTimeSpan) {\n        var scheduler = async_1.async;\n        var windowCreationInterval = null;\n        var maxWindowSize = Number.POSITIVE_INFINITY;\n        if (isScheduler_1.isScheduler(arguments[3])) {\n            scheduler = arguments[3];\n        }\n        if (isScheduler_1.isScheduler(arguments[2])) {\n            scheduler = arguments[2];\n        }\n        else if (isNumeric_1.isNumeric(arguments[2])) {\n            maxWindowSize = arguments[2];\n        }\n        if (isScheduler_1.isScheduler(arguments[1])) {\n            scheduler = arguments[1];\n        }\n        else if (isNumeric_1.isNumeric(arguments[1])) {\n            windowCreationInterval = arguments[1];\n        }\n        return windowTime_1.windowTime(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)(this);\n    }\n    exports.windowTime = windowTime;\n});\n\ndefine('rxjs/add/operator/windowTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/windowTime\"], function (require, exports, Observable_1, windowTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.windowTime = windowTime_1.windowTime;\n});\n\ndefine('rxjs/operator/windowToggle',[\"require\", \"exports\", \"../operators/windowToggle\"], function (require, exports, windowToggle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable starting from\n     * an emission from `openings` and ending when the output of `closingSelector`\n     * emits.\n     *\n     * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowToggle.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits windows that contain those items\n     * emitted by the source Observable between the time when the `openings`\n     * Observable emits an item and when the Observable returned by\n     * `closingSelector` emits an item.\n     *\n     * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var openings = Rx.Observable.interval(1000);\n     * var result = clicks.windowToggle(openings, i =>\n     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n     * ).mergeAll();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowWhen}\n     * @see {@link bufferToggle}\n     *\n     * @param {Observable<O>} openings An observable of notifications to start new\n     * windows.\n     * @param {function(value: O): Observable} closingSelector A function that takes\n     * the value emitted by the `openings` observable and returns an Observable,\n     * which, when it emits (either `next` or `complete`), signals that the\n     * associated window should complete.\n     * @return {Observable<Observable<T>>} An observable of windows, which in turn\n     * are Observables.\n     * @method windowToggle\n     * @owner Observable\n     */\n    function windowToggle(openings, closingSelector) {\n        return windowToggle_1.windowToggle(openings, closingSelector)(this);\n    }\n    exports.windowToggle = windowToggle;\n});\n\ndefine('rxjs/add/operator/windowToggle',[\"require\", \"exports\", \"../../Observable\", \"../../operator/windowToggle\"], function (require, exports, Observable_1, windowToggle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;\n});\n\ndefine('rxjs/operator/windowWhen',[\"require\", \"exports\", \"../operators/windowWhen\"], function (require, exports, windowWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable using a\n     * factory function of closing Observables to determine when to start a new\n     * window.\n     *\n     * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowWhen.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits connected, non-overlapping windows.\n     * It emits the current window and opens a new one whenever the Observable\n     * produced by the specified `closingSelector` function emits an item. The first\n     * window is opened immediately when subscribing to the output Observable.\n     *\n     * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks\n     *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n     *   .map(win => win.take(2)) // each window has at most 2 emissions\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link bufferWhen}\n     *\n     * @param {function(): Observable} closingSelector A function that takes no\n     * arguments and returns an Observable that signals (on either `next` or\n     * `complete`) when to close the previous window and start a new one.\n     * @return {Observable<Observable<T>>} An observable of windows, which in turn\n     * are Observables.\n     * @method windowWhen\n     * @owner Observable\n     */\n    function windowWhen(closingSelector) {\n        return windowWhen_1.windowWhen(closingSelector)(this);\n    }\n    exports.windowWhen = windowWhen;\n});\n\ndefine('rxjs/add/operator/windowWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/windowWhen\"], function (require, exports, Observable_1, windowWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;\n});\n\ndefine('rxjs/operator/withLatestFrom',[\"require\", \"exports\", \"../operators/withLatestFrom\"], function (require, exports, withLatestFrom_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines the source Observable with other Observables to create an Observable\n     * whose values are calculated from the latest values of each, only when the\n     * source emits.\n     *\n     * <span class=\"informal\">Whenever the source Observable emits a value, it\n     * computes a formula using that value plus the latest values from other input\n     * Observables, then emits the output of that formula.</span>\n     *\n     * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n     *\n     * `withLatestFrom` combines each value from the source Observable (the\n     * instance) with the latest values from the other input Observables only when\n     * the source emits a value, optionally using a `project` function to determine\n     * the value to be emitted on the output Observable. All input Observables must\n     * emit at least one value before the output Observable will emit a value.\n     *\n     * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var result = clicks.withLatestFrom(timer);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineLatest}\n     *\n     * @param {ObservableInput} other An input Observable to combine with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {Function} [project] Projection function for combining values\n     * together. Receives all values in order of the Observables passed, where the\n     * first parameter is a value from the source Observable. (e.g.\n     * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n     * passed, arrays will be emitted on the output Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @method withLatestFrom\n     * @owner Observable\n     */\n    function withLatestFrom() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return withLatestFrom_1.withLatestFrom.apply(void 0, args)(this);\n    }\n    exports.withLatestFrom = withLatestFrom;\n});\n\ndefine('rxjs/add/operator/withLatestFrom',[\"require\", \"exports\", \"../../Observable\", \"../../operator/withLatestFrom\"], function (require, exports, Observable_1, withLatestFrom_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n});\n\ndefine('rxjs/operator/zip',[\"require\", \"exports\", \"../operators/zip\"], function (require, exports, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * @param observables\n     * @return {Observable<R>}\n     * @method zip\n     * @owner Observable\n     */\n    function zipProto() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return zip_1.zip.apply(void 0, observables)(this);\n    }\n    exports.zipProto = zipProto;\n});\n\ndefine('rxjs/add/operator/zip',[\"require\", \"exports\", \"../../Observable\", \"../../operator/zip\"], function (require, exports, Observable_1, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.zip = zip_1.zipProto;\n});\n\ndefine('rxjs/operator/zipAll',[\"require\", \"exports\", \"../operators/zipAll\"], function (require, exports, zipAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param project\n     * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n     * @method zipAll\n     * @owner Observable\n     */\n    function zipAll(project) {\n        return zipAll_1.zipAll(project)(this);\n    }\n    exports.zipAll = zipAll;\n});\n\ndefine('rxjs/add/operator/zipAll',[\"require\", \"exports\", \"../../Observable\", \"../../operator/zipAll\"], function (require, exports, Observable_1, zipAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.zipAll = zipAll_1.zipAll;\n});\n\ndefine('rxjs/Rx',[\"require\", \"exports\", \"./Subject\", \"./Observable\", \"./Subscription\", \"./Subscriber\", \"./AsyncSubject\", \"./ReplaySubject\", \"./BehaviorSubject\", \"./observable/ConnectableObservable\", \"./Notification\", \"./util/EmptyError\", \"./util/ArgumentOutOfRangeError\", \"./util/ObjectUnsubscribedError\", \"./util/TimeoutError\", \"./util/UnsubscriptionError\", \"./operator/timeInterval\", \"./operators/timestamp\", \"./testing/TestScheduler\", \"./scheduler/VirtualTimeScheduler\", \"./observable/dom/AjaxObservable\", \"./util/pipe\", \"./scheduler/asap\", \"./scheduler/async\", \"./scheduler/queue\", \"./scheduler/animationFrame\", \"./symbol/rxSubscriber\", \"./symbol/iterator\", \"./symbol/observable\", \"./operators\", \"./add/observable/bindCallback\", \"./add/observable/bindNodeCallback\", \"./add/observable/combineLatest\", \"./add/observable/concat\", \"./add/observable/defer\", \"./add/observable/empty\", \"./add/observable/forkJoin\", \"./add/observable/from\", \"./add/observable/fromEvent\", \"./add/observable/fromEventPattern\", \"./add/observable/fromPromise\", \"./add/observable/generate\", \"./add/observable/if\", \"./add/observable/interval\", \"./add/observable/merge\", \"./add/observable/race\", \"./add/observable/never\", \"./add/observable/of\", \"./add/observable/onErrorResumeNext\", \"./add/observable/pairs\", \"./add/observable/range\", \"./add/observable/using\", \"./add/observable/throw\", \"./add/observable/timer\", \"./add/observable/zip\", \"./add/observable/dom/ajax\", \"./add/observable/dom/webSocket\", \"./add/operator/buffer\", \"./add/operator/bufferCount\", \"./add/operator/bufferTime\", \"./add/operator/bufferToggle\", \"./add/operator/bufferWhen\", \"./add/operator/catch\", \"./add/operator/combineAll\", \"./add/operator/combineLatest\", \"./add/operator/concat\", \"./add/operator/concatAll\", \"./add/operator/concatMap\", \"./add/operator/concatMapTo\", \"./add/operator/count\", \"./add/operator/dematerialize\", \"./add/operator/debounce\", \"./add/operator/debounceTime\", \"./add/operator/defaultIfEmpty\", \"./add/operator/delay\", \"./add/operator/delayWhen\", \"./add/operator/distinct\", \"./add/operator/distinctUntilChanged\", \"./add/operator/distinctUntilKeyChanged\", \"./add/operator/do\", \"./add/operator/exhaust\", \"./add/operator/exhaustMap\", \"./add/operator/expand\", \"./add/operator/elementAt\", \"./add/operator/filter\", \"./add/operator/finally\", \"./add/operator/find\", \"./add/operator/findIndex\", \"./add/operator/first\", \"./add/operator/groupBy\", \"./add/operator/ignoreElements\", \"./add/operator/isEmpty\", \"./add/operator/audit\", \"./add/operator/auditTime\", \"./add/operator/last\", \"./add/operator/let\", \"./add/operator/every\", \"./add/operator/map\", \"./add/operator/mapTo\", \"./add/operator/materialize\", \"./add/operator/max\", \"./add/operator/merge\", \"./add/operator/mergeAll\", \"./add/operator/mergeMap\", \"./add/operator/mergeMapTo\", \"./add/operator/mergeScan\", \"./add/operator/min\", \"./add/operator/multicast\", \"./add/operator/observeOn\", \"./add/operator/onErrorResumeNext\", \"./add/operator/pairwise\", \"./add/operator/partition\", \"./add/operator/pluck\", \"./add/operator/publish\", \"./add/operator/publishBehavior\", \"./add/operator/publishReplay\", \"./add/operator/publishLast\", \"./add/operator/race\", \"./add/operator/reduce\", \"./add/operator/repeat\", \"./add/operator/repeatWhen\", \"./add/operator/retry\", \"./add/operator/retryWhen\", \"./add/operator/sample\", \"./add/operator/sampleTime\", \"./add/operator/scan\", \"./add/operator/sequenceEqual\", \"./add/operator/share\", \"./add/operator/shareReplay\", \"./add/operator/single\", \"./add/operator/skip\", \"./add/operator/skipLast\", \"./add/operator/skipUntil\", \"./add/operator/skipWhile\", \"./add/operator/startWith\", \"./add/operator/subscribeOn\", \"./add/operator/switch\", \"./add/operator/switchMap\", \"./add/operator/switchMapTo\", \"./add/operator/take\", \"./add/operator/takeLast\", \"./add/operator/takeUntil\", \"./add/operator/takeWhile\", \"./add/operator/throttle\", \"./add/operator/throttleTime\", \"./add/operator/timeInterval\", \"./add/operator/timeout\", \"./add/operator/timeoutWith\", \"./add/operator/timestamp\", \"./add/operator/toArray\", \"./add/operator/toPromise\", \"./add/operator/window\", \"./add/operator/windowCount\", \"./add/operator/windowTime\", \"./add/operator/windowToggle\", \"./add/operator/windowWhen\", \"./add/operator/withLatestFrom\", \"./add/operator/zip\", \"./add/operator/zipAll\"], function (require, exports, Subject_1, Observable_1, Subscription_1, Subscriber_1, AsyncSubject_1, ReplaySubject_1, BehaviorSubject_1, ConnectableObservable_1, Notification_1, EmptyError_1, ArgumentOutOfRangeError_1, ObjectUnsubscribedError_1, TimeoutError_1, UnsubscriptionError_1, timeInterval_1, timestamp_1, TestScheduler_1, VirtualTimeScheduler_1, AjaxObservable_1, pipe_1, asap_1, async_1, queue_1, animationFrame_1, rxSubscriber_1, iterator_1, observable_1, _operators) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Subject = Subject_1.Subject;\n    exports.AnonymousSubject = Subject_1.AnonymousSubject;\n    exports.Observable = Observable_1.Observable;\n    exports.Subscription = Subscription_1.Subscription;\n    exports.Subscriber = Subscriber_1.Subscriber;\n    exports.AsyncSubject = AsyncSubject_1.AsyncSubject;\n    exports.ReplaySubject = ReplaySubject_1.ReplaySubject;\n    exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;\n    exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;\n    exports.Notification = Notification_1.Notification;\n    exports.EmptyError = EmptyError_1.EmptyError;\n    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n    exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;\n    exports.TimeoutError = TimeoutError_1.TimeoutError;\n    exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;\n    exports.TimeInterval = timeInterval_1.TimeInterval;\n    exports.Timestamp = timestamp_1.Timestamp;\n    exports.TestScheduler = TestScheduler_1.TestScheduler;\n    exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;\n    exports.AjaxResponse = AjaxObservable_1.AjaxResponse;\n    exports.AjaxError = AjaxObservable_1.AjaxError;\n    exports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;\n    exports.pipe = pipe_1.pipe;\n    exports.operators = _operators;\n    /* tslint:enable:no-unused-variable */\n    /**\n     * @typedef {Object} Rx.Scheduler\n     * @property {Scheduler} queue Schedules on a queue in the current event frame\n     * (trampoline scheduler). Use this for iteration operations.\n     * @property {Scheduler} asap Schedules on the micro task queue, which uses the\n     * fastest transport mechanism available, either Node.js' `process.nextTick()`\n     * or Web Worker MessageChannel or setTimeout or others. Use this for\n     * asynchronous conversions.\n     * @property {Scheduler} async Schedules work with `setInterval`. Use this for\n     * time-based operations.\n     * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.\n     * Use this for synchronizing with the platform's painting\n     */\n    var Scheduler = {\n        asap: asap_1.asap,\n        queue: queue_1.queue,\n        animationFrame: animationFrame_1.animationFrame,\n        async: async_1.async\n    };\n    exports.Scheduler = Scheduler;\n    /**\n     * @typedef {Object} Rx.Symbol\n     * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n     * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n     * an object that has all of the traits of an Rx Subscriber, including the\n     * ability to add and remove subscriptions to the subscription chain and\n     * guarantees involving event triggering (can't \"next\" after unsubscription,\n     * etc).\n     * @property {Symbol|string} observable A symbol to use as a property name to\n     * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n     * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n     * to retrieve an iterator from an object.\n     */\n    var Symbol = {\n        rxSubscriber: rxSubscriber_1.rxSubscriber,\n        observable: observable_1.observable,\n        iterator: iterator_1.iterator\n    };\n    exports.Symbol = Symbol;\n});\n\n"]}