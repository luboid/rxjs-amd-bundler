{"version":3,"sources":["rxjs.js"],"names":["define","require","exports","Object","defineProperty","value","__window","window","__self","self","WorkerGlobalScope","__global","global","_root","root","Error","isFunction","x","isArray","Array","length","isObject","errorObject","e","errorObject_1","tryCatcher","tryCatchTarget","apply","this","arguments","tryCatch","fn","tslib_1","UnsubscriptionError","_super","errors","_this","call","err","map","i","toString","join","name","stack","message","__extends","isArray_1","isObject_1","isFunction_1","tryCatch_1","UnsubscriptionError_1","flattenUnsubscriptionErrors","reduce","errs","concat","Subscription","unsubscribe","closed","_parent","_parents","_subscriptions","_unsubscribe","prototype","hasErrors","index","len","remove","sub","push","add","teardown","EMPTY","subscription","_addParent","tmp","subscriptions","subscriptionIndex","indexOf","splice","parent","empty","next","error","complete","root_1","Symbol","rxSubscriber","for","$$rxSubscriber","Subscription_1","Observer_1","rxSubscriber_1","Subscriber","destinationOrNext","syncErrorValue","syncErrorThrown","syncErrorThrowable","isStopped","destination","SafeSubscriber","create","subscriber","_next","_error","_complete","_unsubscribeAndRecycle","_parentSubscriber","observerOrNext","context","bind","_context","__tryOrSetError","__tryOrUnsub","wrappedComplete","Subscriber_1","toSubscriber","nextOrObserver","getSymbolObservable","$$observable","observable","noop","noop_1","pipeFromArray","fns","input","prev","pipe","_i","toSubscriber_1","observable_1","pipe_1","Observable","subscribe","_isScalar","_subscribe","lift","operator","source","sink","_trySubscribe","forEach","PromiseCtor","Rx","config","Promise","resolve","reject","operations","toPromise","ObjectUnsubscribedError","SubjectSubscription","subject","observers","subscriberIndex","Observable_1","ObjectUnsubscribedError_1","SubjectSubscription_1","SubjectSubscriber","Subject","hasError","thrownError","AnonymousSubject","copy","slice","asObservable","Subject_1","AsyncSubject","hasNext","hasCompleted","Action","scheduler","work","schedule","state","delay","Action_1","AsyncAction","pending","id","recycleAsyncId","requestAsyncId","setInterval","flush","clearInterval","execute","_execute","errored","errorValue","undefined","actions","AsyncAction_1","QueueAction","Scheduler","SchedulerAction","now","Date","Scheduler_1","AsyncScheduler","active","scheduled","action","shift","AsyncScheduler_1","QueueScheduler","QueueAction_1","QueueScheduler_1","queue","Notification","kind","hasValue","observe","observer","do","accept","toObservable","of","throw","createNext","undefinedValueNotification","createError","createComplete","completeNotification","Notification_1","observeOn","ObserveOnOperator","ObserveOnSubscriber","dispatch","arg","notification","scheduleMessage","ObserveOnMessage","queue_1","observeOn_1","ReplaySubject","bufferSize","windowTime","Number","POSITIVE_INFINITY","_events","_bufferSize","_windowTime","_getNow","ReplayEvent","_trimBufferThenGetEvents","eventsCount","spliceCount","time","Math","max","BehaviorSubject","_value","get","getValue","enumerable","configurable","refCount","RefCountOperator","connectable","_refCount","refCounter","RefCountSubscriber","connection","connect","sharedConnection","_connection","refCount_1","ConnectableObservable","subjectFactory","_isComplete","getSubject","_subject","ConnectableSubscriber","connectableProto","connectableObservableDescriptor","writable","EmptyError","ArgumentOutOfRangeError","TimeoutError","async","async_1","timeInterval","TimeIntervalOperator","TimeInterval","interval","TimeIntervalSubscriber","lastTime","span","timeInterval_1","project","thisArg","TypeError","MapOperator","MapSubscriber","count","result","map_1","timestamp","Timestamp","SubscriptionLog","subscribedFrame","unsubscribedFrame","SubscriptionLog_1","SubscriptionLoggable","logSubscribedFrame","logUnsubscribedFrame","subscriptionLogs","oldSubscriptionLog","applyMixins","derivedCtor","baseCtors","baseCtor","propertyKeys","getOwnPropertyNames","j","len2","name_1","SubscriptionLoggable_1","applyMixins_1","ColdObservable","messages","scheduleMessages","messagesLength","_a","frame","HotObservable","setup","VirtualTimeScheduler","maxFrames","VirtualAction","frameTimeFactor","sort","sortActions","a","b","ColdObservable_1","HotObservable_1","VirtualTimeScheduler_1","defaultMaxFrame","TestScheduler","assertDeepEqual","hotObservables","coldObservables","flushTests","createTime","marbles","createColdObservable","values","parseMarbles","cold","createHotObservable","materializeInnerObservable","outerFrame","expectObservable","unsubscriptionMarbles","actual","flushTest","ready","unsubscriptionFrame","parseMarblesAsSubscriptions","toBe","expected","expectSubscriptions","actualSubscriptionLogs","marblesArray","readyFlushTests","filter","test","groupStart","subscriptionFrame","c","materializeInnerObservables","testMessages","subIndex","frameOffset","ajaxGet","url","headers","AjaxObservable","method","ajaxPost","body","ajaxDelete","ajaxPut","ajaxPatch","ajaxGetJSON","mapResponse","responseType","parseXhrResponse","xhr","response","JSON","parse","responseText","responseXML","urlOrRequest","request","createXHR","crossDomain","XMLHttpRequest","XDomainRequest","progId","progIds","ActiveXObject","getXMLHttpRequest","withCredentials","timeout","prop","hasOwnProperty","AjaxSubscriber","post","delete","put","patch","getJSON","done","FormData","serializeBody","send","AjaxResponse","_b","user","password","setupEvents","open","setHeaders","contentType","splitIndex","substring","keys","key","encodeURI","stringify","setRequestHeader","xhrTimeout","progressSubscriber","AjaxTimeoutError","xhrReadyStateChange","readyState","status_1","status","AjaxError","ontimeout","upload","xhrProgress_1","onprogress","xhrError_1","onerror","onreadystatechange","abort","originalEvent","ImmediateDefinition","setImmediate","clearImmediate","nextHandle","tasksByHandle","currentlyRunningATask","canUseProcessNextTick","createProcessNextTickSetImmediate","canUsePostMessage","createPostMessageSetImmediate","canUseMessageChannel","createMessageChannelSetImmediate","canUseReadyStateChange","createReadyStateChangeSetImmediate","createSetTimeoutSetImmediate","ci","handle","instance","identify","o","process","Boolean","MessageChannel","document","createElement","postMessage","importScripts","postMessageIsAsynchronous_1","oldOnMessage","onmessage","partiallyApplied","handler","args","Function","addFromSetImmediateArguments","nextTick","runIfPresent","messagePrefix","random","onGlobalMessage","globalMessageHandler","event","data","addEventListener","setTimeout","task","channel","port1","port2","doc","html","documentElement","script","removeChild","appendChild","Immediate","Immediate_1","AsapAction","AsapScheduler","AsapAction_1","AsapScheduler_1","asap","RequestAnimationFrameDefinition","requestAnimationFrame","cancelAnimationFrame","mozRequestAnimationFrame","mozCancelAnimationFrame","webkitRequestAnimationFrame","webkitCancelAnimationFrame","msRequestAnimationFrame","msCancelAnimationFrame","oRequestAnimationFrame","oCancelAnimationFrame","clearTimeout","cb","AnimationFrame","AnimationFrame_1","AnimationFrameAction","AnimationFrameScheduler","AnimationFrameAction_1","AnimationFrameScheduler_1","animationFrame","symbolIteratorPonyfill","iterator","Set_1","Set","Map_1","Map","$$iterator","OuterSubscriber","notifyNext","outerValue","innerValue","outerIndex","innerIndex","innerSub","notifyError","notifyComplete","isArrayLike","isPromise","then","InnerSubscriber","isArrayLike_1","isPromise_1","iterator_1","InnerSubscriber_1","subscribeToResult","outerSubscriber","item","obs","msg","OuterSubscriber_1","subscribeToResult_1","audit","durationSelector","AuditOperator","AuditSubscriber","throttled","duration","innerSubscription","clearThrottle","isNumeric","val","parseFloat","isScheduler","isDate","isNaN","isNumeric_1","isScheduler_1","isDate_1","TimerObservable","dueTime","period","initialDelay","TimerObservable_1","timer","audit_1","timer_1","auditTime","buffer","closingNotifier","BufferOperator","BufferSubscriber","bufferCount","startBufferEvery","BufferCountOperator","subscriberClass","BufferSkipCountSubscriber","BufferCountSubscriber","buffers","dispatchBufferTimeSpanOnly","prevContext","closeContext","openContext","closeAction","bufferTimeSpan","dispatchBufferCreation","bufferCreationInterval","dispatchBufferClose","bufferTime","maxBufferSize","BufferTimeOperator","BufferTimeSubscriber","Context","contexts","timespanOnly","timeSpanOnlyState","closeState","creationState","filledBufferContext","onBufferFull","bufferToggle","openings","closingSelector","BufferToggleOperator","BufferToggleSubscriber","closeBuffer","openBuffer","trySubscribe","bufferWhen","BufferWhenOperator","BufferWhenSubscriber","subscribing","closingSubscription","catchError","selector","CatchOperator","caught","CatchSubscriber","err2","ScalarObservable","EmptyObservable","ScalarObservable_1","EmptyObservable_1","ArrayObservable","array","pop","ArrayObservable_1","none","combineLatest","observables","CombineLatestOperator","CombineLatestSubscriber","toRespond","unused","oldVal","_tryProject","combineLatest_1","combineAll","dispatchNext","dispatchError","PromiseObservable","promise","toLength","isFinite","numberIsFinite","valueAsNumber","sign","floor","abs","maxSafeInteger","IteratorObservable","obj","StringIterator","ArrayIterator","getIterator","return","str","idx","charAt","arr","pow","ArrayLikeObservable","arrayLike","PromiseObservable_1","IteratorObservable_1","ArrayLikeObservable_1","FromObservable","ish","FromObservable_1","from","mergeMap","resultSelector","concurrent","MergeMapOperator","MergeMapSubscriber","_tryNext","_innerSub","_notifyResultSelector","identity","mergeMap_1","identity_1","mergeAll","mergeAll_1","concatAll","of_1","from_1","concatAll_1","concat_1","concat_2","concatStatic","concatMap","concatMap_1","concatMapTo","innerObservable","predicate","CountOperator","CountSubscriber","_tryPredicate","debounce","DebounceOperator","DebounceSubscriber","durationSubscription","emitValue","debouncedNext","debounceTime","DebounceTimeOperator","DebounceTimeSubscriber","debouncedSubscription","lastValue","clearDebounce","defaultIfEmpty","defaultValue","DefaultIfEmptyOperator","DefaultIfEmptySubscriber","isEmpty","delayFor","DelayOperator","DelaySubscriber","delay_1","_schedule","scheduleNotification","DelayMessage","delayWhen","delayDurationSelector","subscriptionDelay","SubscriptionDelayObservable","DelayWhenOperator","DelayWhenSubscriber","completed","delayNotifierSubscriptions","removeSubscription","tryComplete","delayNotifier","tryDelay","subscriptionIdx","notifierSubscription","SubscriptionDelaySubscriber","sourceSubscribed","subscribeToSource","dematerialize","DeMaterializeOperator","DeMaterializeSubscriber","minimalSetImpl","MinimalSet","_values","has","clear","distinct","keySelector","flushes","DistinctOperator","DistinctSubscriber","_useKeySelector","_finalizeNext","distinctUntilChanged","compare","DistinctUntilChangedOperator","DistinctUntilChangedSubscriber","hasKey","y","distinctUntilChanged_1","distinctUntilKeyChanged","ArgumentOutOfRangeError_1","elementAt","ElementAtOperator","ElementAtSubscriber","every","EveryOperator","EverySubscriber","everyValueMatch","exhaust","SwitchFirstOperator","SwitchFirstSubscriber","hasSubscription","exhaustMap","SwitchFirstMapOperator","SwitchFirstMapSubscriber","tryNext","trySelectResult","expand","ExpandOperator","ExpandSubscriber","subscribeToProjection","FilterOperator","FilterSubscriber","finalize","callback","FinallyOperator","FinallySubscriber","find","FindValueOperator","yieldIndex","FindValueSubscriber","find_1","findIndex","EmptyError_1","first","FirstOperator","FirstSubscriber","_emitted","_emit","_tryResultSelector","_emitFinal","MapPolyfill","size","_keys","set","MapPolyfill_1","FastMap","FastMap_1","groupBy","elementSelector","subjectSelector","GroupByOperator","GroupBySubscriber","groups","attemptedToUnsubscribe","_group","element","group","groupedObservable","GroupedObservable","GroupDurationSubscriber","removeGroup","groupSubject","refCountSubscription","InnerRefCountSubscription","ignoreElements","IgnoreElementsOperator","IgnoreElementsSubscriber","IsEmptyOperator","IsEmptySubscriber","last","LastOperator","LastSubscriber","mapTo","MapToOperator","MapToSubscriber","materialize","MaterializeOperator","MaterializeSubscriber","scan","accumulator","seed","hasSeed","ScanOperator","ScanSubscriber","_seed","takeLast","TakeLastOperator","total","TakeLastSubscriber","ring","scan_1","takeLast_1","defaultIfEmpty_1","acc","reduce_1","comparer","merge","merge_1","merge_2","mergeStatic","mergeMapTo","MergeMapToOperator","MergeMapToSubscriber","mergeScan","MergeScanOperator","MergeScanSubscriber","min","ConnectableObservable_1","multicast","subjectOrSubjectFactory","MulticastOperator","onErrorResumeNext","nextSources","OnErrorResumeNextOperator","onErrorResumeNextStatic","OnErrorResumeNextSubscriber","subscribeToNextSource","pairwise","PairwiseOperator","PairwiseSubscriber","hasPrev","not","pred","notPred","not_1","filter_1","partition","pluck","properties","props","currentProp","p","plucker","multicast_1","publish","BehaviorSubject_1","publishBehavior","AsyncSubject_1","publishLast","ReplaySubject_1","publishReplay","selectorOrScheduler","race","RaceOperator","RaceSubscriber","hasFirst","race_1","repeat","RepeatOperator","RepeatSubscriber","repeatWhen","notifier","RepeatWhenOperator","RepeatWhenSubscriber","sourceIsBeingSubscribedTo","retries","retriesSubscription","subscribeToRetries","notifications","retry","RetryOperator","RetrySubscriber","retryWhen","RetryWhenOperator","RetryWhenSubscriber","sample","SampleOperator","sampleSubscriber","SampleSubscriber","dispatchNotification","sampleTime","SampleTimeOperator","SampleTimeSubscriber","sequenceEqual","compareTo","comparor","SequenceEqualOperator","SequenceEqualSubscriber","_oneComplete","SequenceEqualCompareToSubscriber","emit","checkValues","areEqual","nextB","shareSubjectFactory","share","shareReplay","isComplete","shareReplayOperator","single","SingleOperator","SingleSubscriber","seenValue","applySingleValue","singleValue","skip","SkipOperator","SkipSubscriber","skipLast","SkipLastOperator","_skipCount","SkipLastSubscriber","_count","_ring","skipCount","currentIndex","oldValue","skipUntil","SkipUntilOperator","SkipUntilSubscriber","isInnerStopped","skipWhile","SkipWhileOperator","SkipWhileSubscriber","skipping","tryCallPredicate","startWith","switchMap","SwitchMapOperator","SwitchMapSubscriber","_tryNotifyNext","switchMap_1","switchAll","switchMapTo","SwitchMapToOperator","SwitchMapToSubscriber","inner","tryResultSelector","take","TakeOperator","TakeSubscriber","takeUntil","TakeUntilOperator","TakeUntilSubscriber","takeWhile","TakeWhileOperator","TakeWhileSubscriber","nextOrComplete","predicateResult","tap","DoOperator","DoSubscriber","safeSubscriber","defaultThrottleConfig","leading","trailing","throttle","ThrottleOperator","ThrottleSubscriber","_leading","_trailing","_hasTrailingValue","_trailingValue","tryDurationSelector","_sendTrailing","throttle_1","throttleTime","ThrottleTimeOperator","ThrottleTimeSubscriber","TimeoutError_1","due","absoluteTimeout","waitFor","TimeoutOperator","errorInstance","TimeoutSubscriber","scheduleTimeout","dispatchTimeout","timeoutWith","withObservable","TimeoutWithOperator","TimeoutWithSubscriber","toArrayReducer","toArray","windowBoundaries","WindowOperator","windowSubscriber","WindowSubscriber","sourceSubscription","openWindow","prevWindow","newWindow","windowCount","windowSize","startWindowEvery","WindowCountOperator","WindowCountSubscriber","windows","window_1","dispatchWindowTimeSpanOnly","windowTimeSpan","closeWindow","dispatchWindowCreation","windowCreationInterval","timeSpanState","dispatchWindowClose","maxWindowSize","WindowTimeOperator","WindowTimeSubscriber","CountedSubject","_numberOfNextedValues","numberOfNextedValues","window_2","windowToggle","WindowToggleOperator","WindowToggleSubscriber","openSubscription","windowWhen","unsubscribeClosingNotification","closingNotification","withLatestFrom","WithLatestFromOperator","WithLatestFromSubscriber","found","zipStatic","ZipOperator","zip","ZipSubscriber","iterators","StaticArrayIterator","StaticIterator","ZipBufferIterator","stillUnsubscribed","notifyInactive","checkIterators","shouldComplete","nextResult","zip_1","zipAll","auditTime_1","buffer_1","bufferCount_1","bufferTime_1","bufferToggle_1","bufferWhen_1","catchError_1","combineAll_1","concatMapTo_1","count_1","debounce_1","debounceTime_1","delayWhen_1","dematerialize_1","distinct_1","distinctUntilKeyChanged_1","elementAt_1","every_1","exhaust_1","exhaustMap_1","expand_1","finalize_1","findIndex_1","first_1","groupBy_1","ignoreElements_1","isEmpty_1","last_1","mapTo_1","materialize_1","max_1","mergeMap_2","mergeMapTo_1","mergeScan_1","min_1","onErrorResumeNext_1","pairwise_1","partition_1","pluck_1","publish_1","publishBehavior_1","publishLast_1","publishReplay_1","repeat_1","repeatWhen_1","retry_1","retryWhen_1","sample_1","sampleTime_1","sequenceEqual_1","share_1","shareReplay_1","single_1","skip_1","skipLast_1","skipUntil_1","skipWhile_1","startWith_1","switchAll_1","switchMapTo_1","take_1","takeUntil_1","takeWhile_1","tap_1","throttleTime_1","timeout_1","timeoutWith_1","timestamp_1","toArray_1","windowCount_1","windowTime_1","windowToggle_1","windowWhen_1","withLatestFrom_1","zipAll_1","flatMap","BoundCallbackObservable","callbackFunc","func","handlerFn","innerArgs","result_1","result_2","BoundCallbackObservable_1","bindCallback","bindCallback_1","BoundNodeCallbackObservable","BoundNodeCallbackObservable_1","bindNodeCallback","bindNodeCallback_1","DeferObservable","observableFactory","DeferSubscriber","factory","tryDefer","_callFactory","DeferObservable_1","defer","defer_1","empty_1","ForkJoinObservable","sources","ForkJoinSubscriber","haveValues","_hasValue","ForkJoinObservable_1","forkJoin","forkJoin_1","FromEventObservable","sourceObj","eventName","options","target","setupSubscription","isNodeList","isHTMLCollection","removeEventListener","isEventTarget","source_1","on","off","isJQueryStyleEventEmitter","source_2","addListener","removeListener","isNodeStyleEventEmitter","source_3","FromEventObservable_1","fromEvent","fromEvent_1","FromEventPatternObservable","addHandler","removeHandler","_callSelector","retValue","_callAddHandler","errorSubscriber","FromEventPatternObservable_1","fromEventPattern","fromEventPattern_1","fromPromise","fromPromise_1","selfSelector","GenerateObservable","initialState","condition","iterate","initialStateOrOptions","resultSelectorOrObservable","conditionResult","needIterate","GenerateObservable_1","generate","generate_1","IfObservable","thenSource","elseSource","IfSubscriber","tryIf","IfObservable_1","_if","if_1","if","IntervalObservable","IntervalObservable_1","interval_1","NeverObservable","NeverObservable_1","never","never_1","PairsObservable","PairsObservable_1","pairs","pairs_1","RangeObservable","start","RangeObservable_1","range","range_1","UsingObservable","resourceFactory","resource","UsingSubscriber","tryUse","UsingObservable_1","using","using_1","ErrorObservable","ErrorObservable_1","_throw","throw_1","AjaxObservable_1","ajax","ajax_1","assignImpl","k","getAssign","assign","assign_1","WebSocketSubject","urlConfigOrSource","WebSocketCtor","WebSocket","_output","sock","_resetState","socket","multiplex","subMsg","unsubMsg","messageFilter","_connectSocket","protocol","binaryType","close","onopen","openObserver","closingObserver","code","reason","onclose","closeObserver","wasClean","WebSocketSubject_1","webSocket","webSocket_1","_catch","catch_1","catch","_do","do_1","_finally","finally_1","finally","letProto","let_1","let","letBind","flatMapTo","race_2","raceStatic","asap_1","SubscribeOnObservable","delayTime","SubscribeOnObservable_1","subscribeOn","SubscribeOnOperator","subscribeOn_1","_switch","switch_1","switch","zipProto","TestScheduler_1","animationFrame_1","_operators","operators"],"mappings":"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","file":"rxjs.min.js","sourcesContent":["define('rxjs/util/root',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // CommonJS / Node have global context exposed as \"global\" variable.\n    // We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n    // the global \"global\" var for now.\n    var __window = typeof window !== 'undefined' && window;\n    var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self;\n    var __global = typeof global !== 'undefined' && global;\n    var _root = __window || __global || __self;\n    exports.root = _root;\n    // Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n    // This is needed when used with angular/tsickle which inserts a goog.module statement.\n    // Wrap in IIFE\n    (function () {\n        if (!_root) {\n            throw new Error('RxJS could not find any global context (window, self, global)');\n        }\n    })();\n});\n\ndefine('rxjs/util/isFunction',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isFunction(x) {\n        return typeof x === 'function';\n    }\n    exports.isFunction = isFunction;\n});\n\ndefine('rxjs/util/isArray',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });\n});\n\ndefine('rxjs/util/isObject',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isObject(x) {\n        return x != null && typeof x === 'object';\n    }\n    exports.isObject = isObject;\n});\n\ndefine('rxjs/util/errorObject',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // typeof any so that it we don't have to cast when comparing a result to the error object\n    exports.errorObject = { e: {} };\n});\n\ndefine('rxjs/util/tryCatch',[\"require\", \"exports\", \"./errorObject\"], function (require, exports, errorObject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var tryCatchTarget;\n    function tryCatcher() {\n        try {\n            return tryCatchTarget.apply(this, arguments);\n        }\n        catch (e) {\n            errorObject_1.errorObject.e = e;\n            return errorObject_1.errorObject;\n        }\n    }\n    function tryCatch(fn) {\n        tryCatchTarget = fn;\n        return tryCatcher;\n    }\n    exports.tryCatch = tryCatch;\n    ;\n});\n\ndefine('rxjs/util/UnsubscriptionError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when one or more errors have occurred during the\n     * `unsubscribe` of a {@link Subscription}.\n     */\n    var UnsubscriptionError = /** @class */ (function (_super) {\n        tslib_1.__extends(UnsubscriptionError, _super);\n        function UnsubscriptionError(errors) {\n            var _this = _super.call(this) || this;\n            _this.errors = errors;\n            var err = Error.call(_this, errors ?\n                errors.length + \" errors occurred during unsubscription:\\n  \" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ') : '');\n            _this.name = err.name = 'UnsubscriptionError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return UnsubscriptionError;\n    }(Error));\n    exports.UnsubscriptionError = UnsubscriptionError;\n});\n\ndefine('rxjs/Subscription',[\"require\", \"exports\", \"./util/isArray\", \"./util/isObject\", \"./util/isFunction\", \"./util/tryCatch\", \"./util/errorObject\", \"./util/UnsubscriptionError\"], function (require, exports, isArray_1, isObject_1, isFunction_1, tryCatch_1, errorObject_1, UnsubscriptionError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represents a disposable resource, such as the execution of an Observable. A\n     * Subscription has one important method, `unsubscribe`, that takes no argument\n     * and just disposes the resource held by the subscription.\n     *\n     * Additionally, subscriptions may be grouped together through the `add()`\n     * method, which will attach a child Subscription to the current Subscription.\n     * When a Subscription is unsubscribed, all its children (and its grandchildren)\n     * will be unsubscribed as well.\n     *\n     * @class Subscription\n     */\n    var Subscription = /** @class */ (function () {\n        /**\n         * @param {function(): void} [unsubscribe] A function describing how to\n         * perform the disposal of resources when the `unsubscribe` method is called.\n         */\n        function Subscription(unsubscribe) {\n            /**\n             * A flag to indicate whether this Subscription has already been unsubscribed.\n             * @type {boolean}\n             */\n            this.closed = false;\n            this._parent = null;\n            this._parents = null;\n            this._subscriptions = null;\n            if (unsubscribe) {\n                this._unsubscribe = unsubscribe;\n            }\n        }\n        /**\n         * Disposes the resources held by the subscription. May, for instance, cancel\n         * an ongoing Observable execution or cancel any other type of work that\n         * started when the Subscription was created.\n         * @return {void}\n         */\n        Subscription.prototype.unsubscribe = function () {\n            var hasErrors = false;\n            var errors;\n            if (this.closed) {\n                return;\n            }\n            var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n            this.closed = true;\n            this._parent = null;\n            this._parents = null;\n            // null out _subscriptions first so any child subscriptions that attempt\n            // to remove themselves from this subscription will noop\n            this._subscriptions = null;\n            var index = -1;\n            var len = _parents ? _parents.length : 0;\n            // if this._parent is null, then so is this._parents, and we\n            // don't have to remove ourselves from any parent subscriptions.\n            while (_parent) {\n                _parent.remove(this);\n                // if this._parents is null or index >= len,\n                // then _parent is set to null, and the loop exits\n                _parent = ++index < len && _parents[index] || null;\n            }\n            if (isFunction_1.isFunction(_unsubscribe)) {\n                var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);\n                if (trial === errorObject_1.errorObject) {\n                    hasErrors = true;\n                    errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?\n                        flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);\n                }\n            }\n            if (isArray_1.isArray(_subscriptions)) {\n                index = -1;\n                len = _subscriptions.length;\n                while (++index < len) {\n                    var sub = _subscriptions[index];\n                    if (isObject_1.isObject(sub)) {\n                        var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);\n                        if (trial === errorObject_1.errorObject) {\n                            hasErrors = true;\n                            errors = errors || [];\n                            var err = errorObject_1.errorObject.e;\n                            if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {\n                                errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n                            }\n                            else {\n                                errors.push(err);\n                            }\n                        }\n                    }\n                }\n            }\n            if (hasErrors) {\n                throw new UnsubscriptionError_1.UnsubscriptionError(errors);\n            }\n        };\n        /**\n         * Adds a tear down to be called during the unsubscribe() of this\n         * Subscription.\n         *\n         * If the tear down being added is a subscription that is already\n         * unsubscribed, is the same reference `add` is being called on, or is\n         * `Subscription.EMPTY`, it will not be added.\n         *\n         * If this subscription is already in an `closed` state, the passed\n         * tear down logic will be executed immediately.\n         *\n         * @param {TeardownLogic} teardown The additional logic to execute on\n         * teardown.\n         * @return {Subscription} Returns the Subscription used or created to be\n         * added to the inner subscriptions list. This Subscription can be used with\n         * `remove()` to remove the passed teardown logic from the inner subscriptions\n         * list.\n         */\n        Subscription.prototype.add = function (teardown) {\n            if (!teardown || (teardown === Subscription.EMPTY)) {\n                return Subscription.EMPTY;\n            }\n            if (teardown === this) {\n                return this;\n            }\n            var subscription = teardown;\n            switch (typeof teardown) {\n                case 'function':\n                    subscription = new Subscription(teardown);\n                case 'object':\n                    if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                        return subscription;\n                    }\n                    else if (this.closed) {\n                        subscription.unsubscribe();\n                        return subscription;\n                    }\n                    else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n                        var tmp = subscription;\n                        subscription = new Subscription();\n                        subscription._subscriptions = [tmp];\n                    }\n                    break;\n                default:\n                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n            }\n            var subscriptions = this._subscriptions || (this._subscriptions = []);\n            subscriptions.push(subscription);\n            subscription._addParent(this);\n            return subscription;\n        };\n        /**\n         * Removes a Subscription from the internal list of subscriptions that will\n         * unsubscribe during the unsubscribe process of this Subscription.\n         * @param {Subscription} subscription The subscription to remove.\n         * @return {void}\n         */\n        Subscription.prototype.remove = function (subscription) {\n            var subscriptions = this._subscriptions;\n            if (subscriptions) {\n                var subscriptionIndex = subscriptions.indexOf(subscription);\n                if (subscriptionIndex !== -1) {\n                    subscriptions.splice(subscriptionIndex, 1);\n                }\n            }\n        };\n        Subscription.prototype._addParent = function (parent) {\n            var _a = this, _parent = _a._parent, _parents = _a._parents;\n            if (!_parent || _parent === parent) {\n                // If we don't have a parent, or the new parent is the same as the\n                // current parent, then set this._parent to the new parent.\n                this._parent = parent;\n            }\n            else if (!_parents) {\n                // If there's already one parent, but not multiple, allocate an Array to\n                // store the rest of the parent Subscriptions.\n                this._parents = [parent];\n            }\n            else if (_parents.indexOf(parent) === -1) {\n                // Only add the new parent to the _parents list if it's not already there.\n                _parents.push(parent);\n            }\n        };\n        Subscription.EMPTY = (function (empty) {\n            empty.closed = true;\n            return empty;\n        }(new Subscription()));\n        return Subscription;\n    }());\n    exports.Subscription = Subscription;\n    function flattenUnsubscriptionErrors(errors) {\n        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);\n    }\n});\n\ndefine('rxjs/Observer',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.empty = {\n        closed: true,\n        next: function (value) { },\n        error: function (err) { throw err; },\n        complete: function () { }\n    };\n});\n\ndefine('rxjs/symbol/rxSubscriber',[\"require\", \"exports\", \"../util/root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Symbol = root_1.root.Symbol;\n    exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n        Symbol.for('rxSubscriber') : '@@rxSubscriber';\n    /**\n     * @deprecated use rxSubscriber instead\n     */\n    exports.$$rxSubscriber = exports.rxSubscriber;\n});\n\ndefine('rxjs/Subscriber',[\"require\", \"exports\", \"tslib\", \"./util/isFunction\", \"./Subscription\", \"./Observer\", \"./symbol/rxSubscriber\"], function (require, exports, tslib_1, isFunction_1, Subscription_1, Observer_1, rxSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Implements the {@link Observer} interface and extends the\n     * {@link Subscription} class. While the {@link Observer} is the public API for\n     * consuming the values of an {@link Observable}, all Observers get converted to\n     * a Subscriber, in order to provide Subscription-like capabilities such as\n     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n     * implementing operators, but it is rarely used as a public API.\n     *\n     * @class Subscriber<T>\n     */\n    var Subscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(Subscriber, _super);\n        /**\n         * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n         * defined Observer or a `next` callback function.\n         * @param {function(e: ?any): void} [error] The `error` callback of an\n         * Observer.\n         * @param {function(): void} [complete] The `complete` callback of an\n         * Observer.\n         */\n        function Subscriber(destinationOrNext, error, complete) {\n            var _this = _super.call(this) || this;\n            _this.syncErrorValue = null;\n            _this.syncErrorThrown = false;\n            _this.syncErrorThrowable = false;\n            _this.isStopped = false;\n            switch (arguments.length) {\n                case 0:\n                    _this.destination = Observer_1.empty;\n                    break;\n                case 1:\n                    if (!destinationOrNext) {\n                        _this.destination = Observer_1.empty;\n                        break;\n                    }\n                    if (typeof destinationOrNext === 'object') {\n                        if (destinationOrNext instanceof Subscriber) {\n                            _this.destination = destinationOrNext;\n                            _this.destination.add(_this);\n                        }\n                        else {\n                            _this.syncErrorThrowable = true;\n                            _this.destination = new SafeSubscriber(_this, destinationOrNext);\n                        }\n                        break;\n                    }\n                default:\n                    _this.syncErrorThrowable = true;\n                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n                    break;\n            }\n            return _this;\n        }\n        Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };\n        /**\n         * A static factory for a Subscriber, given a (potentially partial) definition\n         * of an Observer.\n         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n         * @param {function(e: ?any): void} [error] The `error` callback of an\n         * Observer.\n         * @param {function(): void} [complete] The `complete` callback of an\n         * Observer.\n         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n         * Observer represented by the given arguments.\n         */\n        Subscriber.create = function (next, error, complete) {\n            var subscriber = new Subscriber(next, error, complete);\n            subscriber.syncErrorThrowable = false;\n            return subscriber;\n        };\n        /**\n         * The {@link Observer} callback to receive notifications of type `next` from\n         * the Observable, with a value. The Observable may call this method 0 or more\n         * times.\n         * @param {T} [value] The `next` value.\n         * @return {void}\n         */\n        Subscriber.prototype.next = function (value) {\n            if (!this.isStopped) {\n                this._next(value);\n            }\n        };\n        /**\n         * The {@link Observer} callback to receive notifications of type `error` from\n         * the Observable, with an attached {@link Error}. Notifies the Observer that\n         * the Observable has experienced an error condition.\n         * @param {any} [err] The `error` exception.\n         * @return {void}\n         */\n        Subscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this._error(err);\n            }\n        };\n        /**\n         * The {@link Observer} callback to receive a valueless notification of type\n         * `complete` from the Observable. Notifies the Observer that the Observable\n         * has finished sending push-based notifications.\n         * @return {void}\n         */\n        Subscriber.prototype.complete = function () {\n            if (!this.isStopped) {\n                this.isStopped = true;\n                this._complete();\n            }\n        };\n        Subscriber.prototype.unsubscribe = function () {\n            if (this.closed) {\n                return;\n            }\n            this.isStopped = true;\n            _super.prototype.unsubscribe.call(this);\n        };\n        Subscriber.prototype._next = function (value) {\n            this.destination.next(value);\n        };\n        Subscriber.prototype._error = function (err) {\n            this.destination.error(err);\n            this.unsubscribe();\n        };\n        Subscriber.prototype._complete = function () {\n            this.destination.complete();\n            this.unsubscribe();\n        };\n        Subscriber.prototype._unsubscribeAndRecycle = function () {\n            var _a = this, _parent = _a._parent, _parents = _a._parents;\n            this._parent = null;\n            this._parents = null;\n            this.unsubscribe();\n            this.closed = false;\n            this.isStopped = false;\n            this._parent = _parent;\n            this._parents = _parents;\n            return this;\n        };\n        return Subscriber;\n    }(Subscription_1.Subscription));\n    exports.Subscriber = Subscriber;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SafeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SafeSubscriber, _super);\n        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n            var _this = _super.call(this) || this;\n            _this._parentSubscriber = _parentSubscriber;\n            var next;\n            var context = _this;\n            if (isFunction_1.isFunction(observerOrNext)) {\n                next = observerOrNext;\n            }\n            else if (observerOrNext) {\n                next = observerOrNext.next;\n                error = observerOrNext.error;\n                complete = observerOrNext.complete;\n                if (observerOrNext !== Observer_1.empty) {\n                    context = Object.create(observerOrNext);\n                    if (isFunction_1.isFunction(context.unsubscribe)) {\n                        _this.add(context.unsubscribe.bind(context));\n                    }\n                    context.unsubscribe = _this.unsubscribe.bind(_this);\n                }\n            }\n            _this._context = context;\n            _this._next = next;\n            _this._error = error;\n            _this._complete = complete;\n            return _this;\n        }\n        SafeSubscriber.prototype.next = function (value) {\n            if (!this.isStopped && this._next) {\n                var _parentSubscriber = this._parentSubscriber;\n                if (!_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._next, value);\n                }\n                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var _parentSubscriber = this._parentSubscriber;\n                if (this._error) {\n                    if (!_parentSubscriber.syncErrorThrowable) {\n                        this.__tryOrUnsub(this._error, err);\n                        this.unsubscribe();\n                    }\n                    else {\n                        this.__tryOrSetError(_parentSubscriber, this._error, err);\n                        this.unsubscribe();\n                    }\n                }\n                else if (!_parentSubscriber.syncErrorThrowable) {\n                    this.unsubscribe();\n                    throw err;\n                }\n                else {\n                    _parentSubscriber.syncErrorValue = err;\n                    _parentSubscriber.syncErrorThrown = true;\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.complete = function () {\n            var _this = this;\n            if (!this.isStopped) {\n                var _parentSubscriber = this._parentSubscriber;\n                if (this._complete) {\n                    var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                    if (!_parentSubscriber.syncErrorThrowable) {\n                        this.__tryOrUnsub(wrappedComplete);\n                        this.unsubscribe();\n                    }\n                    else {\n                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                        this.unsubscribe();\n                    }\n                }\n                else {\n                    this.unsubscribe();\n                }\n            }\n        };\n        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n            try {\n                fn.call(this._context, value);\n            }\n            catch (err) {\n                this.unsubscribe();\n                throw err;\n            }\n        };\n        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n            try {\n                fn.call(this._context, value);\n            }\n            catch (err) {\n                parent.syncErrorValue = err;\n                parent.syncErrorThrown = true;\n                return true;\n            }\n            return false;\n        };\n        SafeSubscriber.prototype._unsubscribe = function () {\n            var _parentSubscriber = this._parentSubscriber;\n            this._context = null;\n            this._parentSubscriber = null;\n            _parentSubscriber.unsubscribe();\n        };\n        return SafeSubscriber;\n    }(Subscriber));\n});\n\ndefine('rxjs/util/toSubscriber',[\"require\", \"exports\", \"../Subscriber\", \"../symbol/rxSubscriber\", \"../Observer\"], function (require, exports, Subscriber_1, rxSubscriber_1, Observer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function toSubscriber(nextOrObserver, error, complete) {\n        if (nextOrObserver) {\n            if (nextOrObserver instanceof Subscriber_1.Subscriber) {\n                return nextOrObserver;\n            }\n            if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {\n                return nextOrObserver[rxSubscriber_1.rxSubscriber]();\n            }\n        }\n        if (!nextOrObserver && !error && !complete) {\n            return new Subscriber_1.Subscriber(Observer_1.empty);\n        }\n        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n    }\n    exports.toSubscriber = toSubscriber;\n});\n\ndefine('rxjs/symbol/observable',[\"require\", \"exports\", \"../util/root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getSymbolObservable(context) {\n        var $$observable;\n        var Symbol = context.Symbol;\n        if (typeof Symbol === 'function') {\n            if (Symbol.observable) {\n                $$observable = Symbol.observable;\n            }\n            else {\n                $$observable = Symbol('observable');\n                Symbol.observable = $$observable;\n            }\n        }\n        else {\n            $$observable = '@@observable';\n        }\n        return $$observable;\n    }\n    exports.getSymbolObservable = getSymbolObservable;\n    exports.observable = getSymbolObservable(root_1.root);\n    /**\n     * @deprecated use observable instead\n     */\n    exports.$$observable = exports.observable;\n});\n\ndefine('rxjs/util/noop',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:disable:no-empty */\n    function noop() { }\n    exports.noop = noop;\n});\n\ndefine('rxjs/util/pipe',[\"require\", \"exports\", \"./noop\"], function (require, exports, noop_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    function pipe() {\n        var fns = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fns[_i] = arguments[_i];\n        }\n        return pipeFromArray(fns);\n    }\n    exports.pipe = pipe;\n    /* @internal */\n    function pipeFromArray(fns) {\n        if (!fns) {\n            return noop_1.noop;\n        }\n        if (fns.length === 1) {\n            return fns[0];\n        }\n        return function piped(input) {\n            return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n        };\n    }\n    exports.pipeFromArray = pipeFromArray;\n});\n\ndefine('rxjs/Observable',[\"require\", \"exports\", \"./util/root\", \"./util/toSubscriber\", \"./symbol/observable\", \"./util/pipe\"], function (require, exports, root_1, toSubscriber_1, observable_1, pipe_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A representation of any set of values over any amount of time. This is the most basic building block\n     * of RxJS.\n     *\n     * @class Observable<T>\n     */\n    var Observable = /** @class */ (function () {\n        /**\n         * @constructor\n         * @param {Function} subscribe the function that is called when the Observable is\n         * initially subscribed to. This function is given a Subscriber, to which new values\n         * can be `next`ed, or an `error` method can be called to raise an error, or\n         * `complete` can be called to notify of a successful completion.\n         */\n        function Observable(subscribe) {\n            this._isScalar = false;\n            if (subscribe) {\n                this._subscribe = subscribe;\n            }\n        }\n        /**\n         * Creates a new Observable, with this Observable as the source, and the passed\n         * operator defined as the new observable's operator.\n         * @method lift\n         * @param {Operator} operator the operator defining the operation to take on the observable\n         * @return {Observable} a new observable with the Operator applied\n         */\n        Observable.prototype.lift = function (operator) {\n            var observable = new Observable();\n            observable.source = this;\n            observable.operator = operator;\n            return observable;\n        };\n        /**\n         * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n         *\n         * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n         *\n         * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n         * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n         * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n         * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n         * thought.\n         *\n         * Apart from starting the execution of an Observable, this method allows you to listen for values\n         * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n         * following ways.\n         *\n         * The first way is creating an object that implements {@link Observer} interface. It should have methods\n         * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n         * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n         * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n         * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n         * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n         * be left uncaught.\n         *\n         * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n         * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n         * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n         * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n         * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n         * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n         *\n         * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n         * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n         * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n         * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n         *\n         * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n         * It is an Observable itself that decides when these functions will be called. For example {@link of}\n         * by default emits all its values synchronously. Always check documentation for how given Observable\n         * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n         *\n         * @example <caption>Subscribe with an Observer</caption>\n         * const sumObserver = {\n         *   sum: 0,\n         *   next(value) {\n         *     console.log('Adding: ' + value);\n         *     this.sum = this.sum + value;\n         *   },\n         *   error() { // We actually could just remove this method,\n         *   },        // since we do not really care about errors right now.\n         *   complete() {\n         *     console.log('Sum equals: ' + this.sum);\n         *   }\n         * };\n         *\n         * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n         * .subscribe(sumObserver);\n         *\n         * // Logs:\n         * // \"Adding: 1\"\n         * // \"Adding: 2\"\n         * // \"Adding: 3\"\n         * // \"Sum equals: 6\"\n         *\n         *\n         * @example <caption>Subscribe with functions</caption>\n         * let sum = 0;\n         *\n         * Rx.Observable.of(1, 2, 3)\n         * .subscribe(\n         *   function(value) {\n         *     console.log('Adding: ' + value);\n         *     sum = sum + value;\n         *   },\n         *   undefined,\n         *   function() {\n         *     console.log('Sum equals: ' + sum);\n         *   }\n         * );\n         *\n         * // Logs:\n         * // \"Adding: 1\"\n         * // \"Adding: 2\"\n         * // \"Adding: 3\"\n         * // \"Sum equals: 6\"\n         *\n         *\n         * @example <caption>Cancel a subscription</caption>\n         * const subscription = Rx.Observable.interval(1000).subscribe(\n         *   num => console.log(num),\n         *   undefined,\n         *   () => console.log('completed!') // Will not be called, even\n         * );                                // when cancelling subscription\n         *\n         *\n         * setTimeout(() => {\n         *   subscription.unsubscribe();\n         *   console.log('unsubscribed!');\n         * }, 2500);\n         *\n         * // Logs:\n         * // 0 after 1s\n         * // 1 after 2s\n         * // \"unsubscribed!\" after 2.5s\n         *\n         *\n         * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n         *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n         *  Observable.\n         * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n         *  the error will be thrown as unhandled.\n         * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n         * @return {ISubscription} a subscription reference to the registered handlers\n         * @method subscribe\n         */\n        Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n            var operator = this.operator;\n            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);\n            if (operator) {\n                operator.call(sink, this.source);\n            }\n            else {\n                sink.add(this.source ? this._subscribe(sink) : this._trySubscribe(sink));\n            }\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n            return sink;\n        };\n        Observable.prototype._trySubscribe = function (sink) {\n            try {\n                return this._subscribe(sink);\n            }\n            catch (err) {\n                sink.syncErrorThrown = true;\n                sink.syncErrorValue = err;\n                sink.error(err);\n            }\n        };\n        /**\n         * @method forEach\n         * @param {Function} next a handler for each value emitted by the observable\n         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n         * @return {Promise} a promise that either resolves on observable completion or\n         *  rejects with the handled error\n         */\n        Observable.prototype.forEach = function (next, PromiseCtor) {\n            var _this = this;\n            if (!PromiseCtor) {\n                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                    PromiseCtor = root_1.root.Rx.config.Promise;\n                }\n                else if (root_1.root.Promise) {\n                    PromiseCtor = root_1.root.Promise;\n                }\n            }\n            if (!PromiseCtor) {\n                throw new Error('no Promise impl found');\n            }\n            return new PromiseCtor(function (resolve, reject) {\n                // Must be declared in a separate statement to avoid a RefernceError when\n                // accessing subscription below in the closure due to Temporal Dead Zone.\n                var subscription;\n                subscription = _this.subscribe(function (value) {\n                    if (subscription) {\n                        // if there is a subscription, then we can surmise\n                        // the next handling is asynchronous. Any errors thrown\n                        // need to be rejected explicitly and unsubscribe must be\n                        // called manually\n                        try {\n                            next(value);\n                        }\n                        catch (err) {\n                            reject(err);\n                            subscription.unsubscribe();\n                        }\n                    }\n                    else {\n                        // if there is NO subscription, then we're getting a nexted\n                        // value synchronously during subscription. We can just call it.\n                        // If it errors, Observable's `subscribe` will ensure the\n                        // unsubscription logic is called, then synchronously rethrow the error.\n                        // After that, Promise will trap the error and send it\n                        // down the rejection path.\n                        next(value);\n                    }\n                }, reject, resolve);\n            });\n        };\n        Observable.prototype._subscribe = function (subscriber) {\n            return this.source.subscribe(subscriber);\n        };\n        /**\n         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n         * @method Symbol.observable\n         * @return {Observable} this instance of the observable\n         */\n        Observable.prototype[observable_1.observable] = function () {\n            return this;\n        };\n        /* tslint:enable:max-line-length */\n        /**\n         * Used to stitch together functional operators into a chain.\n         * @method pipe\n         * @return {Observable} the Observable result of all of the operators having\n         * been called in the order they were passed in.\n         *\n         * @example\n         *\n         * import { map, filter, scan } from 'rxjs/operators';\n         *\n         * Rx.Observable.interval(1000)\n         *   .pipe(\n         *     filter(x => x % 2 === 0),\n         *     map(x => x + x),\n         *     scan((acc, x) => acc + x)\n         *   )\n         *   .subscribe(x => console.log(x))\n         */\n        Observable.prototype.pipe = function () {\n            var operations = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                operations[_i] = arguments[_i];\n            }\n            if (operations.length === 0) {\n                return this;\n            }\n            return pipe_1.pipeFromArray(operations)(this);\n        };\n        /* tslint:enable:max-line-length */\n        Observable.prototype.toPromise = function (PromiseCtor) {\n            var _this = this;\n            if (!PromiseCtor) {\n                if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {\n                    PromiseCtor = root_1.root.Rx.config.Promise;\n                }\n                else if (root_1.root.Promise) {\n                    PromiseCtor = root_1.root.Promise;\n                }\n            }\n            if (!PromiseCtor) {\n                throw new Error('no Promise impl found');\n            }\n            return new PromiseCtor(function (resolve, reject) {\n                var value;\n                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n            });\n        };\n        // HACK: Since TypeScript inherits static properties too, we have to\n        // fight against TypeScript here so Subject can have a different static create signature\n        /**\n         * Creates a new cold Observable by calling the Observable constructor\n         * @static true\n         * @owner Observable\n         * @method create\n         * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n         * @return {Observable} a new cold observable\n         */\n        Observable.create = function (subscribe) {\n            return new Observable(subscribe);\n        };\n        return Observable;\n    }());\n    exports.Observable = Observable;\n});\n\ndefine('rxjs/util/ObjectUnsubscribedError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when an action is invalid because the object has been\n     * unsubscribed.\n     *\n     * @see {@link Subject}\n     * @see {@link BehaviorSubject}\n     *\n     * @class ObjectUnsubscribedError\n     */\n    var ObjectUnsubscribedError = /** @class */ (function (_super) {\n        tslib_1.__extends(ObjectUnsubscribedError, _super);\n        function ObjectUnsubscribedError() {\n            var _this = this;\n            var err = _this = _super.call(this, 'object unsubscribed') || this;\n            _this.name = err.name = 'ObjectUnsubscribedError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return ObjectUnsubscribedError;\n    }(Error));\n    exports.ObjectUnsubscribedError = ObjectUnsubscribedError;\n});\n\ndefine('rxjs/SubjectSubscription',[\"require\", \"exports\", \"tslib\", \"./Subscription\"], function (require, exports, tslib_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SubjectSubscription = /** @class */ (function (_super) {\n        tslib_1.__extends(SubjectSubscription, _super);\n        function SubjectSubscription(subject, subscriber) {\n            var _this = _super.call(this) || this;\n            _this.subject = subject;\n            _this.subscriber = subscriber;\n            _this.closed = false;\n            return _this;\n        }\n        SubjectSubscription.prototype.unsubscribe = function () {\n            if (this.closed) {\n                return;\n            }\n            this.closed = true;\n            var subject = this.subject;\n            var observers = subject.observers;\n            this.subject = null;\n            if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n                return;\n            }\n            var subscriberIndex = observers.indexOf(this.subscriber);\n            if (subscriberIndex !== -1) {\n                observers.splice(subscriberIndex, 1);\n            }\n        };\n        return SubjectSubscription;\n    }(Subscription_1.Subscription));\n    exports.SubjectSubscription = SubjectSubscription;\n});\n\ndefine('rxjs/Subject',[\"require\", \"exports\", \"tslib\", \"./Observable\", \"./Subscriber\", \"./Subscription\", \"./util/ObjectUnsubscribedError\", \"./SubjectSubscription\", \"./symbol/rxSubscriber\"], function (require, exports, tslib_1, Observable_1, Subscriber_1, Subscription_1, ObjectUnsubscribedError_1, SubjectSubscription_1, rxSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class SubjectSubscriber<T>\n     */\n    var SubjectSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SubjectSubscriber, _super);\n        function SubjectSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            return _this;\n        }\n        return SubjectSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.SubjectSubscriber = SubjectSubscriber;\n    /**\n     * @class Subject<T>\n     */\n    var Subject = /** @class */ (function (_super) {\n        tslib_1.__extends(Subject, _super);\n        function Subject() {\n            var _this = _super.call(this) || this;\n            _this.observers = [];\n            _this.closed = false;\n            _this.isStopped = false;\n            _this.hasError = false;\n            _this.thrownError = null;\n            return _this;\n        }\n        Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {\n            return new SubjectSubscriber(this);\n        };\n        Subject.prototype.lift = function (operator) {\n            var subject = new AnonymousSubject(this, this);\n            subject.operator = operator;\n            return subject;\n        };\n        Subject.prototype.next = function (value) {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            if (!this.isStopped) {\n                var observers = this.observers;\n                var len = observers.length;\n                var copy = observers.slice();\n                for (var i = 0; i < len; i++) {\n                    copy[i].next(value);\n                }\n            }\n        };\n        Subject.prototype.error = function (err) {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            this.hasError = true;\n            this.thrownError = err;\n            this.isStopped = true;\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].error(err);\n            }\n            this.observers.length = 0;\n        };\n        Subject.prototype.complete = function () {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            this.isStopped = true;\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].complete();\n            }\n            this.observers.length = 0;\n        };\n        Subject.prototype.unsubscribe = function () {\n            this.isStopped = true;\n            this.closed = true;\n            this.observers = null;\n        };\n        Subject.prototype._trySubscribe = function (subscriber) {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            else {\n                return _super.prototype._trySubscribe.call(this, subscriber);\n            }\n        };\n        Subject.prototype._subscribe = function (subscriber) {\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            else if (this.hasError) {\n                subscriber.error(this.thrownError);\n                return Subscription_1.Subscription.EMPTY;\n            }\n            else if (this.isStopped) {\n                subscriber.complete();\n                return Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this.observers.push(subscriber);\n                return new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n            }\n        };\n        Subject.prototype.asObservable = function () {\n            var observable = new Observable_1.Observable();\n            observable.source = this;\n            return observable;\n        };\n        Subject.create = function (destination, source) {\n            return new AnonymousSubject(destination, source);\n        };\n        return Subject;\n    }(Observable_1.Observable));\n    exports.Subject = Subject;\n    /**\n     * @class AnonymousSubject<T>\n     */\n    var AnonymousSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(AnonymousSubject, _super);\n        function AnonymousSubject(destination, source) {\n            var _this = _super.call(this) || this;\n            _this.destination = destination;\n            _this.source = source;\n            return _this;\n        }\n        AnonymousSubject.prototype.next = function (value) {\n            var destination = this.destination;\n            if (destination && destination.next) {\n                destination.next(value);\n            }\n        };\n        AnonymousSubject.prototype.error = function (err) {\n            var destination = this.destination;\n            if (destination && destination.error) {\n                this.destination.error(err);\n            }\n        };\n        AnonymousSubject.prototype.complete = function () {\n            var destination = this.destination;\n            if (destination && destination.complete) {\n                this.destination.complete();\n            }\n        };\n        AnonymousSubject.prototype._subscribe = function (subscriber) {\n            var source = this.source;\n            if (source) {\n                return this.source.subscribe(subscriber);\n            }\n            else {\n                return Subscription_1.Subscription.EMPTY;\n            }\n        };\n        return AnonymousSubject;\n    }(Subject));\n    exports.AnonymousSubject = AnonymousSubject;\n});\n\ndefine('rxjs/AsyncSubject',[\"require\", \"exports\", \"tslib\", \"./Subject\", \"./Subscription\"], function (require, exports, tslib_1, Subject_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class AsyncSubject<T>\n     */\n    var AsyncSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(AsyncSubject, _super);\n        function AsyncSubject() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.value = null;\n            _this.hasNext = false;\n            _this.hasCompleted = false;\n            return _this;\n        }\n        AsyncSubject.prototype._subscribe = function (subscriber) {\n            if (this.hasError) {\n                subscriber.error(this.thrownError);\n                return Subscription_1.Subscription.EMPTY;\n            }\n            else if (this.hasCompleted && this.hasNext) {\n                subscriber.next(this.value);\n                subscriber.complete();\n                return Subscription_1.Subscription.EMPTY;\n            }\n            return _super.prototype._subscribe.call(this, subscriber);\n        };\n        AsyncSubject.prototype.next = function (value) {\n            if (!this.hasCompleted) {\n                this.value = value;\n                this.hasNext = true;\n            }\n        };\n        AsyncSubject.prototype.error = function (error) {\n            if (!this.hasCompleted) {\n                _super.prototype.error.call(this, error);\n            }\n        };\n        AsyncSubject.prototype.complete = function () {\n            this.hasCompleted = true;\n            if (this.hasNext) {\n                _super.prototype.next.call(this, this.value);\n            }\n            _super.prototype.complete.call(this);\n        };\n        return AsyncSubject;\n    }(Subject_1.Subject));\n    exports.AsyncSubject = AsyncSubject;\n});\n\ndefine('rxjs/scheduler/Action',[\"require\", \"exports\", \"tslib\", \"../Subscription\"], function (require, exports, tslib_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * A unit of work to be executed in a {@link Scheduler}. An action is typically\n     * created from within a Scheduler and an RxJS user does not need to concern\n     * themselves about creating and manipulating an Action.\n     *\n     * ```ts\n     * class Action<T> extends Subscription {\n     *   new (scheduler: Scheduler, work: (state?: T) => void);\n     *   schedule(state?: T, delay: number = 0): Subscription;\n     * }\n     * ```\n     *\n     * @class Action<T>\n     */\n    var Action = /** @class */ (function (_super) {\n        tslib_1.__extends(Action, _super);\n        function Action(scheduler, work) {\n            return _super.call(this) || this;\n        }\n        /**\n         * Schedules this action on its parent Scheduler for execution. May be passed\n         * some context object, `state`. May happen at some point in the future,\n         * according to the `delay` parameter, if specified.\n         * @param {T} [state] Some contextual data that the `work` function uses when\n         * called by the Scheduler.\n         * @param {number} [delay] Time to wait before executing the work, where the\n         * time unit is implicit and defined by the Scheduler.\n         * @return {void}\n         */\n        Action.prototype.schedule = function (state, delay) {\n            if (delay === void 0) { delay = 0; }\n            return this;\n        };\n        return Action;\n    }(Subscription_1.Subscription));\n    exports.Action = Action;\n});\n\ndefine('rxjs/scheduler/AsyncAction',[\"require\", \"exports\", \"tslib\", \"../util/root\", \"./Action\"], function (require, exports, tslib_1, root_1, Action_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AsyncAction = /** @class */ (function (_super) {\n        tslib_1.__extends(AsyncAction, _super);\n        function AsyncAction(scheduler, work) {\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            _this.pending = false;\n            return _this;\n        }\n        AsyncAction.prototype.schedule = function (state, delay) {\n            if (delay === void 0) { delay = 0; }\n            if (this.closed) {\n                return this;\n            }\n            // Always replace the current state with the new state.\n            this.state = state;\n            // Set the pending flag indicating that this action has been scheduled, or\n            // has recursively rescheduled itself.\n            this.pending = true;\n            var id = this.id;\n            var scheduler = this.scheduler;\n            //\n            // Important implementation note:\n            //\n            // Actions only execute once by default, unless rescheduled from within the\n            // scheduled callback. This allows us to implement single and repeat\n            // actions via the same code path, without adding API surface area, as well\n            // as mimic traditional recursion but across asynchronous boundaries.\n            //\n            // However, JS runtimes and timers distinguish between intervals achieved by\n            // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n            // serial `setTimeout` calls can be individually delayed, which delays\n            // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n            // guarantee the interval callback will be invoked more precisely to the\n            // interval period, regardless of load.\n            //\n            // Therefore, we use `setInterval` to schedule single and repeat actions.\n            // If the action reschedules itself with the same delay, the interval is not\n            // canceled. If the action doesn't reschedule, or reschedules with a\n            // different delay, the interval will be canceled after scheduled callback\n            // execution.\n            //\n            if (id != null) {\n                this.id = this.recycleAsyncId(scheduler, id, delay);\n            }\n            this.delay = delay;\n            // If this action has already an async Id, don't request a new one.\n            this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n            return this;\n        };\n        AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);\n        };\n        AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If this action is rescheduled with the same delay time, don't clear the interval id.\n            if (delay !== null && this.delay === delay && this.pending === false) {\n                return id;\n            }\n            // Otherwise, if the action's delay time is different from the current delay,\n            // or the action has been rescheduled before it's executed, clear the interval id\n            return root_1.root.clearInterval(id) && undefined || undefined;\n        };\n        /**\n         * Immediately executes this action and the `work` it contains.\n         * @return {any}\n         */\n        AsyncAction.prototype.execute = function (state, delay) {\n            if (this.closed) {\n                return new Error('executing a cancelled action');\n            }\n            this.pending = false;\n            var error = this._execute(state, delay);\n            if (error) {\n                return error;\n            }\n            else if (this.pending === false && this.id != null) {\n                // Dequeue if the action didn't reschedule itself. Don't call\n                // unsubscribe(), because the action could reschedule later.\n                // For example:\n                // ```\n                // scheduler.schedule(function doWork(counter) {\n                //   /* ... I'm a busy worker bee ... */\n                //   var originalAction = this;\n                //   /* wait 100ms before rescheduling the action */\n                //   setTimeout(function () {\n                //     originalAction.schedule(counter + 1);\n                //   }, 100);\n                // }, 1000);\n                // ```\n                this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n            }\n        };\n        AsyncAction.prototype._execute = function (state, delay) {\n            var errored = false;\n            var errorValue = undefined;\n            try {\n                this.work(state);\n            }\n            catch (e) {\n                errored = true;\n                errorValue = !!e && e || new Error(e);\n            }\n            if (errored) {\n                this.unsubscribe();\n                return errorValue;\n            }\n        };\n        AsyncAction.prototype._unsubscribe = function () {\n            var id = this.id;\n            var scheduler = this.scheduler;\n            var actions = scheduler.actions;\n            var index = actions.indexOf(this);\n            this.work = null;\n            this.state = null;\n            this.pending = false;\n            this.scheduler = null;\n            if (index !== -1) {\n                actions.splice(index, 1);\n            }\n            if (id != null) {\n                this.id = this.recycleAsyncId(scheduler, id, null);\n            }\n            this.delay = null;\n        };\n        return AsyncAction;\n    }(Action_1.Action));\n    exports.AsyncAction = AsyncAction;\n});\n\ndefine('rxjs/scheduler/QueueAction',[\"require\", \"exports\", \"tslib\", \"./AsyncAction\"], function (require, exports, tslib_1, AsyncAction_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var QueueAction = /** @class */ (function (_super) {\n        tslib_1.__extends(QueueAction, _super);\n        function QueueAction(scheduler, work) {\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            return _this;\n        }\n        QueueAction.prototype.schedule = function (state, delay) {\n            if (delay === void 0) { delay = 0; }\n            if (delay > 0) {\n                return _super.prototype.schedule.call(this, state, delay);\n            }\n            this.delay = delay;\n            this.state = state;\n            this.scheduler.flush(this);\n            return this;\n        };\n        QueueAction.prototype.execute = function (state, delay) {\n            return (delay > 0 || this.closed) ?\n                _super.prototype.execute.call(this, state, delay) :\n                this._execute(state, delay);\n        };\n        QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay exists and is greater than 0, or if the delay is null (the\n            // action wasn't rescheduled) but was originally scheduled as an async\n            // action, then recycle as an async action.\n            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n            }\n            // Otherwise flush the scheduler starting with this action.\n            return scheduler.flush(this);\n        };\n        return QueueAction;\n    }(AsyncAction_1.AsyncAction));\n    exports.QueueAction = QueueAction;\n});\n\ndefine('rxjs/Scheduler',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An execution context and a data structure to order tasks and schedule their\n     * execution. Provides a notion of (potentially virtual) time, through the\n     * `now()` getter method.\n     *\n     * Each unit of work in a Scheduler is called an {@link Action}.\n     *\n     * ```ts\n     * class Scheduler {\n     *   now(): number;\n     *   schedule(work, delay?, state?): Subscription;\n     * }\n     * ```\n     *\n     * @class Scheduler\n     */\n    var Scheduler = /** @class */ (function () {\n        function Scheduler(SchedulerAction, now) {\n            if (now === void 0) { now = Scheduler.now; }\n            this.SchedulerAction = SchedulerAction;\n            this.now = now;\n        }\n        /**\n         * Schedules a function, `work`, for execution. May happen at some point in\n         * the future, according to the `delay` parameter, if specified. May be passed\n         * some context object, `state`, which will be passed to the `work` function.\n         *\n         * The given arguments will be processed an stored as an Action object in a\n         * queue of actions.\n         *\n         * @param {function(state: ?T): ?Subscription} work A function representing a\n         * task, or some unit of work to be executed by the Scheduler.\n         * @param {number} [delay] Time to wait before executing the work, where the\n         * time unit is implicit and defined by the Scheduler itself.\n         * @param {T} [state] Some contextual data that the `work` function uses when\n         * called by the Scheduler.\n         * @return {Subscription} A subscription in order to be able to unsubscribe\n         * the scheduled work.\n         */\n        Scheduler.prototype.schedule = function (work, delay, state) {\n            if (delay === void 0) { delay = 0; }\n            return new this.SchedulerAction(this, work).schedule(state, delay);\n        };\n        Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };\n        return Scheduler;\n    }());\n    exports.Scheduler = Scheduler;\n});\n\ndefine('rxjs/scheduler/AsyncScheduler',[\"require\", \"exports\", \"tslib\", \"../Scheduler\"], function (require, exports, tslib_1, Scheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var AsyncScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(AsyncScheduler, _super);\n        function AsyncScheduler() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.actions = [];\n            /**\n             * A flag to indicate whether the Scheduler is currently executing a batch of\n             * queued actions.\n             * @type {boolean}\n             */\n            _this.active = false;\n            /**\n             * An internal ID used to track the latest asynchronous task such as those\n             * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n             * others.\n             * @type {any}\n             */\n            _this.scheduled = undefined;\n            return _this;\n        }\n        AsyncScheduler.prototype.flush = function (action) {\n            var actions = this.actions;\n            if (this.active) {\n                actions.push(action);\n                return;\n            }\n            var error;\n            this.active = true;\n            do {\n                if (error = action.execute(action.state, action.delay)) {\n                    break;\n                }\n            } while (action = actions.shift()); // exhaust the scheduler queue\n            this.active = false;\n            if (error) {\n                while (action = actions.shift()) {\n                    action.unsubscribe();\n                }\n                throw error;\n            }\n        };\n        return AsyncScheduler;\n    }(Scheduler_1.Scheduler));\n    exports.AsyncScheduler = AsyncScheduler;\n});\n\ndefine('rxjs/scheduler/QueueScheduler',[\"require\", \"exports\", \"tslib\", \"./AsyncScheduler\"], function (require, exports, tslib_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var QueueScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(QueueScheduler, _super);\n        function QueueScheduler() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return QueueScheduler;\n    }(AsyncScheduler_1.AsyncScheduler));\n    exports.QueueScheduler = QueueScheduler;\n});\n\ndefine('rxjs/scheduler/queue',[\"require\", \"exports\", \"./QueueAction\", \"./QueueScheduler\"], function (require, exports, QueueAction_1, QueueScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Queue Scheduler\n     *\n     * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n     *\n     * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.\n     *\n     * When used without delay, it schedules given task synchronously - executes it right when\n     * it is scheduled. However when called recursively, that is when inside the scheduled task,\n     * another task is scheduled with queue scheduler, instead of executing immediately as well,\n     * that task will be put on a queue and wait for current one to finish.\n     *\n     * This means that when you execute task with `queue` scheduler, you are sure it will end\n     * before any other task scheduled with that scheduler will start.\n     *\n     * @examples <caption>Schedule recursively first, then do something</caption>\n     *\n     * Rx.Scheduler.queue.schedule(() => {\n     *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n     *\n     *   console.log('first');\n     * });\n     *\n     * // Logs:\n     * // \"first\"\n     * // \"second\"\n     *\n     *\n     * @example <caption>Reschedule itself recursively</caption>\n     *\n     * Rx.Scheduler.queue.schedule(function(state) {\n     *   if (state !== 0) {\n     *     console.log('before', state);\n     *     this.schedule(state - 1); // `this` references currently executing Action,\n     *                               // which we reschedule with new state\n     *     console.log('after', state);\n     *   }\n     * }, 0, 3);\n     *\n     * // In scheduler that runs recursively, you would expect:\n     * // \"before\", 3\n     * // \"before\", 2\n     * // \"before\", 1\n     * // \"after\", 1\n     * // \"after\", 2\n     * // \"after\", 3\n     *\n     * // But with queue it logs:\n     * // \"before\", 3\n     * // \"after\", 3\n     * // \"before\", 2\n     * // \"after\", 2\n     * // \"before\", 1\n     * // \"after\", 1\n     *\n     *\n     * @static true\n     * @name queue\n     * @owner Scheduler\n     */\n    exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);\n});\n\ndefine('rxjs/Notification',[\"require\", \"exports\", \"./Observable\"], function (require, exports, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represents a push-based event or value that an {@link Observable} can emit.\n     * This class is particularly useful for operators that manage notifications,\n     * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n     * others. Besides wrapping the actual delivered value, it also annotates it\n     * with metadata of, for instance, what type of push message it is (`next`,\n     * `error`, or `complete`).\n     *\n     * @see {@link materialize}\n     * @see {@link dematerialize}\n     * @see {@link observeOn}\n     *\n     * @class Notification<T>\n     */\n    var Notification = /** @class */ (function () {\n        function Notification(kind, value, error) {\n            this.kind = kind;\n            this.value = value;\n            this.error = error;\n            this.hasValue = kind === 'N';\n        }\n        /**\n         * Delivers to the given `observer` the value wrapped by this Notification.\n         * @param {Observer} observer\n         * @return\n         */\n        Notification.prototype.observe = function (observer) {\n            switch (this.kind) {\n                case 'N':\n                    return observer.next && observer.next(this.value);\n                case 'E':\n                    return observer.error && observer.error(this.error);\n                case 'C':\n                    return observer.complete && observer.complete();\n            }\n        };\n        /**\n         * Given some {@link Observer} callbacks, deliver the value represented by the\n         * current Notification to the correctly corresponding callback.\n         * @param {function(value: T): void} next An Observer `next` callback.\n         * @param {function(err: any): void} [error] An Observer `error` callback.\n         * @param {function(): void} [complete] An Observer `complete` callback.\n         * @return {any}\n         */\n        Notification.prototype.do = function (next, error, complete) {\n            var kind = this.kind;\n            switch (kind) {\n                case 'N':\n                    return next && next(this.value);\n                case 'E':\n                    return error && error(this.error);\n                case 'C':\n                    return complete && complete();\n            }\n        };\n        /**\n         * Takes an Observer or its individual callback functions, and calls `observe`\n         * or `do` methods accordingly.\n         * @param {Observer|function(value: T): void} nextOrObserver An Observer or\n         * the `next` callback.\n         * @param {function(err: any): void} [error] An Observer `error` callback.\n         * @param {function(): void} [complete] An Observer `complete` callback.\n         * @return {any}\n         */\n        Notification.prototype.accept = function (nextOrObserver, error, complete) {\n            if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n                return this.observe(nextOrObserver);\n            }\n            else {\n                return this.do(nextOrObserver, error, complete);\n            }\n        };\n        /**\n         * Returns a simple Observable that just delivers the notification represented\n         * by this Notification instance.\n         * @return {any}\n         */\n        Notification.prototype.toObservable = function () {\n            var kind = this.kind;\n            switch (kind) {\n                case 'N':\n                    return Observable_1.Observable.of(this.value);\n                case 'E':\n                    return Observable_1.Observable.throw(this.error);\n                case 'C':\n                    return Observable_1.Observable.empty();\n            }\n            throw new Error('unexpected notification kind value');\n        };\n        /**\n         * A shortcut to create a Notification instance of the type `next` from a\n         * given value.\n         * @param {T} value The `next` value.\n         * @return {Notification<T>} The \"next\" Notification representing the\n         * argument.\n         */\n        Notification.createNext = function (value) {\n            if (typeof value !== 'undefined') {\n                return new Notification('N', value);\n            }\n            return Notification.undefinedValueNotification;\n        };\n        /**\n         * A shortcut to create a Notification instance of the type `error` from a\n         * given error.\n         * @param {any} [err] The `error` error.\n         * @return {Notification<T>} The \"error\" Notification representing the\n         * argument.\n         */\n        Notification.createError = function (err) {\n            return new Notification('E', undefined, err);\n        };\n        /**\n         * A shortcut to create a Notification instance of the type `complete`.\n         * @return {Notification<any>} The valueless \"complete\" Notification.\n         */\n        Notification.createComplete = function () {\n            return Notification.completeNotification;\n        };\n        Notification.completeNotification = new Notification('C');\n        Notification.undefinedValueNotification = new Notification('N', undefined);\n        return Notification;\n    }());\n    exports.Notification = Notification;\n});\n\ndefine('rxjs/operators/observeOn',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Notification\"], function (require, exports, tslib_1, Subscriber_1, Notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Re-emits all notifications from source Observable with specified scheduler.\n     *\n     * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n     *\n     * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n     * notifications emitted by the source Observable. It might be useful, if you do not have control over\n     * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n     *\n     * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n     * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n     * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n     * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n     * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n     * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n     * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n     * little bit more, to ensure that they are emitted at expected moments.\n     *\n     * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n     * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n     * will delay all notifications - including error notifications - while `delay` will pass through error\n     * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n     * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n     * for notification emissions in general.\n     *\n     * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n     * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n     *                                               // with async scheduler by default...\n     *\n     * intervals\n     * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n     * .subscribe(val => {                           // scheduler to ensure smooth animation.\n     *   someDiv.style.height = val + 'px';\n     * });\n     *\n     * @see {@link delay}\n     *\n     * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n     * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n     * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n     * but with provided scheduler.\n     *\n     * @method observeOn\n     * @owner Observable\n     */\n    function observeOn(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        return function observeOnOperatorFunction(source) {\n            return source.lift(new ObserveOnOperator(scheduler, delay));\n        };\n    }\n    exports.observeOn = observeOn;\n    var ObserveOnOperator = /** @class */ (function () {\n        function ObserveOnOperator(scheduler, delay) {\n            if (delay === void 0) { delay = 0; }\n            this.scheduler = scheduler;\n            this.delay = delay;\n        }\n        ObserveOnOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n        };\n        return ObserveOnOperator;\n    }());\n    exports.ObserveOnOperator = ObserveOnOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ObserveOnSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ObserveOnSubscriber, _super);\n        function ObserveOnSubscriber(destination, scheduler, delay) {\n            if (delay === void 0) { delay = 0; }\n            var _this = _super.call(this, destination) || this;\n            _this.scheduler = scheduler;\n            _this.delay = delay;\n            return _this;\n        }\n        ObserveOnSubscriber.dispatch = function (arg) {\n            var notification = arg.notification, destination = arg.destination;\n            notification.observe(destination);\n            this.unsubscribe();\n        };\n        ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {\n            this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n        };\n        ObserveOnSubscriber.prototype._next = function (value) {\n            this.scheduleMessage(Notification_1.Notification.createNext(value));\n        };\n        ObserveOnSubscriber.prototype._error = function (err) {\n            this.scheduleMessage(Notification_1.Notification.createError(err));\n        };\n        ObserveOnSubscriber.prototype._complete = function () {\n            this.scheduleMessage(Notification_1.Notification.createComplete());\n        };\n        return ObserveOnSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.ObserveOnSubscriber = ObserveOnSubscriber;\n    var ObserveOnMessage = /** @class */ (function () {\n        function ObserveOnMessage(notification, destination) {\n            this.notification = notification;\n            this.destination = destination;\n        }\n        return ObserveOnMessage;\n    }());\n    exports.ObserveOnMessage = ObserveOnMessage;\n});\n\ndefine('rxjs/ReplaySubject',[\"require\", \"exports\", \"tslib\", \"./Subject\", \"./scheduler/queue\", \"./Subscription\", \"./operators/observeOn\", \"./util/ObjectUnsubscribedError\", \"./SubjectSubscription\"], function (require, exports, tslib_1, Subject_1, queue_1, Subscription_1, observeOn_1, ObjectUnsubscribedError_1, SubjectSubscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class ReplaySubject<T>\n     */\n    var ReplaySubject = /** @class */ (function (_super) {\n        tslib_1.__extends(ReplaySubject, _super);\n        function ReplaySubject(bufferSize, windowTime, scheduler) {\n            if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }\n            if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }\n            var _this = _super.call(this) || this;\n            _this.scheduler = scheduler;\n            _this._events = [];\n            _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n            _this._windowTime = windowTime < 1 ? 1 : windowTime;\n            return _this;\n        }\n        ReplaySubject.prototype.next = function (value) {\n            var now = this._getNow();\n            this._events.push(new ReplayEvent(now, value));\n            this._trimBufferThenGetEvents();\n            _super.prototype.next.call(this, value);\n        };\n        ReplaySubject.prototype._subscribe = function (subscriber) {\n            var _events = this._trimBufferThenGetEvents();\n            var scheduler = this.scheduler;\n            var subscription;\n            if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            else if (this.hasError) {\n                subscription = Subscription_1.Subscription.EMPTY;\n            }\n            else if (this.isStopped) {\n                subscription = Subscription_1.Subscription.EMPTY;\n            }\n            else {\n                this.observers.push(subscriber);\n                subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);\n            }\n            if (scheduler) {\n                subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));\n            }\n            var len = _events.length;\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n            if (this.hasError) {\n                subscriber.error(this.thrownError);\n            }\n            else if (this.isStopped) {\n                subscriber.complete();\n            }\n            return subscription;\n        };\n        ReplaySubject.prototype._getNow = function () {\n            return (this.scheduler || queue_1.queue).now();\n        };\n        ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n            var now = this._getNow();\n            var _bufferSize = this._bufferSize;\n            var _windowTime = this._windowTime;\n            var _events = this._events;\n            var eventsCount = _events.length;\n            var spliceCount = 0;\n            // Trim events that fall out of the time window.\n            // Start at the front of the list. Break early once\n            // we encounter an event that falls within the window.\n            while (spliceCount < eventsCount) {\n                if ((now - _events[spliceCount].time) < _windowTime) {\n                    break;\n                }\n                spliceCount++;\n            }\n            if (eventsCount > _bufferSize) {\n                spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n            }\n            if (spliceCount > 0) {\n                _events.splice(0, spliceCount);\n            }\n            return _events;\n        };\n        return ReplaySubject;\n    }(Subject_1.Subject));\n    exports.ReplaySubject = ReplaySubject;\n    var ReplayEvent = /** @class */ (function () {\n        function ReplayEvent(time, value) {\n            this.time = time;\n            this.value = value;\n        }\n        return ReplayEvent;\n    }());\n});\n\ndefine('rxjs/BehaviorSubject',[\"require\", \"exports\", \"tslib\", \"./Subject\", \"./util/ObjectUnsubscribedError\"], function (require, exports, tslib_1, Subject_1, ObjectUnsubscribedError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class BehaviorSubject<T>\n     */\n    var BehaviorSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(BehaviorSubject, _super);\n        function BehaviorSubject(_value) {\n            var _this = _super.call(this) || this;\n            _this._value = _value;\n            return _this;\n        }\n        Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n            get: function () {\n                return this.getValue();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        BehaviorSubject.prototype._subscribe = function (subscriber) {\n            var subscription = _super.prototype._subscribe.call(this, subscriber);\n            if (subscription && !subscription.closed) {\n                subscriber.next(this._value);\n            }\n            return subscription;\n        };\n        BehaviorSubject.prototype.getValue = function () {\n            if (this.hasError) {\n                throw this.thrownError;\n            }\n            else if (this.closed) {\n                throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();\n            }\n            else {\n                return this._value;\n            }\n        };\n        BehaviorSubject.prototype.next = function (value) {\n            _super.prototype.next.call(this, this._value = value);\n        };\n        return BehaviorSubject;\n    }(Subject_1.Subject));\n    exports.BehaviorSubject = BehaviorSubject;\n});\n\ndefine('rxjs/operators/refCount',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function refCount() {\n        return function refCountOperatorFunction(source) {\n            return source.lift(new RefCountOperator(source));\n        };\n    }\n    exports.refCount = refCount;\n    var RefCountOperator = /** @class */ (function () {\n        function RefCountOperator(connectable) {\n            this.connectable = connectable;\n        }\n        RefCountOperator.prototype.call = function (subscriber, source) {\n            var connectable = this.connectable;\n            connectable._refCount++;\n            var refCounter = new RefCountSubscriber(subscriber, connectable);\n            var subscription = source.subscribe(refCounter);\n            if (!refCounter.closed) {\n                refCounter.connection = connectable.connect();\n            }\n            return subscription;\n        };\n        return RefCountOperator;\n    }());\n    var RefCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RefCountSubscriber, _super);\n        function RefCountSubscriber(destination, connectable) {\n            var _this = _super.call(this, destination) || this;\n            _this.connectable = connectable;\n            return _this;\n        }\n        RefCountSubscriber.prototype._unsubscribe = function () {\n            var connectable = this.connectable;\n            if (!connectable) {\n                this.connection = null;\n                return;\n            }\n            this.connectable = null;\n            var refCount = connectable._refCount;\n            if (refCount <= 0) {\n                this.connection = null;\n                return;\n            }\n            connectable._refCount = refCount - 1;\n            if (refCount > 1) {\n                this.connection = null;\n                return;\n            }\n            ///\n            // Compare the local RefCountSubscriber's connection Subscription to the\n            // connection Subscription on the shared ConnectableObservable. In cases\n            // where the ConnectableObservable source synchronously emits values, and\n            // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n            // execution continues to here before the RefCountOperator has a chance to\n            // supply the RefCountSubscriber with the shared connection Subscription.\n            // For example:\n            // ```\n            // Observable.range(0, 10)\n            //   .publish()\n            //   .refCount()\n            //   .take(5)\n            //   .subscribe();\n            // ```\n            // In order to account for this case, RefCountSubscriber should only dispose\n            // the ConnectableObservable's shared connection Subscription if the\n            // connection Subscription exists, *and* either:\n            //   a. RefCountSubscriber doesn't have a reference to the shared connection\n            //      Subscription yet, or,\n            //   b. RefCountSubscriber's connection Subscription reference is identical\n            //      to the shared connection Subscription\n            ///\n            var connection = this.connection;\n            var sharedConnection = connectable._connection;\n            this.connection = null;\n            if (sharedConnection && (!connection || sharedConnection === connection)) {\n                sharedConnection.unsubscribe();\n            }\n        };\n        return RefCountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/observable/ConnectableObservable',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../Observable\", \"../Subscriber\", \"../Subscription\", \"../operators/refCount\"], function (require, exports, tslib_1, Subject_1, Observable_1, Subscriber_1, Subscription_1, refCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @class ConnectableObservable<T>\n     */\n    var ConnectableObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ConnectableObservable, _super);\n        function ConnectableObservable(source, subjectFactory) {\n            var _this = _super.call(this) || this;\n            _this.source = source;\n            _this.subjectFactory = subjectFactory;\n            _this._refCount = 0;\n            _this._isComplete = false;\n            return _this;\n        }\n        ConnectableObservable.prototype._subscribe = function (subscriber) {\n            return this.getSubject().subscribe(subscriber);\n        };\n        ConnectableObservable.prototype.getSubject = function () {\n            var subject = this._subject;\n            if (!subject || subject.isStopped) {\n                this._subject = this.subjectFactory();\n            }\n            return this._subject;\n        };\n        ConnectableObservable.prototype.connect = function () {\n            var connection = this._connection;\n            if (!connection) {\n                this._isComplete = false;\n                connection = this._connection = new Subscription_1.Subscription();\n                connection.add(this.source\n                    .subscribe(new ConnectableSubscriber(this.getSubject(), this)));\n                if (connection.closed) {\n                    this._connection = null;\n                    connection = Subscription_1.Subscription.EMPTY;\n                }\n                else {\n                    this._connection = connection;\n                }\n            }\n            return connection;\n        };\n        ConnectableObservable.prototype.refCount = function () {\n            return refCount_1.refCount()(this);\n        };\n        return ConnectableObservable;\n    }(Observable_1.Observable));\n    exports.ConnectableObservable = ConnectableObservable;\n    var connectableProto = ConnectableObservable.prototype;\n    exports.connectableObservableDescriptor = {\n        operator: { value: null },\n        _refCount: { value: 0, writable: true },\n        _subject: { value: null, writable: true },\n        _connection: { value: null, writable: true },\n        _subscribe: { value: connectableProto._subscribe },\n        _isComplete: { value: connectableProto._isComplete, writable: true },\n        getSubject: { value: connectableProto.getSubject },\n        connect: { value: connectableProto.connect },\n        refCount: { value: connectableProto.refCount }\n    };\n    var ConnectableSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ConnectableSubscriber, _super);\n        function ConnectableSubscriber(destination, connectable) {\n            var _this = _super.call(this, destination) || this;\n            _this.connectable = connectable;\n            return _this;\n        }\n        ConnectableSubscriber.prototype._error = function (err) {\n            this._unsubscribe();\n            _super.prototype._error.call(this, err);\n        };\n        ConnectableSubscriber.prototype._complete = function () {\n            this.connectable._isComplete = true;\n            this._unsubscribe();\n            _super.prototype._complete.call(this);\n        };\n        ConnectableSubscriber.prototype._unsubscribe = function () {\n            var connectable = this.connectable;\n            if (connectable) {\n                this.connectable = null;\n                var connection = connectable._connection;\n                connectable._refCount = 0;\n                connectable._subject = null;\n                connectable._connection = null;\n                if (connection) {\n                    connection.unsubscribe();\n                }\n            }\n        };\n        return ConnectableSubscriber;\n    }(Subject_1.SubjectSubscriber));\n    var RefCountOperator = /** @class */ (function () {\n        function RefCountOperator(connectable) {\n            this.connectable = connectable;\n        }\n        RefCountOperator.prototype.call = function (subscriber, source) {\n            var connectable = this.connectable;\n            connectable._refCount++;\n            var refCounter = new RefCountSubscriber(subscriber, connectable);\n            var subscription = source.subscribe(refCounter);\n            if (!refCounter.closed) {\n                refCounter.connection = connectable.connect();\n            }\n            return subscription;\n        };\n        return RefCountOperator;\n    }());\n    var RefCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RefCountSubscriber, _super);\n        function RefCountSubscriber(destination, connectable) {\n            var _this = _super.call(this, destination) || this;\n            _this.connectable = connectable;\n            return _this;\n        }\n        RefCountSubscriber.prototype._unsubscribe = function () {\n            var connectable = this.connectable;\n            if (!connectable) {\n                this.connection = null;\n                return;\n            }\n            this.connectable = null;\n            var refCount = connectable._refCount;\n            if (refCount <= 0) {\n                this.connection = null;\n                return;\n            }\n            connectable._refCount = refCount - 1;\n            if (refCount > 1) {\n                this.connection = null;\n                return;\n            }\n            ///\n            // Compare the local RefCountSubscriber's connection Subscription to the\n            // connection Subscription on the shared ConnectableObservable. In cases\n            // where the ConnectableObservable source synchronously emits values, and\n            // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n            // execution continues to here before the RefCountOperator has a chance to\n            // supply the RefCountSubscriber with the shared connection Subscription.\n            // For example:\n            // ```\n            // Observable.range(0, 10)\n            //   .publish()\n            //   .refCount()\n            //   .take(5)\n            //   .subscribe();\n            // ```\n            // In order to account for this case, RefCountSubscriber should only dispose\n            // the ConnectableObservable's shared connection Subscription if the\n            // connection Subscription exists, *and* either:\n            //   a. RefCountSubscriber doesn't have a reference to the shared connection\n            //      Subscription yet, or,\n            //   b. RefCountSubscriber's connection Subscription reference is identical\n            //      to the shared connection Subscription\n            ///\n            var connection = this.connection;\n            var sharedConnection = connectable._connection;\n            this.connection = null;\n            if (sharedConnection && (!connection || sharedConnection === connection)) {\n                sharedConnection.unsubscribe();\n            }\n        };\n        return RefCountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/util/EmptyError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when an Observable or a sequence was queried but has no\n     * elements.\n     *\n     * @see {@link first}\n     * @see {@link last}\n     * @see {@link single}\n     *\n     * @class EmptyError\n     */\n    var EmptyError = /** @class */ (function (_super) {\n        tslib_1.__extends(EmptyError, _super);\n        function EmptyError() {\n            var _this = this;\n            var err = _this = _super.call(this, 'no elements in sequence') || this;\n            _this.name = err.name = 'EmptyError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return EmptyError;\n    }(Error));\n    exports.EmptyError = EmptyError;\n});\n\ndefine('rxjs/util/ArgumentOutOfRangeError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when an element was queried at a certain index of an\n     * Observable, but no such index or position exists in that sequence.\n     *\n     * @see {@link elementAt}\n     * @see {@link take}\n     * @see {@link takeLast}\n     *\n     * @class ArgumentOutOfRangeError\n     */\n    var ArgumentOutOfRangeError = /** @class */ (function (_super) {\n        tslib_1.__extends(ArgumentOutOfRangeError, _super);\n        function ArgumentOutOfRangeError() {\n            var _this = this;\n            var err = _this = _super.call(this, 'argument out of range') || this;\n            _this.name = err.name = 'ArgumentOutOfRangeError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return ArgumentOutOfRangeError;\n    }(Error));\n    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;\n});\n\ndefine('rxjs/util/TimeoutError',[\"require\", \"exports\", \"tslib\"], function (require, exports, tslib_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * An error thrown when duetime elapses.\n     *\n     * @see {@link timeout}\n     *\n     * @class TimeoutError\n     */\n    var TimeoutError = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeoutError, _super);\n        function TimeoutError() {\n            var _this = this;\n            var err = _this = _super.call(this, 'Timeout has occurred') || this;\n            _this.name = err.name = 'TimeoutError';\n            _this.stack = err.stack;\n            _this.message = err.message;\n            return _this;\n        }\n        return TimeoutError;\n    }(Error));\n    exports.TimeoutError = TimeoutError;\n});\n\ndefine('rxjs/scheduler/async',[\"require\", \"exports\", \"./AsyncAction\", \"./AsyncScheduler\"], function (require, exports, AsyncAction_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Async Scheduler\n     *\n     * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n     *\n     * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n     * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n     * in intervals.\n     *\n     * If you just want to \"defer\" task, that is to perform it right after currently\n     * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n     * better choice will be the {@link asap} scheduler.\n     *\n     * @example <caption>Use async scheduler to delay task</caption>\n     * const task = () => console.log('it works!');\n     *\n     * Rx.Scheduler.async.schedule(task, 2000);\n     *\n     * // After 2 seconds logs:\n     * // \"it works!\"\n     *\n     *\n     * @example <caption>Use async scheduler to repeat task in intervals</caption>\n     * function task(state) {\n     *   console.log(state);\n     *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n     *                                   // which we reschedule with new state and delay\n     * }\n     *\n     * Rx.Scheduler.async.schedule(task, 3000, 0);\n     *\n     * // Logs:\n     * // 0 after 3s\n     * // 1 after 4s\n     * // 2 after 5s\n     * // 3 after 6s\n     *\n     * @static true\n     * @name async\n     * @owner Scheduler\n     */\n    exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);\n});\n\ndefine('rxjs/operators/timeInterval',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../scheduler/async\"], function (require, exports, tslib_1, Subscriber_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function timeInterval(scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return function (source) { return source.lift(new TimeIntervalOperator(scheduler)); };\n    }\n    exports.timeInterval = timeInterval;\n    var TimeInterval = /** @class */ (function () {\n        function TimeInterval(value, interval) {\n            this.value = value;\n            this.interval = interval;\n        }\n        return TimeInterval;\n    }());\n    exports.TimeInterval = TimeInterval;\n    ;\n    var TimeIntervalOperator = /** @class */ (function () {\n        function TimeIntervalOperator(scheduler) {\n            this.scheduler = scheduler;\n        }\n        TimeIntervalOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));\n        };\n        return TimeIntervalOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TimeIntervalSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeIntervalSubscriber, _super);\n        function TimeIntervalSubscriber(destination, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.scheduler = scheduler;\n            _this.lastTime = 0;\n            _this.lastTime = scheduler.now();\n            return _this;\n        }\n        TimeIntervalSubscriber.prototype._next = function (value) {\n            var now = this.scheduler.now();\n            var span = now - this.lastTime;\n            this.lastTime = now;\n            this.destination.next(new TimeInterval(value, span));\n        };\n        return TimeIntervalSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operator/timeInterval',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/timeInterval\"], function (require, exports, async_1, timeInterval_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.TimeInterval = timeInterval_1.TimeInterval;\n    /**\n     * @param scheduler\n     * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}\n     * @method timeInterval\n     * @owner Observable\n     */\n    function timeInterval(scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return timeInterval_1.timeInterval(scheduler)(this);\n    }\n    exports.timeInterval = timeInterval;\n});\n\ndefine('rxjs/operators/map',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Applies a given `project` function to each value emitted by the source\n     * Observable, and emits the resulting values as an Observable.\n     *\n     * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n     * it passes each source value through a transformation function to get\n     * corresponding output values.</span>\n     *\n     * <img src=\"./img/map.png\" width=\"100%\">\n     *\n     * Similar to the well known `Array.prototype.map` function, this operator\n     * applies a projection to each value and emits that projection in the output\n     * Observable.\n     *\n     * @example <caption>Map every click to the clientX position of that click</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var positions = clicks.map(ev => ev.clientX);\n     * positions.subscribe(x => console.log(x));\n     *\n     * @see {@link mapTo}\n     * @see {@link pluck}\n     *\n     * @param {function(value: T, index: number): R} project The function to apply\n     * to each `value` emitted by the source Observable. The `index` parameter is\n     * the number `i` for the i-th emission that has happened since the\n     * subscription, starting from the number `0`.\n     * @param {any} [thisArg] An optional argument to define what `this` is in the\n     * `project` function.\n     * @return {Observable<R>} An Observable that emits the values from the source\n     * Observable transformed by the given `project` function.\n     * @method map\n     * @owner Observable\n     */\n    function map(project, thisArg) {\n        return function mapOperation(source) {\n            if (typeof project !== 'function') {\n                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n            }\n            return source.lift(new MapOperator(project, thisArg));\n        };\n    }\n    exports.map = map;\n    var MapOperator = /** @class */ (function () {\n        function MapOperator(project, thisArg) {\n            this.project = project;\n            this.thisArg = thisArg;\n        }\n        MapOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n        };\n        return MapOperator;\n    }());\n    exports.MapOperator = MapOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MapSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MapSubscriber, _super);\n        function MapSubscriber(destination, project, thisArg) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.count = 0;\n            _this.thisArg = thisArg || _this;\n            return _this;\n        }\n        // NOTE: This looks unoptimized, but it's actually purposefully NOT\n        // using try/catch optimizations.\n        MapSubscriber.prototype._next = function (value) {\n            var result;\n            try {\n                result = this.project.call(this.thisArg, value, this.count++);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return MapSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/timestamp',[\"require\", \"exports\", \"../scheduler/async\", \"./map\"], function (require, exports, async_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param scheduler\n     * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n     * @method timestamp\n     * @owner Observable\n     */\n    function timestamp(scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return map_1.map(function (value) { return new Timestamp(value, scheduler.now()); });\n        // return (source: Observable<T>) => source.lift(new TimestampOperator(scheduler));\n    }\n    exports.timestamp = timestamp;\n    var Timestamp = /** @class */ (function () {\n        function Timestamp(value, timestamp) {\n            this.value = value;\n            this.timestamp = timestamp;\n        }\n        return Timestamp;\n    }());\n    exports.Timestamp = Timestamp;\n    ;\n});\n\ndefine('rxjs/testing/SubscriptionLog',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var SubscriptionLog = /** @class */ (function () {\n        function SubscriptionLog(subscribedFrame, unsubscribedFrame) {\n            if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }\n            this.subscribedFrame = subscribedFrame;\n            this.unsubscribedFrame = unsubscribedFrame;\n        }\n        return SubscriptionLog;\n    }());\n    exports.SubscriptionLog = SubscriptionLog;\n});\n\ndefine('rxjs/testing/SubscriptionLoggable',[\"require\", \"exports\", \"./SubscriptionLog\"], function (require, exports, SubscriptionLog_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var SubscriptionLoggable = /** @class */ (function () {\n        function SubscriptionLoggable() {\n            this.subscriptions = [];\n        }\n        SubscriptionLoggable.prototype.logSubscribedFrame = function () {\n            this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));\n            return this.subscriptions.length - 1;\n        };\n        SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {\n            var subscriptionLogs = this.subscriptions;\n            var oldSubscriptionLog = subscriptionLogs[index];\n            subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());\n        };\n        return SubscriptionLoggable;\n    }());\n    exports.SubscriptionLoggable = SubscriptionLoggable;\n});\n\ndefine('rxjs/util/applyMixins',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function applyMixins(derivedCtor, baseCtors) {\n        for (var i = 0, len = baseCtors.length; i < len; i++) {\n            var baseCtor = baseCtors[i];\n            var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);\n            for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {\n                var name_1 = propertyKeys[j];\n                derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];\n            }\n        }\n    }\n    exports.applyMixins = applyMixins;\n});\n\ndefine('rxjs/testing/ColdObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../Subscription\", \"./SubscriptionLoggable\", \"../util/applyMixins\"], function (require, exports, tslib_1, Observable_1, Subscription_1, SubscriptionLoggable_1, applyMixins_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ColdObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ColdObservable, _super);\n        function ColdObservable(messages, scheduler) {\n            var _this = _super.call(this, function (subscriber) {\n                var observable = this;\n                var index = observable.logSubscribedFrame();\n                subscriber.add(new Subscription_1.Subscription(function () {\n                    observable.logUnsubscribedFrame(index);\n                }));\n                observable.scheduleMessages(subscriber);\n                return subscriber;\n            }) || this;\n            _this.messages = messages;\n            _this.subscriptions = [];\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        ColdObservable.prototype.scheduleMessages = function (subscriber) {\n            var messagesLength = this.messages.length;\n            for (var i = 0; i < messagesLength; i++) {\n                var message = this.messages[i];\n                subscriber.add(this.scheduler.schedule(function (_a) {\n                    var message = _a.message, subscriber = _a.subscriber;\n                    message.notification.observe(subscriber);\n                }, message.frame, { message: message, subscriber: subscriber }));\n            }\n        };\n        return ColdObservable;\n    }(Observable_1.Observable));\n    exports.ColdObservable = ColdObservable;\n    applyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n});\n\ndefine('rxjs/testing/HotObservable',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../Subscription\", \"./SubscriptionLoggable\", \"../util/applyMixins\"], function (require, exports, tslib_1, Subject_1, Subscription_1, SubscriptionLoggable_1, applyMixins_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var HotObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(HotObservable, _super);\n        function HotObservable(messages, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.messages = messages;\n            _this.subscriptions = [];\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        HotObservable.prototype._subscribe = function (subscriber) {\n            var subject = this;\n            var index = subject.logSubscribedFrame();\n            subscriber.add(new Subscription_1.Subscription(function () {\n                subject.logUnsubscribedFrame(index);\n            }));\n            return _super.prototype._subscribe.call(this, subscriber);\n        };\n        HotObservable.prototype.setup = function () {\n            var subject = this;\n            var messagesLength = subject.messages.length;\n            /* tslint:disable:no-var-keyword */\n            for (var i = 0; i < messagesLength; i++) {\n                (function () {\n                    var message = subject.messages[i];\n                    /* tslint:enable */\n                    subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);\n                })();\n            }\n        };\n        return HotObservable;\n    }(Subject_1.Subject));\n    exports.HotObservable = HotObservable;\n    applyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);\n});\n\ndefine('rxjs/scheduler/VirtualTimeScheduler',[\"require\", \"exports\", \"tslib\", \"./AsyncAction\", \"./AsyncScheduler\"], function (require, exports, tslib_1, AsyncAction_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var VirtualTimeScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(VirtualTimeScheduler, _super);\n        function VirtualTimeScheduler(SchedulerAction, maxFrames) {\n            if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }\n            if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }\n            var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;\n            _this.maxFrames = maxFrames;\n            _this.frame = 0;\n            _this.index = -1;\n            return _this;\n        }\n        /**\n         * Prompt the Scheduler to execute all of its queued actions, therefore\n         * clearing its queue.\n         * @return {void}\n         */\n        VirtualTimeScheduler.prototype.flush = function () {\n            var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n            var error, action;\n            while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {\n                if (error = action.execute(action.state, action.delay)) {\n                    break;\n                }\n            }\n            if (error) {\n                while (action = actions.shift()) {\n                    action.unsubscribe();\n                }\n                throw error;\n            }\n        };\n        VirtualTimeScheduler.frameTimeFactor = 10;\n        return VirtualTimeScheduler;\n    }(AsyncScheduler_1.AsyncScheduler));\n    exports.VirtualTimeScheduler = VirtualTimeScheduler;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var VirtualAction = /** @class */ (function (_super) {\n        tslib_1.__extends(VirtualAction, _super);\n        function VirtualAction(scheduler, work, index) {\n            if (index === void 0) { index = scheduler.index += 1; }\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            _this.index = index;\n            _this.active = true;\n            _this.index = scheduler.index = index;\n            return _this;\n        }\n        VirtualAction.prototype.schedule = function (state, delay) {\n            if (delay === void 0) { delay = 0; }\n            if (!this.id) {\n                return _super.prototype.schedule.call(this, state, delay);\n            }\n            this.active = false;\n            // If an action is rescheduled, we save allocations by mutating its state,\n            // pushing it to the end of the scheduler queue, and recycling the action.\n            // But since the VirtualTimeScheduler is used for testing, VirtualActions\n            // must be immutable so they can be inspected later.\n            var action = new VirtualAction(this.scheduler, this.work);\n            this.add(action);\n            return action.schedule(state, delay);\n        };\n        VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            this.delay = scheduler.frame + delay;\n            var actions = scheduler.actions;\n            actions.push(this);\n            actions.sort(VirtualAction.sortActions);\n            return true;\n        };\n        VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            return undefined;\n        };\n        VirtualAction.prototype._execute = function (state, delay) {\n            if (this.active === true) {\n                return _super.prototype._execute.call(this, state, delay);\n            }\n        };\n        VirtualAction.sortActions = function (a, b) {\n            if (a.delay === b.delay) {\n                if (a.index === b.index) {\n                    return 0;\n                }\n                else if (a.index > b.index) {\n                    return 1;\n                }\n                else {\n                    return -1;\n                }\n            }\n            else if (a.delay > b.delay) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        };\n        return VirtualAction;\n    }(AsyncAction_1.AsyncAction));\n    exports.VirtualAction = VirtualAction;\n});\n\ndefine('rxjs/testing/TestScheduler',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../Notification\", \"./ColdObservable\", \"./HotObservable\", \"./SubscriptionLog\", \"../scheduler/VirtualTimeScheduler\"], function (require, exports, tslib_1, Observable_1, Notification_1, ColdObservable_1, HotObservable_1, SubscriptionLog_1, VirtualTimeScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var defaultMaxFrame = 750;\n    var TestScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(TestScheduler, _super);\n        function TestScheduler(assertDeepEqual) {\n            var _this = _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame) || this;\n            _this.assertDeepEqual = assertDeepEqual;\n            _this.hotObservables = [];\n            _this.coldObservables = [];\n            _this.flushTests = [];\n            return _this;\n        }\n        TestScheduler.prototype.createTime = function (marbles) {\n            var indexOf = marbles.indexOf('|');\n            if (indexOf === -1) {\n                throw new Error('marble diagram for time should have a completion marker \"|\"');\n            }\n            return indexOf * TestScheduler.frameTimeFactor;\n        };\n        TestScheduler.prototype.createColdObservable = function (marbles, values, error) {\n            if (marbles.indexOf('^') !== -1) {\n                throw new Error('cold observable cannot have subscription offset \"^\"');\n            }\n            if (marbles.indexOf('!') !== -1) {\n                throw new Error('cold observable cannot have unsubscription marker \"!\"');\n            }\n            var messages = TestScheduler.parseMarbles(marbles, values, error);\n            var cold = new ColdObservable_1.ColdObservable(messages, this);\n            this.coldObservables.push(cold);\n            return cold;\n        };\n        TestScheduler.prototype.createHotObservable = function (marbles, values, error) {\n            if (marbles.indexOf('!') !== -1) {\n                throw new Error('hot observable cannot have unsubscription marker \"!\"');\n            }\n            var messages = TestScheduler.parseMarbles(marbles, values, error);\n            var subject = new HotObservable_1.HotObservable(messages, this);\n            this.hotObservables.push(subject);\n            return subject;\n        };\n        TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {\n            var _this = this;\n            var messages = [];\n            observable.subscribe(function (value) {\n                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });\n            }, function (err) {\n                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });\n            }, function () {\n                messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });\n            });\n            return messages;\n        };\n        TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {\n            var _this = this;\n            if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }\n            var actual = [];\n            var flushTest = { actual: actual, ready: false };\n            var unsubscriptionFrame = TestScheduler\n                .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n            var subscription;\n            this.schedule(function () {\n                subscription = observable.subscribe(function (x) {\n                    var value = x;\n                    // Support Observable-of-Observables\n                    if (x instanceof Observable_1.Observable) {\n                        value = _this.materializeInnerObservable(value, _this.frame);\n                    }\n                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });\n                }, function (err) {\n                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });\n                }, function () {\n                    actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });\n                });\n            }, 0);\n            if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);\n            }\n            this.flushTests.push(flushTest);\n            return {\n                toBe: function (marbles, values, errorValue) {\n                    flushTest.ready = true;\n                    flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n                }\n            };\n        };\n        TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {\n            var flushTest = { actual: actualSubscriptionLogs, ready: false };\n            this.flushTests.push(flushTest);\n            return {\n                toBe: function (marbles) {\n                    var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                    flushTest.ready = true;\n                    flushTest.expected = marblesArray.map(function (marbles) {\n                        return TestScheduler.parseMarblesAsSubscriptions(marbles);\n                    });\n                }\n            };\n        };\n        TestScheduler.prototype.flush = function () {\n            var hotObservables = this.hotObservables;\n            while (hotObservables.length > 0) {\n                hotObservables.shift().setup();\n            }\n            _super.prototype.flush.call(this);\n            var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });\n            while (readyFlushTests.length > 0) {\n                var test = readyFlushTests.shift();\n                this.assertDeepEqual(test.actual, test.expected);\n            }\n        };\n        TestScheduler.parseMarblesAsSubscriptions = function (marbles) {\n            if (typeof marbles !== 'string') {\n                return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);\n            }\n            var len = marbles.length;\n            var groupStart = -1;\n            var subscriptionFrame = Number.POSITIVE_INFINITY;\n            var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n            for (var i = 0; i < len; i++) {\n                var frame = i * this.frameTimeFactor;\n                var c = marbles[i];\n                switch (c) {\n                    case '-':\n                    case ' ':\n                        break;\n                    case '(':\n                        groupStart = frame;\n                        break;\n                    case ')':\n                        groupStart = -1;\n                        break;\n                    case '^':\n                        if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                            throw new Error('found a second subscription point \\'^\\' in a ' +\n                                'subscription marble diagram. There can only be one.');\n                        }\n                        subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                        break;\n                    case '!':\n                        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                            throw new Error('found a second subscription point \\'^\\' in a ' +\n                                'subscription marble diagram. There can only be one.');\n                        }\n                        unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                        break;\n                    default:\n                        throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                            'subscription marble diagram. Found instead \\'' + c + '\\'.');\n                }\n            }\n            if (unsubscriptionFrame < 0) {\n                return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);\n            }\n            else {\n                return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n            }\n        };\n        TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {\n            if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }\n            if (marbles.indexOf('!') !== -1) {\n                throw new Error('conventional marble diagrams cannot have the ' +\n                    'unsubscription marker \"!\"');\n            }\n            var len = marbles.length;\n            var testMessages = [];\n            var subIndex = marbles.indexOf('^');\n            var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n            var getValue = typeof values !== 'object' ?\n                function (x) { return x; } :\n                function (x) {\n                    // Support Observable-of-Observables\n                    if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {\n                        return values[x].messages;\n                    }\n                    return values[x];\n                };\n            var groupStart = -1;\n            for (var i = 0; i < len; i++) {\n                var frame = i * this.frameTimeFactor + frameOffset;\n                var notification = void 0;\n                var c = marbles[i];\n                switch (c) {\n                    case '-':\n                    case ' ':\n                        break;\n                    case '(':\n                        groupStart = frame;\n                        break;\n                    case ')':\n                        groupStart = -1;\n                        break;\n                    case '|':\n                        notification = Notification_1.Notification.createComplete();\n                        break;\n                    case '^':\n                        break;\n                    case '#':\n                        notification = Notification_1.Notification.createError(errorValue || 'error');\n                        break;\n                    default:\n                        notification = Notification_1.Notification.createNext(getValue(c));\n                        break;\n                }\n                if (notification) {\n                    testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });\n                }\n            }\n            return testMessages;\n        };\n        return TestScheduler;\n    }(VirtualTimeScheduler_1.VirtualTimeScheduler));\n    exports.TestScheduler = TestScheduler;\n});\n\ndefine('rxjs/observable/dom/AjaxObservable',[\"require\", \"exports\", \"tslib\", \"../../util/root\", \"../../util/tryCatch\", \"../../util/errorObject\", \"../../Observable\", \"../../Subscriber\", \"../../operators/map\"], function (require, exports, tslib_1, root_1, tryCatch_1, errorObject_1, Observable_1, Subscriber_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function getCORSRequest() {\n        if (root_1.root.XMLHttpRequest) {\n            return new root_1.root.XMLHttpRequest();\n        }\n        else if (!!root_1.root.XDomainRequest) {\n            return new root_1.root.XDomainRequest();\n        }\n        else {\n            throw new Error('CORS is not supported by your browser');\n        }\n    }\n    function getXMLHttpRequest() {\n        if (root_1.root.XMLHttpRequest) {\n            return new root_1.root.XMLHttpRequest();\n        }\n        else {\n            var progId = void 0;\n            try {\n                var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];\n                for (var i = 0; i < 3; i++) {\n                    try {\n                        progId = progIds[i];\n                        if (new root_1.root.ActiveXObject(progId)) {\n                            break;\n                        }\n                    }\n                    catch (e) {\n                        //suppress exceptions\n                    }\n                }\n                return new root_1.root.ActiveXObject(progId);\n            }\n            catch (e) {\n                throw new Error('XMLHttpRequest is not supported by your browser');\n            }\n        }\n    }\n    function ajaxGet(url, headers) {\n        if (headers === void 0) { headers = null; }\n        return new AjaxObservable({ method: 'GET', url: url, headers: headers });\n    }\n    exports.ajaxGet = ajaxGet;\n    ;\n    function ajaxPost(url, body, headers) {\n        return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });\n    }\n    exports.ajaxPost = ajaxPost;\n    ;\n    function ajaxDelete(url, headers) {\n        return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });\n    }\n    exports.ajaxDelete = ajaxDelete;\n    ;\n    function ajaxPut(url, body, headers) {\n        return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });\n    }\n    exports.ajaxPut = ajaxPut;\n    ;\n    function ajaxPatch(url, body, headers) {\n        return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });\n    }\n    exports.ajaxPatch = ajaxPatch;\n    ;\n    var mapResponse = map_1.map(function (x, index) { return x.response; });\n    function ajaxGetJSON(url, headers) {\n        return mapResponse(new AjaxObservable({\n            method: 'GET',\n            url: url,\n            responseType: 'json',\n            headers: headers\n        }));\n    }\n    exports.ajaxGetJSON = ajaxGetJSON;\n    ;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var AjaxObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(AjaxObservable, _super);\n        function AjaxObservable(urlOrRequest) {\n            var _this = _super.call(this) || this;\n            var request = {\n                async: true,\n                createXHR: function () {\n                    return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();\n                },\n                crossDomain: false,\n                withCredentials: false,\n                headers: {},\n                method: 'GET',\n                responseType: 'json',\n                timeout: 0\n            };\n            if (typeof urlOrRequest === 'string') {\n                request.url = urlOrRequest;\n            }\n            else {\n                for (var prop in urlOrRequest) {\n                    if (urlOrRequest.hasOwnProperty(prop)) {\n                        request[prop] = urlOrRequest[prop];\n                    }\n                }\n            }\n            _this.request = request;\n            return _this;\n        }\n        AjaxObservable.prototype._subscribe = function (subscriber) {\n            return new AjaxSubscriber(subscriber, this.request);\n        };\n        /**\n         * Creates an observable for an Ajax request with either a request object with\n         * url, headers, etc or a string for a URL.\n         *\n         * @example\n         * source = Rx.Observable.ajax('/products');\n         * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });\n         *\n         * @param {string|Object} request Can be one of the following:\n         *   A string of the URL to make the Ajax call.\n         *   An object with the following properties\n         *   - url: URL of the request\n         *   - body: The body of the request\n         *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE\n         *   - async: Whether the request is async\n         *   - headers: Optional headers\n         *   - crossDomain: true if a cross domain request, else false\n         *   - createXHR: a function to override if you need to use an alternate\n         *   XMLHttpRequest implementation.\n         *   - resultSelector: a function to use to alter the output value type of\n         *   the Observable. Gets {@link AjaxResponse} as an argument.\n         * @return {Observable} An observable sequence containing the XMLHttpRequest.\n         * @static true\n         * @name ajax\n         * @owner Observable\n        */\n        AjaxObservable.create = (function () {\n            var create = function (urlOrRequest) {\n                return new AjaxObservable(urlOrRequest);\n            };\n            create.get = ajaxGet;\n            create.post = ajaxPost;\n            create.delete = ajaxDelete;\n            create.put = ajaxPut;\n            create.patch = ajaxPatch;\n            create.getJSON = ajaxGetJSON;\n            return create;\n        })();\n        return AjaxObservable;\n    }(Observable_1.Observable));\n    exports.AjaxObservable = AjaxObservable;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AjaxSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(AjaxSubscriber, _super);\n        function AjaxSubscriber(destination, request) {\n            var _this = _super.call(this, destination) || this;\n            _this.request = request;\n            _this.done = false;\n            var headers = request.headers = request.headers || {};\n            // force CORS if requested\n            if (!request.crossDomain && !headers['X-Requested-With']) {\n                headers['X-Requested-With'] = 'XMLHttpRequest';\n            }\n            // ensure content type is set\n            if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';\n            }\n            // properly serialize body\n            request.body = _this.serializeBody(request.body, request.headers['Content-Type']);\n            _this.send();\n            return _this;\n        }\n        AjaxSubscriber.prototype.next = function (e) {\n            this.done = true;\n            var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;\n            var response = new AjaxResponse(e, xhr, request);\n            destination.next(response);\n        };\n        AjaxSubscriber.prototype.send = function () {\n            var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;\n            var createXHR = request.createXHR;\n            var xhr = tryCatch_1.tryCatch(createXHR).call(request);\n            if (xhr === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                this.xhr = xhr;\n                // set up the events before open XHR\n                // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest\n                // You need to add the event listeners before calling open() on the request.\n                // Otherwise the progress events will not fire.\n                this.setupEvents(xhr, request);\n                // open XHR\n                var result = void 0;\n                if (user) {\n                    result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);\n                }\n                else {\n                    result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);\n                }\n                if (result === errorObject_1.errorObject) {\n                    this.error(errorObject_1.errorObject.e);\n                    return null;\n                }\n                // timeout, responseType and withCredentials can be set once the XHR is open\n                if (async) {\n                    xhr.timeout = request.timeout;\n                    xhr.responseType = request.responseType;\n                }\n                if ('withCredentials' in xhr) {\n                    xhr.withCredentials = !!request.withCredentials;\n                }\n                // set headers\n                this.setHeaders(xhr, headers);\n                // finally send the request\n                result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);\n                if (result === errorObject_1.errorObject) {\n                    this.error(errorObject_1.errorObject.e);\n                    return null;\n                }\n            }\n            return xhr;\n        };\n        AjaxSubscriber.prototype.serializeBody = function (body, contentType) {\n            if (!body || typeof body === 'string') {\n                return body;\n            }\n            else if (root_1.root.FormData && body instanceof root_1.root.FormData) {\n                return body;\n            }\n            if (contentType) {\n                var splitIndex = contentType.indexOf(';');\n                if (splitIndex !== -1) {\n                    contentType = contentType.substring(0, splitIndex);\n                }\n            }\n            switch (contentType) {\n                case 'application/x-www-form-urlencoded':\n                    return Object.keys(body).map(function (key) { return encodeURI(key) + \"=\" + encodeURI(body[key]); }).join('&');\n                case 'application/json':\n                    return JSON.stringify(body);\n                default:\n                    return body;\n            }\n        };\n        AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {\n            for (var key in headers) {\n                if (headers.hasOwnProperty(key)) {\n                    xhr.setRequestHeader(key, headers[key]);\n                }\n            }\n        };\n        AjaxSubscriber.prototype.setupEvents = function (xhr, request) {\n            var progressSubscriber = request.progressSubscriber;\n            function xhrTimeout(e) {\n                var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n                if (progressSubscriber) {\n                    progressSubscriber.error(e);\n                }\n                subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.\n            }\n            ;\n            xhr.ontimeout = xhrTimeout;\n            xhrTimeout.request = request;\n            xhrTimeout.subscriber = this;\n            xhrTimeout.progressSubscriber = progressSubscriber;\n            if (xhr.upload && 'withCredentials' in xhr) {\n                if (progressSubscriber) {\n                    var xhrProgress_1;\n                    xhrProgress_1 = function (e) {\n                        var progressSubscriber = xhrProgress_1.progressSubscriber;\n                        progressSubscriber.next(e);\n                    };\n                    if (root_1.root.XDomainRequest) {\n                        xhr.onprogress = xhrProgress_1;\n                    }\n                    else {\n                        xhr.upload.onprogress = xhrProgress_1;\n                    }\n                    xhrProgress_1.progressSubscriber = progressSubscriber;\n                }\n                var xhrError_1;\n                xhrError_1 = function (e) {\n                    var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;\n                    if (progressSubscriber) {\n                        progressSubscriber.error(e);\n                    }\n                    subscriber.error(new AjaxError('ajax error', this, request));\n                };\n                xhr.onerror = xhrError_1;\n                xhrError_1.request = request;\n                xhrError_1.subscriber = this;\n                xhrError_1.progressSubscriber = progressSubscriber;\n            }\n            function xhrReadyStateChange(e) {\n                var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;\n                if (this.readyState === 4) {\n                    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)\n                    var status_1 = this.status === 1223 ? 204 : this.status;\n                    var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);\n                    // fix status code when it is 0 (0 status is undocumented).\n                    // Occurs when accessing file resources or on Android 4.1 stock browser\n                    // while retrieving files from application cache.\n                    if (status_1 === 0) {\n                        status_1 = response ? 200 : 0;\n                    }\n                    if (200 <= status_1 && status_1 < 300) {\n                        if (progressSubscriber) {\n                            progressSubscriber.complete();\n                        }\n                        subscriber.next(e);\n                        subscriber.complete();\n                    }\n                    else {\n                        if (progressSubscriber) {\n                            progressSubscriber.error(e);\n                        }\n                        subscriber.error(new AjaxError('ajax error ' + status_1, this, request));\n                    }\n                }\n            }\n            ;\n            xhr.onreadystatechange = xhrReadyStateChange;\n            xhrReadyStateChange.subscriber = this;\n            xhrReadyStateChange.progressSubscriber = progressSubscriber;\n            xhrReadyStateChange.request = request;\n        };\n        AjaxSubscriber.prototype.unsubscribe = function () {\n            var _a = this, done = _a.done, xhr = _a.xhr;\n            if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {\n                xhr.abort();\n            }\n            _super.prototype.unsubscribe.call(this);\n        };\n        return AjaxSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.AjaxSubscriber = AjaxSubscriber;\n    /**\n     * A normalized AJAX response.\n     *\n     * @see {@link ajax}\n     *\n     * @class AjaxResponse\n     */\n    var AjaxResponse = /** @class */ (function () {\n        function AjaxResponse(originalEvent, xhr, request) {\n            this.originalEvent = originalEvent;\n            this.xhr = xhr;\n            this.request = request;\n            this.status = xhr.status;\n            this.responseType = xhr.responseType || request.responseType;\n            this.response = parseXhrResponse(this.responseType, xhr);\n        }\n        return AjaxResponse;\n    }());\n    exports.AjaxResponse = AjaxResponse;\n    /**\n     * A normalized AJAX error.\n     *\n     * @see {@link ajax}\n     *\n     * @class AjaxError\n     */\n    var AjaxError = /** @class */ (function (_super) {\n        tslib_1.__extends(AjaxError, _super);\n        function AjaxError(message, xhr, request) {\n            var _this = _super.call(this, message) || this;\n            _this.message = message;\n            _this.xhr = xhr;\n            _this.request = request;\n            _this.status = xhr.status;\n            _this.responseType = xhr.responseType || request.responseType;\n            _this.response = parseXhrResponse(_this.responseType, xhr);\n            return _this;\n        }\n        return AjaxError;\n    }(Error));\n    exports.AjaxError = AjaxError;\n    function parseXhrResponse(responseType, xhr) {\n        switch (responseType) {\n            case 'json':\n                if ('response' in xhr) {\n                    //IE does not support json as responseType, parse it internally\n                    return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');\n                }\n                else {\n                    return JSON.parse(xhr.responseText || 'null');\n                }\n            case 'xml':\n                return xhr.responseXML;\n            case 'text':\n            default:\n                return ('response' in xhr) ? xhr.response : xhr.responseText;\n        }\n    }\n    /**\n     * @see {@link ajax}\n     *\n     * @class AjaxTimeoutError\n     */\n    var AjaxTimeoutError = /** @class */ (function (_super) {\n        tslib_1.__extends(AjaxTimeoutError, _super);\n        function AjaxTimeoutError(xhr, request) {\n            return _super.call(this, 'ajax timeout', xhr, request) || this;\n        }\n        return AjaxTimeoutError;\n    }(AjaxError));\n    exports.AjaxTimeoutError = AjaxTimeoutError;\n});\n\n/**\nSome credit for this helper goes to http://github.com/YuzuJS/setImmediate\n*/\ndefine('rxjs/util/Immediate',[\"require\", \"exports\", \"./root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var ImmediateDefinition = /** @class */ (function () {\n        function ImmediateDefinition(root) {\n            this.root = root;\n            if (root.setImmediate && typeof root.setImmediate === 'function') {\n                this.setImmediate = root.setImmediate.bind(root);\n                this.clearImmediate = root.clearImmediate.bind(root);\n            }\n            else {\n                this.nextHandle = 1;\n                this.tasksByHandle = {};\n                this.currentlyRunningATask = false;\n                // Don't get fooled by e.g. browserify environments.\n                if (this.canUseProcessNextTick()) {\n                    // For Node.js before 0.9\n                    this.setImmediate = this.createProcessNextTickSetImmediate();\n                }\n                else if (this.canUsePostMessage()) {\n                    // For non-IE10 modern browsers\n                    this.setImmediate = this.createPostMessageSetImmediate();\n                }\n                else if (this.canUseMessageChannel()) {\n                    // For web workers, where supported\n                    this.setImmediate = this.createMessageChannelSetImmediate();\n                }\n                else if (this.canUseReadyStateChange()) {\n                    // For IE 6–8\n                    this.setImmediate = this.createReadyStateChangeSetImmediate();\n                }\n                else {\n                    // For older browsers\n                    this.setImmediate = this.createSetTimeoutSetImmediate();\n                }\n                var ci = function clearImmediate(handle) {\n                    delete clearImmediate.instance.tasksByHandle[handle];\n                };\n                ci.instance = this;\n                this.clearImmediate = ci;\n            }\n        }\n        ImmediateDefinition.prototype.identify = function (o) {\n            return this.root.Object.prototype.toString.call(o);\n        };\n        ImmediateDefinition.prototype.canUseProcessNextTick = function () {\n            return this.identify(this.root.process) === '[object process]';\n        };\n        ImmediateDefinition.prototype.canUseMessageChannel = function () {\n            return Boolean(this.root.MessageChannel);\n        };\n        ImmediateDefinition.prototype.canUseReadyStateChange = function () {\n            var document = this.root.document;\n            return Boolean(document && 'onreadystatechange' in document.createElement('script'));\n        };\n        ImmediateDefinition.prototype.canUsePostMessage = function () {\n            var root = this.root;\n            // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n            // where `root.postMessage` means something completely different and can't be used for this purpose.\n            if (root.postMessage && !root.importScripts) {\n                var postMessageIsAsynchronous_1 = true;\n                var oldOnMessage = root.onmessage;\n                root.onmessage = function () {\n                    postMessageIsAsynchronous_1 = false;\n                };\n                root.postMessage('', '*');\n                root.onmessage = oldOnMessage;\n                return postMessageIsAsynchronous_1;\n            }\n            return false;\n        };\n        // This function accepts the same arguments as setImmediate, but\n        // returns a function that requires no arguments.\n        ImmediateDefinition.prototype.partiallyApplied = function (handler) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var fn = function result() {\n                var _a = result, handler = _a.handler, args = _a.args;\n                if (typeof handler === 'function') {\n                    handler.apply(undefined, args);\n                }\n                else {\n                    (new Function('' + handler))();\n                }\n            };\n            fn.handler = handler;\n            fn.args = args;\n            return fn;\n        };\n        ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {\n            this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);\n            return this.nextHandle++;\n        };\n        ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {\n            var fn = function setImmediate() {\n                var instance = setImmediate.instance;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));\n                return handle;\n            };\n            fn.instance = this;\n            return fn;\n        };\n        ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {\n            // Installs an event handler on `global` for the `message` event: see\n            // * https://developer.mozilla.org/en/DOM/window.postMessage\n            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n            var root = this.root;\n            var messagePrefix = 'setImmediate$' + root.Math.random() + '$';\n            var onGlobalMessage = function globalMessageHandler(event) {\n                var instance = globalMessageHandler.instance;\n                if (event.source === root &&\n                    typeof event.data === 'string' &&\n                    event.data.indexOf(messagePrefix) === 0) {\n                    instance.runIfPresent(+event.data.slice(messagePrefix.length));\n                }\n            };\n            onGlobalMessage.instance = this;\n            root.addEventListener('message', onGlobalMessage, false);\n            var fn = function setImmediate() {\n                var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                instance.root.postMessage(messagePrefix + handle, '*');\n                return handle;\n            };\n            fn.instance = this;\n            fn.messagePrefix = messagePrefix;\n            return fn;\n        };\n        ImmediateDefinition.prototype.runIfPresent = function (handle) {\n            // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'\n            // So if we're currently running a task, we'll need to delay this invocation.\n            if (this.currentlyRunningATask) {\n                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n                // 'too much recursion' error.\n                this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);\n            }\n            else {\n                var task = this.tasksByHandle[handle];\n                if (task) {\n                    this.currentlyRunningATask = true;\n                    try {\n                        task();\n                    }\n                    finally {\n                        this.clearImmediate(handle);\n                        this.currentlyRunningATask = false;\n                    }\n                }\n            }\n        };\n        ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {\n            var _this = this;\n            var channel = new this.root.MessageChannel();\n            channel.port1.onmessage = function (event) {\n                var handle = event.data;\n                _this.runIfPresent(handle);\n            };\n            var fn = function setImmediate() {\n                var _a = setImmediate, channel = _a.channel, instance = _a.instance;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                channel.port2.postMessage(handle);\n                return handle;\n            };\n            fn.channel = channel;\n            fn.instance = this;\n            return fn;\n        };\n        ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {\n            var fn = function setImmediate() {\n                var instance = setImmediate.instance;\n                var root = instance.root;\n                var doc = root.document;\n                var html = doc.documentElement;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n                var script = doc.createElement('script');\n                script.onreadystatechange = function () {\n                    instance.runIfPresent(handle);\n                    script.onreadystatechange = null;\n                    html.removeChild(script);\n                    script = null;\n                };\n                html.appendChild(script);\n                return handle;\n            };\n            fn.instance = this;\n            return fn;\n        };\n        ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {\n            var fn = function setImmediate() {\n                var instance = setImmediate.instance;\n                var handle = instance.addFromSetImmediateArguments(arguments);\n                instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);\n                return handle;\n            };\n            fn.instance = this;\n            return fn;\n        };\n        return ImmediateDefinition;\n    }());\n    exports.ImmediateDefinition = ImmediateDefinition;\n    exports.Immediate = new ImmediateDefinition(root_1.root);\n});\n\ndefine('rxjs/scheduler/AsapAction',[\"require\", \"exports\", \"tslib\", \"../util/Immediate\", \"./AsyncAction\"], function (require, exports, tslib_1, Immediate_1, AsyncAction_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AsapAction = /** @class */ (function (_super) {\n        tslib_1.__extends(AsapAction, _super);\n        function AsapAction(scheduler, work) {\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            return _this;\n        }\n        AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay is greater than 0, request as an async action.\n            if (delay !== null && delay > 0) {\n                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n            }\n            // Push the action to the end of the scheduler queue.\n            scheduler.actions.push(this);\n            // If a microtask has already been scheduled, don't schedule another\n            // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n            // the current scheduled microtask id.\n            return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n        };\n        AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay exists and is greater than 0, or if the delay is null (the\n            // action wasn't rescheduled) but was originally scheduled as an async\n            // action, then recycle as an async action.\n            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n            }\n            // If the scheduler queue is empty, cancel the requested microtask and\n            // set the scheduled flag to undefined so the next AsapAction will schedule\n            // its own.\n            if (scheduler.actions.length === 0) {\n                Immediate_1.Immediate.clearImmediate(id);\n                scheduler.scheduled = undefined;\n            }\n            // Return undefined so the action knows to request a new async id if it's rescheduled.\n            return undefined;\n        };\n        return AsapAction;\n    }(AsyncAction_1.AsyncAction));\n    exports.AsapAction = AsapAction;\n});\n\ndefine('rxjs/scheduler/AsapScheduler',[\"require\", \"exports\", \"tslib\", \"./AsyncScheduler\"], function (require, exports, tslib_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var AsapScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(AsapScheduler, _super);\n        function AsapScheduler() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        AsapScheduler.prototype.flush = function (action) {\n            this.active = true;\n            this.scheduled = undefined;\n            var actions = this.actions;\n            var error;\n            var index = -1;\n            var count = actions.length;\n            action = action || actions.shift();\n            do {\n                if (error = action.execute(action.state, action.delay)) {\n                    break;\n                }\n            } while (++index < count && (action = actions.shift()));\n            this.active = false;\n            if (error) {\n                while (++index < count && (action = actions.shift())) {\n                    action.unsubscribe();\n                }\n                throw error;\n            }\n        };\n        return AsapScheduler;\n    }(AsyncScheduler_1.AsyncScheduler));\n    exports.AsapScheduler = AsapScheduler;\n});\n\ndefine('rxjs/scheduler/asap',[\"require\", \"exports\", \"./AsapAction\", \"./AsapScheduler\"], function (require, exports, AsapAction_1, AsapScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Asap Scheduler\n     *\n     * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n     *\n     * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task\n     * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n     * code to end and then it will try to execute given task as fast as possible.\n     *\n     * `asap` scheduler will do its best to minimize time between end of currently executing code\n     * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n     * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n     * some (although minimal) unwanted delay.\n     *\n     * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n     * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n     * that task will execute first. That being said, if you need to schedule task asynchronously, but\n     * as soon as possible, `asap` scheduler is your best bet.\n     *\n     * @example <caption>Compare async and asap scheduler</caption>\n     *\n     * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...\n     * Rx.Scheduler.asap.schedule(() => console.log('asap'));\n     *\n     * // Logs:\n     * // \"asap\"\n     * // \"async\"\n     * // ... but 'asap' goes first!\n     *\n     * @static true\n     * @name asap\n     * @owner Scheduler\n     */\n    exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);\n});\n\ndefine('rxjs/util/AnimationFrame',[\"require\", \"exports\", \"./root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var RequestAnimationFrameDefinition = /** @class */ (function () {\n        function RequestAnimationFrameDefinition(root) {\n            if (root.requestAnimationFrame) {\n                this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.requestAnimationFrame.bind(root);\n            }\n            else if (root.mozRequestAnimationFrame) {\n                this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);\n            }\n            else if (root.webkitRequestAnimationFrame) {\n                this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);\n            }\n            else if (root.msRequestAnimationFrame) {\n                this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);\n            }\n            else if (root.oRequestAnimationFrame) {\n                this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);\n                this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);\n            }\n            else {\n                this.cancelAnimationFrame = root.clearTimeout.bind(root);\n                this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };\n            }\n        }\n        return RequestAnimationFrameDefinition;\n    }());\n    exports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;\n    exports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);\n});\n\ndefine('rxjs/scheduler/AnimationFrameAction',[\"require\", \"exports\", \"tslib\", \"./AsyncAction\", \"../util/AnimationFrame\"], function (require, exports, tslib_1, AsyncAction_1, AnimationFrame_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AnimationFrameAction = /** @class */ (function (_super) {\n        tslib_1.__extends(AnimationFrameAction, _super);\n        function AnimationFrameAction(scheduler, work) {\n            var _this = _super.call(this, scheduler, work) || this;\n            _this.scheduler = scheduler;\n            _this.work = work;\n            return _this;\n        }\n        AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay is greater than 0, request as an async action.\n            if (delay !== null && delay > 0) {\n                return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n            }\n            // Push the action to the end of the scheduler queue.\n            scheduler.actions.push(this);\n            // If an animation frame has already been requested, don't request another\n            // one. If an animation frame hasn't been requested yet, request one. Return\n            // the current animation frame request id.\n            return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));\n        };\n        AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n            if (delay === void 0) { delay = 0; }\n            // If delay exists and is greater than 0, or if the delay is null (the\n            // action wasn't rescheduled) but was originally scheduled as an async\n            // action, then recycle as an async action.\n            if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n                return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n            }\n            // If the scheduler queue is empty, cancel the requested animation frame and\n            // set the scheduled flag to undefined so the next AnimationFrameAction will\n            // request its own.\n            if (scheduler.actions.length === 0) {\n                AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);\n                scheduler.scheduled = undefined;\n            }\n            // Return undefined so the action knows to request a new async id if it's rescheduled.\n            return undefined;\n        };\n        return AnimationFrameAction;\n    }(AsyncAction_1.AsyncAction));\n    exports.AnimationFrameAction = AnimationFrameAction;\n});\n\ndefine('rxjs/scheduler/AnimationFrameScheduler',[\"require\", \"exports\", \"tslib\", \"./AsyncScheduler\"], function (require, exports, tslib_1, AsyncScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var AnimationFrameScheduler = /** @class */ (function (_super) {\n        tslib_1.__extends(AnimationFrameScheduler, _super);\n        function AnimationFrameScheduler() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        AnimationFrameScheduler.prototype.flush = function (action) {\n            this.active = true;\n            this.scheduled = undefined;\n            var actions = this.actions;\n            var error;\n            var index = -1;\n            var count = actions.length;\n            action = action || actions.shift();\n            do {\n                if (error = action.execute(action.state, action.delay)) {\n                    break;\n                }\n            } while (++index < count && (action = actions.shift()));\n            this.active = false;\n            if (error) {\n                while (++index < count && (action = actions.shift())) {\n                    action.unsubscribe();\n                }\n                throw error;\n            }\n        };\n        return AnimationFrameScheduler;\n    }(AsyncScheduler_1.AsyncScheduler));\n    exports.AnimationFrameScheduler = AnimationFrameScheduler;\n});\n\ndefine('rxjs/scheduler/animationFrame',[\"require\", \"exports\", \"./AnimationFrameAction\", \"./AnimationFrameScheduler\"], function (require, exports, AnimationFrameAction_1, AnimationFrameScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Animation Frame Scheduler\n     *\n     * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n     *\n     * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler\n     * behaviour.\n     *\n     * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n     * It makes sure scheduled task will happen just before next browser content repaint,\n     * thus performing animations as efficiently as possible.\n     *\n     * @example <caption>Schedule div height animation</caption>\n     * const div = document.querySelector('.some-div');\n     *\n     * Rx.Scheduler.schedule(function(height) {\n     *   div.style.height = height + \"px\";\n     *\n     *   this.schedule(height + 1);  // `this` references currently executing Action,\n     *                               // which we reschedule with new state\n     * }, 0, 0);\n     *\n     * // You will see .some-div element growing in height\n     *\n     *\n     * @static true\n     * @name animationFrame\n     * @owner Scheduler\n     */\n    exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);\n});\n\ndefine('rxjs/symbol/iterator',[\"require\", \"exports\", \"../util/root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function symbolIteratorPonyfill(root) {\n        var Symbol = root.Symbol;\n        if (typeof Symbol === 'function') {\n            if (!Symbol.iterator) {\n                Symbol.iterator = Symbol('iterator polyfill');\n            }\n            return Symbol.iterator;\n        }\n        else {\n            // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)\n            var Set_1 = root.Set;\n            if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {\n                return '@@iterator';\n            }\n            var Map_1 = root.Map;\n            // required for compatability with es6-shim\n            if (Map_1) {\n                var keys = Object.getOwnPropertyNames(Map_1.prototype);\n                for (var i = 0; i < keys.length; ++i) {\n                    var key = keys[i];\n                    // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.\n                    if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {\n                        return key;\n                    }\n                }\n            }\n            return '@@iterator';\n        }\n    }\n    exports.symbolIteratorPonyfill = symbolIteratorPonyfill;\n    exports.iterator = symbolIteratorPonyfill(root_1.root);\n    /**\n     * @deprecated use iterator instead\n     */\n    exports.$$iterator = exports.iterator;\n});\n\ndefine('rxjs/OuterSubscriber',[\"require\", \"exports\", \"tslib\", \"./Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var OuterSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(OuterSubscriber, _super);\n        function OuterSubscriber() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.destination.next(innerValue);\n        };\n        OuterSubscriber.prototype.notifyError = function (error, innerSub) {\n            this.destination.error(error);\n        };\n        OuterSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.destination.complete();\n        };\n        return OuterSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.OuterSubscriber = OuterSubscriber;\n});\n\ndefine('rxjs/util/isArrayLike',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });\n});\n\ndefine('rxjs/util/isPromise',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isPromise(value) {\n        return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n    }\n    exports.isPromise = isPromise;\n});\n\ndefine('rxjs/InnerSubscriber',[\"require\", \"exports\", \"tslib\", \"./Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var InnerSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(InnerSubscriber, _super);\n        function InnerSubscriber(parent, outerValue, outerIndex) {\n            var _this = _super.call(this) || this;\n            _this.parent = parent;\n            _this.outerValue = outerValue;\n            _this.outerIndex = outerIndex;\n            _this.index = 0;\n            return _this;\n        }\n        InnerSubscriber.prototype._next = function (value) {\n            this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);\n        };\n        InnerSubscriber.prototype._error = function (error) {\n            this.parent.notifyError(error, this);\n            this.unsubscribe();\n        };\n        InnerSubscriber.prototype._complete = function () {\n            this.parent.notifyComplete(this);\n            this.unsubscribe();\n        };\n        return InnerSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.InnerSubscriber = InnerSubscriber;\n});\n\ndefine('rxjs/util/subscribeToResult',[\"require\", \"exports\", \"./root\", \"./isArrayLike\", \"./isPromise\", \"./isObject\", \"../Observable\", \"../symbol/iterator\", \"../InnerSubscriber\", \"../symbol/observable\"], function (require, exports, root_1, isArrayLike_1, isPromise_1, isObject_1, Observable_1, iterator_1, InnerSubscriber_1, observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {\n        var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);\n        if (destination.closed) {\n            return null;\n        }\n        if (result instanceof Observable_1.Observable) {\n            if (result._isScalar) {\n                destination.next(result.value);\n                destination.complete();\n                return null;\n            }\n            else {\n                destination.syncErrorThrowable = true;\n                return result.subscribe(destination);\n            }\n        }\n        else if (isArrayLike_1.isArrayLike(result)) {\n            for (var i = 0, len = result.length; i < len && !destination.closed; i++) {\n                destination.next(result[i]);\n            }\n            if (!destination.closed) {\n                destination.complete();\n            }\n        }\n        else if (isPromise_1.isPromise(result)) {\n            result.then(function (value) {\n                if (!destination.closed) {\n                    destination.next(value);\n                    destination.complete();\n                }\n            }, function (err) { return destination.error(err); })\n                .then(null, function (err) {\n                // Escaping the Promise trap: globally throw unhandled errors\n                root_1.root.setTimeout(function () { throw err; });\n            });\n            return destination;\n        }\n        else if (result && typeof result[iterator_1.iterator] === 'function') {\n            var iterator = result[iterator_1.iterator]();\n            do {\n                var item = iterator.next();\n                if (item.done) {\n                    destination.complete();\n                    break;\n                }\n                destination.next(item.value);\n                if (destination.closed) {\n                    break;\n                }\n            } while (true);\n        }\n        else if (result && typeof result[observable_1.observable] === 'function') {\n            var obs = result[observable_1.observable]();\n            if (typeof obs.subscribe !== 'function') {\n                destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));\n            }\n            else {\n                return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));\n            }\n        }\n        else {\n            var value = isObject_1.isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n            var msg = \"You provided \" + value + \" where a stream was expected.\"\n                + ' You can provide an Observable, Promise, Array, or Iterable.';\n            destination.error(new TypeError(msg));\n        }\n        return null;\n    }\n    exports.subscribeToResult = subscribeToResult;\n});\n\ndefine('rxjs/operators/audit',[\"require\", \"exports\", \"tslib\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores source values for a duration determined by another Observable, then\n     * emits the most recent value from the source Observable, then repeats this\n     * process.\n     *\n     * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n     * duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/audit.png\" width=\"100%\">\n     *\n     * `audit` is similar to `throttle`, but emits the last value from the silenced\n     * time window, instead of the first value. `audit` emits the most recent value\n     * from the source Observable on the output Observable as soon as its internal\n     * timer becomes disabled, and ignores source values while the timer is enabled.\n     * Initially, the timer is disabled. As soon as the first source value arrives,\n     * the timer is enabled by calling the `durationSelector` function with the\n     * source value, which returns the \"duration\" Observable. When the duration\n     * Observable emits a value or completes, the timer is disabled, then the most\n     * recent source value is emitted on the output Observable, and this process\n     * repeats for the next source value.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounce}\n     * @see {@link delayWhen}\n     * @see {@link sample}\n     * @see {@link throttle}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the silencing\n     * duration, returned as an Observable or a Promise.\n     * @return {Observable<T>} An Observable that performs rate-limiting of\n     * emissions from the source Observable.\n     * @method audit\n     * @owner Observable\n     */\n    function audit(durationSelector) {\n        return function auditOperatorFunction(source) {\n            return source.lift(new AuditOperator(durationSelector));\n        };\n    }\n    exports.audit = audit;\n    var AuditOperator = /** @class */ (function () {\n        function AuditOperator(durationSelector) {\n            this.durationSelector = durationSelector;\n        }\n        AuditOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));\n        };\n        return AuditOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var AuditSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(AuditSubscriber, _super);\n        function AuditSubscriber(destination, durationSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.durationSelector = durationSelector;\n            _this.hasValue = false;\n            return _this;\n        }\n        AuditSubscriber.prototype._next = function (value) {\n            this.value = value;\n            this.hasValue = true;\n            if (!this.throttled) {\n                var duration = tryCatch_1.tryCatch(this.durationSelector)(value);\n                if (duration === errorObject_1.errorObject) {\n                    this.destination.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    var innerSubscription = subscribeToResult_1.subscribeToResult(this, duration);\n                    if (innerSubscription.closed) {\n                        this.clearThrottle();\n                    }\n                    else {\n                        this.add(this.throttled = innerSubscription);\n                    }\n                }\n            }\n        };\n        AuditSubscriber.prototype.clearThrottle = function () {\n            var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;\n            if (throttled) {\n                this.remove(throttled);\n                this.throttled = null;\n                throttled.unsubscribe();\n            }\n            if (hasValue) {\n                this.value = null;\n                this.hasValue = false;\n                this.destination.next(value);\n            }\n        };\n        AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n            this.clearThrottle();\n        };\n        AuditSubscriber.prototype.notifyComplete = function () {\n            this.clearThrottle();\n        };\n        return AuditSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/util/isNumeric',[\"require\", \"exports\", \"../util/isArray\"], function (require, exports, isArray_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isNumeric(val) {\n        // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n        // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n        // subtraction forces infinities to NaN\n        // adding 1 corrects loss of precision from parseFloat (#15100)\n        return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;\n    }\n    exports.isNumeric = isNumeric;\n    ;\n});\n\ndefine('rxjs/util/isScheduler',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isScheduler(value) {\n        return value && typeof value.schedule === 'function';\n    }\n    exports.isScheduler = isScheduler;\n});\n\ndefine('rxjs/util/isDate',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isDate(value) {\n        return value instanceof Date && !isNaN(+value);\n    }\n    exports.isDate = isDate;\n});\n\ndefine('rxjs/observable/TimerObservable',[\"require\", \"exports\", \"tslib\", \"../util/isNumeric\", \"../Observable\", \"../scheduler/async\", \"../util/isScheduler\", \"../util/isDate\"], function (require, exports, tslib_1, isNumeric_1, Observable_1, async_1, isScheduler_1, isDate_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var TimerObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(TimerObservable, _super);\n        function TimerObservable(dueTime, period, scheduler) {\n            if (dueTime === void 0) { dueTime = 0; }\n            var _this = _super.call(this) || this;\n            _this.period = -1;\n            _this.dueTime = 0;\n            if (isNumeric_1.isNumeric(period)) {\n                _this.period = Number(period) < 1 && 1 || Number(period);\n            }\n            else if (isScheduler_1.isScheduler(period)) {\n                scheduler = period;\n            }\n            if (!isScheduler_1.isScheduler(scheduler)) {\n                scheduler = async_1.async;\n            }\n            _this.scheduler = scheduler;\n            _this.dueTime = isDate_1.isDate(dueTime) ?\n                (+dueTime - _this.scheduler.now()) :\n                dueTime;\n            return _this;\n        }\n        /**\n         * Creates an Observable that starts emitting after an `initialDelay` and\n         * emits ever increasing numbers after each `period` of time thereafter.\n         *\n         * <span class=\"informal\">Its like {@link interval}, but you can specify when\n         * should the emissions start.</span>\n         *\n         * <img src=\"./img/timer.png\" width=\"100%\">\n         *\n         * `timer` returns an Observable that emits an infinite sequence of ascending\n         * integers, with a constant interval of time, `period` of your choosing\n         * between those emissions. The first emission happens after the specified\n         * `initialDelay`. The initial delay may be a {@link Date}. By default, this\n         * operator uses the `async` IScheduler to provide a notion of time, but you\n         * may pass any IScheduler to it. If `period` is not specified, the output\n         * Observable emits only one value, `0`. Otherwise, it emits an infinite\n         * sequence.\n         *\n         * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>\n         * var numbers = Rx.Observable.timer(3000, 1000);\n         * numbers.subscribe(x => console.log(x));\n         *\n         * @example <caption>Emits one number after five seconds</caption>\n         * var numbers = Rx.Observable.timer(5000);\n         * numbers.subscribe(x => console.log(x));\n         *\n         * @see {@link interval}\n         * @see {@link delay}\n         *\n         * @param {number|Date} initialDelay The initial delay time to wait before\n         * emitting the first value of `0`.\n         * @param {number} [period] The period of time between emissions of the\n         * subsequent numbers.\n         * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n         * the emission of values, and providing a notion of \"time\".\n         * @return {Observable} An Observable that emits a `0` after the\n         * `initialDelay` and ever increasing numbers after each `period` of time\n         * thereafter.\n         * @static true\n         * @name timer\n         * @owner Observable\n         */\n        TimerObservable.create = function (initialDelay, period, scheduler) {\n            if (initialDelay === void 0) { initialDelay = 0; }\n            return new TimerObservable(initialDelay, period, scheduler);\n        };\n        TimerObservable.dispatch = function (state) {\n            var index = state.index, period = state.period, subscriber = state.subscriber;\n            var action = this;\n            subscriber.next(index);\n            if (subscriber.closed) {\n                return;\n            }\n            else if (period === -1) {\n                return subscriber.complete();\n            }\n            state.index = index + 1;\n            action.schedule(state, period);\n        };\n        TimerObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;\n            return scheduler.schedule(TimerObservable.dispatch, dueTime, {\n                index: index, period: period, subscriber: subscriber\n            });\n        };\n        return TimerObservable;\n    }(Observable_1.Observable));\n    exports.TimerObservable = TimerObservable;\n});\n\ndefine('rxjs/observable/timer',[\"require\", \"exports\", \"./TimerObservable\"], function (require, exports, TimerObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.timer = TimerObservable_1.TimerObservable.create;\n});\n\ndefine('rxjs/operators/auditTime',[\"require\", \"exports\", \"../scheduler/async\", \"./audit\", \"../observable/timer\"], function (require, exports, async_1, audit_1, timer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores source values for `duration` milliseconds, then emits the most recent\n     * value from the source Observable, then repeats this process.\n     *\n     * <span class=\"informal\">When it sees a source values, it ignores that plus\n     * the next ones for `duration` milliseconds, and then it emits the most recent\n     * value from the source.</span>\n     *\n     * <img src=\"./img/auditTime.png\" width=\"100%\">\n     *\n     * `auditTime` is similar to `throttleTime`, but emits the last value from the\n     * silenced time window, instead of the first value. `auditTime` emits the most\n     * recent value from the source Observable on the output Observable as soon as\n     * its internal timer becomes disabled, and ignores source values while the\n     * timer is enabled. Initially, the timer is disabled. As soon as the first\n     * source value arrives, the timer is enabled. After `duration` milliseconds (or\n     * the time unit determined internally by the optional `scheduler`) has passed,\n     * the timer is disabled, then the most recent source value is emitted on the\n     * output Observable, and this process repeats for the next source value.\n     * Optionally takes a {@link IScheduler} for managing timers.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.auditTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttleTime}\n     *\n     * @param {number} duration Time to wait before emitting the most recent source\n     * value, measured in milliseconds or the time unit determined internally\n     * by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the rate-limiting behavior.\n     * @return {Observable<T>} An Observable that performs rate-limiting of\n     * emissions from the source Observable.\n     * @method auditTime\n     * @owner Observable\n     */\n    function auditTime(duration, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return audit_1.audit(function () { return timer_1.timer(duration, scheduler); });\n    }\n    exports.auditTime = auditTime;\n});\n\ndefine('rxjs/operators/buffer',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values until `closingNotifier` emits.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * that array only when another Observable emits.</span>\n     *\n     * <img src=\"./img/buffer.png\" width=\"100%\">\n     *\n     * Buffers the incoming Observable values until the given `closingNotifier`\n     * Observable emits a value, at which point it emits the buffer on the output\n     * Observable and starts a new buffer internally, awaiting the next time\n     * `closingNotifier` emits.\n     *\n     * @example <caption>On every click, emit array of most recent interval events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var interval = Rx.Observable.interval(1000);\n     * var buffered = interval.buffer(clicks);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link window}\n     *\n     * @param {Observable<any>} closingNotifier An Observable that signals the\n     * buffer to be emitted on the output Observable.\n     * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n     * values.\n     * @method buffer\n     * @owner Observable\n     */\n    function buffer(closingNotifier) {\n        return function bufferOperatorFunction(source) {\n            return source.lift(new BufferOperator(closingNotifier));\n        };\n    }\n    exports.buffer = buffer;\n    var BufferOperator = /** @class */ (function () {\n        function BufferOperator(closingNotifier) {\n            this.closingNotifier = closingNotifier;\n        }\n        BufferOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));\n        };\n        return BufferOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferSubscriber, _super);\n        function BufferSubscriber(destination, closingNotifier) {\n            var _this = _super.call(this, destination) || this;\n            _this.buffer = [];\n            _this.add(subscribeToResult_1.subscribeToResult(_this, closingNotifier));\n            return _this;\n        }\n        BufferSubscriber.prototype._next = function (value) {\n            this.buffer.push(value);\n        };\n        BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var buffer = this.buffer;\n            this.buffer = [];\n            this.destination.next(buffer);\n        };\n        return BufferSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/bufferCount',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values until the size hits the maximum\n     * `bufferSize` given.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * that array only when its size reaches `bufferSize`.</span>\n     *\n     * <img src=\"./img/bufferCount.png\" width=\"100%\">\n     *\n     * Buffers a number of values from the source Observable by `bufferSize` then\n     * emits the buffer and clears it, and starts a new buffer each\n     * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n     * `null`, then new buffers are started immediately at the start of the source\n     * and when each buffer closes and is emitted.\n     *\n     * @example <caption>Emit the last two click events as an array</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferCount(2);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @example <caption>On every click, emit the last two click events as an array</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferCount(2, 1);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link pairwise}\n     * @see {@link windowCount}\n     *\n     * @param {number} bufferSize The maximum size of the buffer emitted.\n     * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n     * For example if `startBufferEvery` is `2`, then a new buffer will be started\n     * on every other value from the source. A new buffer is started at the\n     * beginning of the source by default.\n     * @return {Observable<T[]>} An Observable of arrays of buffered values.\n     * @method bufferCount\n     * @owner Observable\n     */\n    function bufferCount(bufferSize, startBufferEvery) {\n        if (startBufferEvery === void 0) { startBufferEvery = null; }\n        return function bufferCountOperatorFunction(source) {\n            return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));\n        };\n    }\n    exports.bufferCount = bufferCount;\n    var BufferCountOperator = /** @class */ (function () {\n        function BufferCountOperator(bufferSize, startBufferEvery) {\n            this.bufferSize = bufferSize;\n            this.startBufferEvery = startBufferEvery;\n            if (!startBufferEvery || bufferSize === startBufferEvery) {\n                this.subscriberClass = BufferCountSubscriber;\n            }\n            else {\n                this.subscriberClass = BufferSkipCountSubscriber;\n            }\n        }\n        BufferCountOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));\n        };\n        return BufferCountOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferCountSubscriber, _super);\n        function BufferCountSubscriber(destination, bufferSize) {\n            var _this = _super.call(this, destination) || this;\n            _this.bufferSize = bufferSize;\n            _this.buffer = [];\n            return _this;\n        }\n        BufferCountSubscriber.prototype._next = function (value) {\n            var buffer = this.buffer;\n            buffer.push(value);\n            if (buffer.length == this.bufferSize) {\n                this.destination.next(buffer);\n                this.buffer = [];\n            }\n        };\n        BufferCountSubscriber.prototype._complete = function () {\n            var buffer = this.buffer;\n            if (buffer.length > 0) {\n                this.destination.next(buffer);\n            }\n            _super.prototype._complete.call(this);\n        };\n        return BufferCountSubscriber;\n    }(Subscriber_1.Subscriber));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferSkipCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferSkipCountSubscriber, _super);\n        function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {\n            var _this = _super.call(this, destination) || this;\n            _this.bufferSize = bufferSize;\n            _this.startBufferEvery = startBufferEvery;\n            _this.buffers = [];\n            _this.count = 0;\n            return _this;\n        }\n        BufferSkipCountSubscriber.prototype._next = function (value) {\n            var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;\n            this.count++;\n            if (count % startBufferEvery === 0) {\n                buffers.push([]);\n            }\n            for (var i = buffers.length; i--;) {\n                var buffer = buffers[i];\n                buffer.push(value);\n                if (buffer.length === bufferSize) {\n                    buffers.splice(i, 1);\n                    this.destination.next(buffer);\n                }\n            }\n        };\n        BufferSkipCountSubscriber.prototype._complete = function () {\n            var _a = this, buffers = _a.buffers, destination = _a.destination;\n            while (buffers.length > 0) {\n                var buffer = buffers.shift();\n                if (buffer.length > 0) {\n                    destination.next(buffer);\n                }\n            }\n            _super.prototype._complete.call(this);\n        };\n        return BufferSkipCountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/bufferTime',[\"require\", \"exports\", \"tslib\", \"../scheduler/async\", \"../Subscriber\", \"../util/isScheduler\"], function (require, exports, tslib_1, async_1, Subscriber_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Buffers the source Observable values for a specific time period.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * those arrays periodically in time.</span>\n     *\n     * <img src=\"./img/bufferTime.png\" width=\"100%\">\n     *\n     * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n     * Unless the optional argument `bufferCreationInterval` is given, it emits and\n     * resets the buffer every `bufferTimeSpan` milliseconds. If\n     * `bufferCreationInterval` is given, this operator opens the buffer every\n     * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n     * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n     * `maxBufferSize` is specified, the buffer will be closed either after\n     * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n     *\n     * @example <caption>Every second, emit an array of the recent click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferTime(1000);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferTime(2000, 5000);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link windowTime}\n     *\n     * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n     * @param {number} [bufferCreationInterval] The interval at which to start new\n     * buffers.\n     * @param {number} [maxBufferSize] The maximum buffer size.\n     * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n     * intervals that determine buffer boundaries.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferTime\n     * @owner Observable\n     */\n    function bufferTime(bufferTimeSpan) {\n        var length = arguments.length;\n        var scheduler = async_1.async;\n        if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n            scheduler = arguments[arguments.length - 1];\n            length--;\n        }\n        var bufferCreationInterval = null;\n        if (length >= 2) {\n            bufferCreationInterval = arguments[1];\n        }\n        var maxBufferSize = Number.POSITIVE_INFINITY;\n        if (length >= 3) {\n            maxBufferSize = arguments[2];\n        }\n        return function bufferTimeOperatorFunction(source) {\n            return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n        };\n    }\n    exports.bufferTime = bufferTime;\n    var BufferTimeOperator = /** @class */ (function () {\n        function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n            this.bufferTimeSpan = bufferTimeSpan;\n            this.bufferCreationInterval = bufferCreationInterval;\n            this.maxBufferSize = maxBufferSize;\n            this.scheduler = scheduler;\n        }\n        BufferTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n        };\n        return BufferTimeOperator;\n    }());\n    var Context = /** @class */ (function () {\n        function Context() {\n            this.buffer = [];\n        }\n        return Context;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferTimeSubscriber, _super);\n        function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.bufferTimeSpan = bufferTimeSpan;\n            _this.bufferCreationInterval = bufferCreationInterval;\n            _this.maxBufferSize = maxBufferSize;\n            _this.scheduler = scheduler;\n            _this.contexts = [];\n            var context = _this.openContext();\n            _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n            if (_this.timespanOnly) {\n                var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };\n                _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n            }\n            else {\n                var closeState = { subscriber: _this, context: context };\n                var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };\n                _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n                _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n            }\n            return _this;\n        }\n        BufferTimeSubscriber.prototype._next = function (value) {\n            var contexts = this.contexts;\n            var len = contexts.length;\n            var filledBufferContext;\n            for (var i = 0; i < len; i++) {\n                var context = contexts[i];\n                var buffer = context.buffer;\n                buffer.push(value);\n                if (buffer.length == this.maxBufferSize) {\n                    filledBufferContext = context;\n                }\n            }\n            if (filledBufferContext) {\n                this.onBufferFull(filledBufferContext);\n            }\n        };\n        BufferTimeSubscriber.prototype._error = function (err) {\n            this.contexts.length = 0;\n            _super.prototype._error.call(this, err);\n        };\n        BufferTimeSubscriber.prototype._complete = function () {\n            var _a = this, contexts = _a.contexts, destination = _a.destination;\n            while (contexts.length > 0) {\n                var context = contexts.shift();\n                destination.next(context.buffer);\n            }\n            _super.prototype._complete.call(this);\n        };\n        BufferTimeSubscriber.prototype._unsubscribe = function () {\n            this.contexts = null;\n        };\n        BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n            this.closeContext(context);\n            var closeAction = context.closeAction;\n            closeAction.unsubscribe();\n            this.remove(closeAction);\n            if (!this.closed && this.timespanOnly) {\n                context = this.openContext();\n                var bufferTimeSpan = this.bufferTimeSpan;\n                var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n                this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n            }\n        };\n        BufferTimeSubscriber.prototype.openContext = function () {\n            var context = new Context();\n            this.contexts.push(context);\n            return context;\n        };\n        BufferTimeSubscriber.prototype.closeContext = function (context) {\n            this.destination.next(context.buffer);\n            var contexts = this.contexts;\n            var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n            if (spliceIndex >= 0) {\n                contexts.splice(contexts.indexOf(context), 1);\n            }\n        };\n        return BufferTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchBufferTimeSpanOnly(state) {\n        var subscriber = state.subscriber;\n        var prevContext = state.context;\n        if (prevContext) {\n            subscriber.closeContext(prevContext);\n        }\n        if (!subscriber.closed) {\n            state.context = subscriber.openContext();\n            state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n        }\n    }\n    function dispatchBufferCreation(state) {\n        var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n        var context = subscriber.openContext();\n        var action = this;\n        if (!subscriber.closed) {\n            subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n            action.schedule(state, bufferCreationInterval);\n        }\n    }\n    function dispatchBufferClose(arg) {\n        var subscriber = arg.subscriber, context = arg.context;\n        subscriber.closeContext(context);\n    }\n});\n\ndefine('rxjs/operators/bufferToggle',[\"require\", \"exports\", \"tslib\", \"../Subscription\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Subscription_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values starting from an emission from\n     * `openings` and ending when the output of `closingSelector` emits.\n     *\n     * <span class=\"informal\">Collects values from the past as an array. Starts\n     * collecting only when `opening` emits, and calls the `closingSelector`\n     * function to get an Observable that tells when to close the buffer.</span>\n     *\n     * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n     *\n     * Buffers values from the source by opening the buffer via signals from an\n     * Observable provided to `openings`, and closing and sending the buffers when\n     * a Subscribable or Promise returned by the `closingSelector` function emits.\n     *\n     * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var openings = Rx.Observable.interval(1000);\n     * var buffered = clicks.bufferToggle(openings, i =>\n     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n     * );\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferWhen}\n     * @see {@link windowToggle}\n     *\n     * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n     * buffers.\n     * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n     * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n     * which, when it emits, signals that the associated buffer should be emitted\n     * and cleared.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferToggle\n     * @owner Observable\n     */\n    function bufferToggle(openings, closingSelector) {\n        return function bufferToggleOperatorFunction(source) {\n            return source.lift(new BufferToggleOperator(openings, closingSelector));\n        };\n    }\n    exports.bufferToggle = bufferToggle;\n    var BufferToggleOperator = /** @class */ (function () {\n        function BufferToggleOperator(openings, closingSelector) {\n            this.openings = openings;\n            this.closingSelector = closingSelector;\n        }\n        BufferToggleOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n        };\n        return BufferToggleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferToggleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferToggleSubscriber, _super);\n        function BufferToggleSubscriber(destination, openings, closingSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.openings = openings;\n            _this.closingSelector = closingSelector;\n            _this.contexts = [];\n            _this.add(subscribeToResult_1.subscribeToResult(_this, openings));\n            return _this;\n        }\n        BufferToggleSubscriber.prototype._next = function (value) {\n            var contexts = this.contexts;\n            var len = contexts.length;\n            for (var i = 0; i < len; i++) {\n                contexts[i].buffer.push(value);\n            }\n        };\n        BufferToggleSubscriber.prototype._error = function (err) {\n            var contexts = this.contexts;\n            while (contexts.length > 0) {\n                var context = contexts.shift();\n                context.subscription.unsubscribe();\n                context.buffer = null;\n                context.subscription = null;\n            }\n            this.contexts = null;\n            _super.prototype._error.call(this, err);\n        };\n        BufferToggleSubscriber.prototype._complete = function () {\n            var contexts = this.contexts;\n            while (contexts.length > 0) {\n                var context = contexts.shift();\n                this.destination.next(context.buffer);\n                context.subscription.unsubscribe();\n                context.buffer = null;\n                context.subscription = null;\n            }\n            this.contexts = null;\n            _super.prototype._complete.call(this);\n        };\n        BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n        };\n        BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.closeBuffer(innerSub.context);\n        };\n        BufferToggleSubscriber.prototype.openBuffer = function (value) {\n            try {\n                var closingSelector = this.closingSelector;\n                var closingNotifier = closingSelector.call(this, value);\n                if (closingNotifier) {\n                    this.trySubscribe(closingNotifier);\n                }\n            }\n            catch (err) {\n                this._error(err);\n            }\n        };\n        BufferToggleSubscriber.prototype.closeBuffer = function (context) {\n            var contexts = this.contexts;\n            if (contexts && context) {\n                var buffer = context.buffer, subscription = context.subscription;\n                this.destination.next(buffer);\n                contexts.splice(contexts.indexOf(context), 1);\n                this.remove(subscription);\n                subscription.unsubscribe();\n            }\n        };\n        BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {\n            var contexts = this.contexts;\n            var buffer = [];\n            var subscription = new Subscription_1.Subscription();\n            var context = { buffer: buffer, subscription: subscription };\n            contexts.push(context);\n            var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n            if (!innerSubscription || innerSubscription.closed) {\n                this.closeBuffer(context);\n            }\n            else {\n                innerSubscription.context = context;\n                this.add(innerSubscription);\n                subscription.add(innerSubscription);\n            }\n        };\n        return BufferToggleSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/bufferWhen',[\"require\", \"exports\", \"tslib\", \"../Subscription\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subscription_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values, using a factory function of closing\n     * Observables to determine when to close, emit, and reset the buffer.\n     *\n     * <span class=\"informal\">Collects values from the past as an array. When it\n     * starts collecting values, it calls a function that returns an Observable that\n     * tells when to close the buffer and restart collecting.</span>\n     *\n     * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n     *\n     * Opens a buffer immediately, then closes the buffer when the observable\n     * returned by calling `closingSelector` function emits a value. When it closes\n     * the buffer, it immediately opens a new buffer and repeats the process.\n     *\n     * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferWhen(() =>\n     *   Rx.Observable.interval(1000 + Math.random() * 4000)\n     * );\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link windowWhen}\n     *\n     * @param {function(): Observable} closingSelector A function that takes no\n     * arguments and returns an Observable that signals buffer closure.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferWhen\n     * @owner Observable\n     */\n    function bufferWhen(closingSelector) {\n        return function (source) {\n            return source.lift(new BufferWhenOperator(closingSelector));\n        };\n    }\n    exports.bufferWhen = bufferWhen;\n    var BufferWhenOperator = /** @class */ (function () {\n        function BufferWhenOperator(closingSelector) {\n            this.closingSelector = closingSelector;\n        }\n        BufferWhenOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));\n        };\n        return BufferWhenOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var BufferWhenSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(BufferWhenSubscriber, _super);\n        function BufferWhenSubscriber(destination, closingSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.closingSelector = closingSelector;\n            _this.subscribing = false;\n            _this.openBuffer();\n            return _this;\n        }\n        BufferWhenSubscriber.prototype._next = function (value) {\n            this.buffer.push(value);\n        };\n        BufferWhenSubscriber.prototype._complete = function () {\n            var buffer = this.buffer;\n            if (buffer) {\n                this.destination.next(buffer);\n            }\n            _super.prototype._complete.call(this);\n        };\n        BufferWhenSubscriber.prototype._unsubscribe = function () {\n            this.buffer = null;\n            this.subscribing = false;\n        };\n        BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.openBuffer();\n        };\n        BufferWhenSubscriber.prototype.notifyComplete = function () {\n            if (this.subscribing) {\n                this.complete();\n            }\n            else {\n                this.openBuffer();\n            }\n        };\n        BufferWhenSubscriber.prototype.openBuffer = function () {\n            var closingSubscription = this.closingSubscription;\n            if (closingSubscription) {\n                this.remove(closingSubscription);\n                closingSubscription.unsubscribe();\n            }\n            var buffer = this.buffer;\n            if (this.buffer) {\n                this.destination.next(buffer);\n            }\n            this.buffer = [];\n            var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n            if (closingNotifier === errorObject_1.errorObject) {\n                this.error(errorObject_1.errorObject.e);\n            }\n            else {\n                closingSubscription = new Subscription_1.Subscription();\n                this.closingSubscription = closingSubscription;\n                this.add(closingSubscription);\n                this.subscribing = true;\n                closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));\n                this.subscribing = false;\n            }\n        };\n        return BufferWhenSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/catchError',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n     *\n     * <img src=\"./img/catch.png\" width=\"100%\">\n     *\n     * @example <caption>Continues with a different Observable when there's an error</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     * \t   if (n == 4) {\n     * \t     throw 'four!';\n     *     }\n     *\t   return n;\n     *   })\n     *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n     *   .subscribe(x => console.log(x));\n     *   // 1, 2, 3, I, II, III, IV, V\n     *\n     * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     * \t   if (n === 4) {\n     * \t     throw 'four!';\n     *     }\n     * \t   return n;\n     *   })\n     *   .catch((err, caught) => caught)\n     *   .take(30)\n     *   .subscribe(x => console.log(x));\n     *   // 1, 2, 3, 1, 2, 3, ...\n     *\n     * @example <caption>Throws a new error when the source Observable throws an error</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     *     if (n == 4) {\n     *       throw 'four!';\n     *     }\n     *     return n;\n     *   })\n     *   .catch(err => {\n     *     throw 'error in source. Details: ' + err;\n     *   })\n     *   .subscribe(\n     *     x => console.log(x),\n     *     err => console.log(err)\n     *   );\n     *   // 1, 2, 3, error in source. Details: four!\n     *\n     * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n     *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n     *  is returned by the `selector` will be used to continue the observable chain.\n     * @return {Observable} An observable that originates from either the source or the observable returned by the\n     *  catch `selector` function.\n     * @name catchError\n     */\n    function catchError(selector) {\n        return function catchErrorOperatorFunction(source) {\n            var operator = new CatchOperator(selector);\n            var caught = source.lift(operator);\n            return (operator.caught = caught);\n        };\n    }\n    exports.catchError = catchError;\n    var CatchOperator = /** @class */ (function () {\n        function CatchOperator(selector) {\n            this.selector = selector;\n        }\n        CatchOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));\n        };\n        return CatchOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var CatchSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(CatchSubscriber, _super);\n        function CatchSubscriber(destination, selector, caught) {\n            var _this = _super.call(this, destination) || this;\n            _this.selector = selector;\n            _this.caught = caught;\n            return _this;\n        }\n        // NOTE: overriding `error` instead of `_error` because we don't want\n        // to have this flag this subscriber as `isStopped`. We can mimic the\n        // behavior of the RetrySubscriber (from the `retry` operator), where\n        // we unsubscribe from our source chain, reset our Subscriber flags,\n        // then subscribe to the selector result.\n        CatchSubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var result = void 0;\n                try {\n                    result = this.selector(err, this.caught);\n                }\n                catch (err2) {\n                    _super.prototype.error.call(this, err2);\n                    return;\n                }\n                this._unsubscribeAndRecycle();\n                this.add(subscribeToResult_1.subscribeToResult(this, result));\n            }\n        };\n        return CatchSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/ScalarObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ScalarObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ScalarObservable, _super);\n        function ScalarObservable(value, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.value = value;\n            _this.scheduler = scheduler;\n            _this._isScalar = true;\n            if (scheduler) {\n                _this._isScalar = false;\n            }\n            return _this;\n        }\n        ScalarObservable.create = function (value, scheduler) {\n            return new ScalarObservable(value, scheduler);\n        };\n        ScalarObservable.dispatch = function (state) {\n            var done = state.done, value = state.value, subscriber = state.subscriber;\n            if (done) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                return;\n            }\n            state.done = true;\n            this.schedule(state);\n        };\n        ScalarObservable.prototype._subscribe = function (subscriber) {\n            var value = this.value;\n            var scheduler = this.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(ScalarObservable.dispatch, 0, {\n                    done: false, value: value, subscriber: subscriber\n                });\n            }\n            else {\n                subscriber.next(value);\n                if (!subscriber.closed) {\n                    subscriber.complete();\n                }\n            }\n        };\n        return ScalarObservable;\n    }(Observable_1.Observable));\n    exports.ScalarObservable = ScalarObservable;\n});\n\ndefine('rxjs/observable/EmptyObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var EmptyObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(EmptyObservable, _super);\n        function EmptyObservable(scheduler) {\n            var _this = _super.call(this) || this;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Creates an Observable that emits no items to the Observer and immediately\n         * emits a complete notification.\n         *\n         * <span class=\"informal\">Just emits 'complete', and nothing else.\n         * </span>\n         *\n         * <img src=\"./img/empty.png\" width=\"100%\">\n         *\n         * This static operator is useful for creating a simple Observable that only\n         * emits the complete notification. It can be used for composing with other\n         * Observables, such as in a {@link mergeMap}.\n         *\n         * @example <caption>Emit the number 7, then complete.</caption>\n         * var result = Rx.Observable.empty().startWith(7);\n         * result.subscribe(x => console.log(x));\n         *\n         * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n         * var interval = Rx.Observable.interval(1000);\n         * var result = interval.mergeMap(x =>\n         *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n         * );\n         * result.subscribe(x => console.log(x));\n         *\n         * // Results in the following to the console:\n         * // x is equal to the count on the interval eg(0,1,2,3,...)\n         * // x will occur every 1000ms\n         * // if x % 2 is equal to 1 print abc\n         * // if x % 2 is not equal to 1 nothing will be output\n         *\n         * @see {@link create}\n         * @see {@link never}\n         * @see {@link of}\n         * @see {@link throw}\n         *\n         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n         * the emission of the complete notification.\n         * @return {Observable} An \"empty\" Observable: emits only the complete\n         * notification.\n         * @static true\n         * @name empty\n         * @owner Observable\n         */\n        EmptyObservable.create = function (scheduler) {\n            return new EmptyObservable(scheduler);\n        };\n        EmptyObservable.dispatch = function (arg) {\n            var subscriber = arg.subscriber;\n            subscriber.complete();\n        };\n        EmptyObservable.prototype._subscribe = function (subscriber) {\n            var scheduler = this.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });\n            }\n            else {\n                subscriber.complete();\n            }\n        };\n        return EmptyObservable;\n    }(Observable_1.Observable));\n    exports.EmptyObservable = EmptyObservable;\n});\n\ndefine('rxjs/observable/ArrayObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"./ScalarObservable\", \"./EmptyObservable\", \"../util/isScheduler\"], function (require, exports, tslib_1, Observable_1, ScalarObservable_1, EmptyObservable_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ArrayObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ArrayObservable, _super);\n        function ArrayObservable(array, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.array = array;\n            _this.scheduler = scheduler;\n            if (!scheduler && array.length === 1) {\n                _this._isScalar = true;\n                _this.value = array[0];\n            }\n            return _this;\n        }\n        ArrayObservable.create = function (array, scheduler) {\n            return new ArrayObservable(array, scheduler);\n        };\n        /**\n         * Creates an Observable that emits some values you specify as arguments,\n         * immediately one after the other, and then emits a complete notification.\n         *\n         * <span class=\"informal\">Emits the arguments you provide, then completes.\n         * </span>\n         *\n         * <img src=\"./img/of.png\" width=\"100%\">\n         *\n         * This static operator is useful for creating a simple Observable that only\n         * emits the arguments given, and the complete notification thereafter. It can\n         * be used for composing with other Observables, such as with {@link concat}.\n         * By default, it uses a `null` IScheduler, which means the `next`\n         * notifications are sent synchronously, although with a different IScheduler\n         * it is possible to determine when those notifications will be delivered.\n         *\n         * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n         * var numbers = Rx.Observable.of(10, 20, 30);\n         * var letters = Rx.Observable.of('a', 'b', 'c');\n         * var interval = Rx.Observable.interval(1000);\n         * var result = numbers.concat(letters).concat(interval);\n         * result.subscribe(x => console.log(x));\n         *\n         * @see {@link create}\n         * @see {@link empty}\n         * @see {@link never}\n         * @see {@link throw}\n         *\n         * @param {...T} values Arguments that represent `next` values to be emitted.\n         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n         * the emissions of the `next` notifications.\n         * @return {Observable<T>} An Observable that emits each given input value.\n         * @static true\n         * @name of\n         * @owner Observable\n         */\n        ArrayObservable.of = function () {\n            var array = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                array[_i] = arguments[_i];\n            }\n            var scheduler = array[array.length - 1];\n            if (isScheduler_1.isScheduler(scheduler)) {\n                array.pop();\n            }\n            else {\n                scheduler = null;\n            }\n            var len = array.length;\n            if (len > 1) {\n                return new ArrayObservable(array, scheduler);\n            }\n            else if (len === 1) {\n                return new ScalarObservable_1.ScalarObservable(array[0], scheduler);\n            }\n            else {\n                return new EmptyObservable_1.EmptyObservable(scheduler);\n            }\n        };\n        ArrayObservable.dispatch = function (state) {\n            var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;\n            if (index >= count) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(array[index]);\n            if (subscriber.closed) {\n                return;\n            }\n            state.index = index + 1;\n            this.schedule(state);\n        };\n        ArrayObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var array = this.array;\n            var count = array.length;\n            var scheduler = this.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(ArrayObservable.dispatch, 0, {\n                    array: array, index: index, count: count, subscriber: subscriber\n                });\n            }\n            else {\n                for (var i = 0; i < count && !subscriber.closed; i++) {\n                    subscriber.next(array[i]);\n                }\n                subscriber.complete();\n            }\n        };\n        return ArrayObservable;\n    }(Observable_1.Observable));\n    exports.ArrayObservable = ArrayObservable;\n});\n\ndefine('rxjs/operators/combineLatest',[\"require\", \"exports\", \"tslib\", \"../observable/ArrayObservable\", \"../util/isArray\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, ArrayObservable_1, isArray_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var none = {};\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines multiple Observables to create an Observable whose values are\n     * calculated from the latest values of each of its input Observables.\n     *\n     * <span class=\"informal\">Whenever any input Observable emits a value, it\n     * computes a formula using the latest values from all the inputs, then emits\n     * the output of that formula.</span>\n     *\n     * <img src=\"./img/combineLatest.png\" width=\"100%\">\n     *\n     * `combineLatest` combines the values from this Observable with values from\n     * Observables passed as arguments. This is done by subscribing to each\n     * Observable, in order, and collecting an array of each of the most recent\n     * values any time any of the input Observables emits, then either taking that\n     * array and passing it as arguments to an optional `project` function and\n     * emitting the return value of that, or just emitting the array of recent\n     * values directly if there is no `project` function.\n     *\n     * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n     * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n     * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n     * bmi.subscribe(x => console.log('BMI is ' + x));\n     *\n     * // With output to console:\n     * // BMI is 24.212293388429753\n     * // BMI is 23.93948099205209\n     * // BMI is 23.671253629592222\n     *\n     * @see {@link combineAll}\n     * @see {@link merge}\n     * @see {@link withLatestFrom}\n     *\n     * @param {ObservableInput} other An input Observable to combine with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {function} [project] An optional function to project the values from\n     * the combined latest values into a new value on the output Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @method combineLatest\n     * @owner Observable\n     */\n    function combineLatest() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        var project = null;\n        if (typeof observables[observables.length - 1] === 'function') {\n            project = observables.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0].slice();\n        }\n        return function (source) { return source.lift.call(new ArrayObservable_1.ArrayObservable([source].concat(observables)), new CombineLatestOperator(project)); };\n    }\n    exports.combineLatest = combineLatest;\n    var CombineLatestOperator = /** @class */ (function () {\n        function CombineLatestOperator(project) {\n            this.project = project;\n        }\n        CombineLatestOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));\n        };\n        return CombineLatestOperator;\n    }());\n    exports.CombineLatestOperator = CombineLatestOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var CombineLatestSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(CombineLatestSubscriber, _super);\n        function CombineLatestSubscriber(destination, project) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.active = 0;\n            _this.values = [];\n            _this.observables = [];\n            return _this;\n        }\n        CombineLatestSubscriber.prototype._next = function (observable) {\n            this.values.push(none);\n            this.observables.push(observable);\n        };\n        CombineLatestSubscriber.prototype._complete = function () {\n            var observables = this.observables;\n            var len = observables.length;\n            if (len === 0) {\n                this.destination.complete();\n            }\n            else {\n                this.active = len;\n                this.toRespond = len;\n                for (var i = 0; i < len; i++) {\n                    var observable = observables[i];\n                    this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));\n                }\n            }\n        };\n        CombineLatestSubscriber.prototype.notifyComplete = function (unused) {\n            if ((this.active -= 1) === 0) {\n                this.destination.complete();\n            }\n        };\n        CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var values = this.values;\n            var oldVal = values[outerIndex];\n            var toRespond = !this.toRespond\n                ? 0\n                : oldVal === none ? --this.toRespond : this.toRespond;\n            values[outerIndex] = innerValue;\n            if (toRespond === 0) {\n                if (this.project) {\n                    this._tryProject(values);\n                }\n                else {\n                    this.destination.next(values.slice());\n                }\n            }\n        };\n        CombineLatestSubscriber.prototype._tryProject = function (values) {\n            var result;\n            try {\n                result = this.project.apply(this, values);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return CombineLatestSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.CombineLatestSubscriber = CombineLatestSubscriber;\n});\n\ndefine('rxjs/operators/combineAll',[\"require\", \"exports\", \"../operators/combineLatest\"], function (require, exports, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function combineAll(project) {\n        return function (source) { return source.lift(new combineLatest_1.CombineLatestOperator(project)); };\n    }\n    exports.combineAll = combineAll;\n});\n\ndefine('rxjs/observable/of',[\"require\", \"exports\", \"./ArrayObservable\"], function (require, exports, ArrayObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.of = ArrayObservable_1.ArrayObservable.of;\n});\n\ndefine('rxjs/observable/PromiseObservable',[\"require\", \"exports\", \"tslib\", \"../util/root\", \"../Observable\"], function (require, exports, tslib_1, root_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var PromiseObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(PromiseObservable, _super);\n        function PromiseObservable(promise, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.promise = promise;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Converts a Promise to an Observable.\n         *\n         * <span class=\"informal\">Returns an Observable that just emits the Promise's\n         * resolved value, then completes.</span>\n         *\n         * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an\n         * Observable. If the Promise resolves with a value, the output Observable\n         * emits that resolved value as a `next`, and then completes. If the Promise\n         * is rejected, then the output Observable emits the corresponding Error.\n         *\n         * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>\n         * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         * @see {@link bindCallback}\n         * @see {@link from}\n         *\n         * @param {PromiseLike<T>} promise The promise to be converted.\n         * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling\n         * the delivery of the resolved value (or the rejection).\n         * @return {Observable<T>} An Observable which wraps the Promise.\n         * @static true\n         * @name fromPromise\n         * @owner Observable\n         */\n        PromiseObservable.create = function (promise, scheduler) {\n            return new PromiseObservable(promise, scheduler);\n        };\n        PromiseObservable.prototype._subscribe = function (subscriber) {\n            var _this = this;\n            var promise = this.promise;\n            var scheduler = this.scheduler;\n            if (scheduler == null) {\n                if (this._isScalar) {\n                    if (!subscriber.closed) {\n                        subscriber.next(this.value);\n                        subscriber.complete();\n                    }\n                }\n                else {\n                    promise.then(function (value) {\n                        _this.value = value;\n                        _this._isScalar = true;\n                        if (!subscriber.closed) {\n                            subscriber.next(value);\n                            subscriber.complete();\n                        }\n                    }, function (err) {\n                        if (!subscriber.closed) {\n                            subscriber.error(err);\n                        }\n                    })\n                        .then(null, function (err) {\n                        // escape the promise trap, throw unhandled errors\n                        root_1.root.setTimeout(function () { throw err; });\n                    });\n                }\n            }\n            else {\n                if (this._isScalar) {\n                    if (!subscriber.closed) {\n                        return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });\n                    }\n                }\n                else {\n                    promise.then(function (value) {\n                        _this.value = value;\n                        _this._isScalar = true;\n                        if (!subscriber.closed) {\n                            subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));\n                        }\n                    }, function (err) {\n                        if (!subscriber.closed) {\n                            subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));\n                        }\n                    })\n                        .then(null, function (err) {\n                        // escape the promise trap, throw unhandled errors\n                        root_1.root.setTimeout(function () { throw err; });\n                    });\n                }\n            }\n        };\n        return PromiseObservable;\n    }(Observable_1.Observable));\n    exports.PromiseObservable = PromiseObservable;\n    function dispatchNext(arg) {\n        var value = arg.value, subscriber = arg.subscriber;\n        if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n        }\n    }\n    function dispatchError(arg) {\n        var err = arg.err, subscriber = arg.subscriber;\n        if (!subscriber.closed) {\n            subscriber.error(err);\n        }\n    }\n});\n\ndefine('rxjs/observable/IteratorObservable',[\"require\", \"exports\", \"tslib\", \"../util/root\", \"../Observable\", \"../symbol/iterator\"], function (require, exports, tslib_1, root_1, Observable_1, iterator_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var IteratorObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(IteratorObservable, _super);\n        function IteratorObservable(iterator, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.scheduler = scheduler;\n            if (iterator == null) {\n                throw new Error('iterator cannot be null.');\n            }\n            _this.iterator = getIterator(iterator);\n            return _this;\n        }\n        IteratorObservable.create = function (iterator, scheduler) {\n            return new IteratorObservable(iterator, scheduler);\n        };\n        IteratorObservable.dispatch = function (state) {\n            var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;\n            if (hasError) {\n                subscriber.error(state.error);\n                return;\n            }\n            var result = iterator.next();\n            if (result.done) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(result.value);\n            state.index = index + 1;\n            if (subscriber.closed) {\n                if (typeof iterator.return === 'function') {\n                    iterator.return();\n                }\n                return;\n            }\n            this.schedule(state);\n        };\n        IteratorObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(IteratorObservable.dispatch, 0, {\n                    index: index, iterator: iterator, subscriber: subscriber\n                });\n            }\n            else {\n                do {\n                    var result = iterator.next();\n                    if (result.done) {\n                        subscriber.complete();\n                        break;\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                    if (subscriber.closed) {\n                        if (typeof iterator.return === 'function') {\n                            iterator.return();\n                        }\n                        break;\n                    }\n                } while (true);\n            }\n        };\n        return IteratorObservable;\n    }(Observable_1.Observable));\n    exports.IteratorObservable = IteratorObservable;\n    var StringIterator = /** @class */ (function () {\n        function StringIterator(str, idx, len) {\n            if (idx === void 0) { idx = 0; }\n            if (len === void 0) { len = str.length; }\n            this.str = str;\n            this.idx = idx;\n            this.len = len;\n        }\n        StringIterator.prototype[iterator_1.iterator] = function () { return (this); };\n        StringIterator.prototype.next = function () {\n            return this.idx < this.len ? {\n                done: false,\n                value: this.str.charAt(this.idx++)\n            } : {\n                done: true,\n                value: undefined\n            };\n        };\n        return StringIterator;\n    }());\n    var ArrayIterator = /** @class */ (function () {\n        function ArrayIterator(arr, idx, len) {\n            if (idx === void 0) { idx = 0; }\n            if (len === void 0) { len = toLength(arr); }\n            this.arr = arr;\n            this.idx = idx;\n            this.len = len;\n        }\n        ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };\n        ArrayIterator.prototype.next = function () {\n            return this.idx < this.len ? {\n                done: false,\n                value: this.arr[this.idx++]\n            } : {\n                done: true,\n                value: undefined\n            };\n        };\n        return ArrayIterator;\n    }());\n    function getIterator(obj) {\n        var i = obj[iterator_1.iterator];\n        if (!i && typeof obj === 'string') {\n            return new StringIterator(obj);\n        }\n        if (!i && obj.length !== undefined) {\n            return new ArrayIterator(obj);\n        }\n        if (!i) {\n            throw new TypeError('object is not iterable');\n        }\n        return obj[iterator_1.iterator]();\n    }\n    var maxSafeInteger = Math.pow(2, 53) - 1;\n    function toLength(o) {\n        var len = +o.length;\n        if (isNaN(len)) {\n            return 0;\n        }\n        if (len === 0 || !numberIsFinite(len)) {\n            return len;\n        }\n        len = sign(len) * Math.floor(Math.abs(len));\n        if (len <= 0) {\n            return 0;\n        }\n        if (len > maxSafeInteger) {\n            return maxSafeInteger;\n        }\n        return len;\n    }\n    function numberIsFinite(value) {\n        return typeof value === 'number' && root_1.root.isFinite(value);\n    }\n    function sign(value) {\n        var valueAsNumber = +value;\n        if (valueAsNumber === 0) {\n            return valueAsNumber;\n        }\n        if (isNaN(valueAsNumber)) {\n            return valueAsNumber;\n        }\n        return valueAsNumber < 0 ? -1 : 1;\n    }\n});\n\ndefine('rxjs/observable/ArrayLikeObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"./ScalarObservable\", \"./EmptyObservable\"], function (require, exports, tslib_1, Observable_1, ScalarObservable_1, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ArrayLikeObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ArrayLikeObservable, _super);\n        function ArrayLikeObservable(arrayLike, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.arrayLike = arrayLike;\n            _this.scheduler = scheduler;\n            if (!scheduler && arrayLike.length === 1) {\n                _this._isScalar = true;\n                _this.value = arrayLike[0];\n            }\n            return _this;\n        }\n        ArrayLikeObservable.create = function (arrayLike, scheduler) {\n            var length = arrayLike.length;\n            if (length === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            else if (length === 1) {\n                return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);\n            }\n            else {\n                return new ArrayLikeObservable(arrayLike, scheduler);\n            }\n        };\n        ArrayLikeObservable.dispatch = function (state) {\n            var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;\n            if (subscriber.closed) {\n                return;\n            }\n            if (index >= length) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(arrayLike[index]);\n            state.index = index + 1;\n            this.schedule(state);\n        };\n        ArrayLikeObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;\n            var length = arrayLike.length;\n            if (scheduler) {\n                return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {\n                    arrayLike: arrayLike, index: index, length: length, subscriber: subscriber\n                });\n            }\n            else {\n                for (var i = 0; i < length && !subscriber.closed; i++) {\n                    subscriber.next(arrayLike[i]);\n                }\n                subscriber.complete();\n            }\n        };\n        return ArrayLikeObservable;\n    }(Observable_1.Observable));\n    exports.ArrayLikeObservable = ArrayLikeObservable;\n});\n\ndefine('rxjs/observable/FromObservable',[\"require\", \"exports\", \"tslib\", \"../util/isArray\", \"../util/isArrayLike\", \"../util/isPromise\", \"./PromiseObservable\", \"./IteratorObservable\", \"./ArrayObservable\", \"./ArrayLikeObservable\", \"../symbol/iterator\", \"../Observable\", \"../operators/observeOn\", \"../symbol/observable\"], function (require, exports, tslib_1, isArray_1, isArrayLike_1, isPromise_1, PromiseObservable_1, IteratorObservable_1, ArrayObservable_1, ArrayLikeObservable_1, iterator_1, Observable_1, observeOn_1, observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var FromObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(FromObservable, _super);\n        function FromObservable(ish, scheduler) {\n            var _this = _super.call(this, null) || this;\n            _this.ish = ish;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Creates an Observable from an Array, an array-like object, a Promise, an\n         * iterable object, or an Observable-like object.\n         *\n         * <span class=\"informal\">Converts almost anything to an Observable.</span>\n         *\n         * <img src=\"./img/from.png\" width=\"100%\">\n         *\n         * Convert various other objects and data types into Observables. `from`\n         * converts a Promise or an array-like or an\n         * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)\n         * object into an Observable that emits the items in that promise or array or\n         * iterable. A String, in this context, is treated as an array of characters.\n         * Observable-like objects (contains a function named with the ES2015 Symbol\n         * for Observable) can also be converted through this operator.\n         *\n         * @example <caption>Converts an array to an Observable</caption>\n         * var array = [10, 20, 30];\n         * var result = Rx.Observable.from(array);\n         * result.subscribe(x => console.log(x));\n         *\n         * // Results in the following:\n         * // 10 20 30\n         *\n         * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>\n         * function* generateDoubles(seed) {\n         *   var i = seed;\n         *   while (true) {\n         *     yield i;\n         *     i = 2 * i; // double it\n         *   }\n         * }\n         *\n         * var iterator = generateDoubles(3);\n         * var result = Rx.Observable.from(iterator).take(10);\n         * result.subscribe(x => console.log(x));\n         *\n         * // Results in the following:\n         * // 3 6 12 24 48 96 192 384 768 1536\n         *\n         * @see {@link create}\n         * @see {@link fromEvent}\n         * @see {@link fromEventPattern}\n         * @see {@link fromPromise}\n         *\n         * @param {ObservableInput<T>} ish A subscribable object, a Promise, an\n         * Observable-like, an Array, an iterable or an array-like object to be\n         * converted.\n         * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n         * emissions of values.\n         * @return {Observable<T>} The Observable whose values are originally from the\n         * input object that was converted.\n         * @static true\n         * @name from\n         * @owner Observable\n         */\n        FromObservable.create = function (ish, scheduler) {\n            if (ish != null) {\n                if (typeof ish[observable_1.observable] === 'function') {\n                    if (ish instanceof Observable_1.Observable && !scheduler) {\n                        return ish;\n                    }\n                    return new FromObservable(ish, scheduler);\n                }\n                else if (isArray_1.isArray(ish)) {\n                    return new ArrayObservable_1.ArrayObservable(ish, scheduler);\n                }\n                else if (isPromise_1.isPromise(ish)) {\n                    return new PromiseObservable_1.PromiseObservable(ish, scheduler);\n                }\n                else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {\n                    return new IteratorObservable_1.IteratorObservable(ish, scheduler);\n                }\n                else if (isArrayLike_1.isArrayLike(ish)) {\n                    return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);\n                }\n            }\n            throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');\n        };\n        FromObservable.prototype._subscribe = function (subscriber) {\n            var ish = this.ish;\n            var scheduler = this.scheduler;\n            if (scheduler == null) {\n                return ish[observable_1.observable]().subscribe(subscriber);\n            }\n            else {\n                return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));\n            }\n        };\n        return FromObservable;\n    }(Observable_1.Observable));\n    exports.FromObservable = FromObservable;\n});\n\ndefine('rxjs/observable/from',[\"require\", \"exports\", \"./FromObservable\"], function (require, exports, FromObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.from = FromObservable_1.FromObservable.create;\n});\n\ndefine('rxjs/operators/mergeMap',[\"require\", \"exports\", \"tslib\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link mergeAll}.</span>\n     *\n     * <img src=\"./img/mergeMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an Observable, and then merging those resulting Observables and\n     * emitting the results of this merger.\n     *\n     * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var result = letters.mergeMap(x =>\n     *   Rx.Observable.interval(1000).map(i => x+i)\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // a0\n     * // b0\n     * // c0\n     * // a1\n     * // b1\n     * // c1\n     * // continues to list a,b,c with respective ascending integers\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaustMap}\n     * @see {@link merge}\n     * @see {@link mergeAll}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and merging the results of the Observables obtained\n     * from this transformation.\n     * @method mergeMap\n     * @owner Observable\n     */\n    function mergeMap(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return function mergeMapOperatorFunction(source) {\n            if (typeof resultSelector === 'number') {\n                concurrent = resultSelector;\n                resultSelector = null;\n            }\n            return source.lift(new MergeMapOperator(project, resultSelector, concurrent));\n        };\n    }\n    exports.mergeMap = mergeMap;\n    var MergeMapOperator = /** @class */ (function () {\n        function MergeMapOperator(project, resultSelector, concurrent) {\n            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n            this.project = project;\n            this.resultSelector = resultSelector;\n            this.concurrent = concurrent;\n        }\n        MergeMapOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));\n        };\n        return MergeMapOperator;\n    }());\n    exports.MergeMapOperator = MergeMapOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MergeMapSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MergeMapSubscriber, _super);\n        function MergeMapSubscriber(destination, project, resultSelector, concurrent) {\n            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.resultSelector = resultSelector;\n            _this.concurrent = concurrent;\n            _this.hasCompleted = false;\n            _this.buffer = [];\n            _this.active = 0;\n            _this.index = 0;\n            return _this;\n        }\n        MergeMapSubscriber.prototype._next = function (value) {\n            if (this.active < this.concurrent) {\n                this._tryNext(value);\n            }\n            else {\n                this.buffer.push(value);\n            }\n        };\n        MergeMapSubscriber.prototype._tryNext = function (value) {\n            var result;\n            var index = this.index++;\n            try {\n                result = this.project(value, index);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.active++;\n            this._innerSub(result, value, index);\n        };\n        MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {\n            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n        };\n        MergeMapSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (this.active === 0 && this.buffer.length === 0) {\n                this.destination.complete();\n            }\n        };\n        MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            if (this.resultSelector) {\n                this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                this.destination.next(innerValue);\n            }\n        };\n        MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var result;\n            try {\n                result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {\n            var buffer = this.buffer;\n            this.remove(innerSub);\n            this.active--;\n            if (buffer.length > 0) {\n                this._next(buffer.shift());\n            }\n            else if (this.active === 0 && this.hasCompleted) {\n                this.destination.complete();\n            }\n        };\n        return MergeMapSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.MergeMapSubscriber = MergeMapSubscriber;\n});\n\ndefine('rxjs/util/identity',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function identity(x) {\n        return x;\n    }\n    exports.identity = identity;\n});\n\ndefine('rxjs/operators/mergeAll',[\"require\", \"exports\", \"./mergeMap\", \"../util/identity\"], function (require, exports, mergeMap_1, identity_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable which\n     * concurrently delivers all values that are emitted on the inner Observables.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n     *\n     * <img src=\"./img/mergeAll.png\" width=\"100%\">\n     *\n     * `mergeAll` subscribes to an Observable that emits Observables, also known as\n     * a higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, it subscribes to that and delivers all the values from the\n     * inner Observable on the output Observable. The output Observable only\n     * completes once all inner Observables have completed. Any error delivered by\n     * a inner Observable will be immediately emitted on the output Observable.\n     *\n     * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n     * var firstOrder = higherOrder.mergeAll();\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n     * var firstOrder = higherOrder.mergeAll(2);\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link exhaust}\n     * @see {@link merge}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     * @see {@link switch}\n     * @see {@link zipAll}\n     *\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits values coming from all the\n     * inner Observables emitted by the source Observable.\n     * @method mergeAll\n     * @owner Observable\n     */\n    function mergeAll(concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeMap_1.mergeMap(identity_1.identity, null, concurrent);\n    }\n    exports.mergeAll = mergeAll;\n});\n\ndefine('rxjs/operators/concatAll',[\"require\", \"exports\", \"./mergeAll\"], function (require, exports, mergeAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by\n     * concatenating the inner Observables in order.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n     * inner Observable after the other.</span>\n     *\n     * <img src=\"./img/concatAll.png\" width=\"100%\">\n     *\n     * Joins every Observable emitted by the source (a higher-order Observable), in\n     * a serial fashion. It subscribes to each inner Observable only after the\n     * previous inner Observable has completed, and merges all of their values into\n     * the returned observable.\n     *\n     * __Warning:__ If the source Observable emits Observables quickly and\n     * endlessly, and the inner Observables it emits generally complete slower than\n     * the source emits, you can run into memory issues as the incoming Observables\n     * collect in an unbounded buffer.\n     *\n     * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n     * to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n     * var firstOrder = higherOrder.concatAll();\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link combineAll}\n     * @see {@link concat}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     * @see {@link exhaust}\n     * @see {@link mergeAll}\n     * @see {@link switch}\n     * @see {@link zipAll}\n     *\n     * @return {Observable} An Observable emitting values from all the inner\n     * Observables concatenated.\n     * @method concatAll\n     * @owner Observable\n     */\n    function concatAll() {\n        return mergeAll_1.mergeAll(1);\n    }\n    exports.concatAll = concatAll;\n});\n\ndefine('rxjs/observable/concat',[\"require\", \"exports\", \"../util/isScheduler\", \"./of\", \"./from\", \"../operators/concatAll\"], function (require, exports, isScheduler_1, of_1, from_1, concatAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which sequentially emits all values from given\n     * Observable and then moves on to the next.\n     *\n     * <span class=\"informal\">Concatenates multiple Observables together by\n     * sequentially emitting their values, one Observable after the other.</span>\n     *\n     * <img src=\"./img/concat.png\" width=\"100%\">\n     *\n     * `concat` joins multiple Observables together, by subscribing to them one at a time and\n     * merging their results into the output Observable. You can pass either an array of\n     * Observables, or put them directly as arguments. Passing an empty array will result\n     * in Observable that completes immediately.\n     *\n     * `concat` will subscribe to first input Observable and emit all its values, without\n     * changing or affecting them in any way. When that Observable completes, it will\n     * subscribe to then next Observable passed and, again, emit its values. This will be\n     * repeated, until the operator runs out of Observables. When last input Observable completes,\n     * `concat` will complete as well. At any given moment only one Observable passed to operator\n     * emits values. If you would like to emit values from passed Observables concurrently, check out\n     * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n     * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n     *\n     * Note that if some input Observable never completes, `concat` will also never complete\n     * and Observables following the one that did not complete will never be subscribed. On the other\n     * hand, if some Observable simply completes immediately after it is subscribed, it will be\n     * invisible for `concat`, which will just move on to the next Observable.\n     *\n     * If any Observable in chain errors, instead of passing control to the next Observable,\n     * `concat` will error immediately as well. Observables that would be subscribed after\n     * the one that emitted error, never will.\n     *\n     * If you pass to `concat` the same Observable many times, its stream of values\n     * will be \"replayed\" on every subscription, which means you can repeat given Observable\n     * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n     * you can always use {@link repeat}.\n     *\n     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n     * var timer = Rx.Observable.interval(1000).take(4);\n     * var sequence = Rx.Observable.range(1, 10);\n     * var result = Rx.Observable.concat(timer, sequence);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in:\n     * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n     *\n     *\n     * @example <caption>Concatenate an array of 3 Observables</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in the following:\n     * // (Prints to console sequentially)\n     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n     *\n     *\n     * @example <caption>Concatenate the same Observable to repeat it</caption>\n     * const timer = Rx.Observable.interval(1000).take(2);\n     *\n     * Rx.Observable.concat(timer, timer) // concating the same Observable!\n     * .subscribe(\n     *   value => console.log(value),\n     *   err => {},\n     *   () => console.log('...and it is done!')\n     * );\n     *\n     * // Logs:\n     * // 0 after 1s\n     * // 1 after 2s\n     * // 0 after 3s\n     * // 1 after 4s\n     * // \"...and it is done!\" also after 4s\n     *\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     *\n     * @param {ObservableInput} input1 An input Observable to concatenate with others.\n     * @param {ObservableInput} input2 An input Observable to concatenate with others.\n     * More than one input Observables may be given as argument.\n     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n     * Observable subscription on.\n     * @return {Observable} All values of each passed Observable merged into a\n     * single Observable, in order, in serial fashion.\n     * @static true\n     * @name concat\n     * @owner Observable\n     */\n    function concat() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {\n            return from_1.from(observables[0]);\n        }\n        return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));\n    }\n    exports.concat = concat;\n});\n\ndefine('rxjs/operators/concat',[\"require\", \"exports\", \"../observable/concat\", \"../observable/concat\"], function (require, exports, concat_1, concat_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.concatStatic = concat_2.concat;\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which sequentially emits all values from every\n     * given input Observable after the current Observable.\n     *\n     * <span class=\"informal\">Concatenates multiple Observables together by\n     * sequentially emitting their values, one Observable after the other.</span>\n     *\n     * <img src=\"./img/concat.png\" width=\"100%\">\n     *\n     * Joins this Observable with multiple other Observables by subscribing to them\n     * one at a time, starting with the source, and merging their results into the\n     * output Observable. Will wait for each Observable to complete before moving\n     * on to the next.\n     *\n     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n     * var timer = Rx.Observable.interval(1000).take(4);\n     * var sequence = Rx.Observable.range(1, 10);\n     * var result = timer.concat(sequence);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in:\n     * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n     *\n     * @example <caption>Concatenate 3 Observables</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var result = timer1.concat(timer2, timer3);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in the following:\n     * // (Prints to console sequentially)\n     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n     *\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     *\n     * @param {ObservableInput} other An input Observable to concatenate after the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n     * Observable subscription on.\n     * @return {Observable} All values of each passed Observable merged into a\n     * single Observable, in order, in serial fashion.\n     * @method concat\n     * @owner Observable\n     */\n    function concat() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return function (source) { return source.lift.call(concat_1.concat.apply(void 0, [source].concat(observables))); };\n    }\n    exports.concat = concat;\n});\n\ndefine('rxjs/operators/concatMap',[\"require\", \"exports\", \"./mergeMap\"], function (require, exports, mergeMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable, in a serialized fashion waiting for each one to complete before\n     * merging the next.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link concatAll}.</span>\n     *\n     * <img src=\"./img/concatMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. Each new inner Observable is\n     * concatenated with the previous inner Observable.\n     *\n     * __Warning:__ if source values arrive endlessly and faster than their\n     * corresponding inner Observables can complete, it will result in memory issues\n     * as inner Observables amass in an unbounded buffer waiting for their turn to\n     * be subscribed to.\n     *\n     * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n     * to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link concat}\n     * @see {@link concatAll}\n     * @see {@link concatMapTo}\n     * @see {@link exhaustMap}\n     * @see {@link mergeMap}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and taking values from each projected inner\n     * Observable sequentially.\n     * @method concatMap\n     * @owner Observable\n     */\n    function concatMap(project, resultSelector) {\n        return mergeMap_1.mergeMap(project, resultSelector, 1);\n    }\n    exports.concatMap = concatMap;\n});\n\ndefine('rxjs/operators/concatMapTo',[\"require\", \"exports\", \"./concatMap\"], function (require, exports, concatMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is merged multiple\n     * times in a serialized fashion on the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n     * always to the same inner Observable.</span>\n     *\n     * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then flattens those resulting Observables into one\n     * single Observable, which is the output Observable. Each new `innerObservable`\n     * instance emitted on the output Observable is concatenated with the previous\n     * `innerObservable` instance.\n     *\n     * __Warning:__ if source values arrive endlessly and faster than their\n     * corresponding inner Observables can complete, it will result in memory issues\n     * as inner Observables amass in an unbounded buffer waiting for their turn to\n     * be subscribed to.\n     *\n     * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n     * set to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link concat}\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link mergeMapTo}\n     * @see {@link switchMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An observable of values merged together by joining the\n     * passed observable with itself, one after the other, for each value emitted\n     * from the source.\n     * @method concatMapTo\n     * @owner Observable\n     */\n    function concatMapTo(innerObservable, resultSelector) {\n        return concatMap_1.concatMap(function () { return innerObservable; }, resultSelector);\n    }\n    exports.concatMapTo = concatMapTo;\n});\n\ndefine('rxjs/operators/count',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Counts the number of emissions on the source and emits that number when the\n     * source completes.\n     *\n     * <span class=\"informal\">Tells how many values were emitted, when the source\n     * completes.</span>\n     *\n     * <img src=\"./img/count.png\" width=\"100%\">\n     *\n     * `count` transforms an Observable that emits values into an Observable that\n     * emits a single value that represents the number of values emitted by the\n     * source Observable. If the source Observable terminates with an error, `count`\n     * will pass this error notification along without emitting a value first. If\n     * the source Observable does not terminate at all, `count` will neither emit\n     * a value nor terminate. This operator takes an optional `predicate` function\n     * as argument, in which case the output emission will represent the number of\n     * source values that matched `true` with the `predicate`.\n     *\n     * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n     * var seconds = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var secondsBeforeClick = seconds.takeUntil(clicks);\n     * var result = secondsBeforeClick.count();\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n     * var numbers = Rx.Observable.range(1, 7);\n     * var result = numbers.count(i => i % 2 === 1);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // 4\n     *\n     * @see {@link max}\n     * @see {@link min}\n     * @see {@link reduce}\n     *\n     * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n     * boolean function to select what values are to be counted. It is provided with\n     * arguments of:\n     * - `value`: the value from the source Observable.\n     * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n     * - `source`: the source Observable instance itself.\n     * @return {Observable} An Observable of one number that represents the count as\n     * described above.\n     * @method count\n     * @owner Observable\n     */\n    function count(predicate) {\n        return function (source) { return source.lift(new CountOperator(predicate, source)); };\n    }\n    exports.count = count;\n    var CountOperator = /** @class */ (function () {\n        function CountOperator(predicate, source) {\n            this.predicate = predicate;\n            this.source = source;\n        }\n        CountOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));\n        };\n        return CountOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var CountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(CountSubscriber, _super);\n        function CountSubscriber(destination, predicate, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.source = source;\n            _this.count = 0;\n            _this.index = 0;\n            return _this;\n        }\n        CountSubscriber.prototype._next = function (value) {\n            if (this.predicate) {\n                this._tryPredicate(value);\n            }\n            else {\n                this.count++;\n            }\n        };\n        CountSubscriber.prototype._tryPredicate = function (value) {\n            var result;\n            try {\n                result = this.predicate(value, this.index++, this.source);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (result) {\n                this.count++;\n            }\n        };\n        CountSubscriber.prototype._complete = function () {\n            this.destination.next(this.count);\n            this.destination.complete();\n        };\n        return CountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/debounce',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable only after a particular time span\n     * determined by another Observable has passed without another source emission.\n     *\n     * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n     * emission silence is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/debounce.png\" width=\"100%\">\n     *\n     * `debounce` delays values emitted by the source Observable, but drops previous\n     * pending delayed emissions if a new value arrives on the source Observable.\n     * This operator keeps track of the most recent value from the source\n     * Observable, and spawns a duration Observable by calling the\n     * `durationSelector` function. The value is emitted only when the duration\n     * Observable emits a value or completes, and if no other value was emitted on\n     * the source Observable since the duration Observable was spawned. If a new\n     * value appears before the duration Observable emits, the previous value will\n     * be dropped and will not be emitted on the output Observable.\n     *\n     * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n     * delay-like operator since output emissions do not necessarily occur at the\n     * same time as they did on the source Observable.\n     *\n     * @example <caption>Emit the most recent click after a burst of clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounceTime}\n     * @see {@link delayWhen}\n     * @see {@link throttle}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the timeout\n     * duration for each source value, returned as an Observable or a Promise.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified duration Observable returned by\n     * `durationSelector`, and may drop some values if they occur too frequently.\n     * @method debounce\n     * @owner Observable\n     */\n    function debounce(durationSelector) {\n        return function (source) { return source.lift(new DebounceOperator(durationSelector)); };\n    }\n    exports.debounce = debounce;\n    var DebounceOperator = /** @class */ (function () {\n        function DebounceOperator(durationSelector) {\n            this.durationSelector = durationSelector;\n        }\n        DebounceOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));\n        };\n        return DebounceOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DebounceSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DebounceSubscriber, _super);\n        function DebounceSubscriber(destination, durationSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.durationSelector = durationSelector;\n            _this.hasValue = false;\n            _this.durationSubscription = null;\n            return _this;\n        }\n        DebounceSubscriber.prototype._next = function (value) {\n            try {\n                var result = this.durationSelector.call(this, value);\n                if (result) {\n                    this._tryNext(value, result);\n                }\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        DebounceSubscriber.prototype._complete = function () {\n            this.emitValue();\n            this.destination.complete();\n        };\n        DebounceSubscriber.prototype._tryNext = function (value, duration) {\n            var subscription = this.durationSubscription;\n            this.value = value;\n            this.hasValue = true;\n            if (subscription) {\n                subscription.unsubscribe();\n                this.remove(subscription);\n            }\n            subscription = subscribeToResult_1.subscribeToResult(this, duration);\n            if (!subscription.closed) {\n                this.add(this.durationSubscription = subscription);\n            }\n        };\n        DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.emitValue();\n        };\n        DebounceSubscriber.prototype.notifyComplete = function () {\n            this.emitValue();\n        };\n        DebounceSubscriber.prototype.emitValue = function () {\n            if (this.hasValue) {\n                var value = this.value;\n                var subscription = this.durationSubscription;\n                if (subscription) {\n                    this.durationSubscription = null;\n                    subscription.unsubscribe();\n                    this.remove(subscription);\n                }\n                this.value = null;\n                this.hasValue = false;\n                _super.prototype._next.call(this, value);\n            }\n        };\n        return DebounceSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/debounceTime',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../scheduler/async\"], function (require, exports, tslib_1, Subscriber_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable only after a particular time span\n     * has passed without another source emission.\n     *\n     * <span class=\"informal\">It's like {@link delay}, but passes only the most\n     * recent value from each burst of emissions.</span>\n     *\n     * <img src=\"./img/debounceTime.png\" width=\"100%\">\n     *\n     * `debounceTime` delays values emitted by the source Observable, but drops\n     * previous pending delayed emissions if a new value arrives on the source\n     * Observable. This operator keeps track of the most recent value from the\n     * source Observable, and emits that only when `dueTime` enough time has passed\n     * without any other value appearing on the source Observable. If a new value\n     * appears before `dueTime` silence occurs, the previous value will be dropped\n     * and will not be emitted on the output Observable.\n     *\n     * This is a rate-limiting operator, because it is impossible for more than one\n     * value to be emitted in any time window of duration `dueTime`, but it is also\n     * a delay-like operator since output emissions do not occur at the same time as\n     * they did on the source Observable. Optionally takes a {@link IScheduler} for\n     * managing timers.\n     *\n     * @example <caption>Emit the most recent click after a burst of clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.debounceTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounce}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttleTime}\n     *\n     * @param {number} dueTime The timeout duration in milliseconds (or the time\n     * unit determined internally by the optional `scheduler`) for the window of\n     * time required to wait for emission silence before emitting the most recent\n     * source value.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the timeout for each value.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified `dueTime`, and may drop some values if they occur\n     * too frequently.\n     * @method debounceTime\n     * @owner Observable\n     */\n    function debounceTime(dueTime, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };\n    }\n    exports.debounceTime = debounceTime;\n    var DebounceTimeOperator = /** @class */ (function () {\n        function DebounceTimeOperator(dueTime, scheduler) {\n            this.dueTime = dueTime;\n            this.scheduler = scheduler;\n        }\n        DebounceTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n        };\n        return DebounceTimeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DebounceTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DebounceTimeSubscriber, _super);\n        function DebounceTimeSubscriber(destination, dueTime, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.dueTime = dueTime;\n            _this.scheduler = scheduler;\n            _this.debouncedSubscription = null;\n            _this.lastValue = null;\n            _this.hasValue = false;\n            return _this;\n        }\n        DebounceTimeSubscriber.prototype._next = function (value) {\n            this.clearDebounce();\n            this.lastValue = value;\n            this.hasValue = true;\n            this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n        };\n        DebounceTimeSubscriber.prototype._complete = function () {\n            this.debouncedNext();\n            this.destination.complete();\n        };\n        DebounceTimeSubscriber.prototype.debouncedNext = function () {\n            this.clearDebounce();\n            if (this.hasValue) {\n                this.destination.next(this.lastValue);\n                this.lastValue = null;\n                this.hasValue = false;\n            }\n        };\n        DebounceTimeSubscriber.prototype.clearDebounce = function () {\n            var debouncedSubscription = this.debouncedSubscription;\n            if (debouncedSubscription !== null) {\n                this.remove(debouncedSubscription);\n                debouncedSubscription.unsubscribe();\n                this.debouncedSubscription = null;\n            }\n        };\n        return DebounceTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchNext(subscriber) {\n        subscriber.debouncedNext();\n    }\n});\n\ndefine('rxjs/operators/defaultIfEmpty',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Emits a given value if the source Observable completes without emitting any\n     * `next` value, otherwise mirrors the source Observable.\n     *\n     * <span class=\"informal\">If the source Observable turns out to be empty, then\n     * this operator will emit a default value.</span>\n     *\n     * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n     *\n     * `defaultIfEmpty` emits the values emitted by the source Observable or a\n     * specified default value if the source Observable is empty (completes without\n     * having emitted any `next` value).\n     *\n     * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n     * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link empty}\n     * @see {@link last}\n     *\n     * @param {any} [defaultValue=null] The default value used if the source\n     * Observable is empty.\n     * @return {Observable} An Observable that emits either the specified\n     * `defaultValue` if the source Observable emits no items, or the values emitted\n     * by the source Observable.\n     * @method defaultIfEmpty\n     * @owner Observable\n     */\n    function defaultIfEmpty(defaultValue) {\n        if (defaultValue === void 0) { defaultValue = null; }\n        return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };\n    }\n    exports.defaultIfEmpty = defaultIfEmpty;\n    var DefaultIfEmptyOperator = /** @class */ (function () {\n        function DefaultIfEmptyOperator(defaultValue) {\n            this.defaultValue = defaultValue;\n        }\n        DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));\n        };\n        return DefaultIfEmptyOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DefaultIfEmptySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DefaultIfEmptySubscriber, _super);\n        function DefaultIfEmptySubscriber(destination, defaultValue) {\n            var _this = _super.call(this, destination) || this;\n            _this.defaultValue = defaultValue;\n            _this.isEmpty = true;\n            return _this;\n        }\n        DefaultIfEmptySubscriber.prototype._next = function (value) {\n            this.isEmpty = false;\n            this.destination.next(value);\n        };\n        DefaultIfEmptySubscriber.prototype._complete = function () {\n            if (this.isEmpty) {\n                this.destination.next(this.defaultValue);\n            }\n            this.destination.complete();\n        };\n        return DefaultIfEmptySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/delay',[\"require\", \"exports\", \"tslib\", \"../scheduler/async\", \"../util/isDate\", \"../Subscriber\", \"../Notification\"], function (require, exports, tslib_1, async_1, isDate_1, Subscriber_1, Notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Delays the emission of items from the source Observable by a given timeout or\n     * until a given Date.\n     *\n     * <span class=\"informal\">Time shifts each item by some specified amount of\n     * milliseconds.</span>\n     *\n     * <img src=\"./img/delay.png\" width=\"100%\">\n     *\n     * If the delay argument is a Number, this operator time shifts the source\n     * Observable by that amount of time expressed in milliseconds. The relative\n     * time intervals between the values are preserved.\n     *\n     * If the delay argument is a Date, this operator time shifts the start of the\n     * Observable execution until the given date occurs.\n     *\n     * @example <caption>Delay each click by one second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @example <caption>Delay all clicks until a future date happens</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var date = new Date('March 15, 2050 12:00:00'); // in the future\n     * var delayedClicks = clicks.delay(date); // click emitted only after that date\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @see {@link debounceTime}\n     * @see {@link delayWhen}\n     *\n     * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n     * a `Date` until which the emission of the source items is delayed.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for\n     * managing the timers that handle the time-shift for each item.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified timeout or Date.\n     * @method delay\n     * @owner Observable\n     */\n    function delay(delay, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        var absoluteDelay = isDate_1.isDate(delay);\n        var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);\n        return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };\n    }\n    exports.delay = delay;\n    var DelayOperator = /** @class */ (function () {\n        function DelayOperator(delay, scheduler) {\n            this.delay = delay;\n            this.scheduler = scheduler;\n        }\n        DelayOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));\n        };\n        return DelayOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DelaySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DelaySubscriber, _super);\n        function DelaySubscriber(destination, delay, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.delay = delay;\n            _this.scheduler = scheduler;\n            _this.queue = [];\n            _this.active = false;\n            _this.errored = false;\n            return _this;\n        }\n        DelaySubscriber.dispatch = function (state) {\n            var source = state.source;\n            var queue = source.queue;\n            var scheduler = state.scheduler;\n            var destination = state.destination;\n            while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {\n                queue.shift().notification.observe(destination);\n            }\n            if (queue.length > 0) {\n                var delay_1 = Math.max(0, queue[0].time - scheduler.now());\n                this.schedule(state, delay_1);\n            }\n            else {\n                source.active = false;\n            }\n        };\n        DelaySubscriber.prototype._schedule = function (scheduler) {\n            this.active = true;\n            this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {\n                source: this, destination: this.destination, scheduler: scheduler\n            }));\n        };\n        DelaySubscriber.prototype.scheduleNotification = function (notification) {\n            if (this.errored === true) {\n                return;\n            }\n            var scheduler = this.scheduler;\n            var message = new DelayMessage(scheduler.now() + this.delay, notification);\n            this.queue.push(message);\n            if (this.active === false) {\n                this._schedule(scheduler);\n            }\n        };\n        DelaySubscriber.prototype._next = function (value) {\n            this.scheduleNotification(Notification_1.Notification.createNext(value));\n        };\n        DelaySubscriber.prototype._error = function (err) {\n            this.errored = true;\n            this.queue = [];\n            this.destination.error(err);\n        };\n        DelaySubscriber.prototype._complete = function () {\n            this.scheduleNotification(Notification_1.Notification.createComplete());\n        };\n        return DelaySubscriber;\n    }(Subscriber_1.Subscriber));\n    var DelayMessage = /** @class */ (function () {\n        function DelayMessage(time, notification) {\n            this.time = time;\n            this.notification = notification;\n        }\n        return DelayMessage;\n    }());\n});\n\ndefine('rxjs/operators/delayWhen',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Observable\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subscriber_1, Observable_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Delays the emission of items from the source Observable by a given time span\n     * determined by the emissions of another Observable.\n     *\n     * <span class=\"informal\">It's like {@link delay}, but the time span of the\n     * delay duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/delayWhen.png\" width=\"100%\">\n     *\n     * `delayWhen` time shifts each emitted value from the source Observable by a\n     * time span determined by another Observable. When the source emits a value,\n     * the `delayDurationSelector` function is called with the source value as\n     * argument, and should return an Observable, called the \"duration\" Observable.\n     * The source value is emitted on the output Observable only when the duration\n     * Observable emits a value or completes.\n     *\n     * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n     * is an Observable. When `subscriptionDelay` emits its first value or\n     * completes, the source Observable is subscribed to and starts behaving like\n     * described in the previous paragraph. If `subscriptionDelay` is not provided,\n     * `delayWhen` will subscribe to the source Observable as soon as the output\n     * Observable is subscribed.\n     *\n     * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var delayedClicks = clicks.delayWhen(event =>\n     *   Rx.Observable.interval(Math.random() * 5000)\n     * );\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @see {@link debounce}\n     * @see {@link delay}\n     *\n     * @param {function(value: T): Observable} delayDurationSelector A function that\n     * returns an Observable for each value emitted by the source Observable, which\n     * is then used to delay the emission of that item on the output Observable\n     * until the Observable returned from this function emits a value.\n     * @param {Observable} subscriptionDelay An Observable that triggers the\n     * subscription to the source Observable once it emits any value.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by an amount of time specified by the Observable returned by\n     * `delayDurationSelector`.\n     * @method delayWhen\n     * @owner Observable\n     */\n    function delayWhen(delayDurationSelector, subscriptionDelay) {\n        if (subscriptionDelay) {\n            return function (source) {\n                return new SubscriptionDelayObservable(source, subscriptionDelay)\n                    .lift(new DelayWhenOperator(delayDurationSelector));\n            };\n        }\n        return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };\n    }\n    exports.delayWhen = delayWhen;\n    var DelayWhenOperator = /** @class */ (function () {\n        function DelayWhenOperator(delayDurationSelector) {\n            this.delayDurationSelector = delayDurationSelector;\n        }\n        DelayWhenOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));\n        };\n        return DelayWhenOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DelayWhenSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DelayWhenSubscriber, _super);\n        function DelayWhenSubscriber(destination, delayDurationSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.delayDurationSelector = delayDurationSelector;\n            _this.completed = false;\n            _this.delayNotifierSubscriptions = [];\n            _this.values = [];\n            return _this;\n        }\n        DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.destination.next(outerValue);\n            this.removeSubscription(innerSub);\n            this.tryComplete();\n        };\n        DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {\n            this._error(error);\n        };\n        DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n            var value = this.removeSubscription(innerSub);\n            if (value) {\n                this.destination.next(value);\n            }\n            this.tryComplete();\n        };\n        DelayWhenSubscriber.prototype._next = function (value) {\n            try {\n                var delayNotifier = this.delayDurationSelector(value);\n                if (delayNotifier) {\n                    this.tryDelay(delayNotifier, value);\n                }\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        DelayWhenSubscriber.prototype._complete = function () {\n            this.completed = true;\n            this.tryComplete();\n        };\n        DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {\n            subscription.unsubscribe();\n            var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);\n            var value = null;\n            if (subscriptionIdx !== -1) {\n                value = this.values[subscriptionIdx];\n                this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);\n                this.values.splice(subscriptionIdx, 1);\n            }\n            return value;\n        };\n        DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {\n            var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);\n            if (notifierSubscription && !notifierSubscription.closed) {\n                this.add(notifierSubscription);\n                this.delayNotifierSubscriptions.push(notifierSubscription);\n            }\n            this.values.push(value);\n        };\n        DelayWhenSubscriber.prototype.tryComplete = function () {\n            if (this.completed && this.delayNotifierSubscriptions.length === 0) {\n                this.destination.complete();\n            }\n        };\n        return DelayWhenSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SubscriptionDelayObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(SubscriptionDelayObservable, _super);\n        function SubscriptionDelayObservable(source, subscriptionDelay) {\n            var _this = _super.call(this) || this;\n            _this.source = source;\n            _this.subscriptionDelay = subscriptionDelay;\n            return _this;\n        }\n        SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {\n            this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));\n        };\n        return SubscriptionDelayObservable;\n    }(Observable_1.Observable));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SubscriptionDelaySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SubscriptionDelaySubscriber, _super);\n        function SubscriptionDelaySubscriber(parent, source) {\n            var _this = _super.call(this) || this;\n            _this.parent = parent;\n            _this.source = source;\n            _this.sourceSubscribed = false;\n            return _this;\n        }\n        SubscriptionDelaySubscriber.prototype._next = function (unused) {\n            this.subscribeToSource();\n        };\n        SubscriptionDelaySubscriber.prototype._error = function (err) {\n            this.unsubscribe();\n            this.parent.error(err);\n        };\n        SubscriptionDelaySubscriber.prototype._complete = function () {\n            this.subscribeToSource();\n        };\n        SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {\n            if (!this.sourceSubscribed) {\n                this.sourceSubscribed = true;\n                this.unsubscribe();\n                this.source.subscribe(this.parent);\n            }\n        };\n        return SubscriptionDelaySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/dematerialize',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts an Observable of {@link Notification} objects into the emissions\n     * that they represent.\n     *\n     * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n     * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n     *\n     * <img src=\"./img/dematerialize.png\" width=\"100%\">\n     *\n     * `dematerialize` is assumed to operate an Observable that only emits\n     * {@link Notification} objects as `next` emissions, and does not emit any\n     * `error`. Such Observable is the output of a `materialize` operation. Those\n     * notifications are then unwrapped using the metadata they contain, and emitted\n     * as `next`, `error`, and `complete` on the output Observable.\n     *\n     * Use this operator in conjunction with {@link materialize}.\n     *\n     * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n     * var notifA = new Rx.Notification('N', 'A');\n     * var notifB = new Rx.Notification('N', 'B');\n     * var notifE = new Rx.Notification('E', void 0,\n     *   new TypeError('x.toUpperCase is not a function')\n     * );\n     * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n     * var upperCase = materialized.dematerialize();\n     * upperCase.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * // Results in:\n     * // A\n     * // B\n     * // TypeError: x.toUpperCase is not a function\n     *\n     * @see {@link Notification}\n     * @see {@link materialize}\n     *\n     * @return {Observable} An Observable that emits items and notifications\n     * embedded in Notification objects emitted by the source Observable.\n     * @method dematerialize\n     * @owner Observable\n     */\n    function dematerialize() {\n        return function dematerializeOperatorFunction(source) {\n            return source.lift(new DeMaterializeOperator());\n        };\n    }\n    exports.dematerialize = dematerialize;\n    var DeMaterializeOperator = /** @class */ (function () {\n        function DeMaterializeOperator() {\n        }\n        DeMaterializeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DeMaterializeSubscriber(subscriber));\n        };\n        return DeMaterializeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DeMaterializeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DeMaterializeSubscriber, _super);\n        function DeMaterializeSubscriber(destination) {\n            return _super.call(this, destination) || this;\n        }\n        DeMaterializeSubscriber.prototype._next = function (value) {\n            value.observe(this.destination);\n        };\n        return DeMaterializeSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/util/Set',[\"require\", \"exports\", \"./root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function minimalSetImpl() {\n        // THIS IS NOT a full impl of Set, this is just the minimum\n        // bits of functionality we need for this library.\n        return /** @class */ (function () {\n            function MinimalSet() {\n                this._values = [];\n            }\n            MinimalSet.prototype.add = function (value) {\n                if (!this.has(value)) {\n                    this._values.push(value);\n                }\n            };\n            MinimalSet.prototype.has = function (value) {\n                return this._values.indexOf(value) !== -1;\n            };\n            Object.defineProperty(MinimalSet.prototype, \"size\", {\n                get: function () {\n                    return this._values.length;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            MinimalSet.prototype.clear = function () {\n                this._values.length = 0;\n            };\n            return MinimalSet;\n        }());\n    }\n    exports.minimalSetImpl = minimalSetImpl;\n    exports.Set = root_1.root.Set || minimalSetImpl();\n});\n\ndefine('rxjs/operators/distinct',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\", \"../util/Set\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1, Set_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n     *\n     * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n     * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n     * source observable directly with an equality check against previous values.\n     *\n     * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n     *\n     * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n     * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n     * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n     * that the internal `Set` can be \"flushed\", basically clearing it of values.\n     *\n     * @example <caption>A simple example with numbers</caption>\n     * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n     *   .distinct()\n     *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n     *\n     * @example <caption>An example using a keySelector function</caption>\n     * interface Person {\n     *    age: number,\n     *    name: string\n     * }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'})\n     *     .distinct((p: Person) => p.name)\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     *\n     * @see {@link distinctUntilChanged}\n     * @see {@link distinctUntilKeyChanged}\n     *\n     * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n     * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n     * @method distinct\n     * @owner Observable\n     */\n    function distinct(keySelector, flushes) {\n        return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };\n    }\n    exports.distinct = distinct;\n    var DistinctOperator = /** @class */ (function () {\n        function DistinctOperator(keySelector, flushes) {\n            this.keySelector = keySelector;\n            this.flushes = flushes;\n        }\n        DistinctOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));\n        };\n        return DistinctOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DistinctSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DistinctSubscriber, _super);\n        function DistinctSubscriber(destination, keySelector, flushes) {\n            var _this = _super.call(this, destination) || this;\n            _this.keySelector = keySelector;\n            _this.values = new Set_1.Set();\n            if (flushes) {\n                _this.add(subscribeToResult_1.subscribeToResult(_this, flushes));\n            }\n            return _this;\n        }\n        DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.values.clear();\n        };\n        DistinctSubscriber.prototype.notifyError = function (error, innerSub) {\n            this._error(error);\n        };\n        DistinctSubscriber.prototype._next = function (value) {\n            if (this.keySelector) {\n                this._useKeySelector(value);\n            }\n            else {\n                this._finalizeNext(value, value);\n            }\n        };\n        DistinctSubscriber.prototype._useKeySelector = function (value) {\n            var key;\n            var destination = this.destination;\n            try {\n                key = this.keySelector(value);\n            }\n            catch (err) {\n                destination.error(err);\n                return;\n            }\n            this._finalizeNext(key, value);\n        };\n        DistinctSubscriber.prototype._finalizeNext = function (key, value) {\n            var values = this.values;\n            if (!values.has(key)) {\n                values.add(key);\n                this.destination.next(value);\n            }\n        };\n        return DistinctSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.DistinctSubscriber = DistinctSubscriber;\n});\n\ndefine('rxjs/operators/distinctUntilChanged',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/tryCatch\", \"../util/errorObject\"], function (require, exports, tslib_1, Subscriber_1, tryCatch_1, errorObject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n     *\n     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n     *\n     * If a comparator function is not provided, an equality check is used by default.\n     *\n     * @example <caption>A simple example with numbers</caption>\n     * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n     *   .distinctUntilChanged()\n     *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n     *\n     * @example <caption>An example using a compare function</caption>\n     * interface Person {\n     *    age: number,\n     *    name: string\n     * }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'})\n     *     { age: 6, name: 'Foo'})\n     *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo' }\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilKeyChanged}\n     *\n     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n     * @method distinctUntilChanged\n     * @owner Observable\n     */\n    function distinctUntilChanged(compare, keySelector) {\n        return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };\n    }\n    exports.distinctUntilChanged = distinctUntilChanged;\n    var DistinctUntilChangedOperator = /** @class */ (function () {\n        function DistinctUntilChangedOperator(compare, keySelector) {\n            this.compare = compare;\n            this.keySelector = keySelector;\n        }\n        DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n        };\n        return DistinctUntilChangedOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DistinctUntilChangedSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DistinctUntilChangedSubscriber, _super);\n        function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.keySelector = keySelector;\n            _this.hasKey = false;\n            if (typeof compare === 'function') {\n                _this.compare = compare;\n            }\n            return _this;\n        }\n        DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n            return x === y;\n        };\n        DistinctUntilChangedSubscriber.prototype._next = function (value) {\n            var keySelector = this.keySelector;\n            var key = value;\n            if (keySelector) {\n                key = tryCatch_1.tryCatch(this.keySelector)(value);\n                if (key === errorObject_1.errorObject) {\n                    return this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            var result = false;\n            if (this.hasKey) {\n                result = tryCatch_1.tryCatch(this.compare)(this.key, key);\n                if (result === errorObject_1.errorObject) {\n                    return this.destination.error(errorObject_1.errorObject.e);\n                }\n            }\n            else {\n                this.hasKey = true;\n            }\n            if (Boolean(result) === false) {\n                this.key = key;\n                this.destination.next(value);\n            }\n        };\n        return DistinctUntilChangedSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/distinctUntilKeyChanged',[\"require\", \"exports\", \"./distinctUntilChanged\"], function (require, exports, distinctUntilChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n     * using a property accessed by using the key provided to check if the two items are distinct.\n     *\n     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n     *\n     * If a comparator function is not provided, an equality check is used by default.\n     *\n     * @example <caption>An example comparing the name of persons</caption>\n     *\n     *  interface Person {\n     *     age: number,\n     *     name: string\n     *  }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'},\n     *     { age: 6, name: 'Foo'})\n     *     .distinctUntilKeyChanged('name')\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo' }\n     *\n     * @example <caption>An example comparing the first letters of the name</caption>\n     *\n     * interface Person {\n     *     age: number,\n     *     name: string\n     *  }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo1'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo2'},\n     *     { age: 6, name: 'Foo3'})\n     *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo1' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo2' }\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilChanged}\n     *\n     * @param {string} key String key for object property lookup on each item.\n     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n     * @method distinctUntilKeyChanged\n     * @owner Observable\n     */\n    function distinctUntilKeyChanged(key, compare) {\n        return distinctUntilChanged_1.distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });\n    }\n    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n});\n\ndefine('rxjs/operators/elementAt',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/ArgumentOutOfRangeError\"], function (require, exports, tslib_1, Subscriber_1, ArgumentOutOfRangeError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the single value at the specified `index` in a sequence of emissions\n     * from the source Observable.\n     *\n     * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n     *\n     * <img src=\"./img/elementAt.png\" width=\"100%\">\n     *\n     * `elementAt` returns an Observable that emits the item at the specified\n     * `index` in the source Observable, or a default value if that `index` is out\n     * of range and the `default` argument is provided. If the `default` argument is\n     * not given and the `index` is out of range, the output Observable will emit an\n     * `ArgumentOutOfRangeError` error.\n     *\n     * @example <caption>Emit only the third click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.elementAt(2);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // click 1 = nothing\n     * // click 2 = nothing\n     * // click 3 = MouseEvent object logged to console\n     *\n     * @see {@link first}\n     * @see {@link last}\n     * @see {@link skip}\n     * @see {@link single}\n     * @see {@link take}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n     * Observable has completed before emitting the i-th `next` notification.\n     *\n     * @param {number} index Is the number `i` for the i-th source emission that has\n     * happened since the subscription, starting from the number `0`.\n     * @param {T} [defaultValue] The default value returned for missing indices.\n     * @return {Observable} An Observable that emits a single item, if it is found.\n     * Otherwise, will emit the default value if given. If not, then emits an error.\n     * @method elementAt\n     * @owner Observable\n     */\n    function elementAt(index, defaultValue) {\n        return function (source) { return source.lift(new ElementAtOperator(index, defaultValue)); };\n    }\n    exports.elementAt = elementAt;\n    var ElementAtOperator = /** @class */ (function () {\n        function ElementAtOperator(index, defaultValue) {\n            this.index = index;\n            this.defaultValue = defaultValue;\n            if (index < 0) {\n                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n            }\n        }\n        ElementAtOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));\n        };\n        return ElementAtOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ElementAtSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ElementAtSubscriber, _super);\n        function ElementAtSubscriber(destination, index, defaultValue) {\n            var _this = _super.call(this, destination) || this;\n            _this.index = index;\n            _this.defaultValue = defaultValue;\n            return _this;\n        }\n        ElementAtSubscriber.prototype._next = function (x) {\n            if (this.index-- === 0) {\n                this.destination.next(x);\n                this.destination.complete();\n            }\n        };\n        ElementAtSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            if (this.index >= 0) {\n                if (typeof this.defaultValue !== 'undefined') {\n                    destination.next(this.defaultValue);\n                }\n                else {\n                    destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);\n                }\n            }\n            destination.complete();\n        };\n        return ElementAtSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/every',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n     *\n     * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n     *  Observable.of(1, 2, 3, 4, 5, 6)\n     *     .every(x => x < 5)\n     *     .subscribe(x => console.log(x)); // -> false\n     *\n     * @param {function} predicate A function for determining if an item meets a specified condition.\n     * @param {any} [thisArg] Optional object to use for `this` in the callback.\n     * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n     * @method every\n     * @owner Observable\n     */\n    function every(predicate, thisArg) {\n        return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };\n    }\n    exports.every = every;\n    var EveryOperator = /** @class */ (function () {\n        function EveryOperator(predicate, thisArg, source) {\n            this.predicate = predicate;\n            this.thisArg = thisArg;\n            this.source = source;\n        }\n        EveryOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));\n        };\n        return EveryOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var EverySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(EverySubscriber, _super);\n        function EverySubscriber(destination, predicate, thisArg, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.thisArg = thisArg;\n            _this.source = source;\n            _this.index = 0;\n            _this.thisArg = thisArg || _this;\n            return _this;\n        }\n        EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {\n            this.destination.next(everyValueMatch);\n            this.destination.complete();\n        };\n        EverySubscriber.prototype._next = function (value) {\n            var result = false;\n            try {\n                result = this.predicate.call(this.thisArg, value, this.index++, this.source);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (!result) {\n                this.notifyComplete(false);\n            }\n        };\n        EverySubscriber.prototype._complete = function () {\n            this.notifyComplete(true);\n        };\n        return EverySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/exhaust',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by dropping\n     * inner Observables while the previous inner Observable has not yet completed.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n     * next inner Observables while the current inner is still executing.</span>\n     *\n     * <img src=\"./img/exhaust.png\" width=\"100%\">\n     *\n     * `exhaust` subscribes to an Observable that emits Observables, also known as a\n     * higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, the output Observable begins emitting the items emitted by that\n     * inner Observable. So far, it behaves like {@link mergeAll}. However,\n     * `exhaust` ignores every new inner Observable if the previous Observable has\n     * not yet completed. Once that one completes, it will accept and flatten the\n     * next inner Observable and repeat this process.\n     *\n     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n     * var result = higherOrder.exhaust();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link switch}\n     * @see {@link mergeAll}\n     * @see {@link exhaustMap}\n     * @see {@link zipAll}\n     *\n     * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n     * exclusively until it completes before subscribing to the next.\n     * @method exhaust\n     * @owner Observable\n     */\n    function exhaust() {\n        return function (source) { return source.lift(new SwitchFirstOperator()); };\n    }\n    exports.exhaust = exhaust;\n    var SwitchFirstOperator = /** @class */ (function () {\n        function SwitchFirstOperator() {\n        }\n        SwitchFirstOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SwitchFirstSubscriber(subscriber));\n        };\n        return SwitchFirstOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SwitchFirstSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SwitchFirstSubscriber, _super);\n        function SwitchFirstSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.hasCompleted = false;\n            _this.hasSubscription = false;\n            return _this;\n        }\n        SwitchFirstSubscriber.prototype._next = function (value) {\n            if (!this.hasSubscription) {\n                this.hasSubscription = true;\n                this.add(subscribeToResult_1.subscribeToResult(this, value));\n            }\n        };\n        SwitchFirstSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (!this.hasSubscription) {\n                this.destination.complete();\n            }\n        };\n        SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.remove(innerSub);\n            this.hasSubscription = false;\n            if (this.hasCompleted) {\n                this.destination.complete();\n            }\n        };\n        return SwitchFirstSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/exhaustMap',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable only if the previous projected Observable has completed.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link exhaust}.</span>\n     *\n     * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. When it projects a source value to\n     * an Observable, the output Observable begins emitting the items emitted by\n     * that projected Observable. However, `exhaustMap` ignores every new projected\n     * Observable if the previous projected Observable has not yet completed. Once\n     * that one completes, it will accept and flatten the next projected Observable\n     * and repeat this process.\n     *\n     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaust}\n     * @see {@link mergeMap}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable containing projected Observables\n     * of each item of the source, ignoring projected Observables that start before\n     * their preceding Observable has completed.\n     * @method exhaustMap\n     * @owner Observable\n     */\n    function exhaustMap(project, resultSelector) {\n        return function (source) { return source.lift(new SwitchFirstMapOperator(project, resultSelector)); };\n    }\n    exports.exhaustMap = exhaustMap;\n    var SwitchFirstMapOperator = /** @class */ (function () {\n        function SwitchFirstMapOperator(project, resultSelector) {\n            this.project = project;\n            this.resultSelector = resultSelector;\n        }\n        SwitchFirstMapOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));\n        };\n        return SwitchFirstMapOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SwitchFirstMapSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SwitchFirstMapSubscriber, _super);\n        function SwitchFirstMapSubscriber(destination, project, resultSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.resultSelector = resultSelector;\n            _this.hasSubscription = false;\n            _this.hasCompleted = false;\n            _this.index = 0;\n            return _this;\n        }\n        SwitchFirstMapSubscriber.prototype._next = function (value) {\n            if (!this.hasSubscription) {\n                this.tryNext(value);\n            }\n        };\n        SwitchFirstMapSubscriber.prototype.tryNext = function (value) {\n            var index = this.index++;\n            var destination = this.destination;\n            try {\n                var result = this.project(value, index);\n                this.hasSubscription = true;\n                this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n            }\n            catch (err) {\n                destination.error(err);\n            }\n        };\n        SwitchFirstMapSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (!this.hasSubscription) {\n                this.destination.complete();\n            }\n        };\n        SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            if (resultSelector) {\n                this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                destination.next(innerValue);\n            }\n        };\n        SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            try {\n                var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n                destination.next(result);\n            }\n            catch (err) {\n                destination.error(err);\n            }\n        };\n        SwitchFirstMapSubscriber.prototype.notifyError = function (err) {\n            this.destination.error(err);\n        };\n        SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.remove(innerSub);\n            this.hasSubscription = false;\n            if (this.hasCompleted) {\n                this.destination.complete();\n            }\n        };\n        return SwitchFirstMapSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/expand',[\"require\", \"exports\", \"tslib\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Recursively projects each source value to an Observable which is merged in\n     * the output Observable.\n     *\n     * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n     * projection function to every source value as well as every output value.\n     * It's recursive.</span>\n     *\n     * <img src=\"./img/expand.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an Observable, and then merging those resulting Observables and\n     * emitting the results of this merger. *Expand* will re-emit on the output\n     * Observable every source value. Then, each output value is given to the\n     * `project` function which returns an inner Observable to be merged on the\n     * output Observable. Those output values resulting from the projection are also\n     * given to the `project` function to produce new output values. This is how\n     * *expand* behaves recursively.\n     *\n     * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var powersOfTwo = clicks\n     *   .mapTo(1)\n     *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n     *   .take(10);\n     * powersOfTwo.subscribe(x => console.log(x));\n     *\n     * @see {@link mergeMap}\n     * @see {@link mergeScan}\n     *\n     * @param {function(value: T, index: number) => Observable} project A function\n     * that, when applied to an item emitted by the source or the output Observable,\n     * returns an Observable.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n     * each projected inner Observable.\n     * @return {Observable} An Observable that emits the source values and also\n     * result of applying the projection function to each value emitted on the\n     * output Observable and and merging the results of the Observables obtained\n     * from this transformation.\n     * @method expand\n     * @owner Observable\n     */\n    function expand(project, concurrent, scheduler) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        if (scheduler === void 0) { scheduler = undefined; }\n        concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n        return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };\n    }\n    exports.expand = expand;\n    var ExpandOperator = /** @class */ (function () {\n        function ExpandOperator(project, concurrent, scheduler) {\n            this.project = project;\n            this.concurrent = concurrent;\n            this.scheduler = scheduler;\n        }\n        ExpandOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));\n        };\n        return ExpandOperator;\n    }());\n    exports.ExpandOperator = ExpandOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ExpandSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ExpandSubscriber, _super);\n        function ExpandSubscriber(destination, project, concurrent, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.concurrent = concurrent;\n            _this.scheduler = scheduler;\n            _this.index = 0;\n            _this.active = 0;\n            _this.hasCompleted = false;\n            if (concurrent < Number.POSITIVE_INFINITY) {\n                _this.buffer = [];\n            }\n            return _this;\n        }\n        ExpandSubscriber.dispatch = function (arg) {\n            var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;\n            subscriber.subscribeToProjection(result, value, index);\n        };\n        ExpandSubscriber.prototype._next = function (value) {\n            var destination = this.destination;\n            if (destination.closed) {\n                this._complete();\n                return;\n            }\n            var index = this.index++;\n            if (this.active < this.concurrent) {\n                destination.next(value);\n                var result = tryCatch_1.tryCatch(this.project)(value, index);\n                if (result === errorObject_1.errorObject) {\n                    destination.error(errorObject_1.errorObject.e);\n                }\n                else if (!this.scheduler) {\n                    this.subscribeToProjection(result, value, index);\n                }\n                else {\n                    var state = { subscriber: this, result: result, value: value, index: index };\n                    this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));\n                }\n            }\n            else {\n                this.buffer.push(value);\n            }\n        };\n        ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {\n            this.active++;\n            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));\n        };\n        ExpandSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (this.hasCompleted && this.active === 0) {\n                this.destination.complete();\n            }\n        };\n        ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this._next(innerValue);\n        };\n        ExpandSubscriber.prototype.notifyComplete = function (innerSub) {\n            var buffer = this.buffer;\n            this.remove(innerSub);\n            this.active--;\n            if (buffer && buffer.length > 0) {\n                this._next(buffer.shift());\n            }\n            if (this.hasCompleted && this.active === 0) {\n                this.destination.complete();\n            }\n        };\n        return ExpandSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.ExpandSubscriber = ExpandSubscriber;\n});\n\ndefine('rxjs/operators/filter',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Filter items emitted by the source Observable by only emitting those that\n     * satisfy a specified predicate.\n     *\n     * <span class=\"informal\">Like\n     * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n     * it only emits a value from the source if it passes a criterion function.</span>\n     *\n     * <img src=\"./img/filter.png\" width=\"100%\">\n     *\n     * Similar to the well-known `Array.prototype.filter` method, this operator\n     * takes values from the source Observable, passes them through a `predicate`\n     * function and only emits those values that yielded `true`.\n     *\n     * @example <caption>Emit only click events whose target was a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n     * clicksOnDivs.subscribe(x => console.log(x));\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilChanged}\n     * @see {@link distinctUntilKeyChanged}\n     * @see {@link ignoreElements}\n     * @see {@link partition}\n     * @see {@link skip}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates each value emitted by the source Observable. If it returns `true`,\n     * the value is emitted, if `false` the value is not passed to the output\n     * Observable. The `index` parameter is the number `i` for the i-th source\n     * emission that has happened since the subscription, starting from the number\n     * `0`.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable} An Observable of values from the source that were\n     * allowed by the `predicate` function.\n     * @method filter\n     * @owner Observable\n     */\n    function filter(predicate, thisArg) {\n        return function filterOperatorFunction(source) {\n            return source.lift(new FilterOperator(predicate, thisArg));\n        };\n    }\n    exports.filter = filter;\n    var FilterOperator = /** @class */ (function () {\n        function FilterOperator(predicate, thisArg) {\n            this.predicate = predicate;\n            this.thisArg = thisArg;\n        }\n        FilterOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n        };\n        return FilterOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var FilterSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(FilterSubscriber, _super);\n        function FilterSubscriber(destination, predicate, thisArg) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.thisArg = thisArg;\n            _this.count = 0;\n            return _this;\n        }\n        // the try catch block below is left specifically for\n        // optimization and perf reasons. a tryCatcher is not necessary here.\n        FilterSubscriber.prototype._next = function (value) {\n            var result;\n            try {\n                result = this.predicate.call(this.thisArg, value, this.count++);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (result) {\n                this.destination.next(value);\n            }\n        };\n        return FilterSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/finalize',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Subscription\"], function (require, exports, tslib_1, Subscriber_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable, but will call a specified function when\n     * the source terminates on complete or error.\n     * @param {function} callback Function to be called when source terminates.\n     * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n     * @method finally\n     * @owner Observable\n     */\n    function finalize(callback) {\n        return function (source) { return source.lift(new FinallyOperator(callback)); };\n    }\n    exports.finalize = finalize;\n    var FinallyOperator = /** @class */ (function () {\n        function FinallyOperator(callback) {\n            this.callback = callback;\n        }\n        FinallyOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new FinallySubscriber(subscriber, this.callback));\n        };\n        return FinallyOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var FinallySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(FinallySubscriber, _super);\n        function FinallySubscriber(destination, callback) {\n            var _this = _super.call(this, destination) || this;\n            _this.add(new Subscription_1.Subscription(callback));\n            return _this;\n        }\n        return FinallySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/find',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first value emitted by the source Observable that meets some\n     * condition.\n     *\n     * <span class=\"informal\">Finds the first value that passes some test and emits\n     * that.</span>\n     *\n     * <img src=\"./img/find.png\" width=\"100%\">\n     *\n     * `find` searches for the first item in the source Observable that matches the\n     * specified condition embodied by the `predicate`, and returns the first\n     * occurrence in the source. Unlike {@link first}, the `predicate` is required\n     * in `find`, and does not emit an error if a valid value is not found.\n     *\n     * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link first}\n     * @see {@link findIndex}\n     * @see {@link take}\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n     * A function called with each item to test for condition matching.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable<T>} An Observable of the first item that matches the\n     * condition.\n     * @method find\n     * @owner Observable\n     */\n    function find(predicate, thisArg) {\n        if (typeof predicate !== 'function') {\n            throw new TypeError('predicate is not a function');\n        }\n        return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };\n    }\n    exports.find = find;\n    var FindValueOperator = /** @class */ (function () {\n        function FindValueOperator(predicate, source, yieldIndex, thisArg) {\n            this.predicate = predicate;\n            this.source = source;\n            this.yieldIndex = yieldIndex;\n            this.thisArg = thisArg;\n        }\n        FindValueOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));\n        };\n        return FindValueOperator;\n    }());\n    exports.FindValueOperator = FindValueOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var FindValueSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(FindValueSubscriber, _super);\n        function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.source = source;\n            _this.yieldIndex = yieldIndex;\n            _this.thisArg = thisArg;\n            _this.index = 0;\n            return _this;\n        }\n        FindValueSubscriber.prototype.notifyComplete = function (value) {\n            var destination = this.destination;\n            destination.next(value);\n            destination.complete();\n        };\n        FindValueSubscriber.prototype._next = function (value) {\n            var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;\n            var index = this.index++;\n            try {\n                var result = predicate.call(thisArg || this, value, index, this.source);\n                if (result) {\n                    this.notifyComplete(this.yieldIndex ? index : value);\n                }\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        FindValueSubscriber.prototype._complete = function () {\n            this.notifyComplete(this.yieldIndex ? -1 : undefined);\n        };\n        return FindValueSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.FindValueSubscriber = FindValueSubscriber;\n});\n\ndefine('rxjs/operators/findIndex',[\"require\", \"exports\", \"../operators/find\"], function (require, exports, find_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the index of the first value emitted by the source Observable that\n     * meets some condition.\n     *\n     * <span class=\"informal\">It's like {@link find}, but emits the index of the\n     * found value, not the value itself.</span>\n     *\n     * <img src=\"./img/findIndex.png\" width=\"100%\">\n     *\n     * `findIndex` searches for the first item in the source Observable that matches\n     * the specified condition embodied by the `predicate`, and returns the\n     * (zero-based) index of the first occurrence in the source. Unlike\n     * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n     * an error if a valid value is not found.\n     *\n     * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link find}\n     * @see {@link first}\n     * @see {@link take}\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n     * A function called with each item to test for condition matching.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable} An Observable of the index of the first item that\n     * matches the condition.\n     * @method find\n     * @owner Observable\n     */\n    function findIndex(predicate, thisArg) {\n        return function (source) { return source.lift(new find_1.FindValueOperator(predicate, source, true, thisArg)); };\n    }\n    exports.findIndex = findIndex;\n});\n\ndefine('rxjs/operators/first',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/EmptyError\"], function (require, exports, tslib_1, Subscriber_1, EmptyError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first value (or the first value that meets some condition)\n     * emitted by the source Observable.\n     *\n     * <span class=\"informal\">Emits only the first value. Or emits only the first\n     * value that passes some test.</span>\n     *\n     * <img src=\"./img/first.png\" width=\"100%\">\n     *\n     * If called with no arguments, `first` emits the first value of the source\n     * Observable, then completes. If called with a `predicate` function, `first`\n     * emits the first value of the source that matches the specified condition. It\n     * may also take a `resultSelector` function to produce the output value from\n     * the input value, and a `defaultValue` to emit in case the source completes\n     * before it is able to emit a valid value. Throws an error if `defaultValue`\n     * was not provided and a matching element is not found.\n     *\n     * @example <caption>Emit only the first click that happens on the DOM</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.first();\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits the first click that happens on a DIV</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link find}\n     * @see {@link take}\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n     * An optional function called with each item to test for condition matching.\n     * @param {function(value: T, index: number): R} [resultSelector] A function to\n     * produce the value on the output Observable based on the values\n     * and the indices of the source Observable. The arguments passed to this\n     * function are:\n     * - `value`: the value that was emitted on the source.\n     * - `index`: the \"index\" of the value from the source.\n     * @param {R} [defaultValue] The default value emitted in case no valid value\n     * was found on the source.\n     * @return {Observable<T|R>} An Observable of the first item that matches the\n     * condition.\n     * @method first\n     * @owner Observable\n     */\n    function first(predicate, resultSelector, defaultValue) {\n        return function (source) { return source.lift(new FirstOperator(predicate, resultSelector, defaultValue, source)); };\n    }\n    exports.first = first;\n    var FirstOperator = /** @class */ (function () {\n        function FirstOperator(predicate, resultSelector, defaultValue, source) {\n            this.predicate = predicate;\n            this.resultSelector = resultSelector;\n            this.defaultValue = defaultValue;\n            this.source = source;\n        }\n        FirstOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n        };\n        return FirstOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var FirstSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(FirstSubscriber, _super);\n        function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.resultSelector = resultSelector;\n            _this.defaultValue = defaultValue;\n            _this.source = source;\n            _this.index = 0;\n            _this.hasCompleted = false;\n            _this._emitted = false;\n            return _this;\n        }\n        FirstSubscriber.prototype._next = function (value) {\n            var index = this.index++;\n            if (this.predicate) {\n                this._tryPredicate(value, index);\n            }\n            else {\n                this._emit(value, index);\n            }\n        };\n        FirstSubscriber.prototype._tryPredicate = function (value, index) {\n            var result;\n            try {\n                result = this.predicate(value, index, this.source);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (result) {\n                this._emit(value, index);\n            }\n        };\n        FirstSubscriber.prototype._emit = function (value, index) {\n            if (this.resultSelector) {\n                this._tryResultSelector(value, index);\n                return;\n            }\n            this._emitFinal(value);\n        };\n        FirstSubscriber.prototype._tryResultSelector = function (value, index) {\n            var result;\n            try {\n                result = this.resultSelector(value, index);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this._emitFinal(result);\n        };\n        FirstSubscriber.prototype._emitFinal = function (value) {\n            var destination = this.destination;\n            if (!this._emitted) {\n                this._emitted = true;\n                destination.next(value);\n                destination.complete();\n                this.hasCompleted = true;\n            }\n        };\n        FirstSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {\n                destination.next(this.defaultValue);\n                destination.complete();\n            }\n            else if (!this.hasCompleted) {\n                destination.error(new EmptyError_1.EmptyError);\n            }\n        };\n        return FirstSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/util/MapPolyfill',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var MapPolyfill = /** @class */ (function () {\n        function MapPolyfill() {\n            this.size = 0;\n            this._values = [];\n            this._keys = [];\n        }\n        MapPolyfill.prototype.get = function (key) {\n            var i = this._keys.indexOf(key);\n            return i === -1 ? undefined : this._values[i];\n        };\n        MapPolyfill.prototype.set = function (key, value) {\n            var i = this._keys.indexOf(key);\n            if (i === -1) {\n                this._keys.push(key);\n                this._values.push(value);\n                this.size++;\n            }\n            else {\n                this._values[i] = value;\n            }\n            return this;\n        };\n        MapPolyfill.prototype.delete = function (key) {\n            var i = this._keys.indexOf(key);\n            if (i === -1) {\n                return false;\n            }\n            this._values.splice(i, 1);\n            this._keys.splice(i, 1);\n            this.size--;\n            return true;\n        };\n        MapPolyfill.prototype.clear = function () {\n            this._keys.length = 0;\n            this._values.length = 0;\n            this.size = 0;\n        };\n        MapPolyfill.prototype.forEach = function (cb, thisArg) {\n            for (var i = 0; i < this.size; i++) {\n                cb.call(thisArg, this._values[i], this._keys[i]);\n            }\n        };\n        return MapPolyfill;\n    }());\n    exports.MapPolyfill = MapPolyfill;\n});\n\ndefine('rxjs/util/Map',[\"require\", \"exports\", \"./root\", \"./MapPolyfill\"], function (require, exports, root_1, MapPolyfill_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();\n});\n\ndefine('rxjs/util/FastMap',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var FastMap = /** @class */ (function () {\n        function FastMap() {\n            this.values = {};\n        }\n        FastMap.prototype.delete = function (key) {\n            this.values[key] = null;\n            return true;\n        };\n        FastMap.prototype.set = function (key, value) {\n            this.values[key] = value;\n            return this;\n        };\n        FastMap.prototype.get = function (key) {\n            return this.values[key];\n        };\n        FastMap.prototype.forEach = function (cb, thisArg) {\n            var values = this.values;\n            for (var key in values) {\n                if (values.hasOwnProperty(key) && values[key] !== null) {\n                    cb.call(thisArg, values[key], key);\n                }\n            }\n        };\n        FastMap.prototype.clear = function () {\n            this.values = {};\n        };\n        return FastMap;\n    }());\n    exports.FastMap = FastMap;\n});\n\ndefine('rxjs/operators/groupBy',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Subscription\", \"../Observable\", \"../Subject\", \"../util/Map\", \"../util/FastMap\"], function (require, exports, tslib_1, Subscriber_1, Subscription_1, Observable_1, Subject_1, Map_1, FastMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Groups the items emitted by an Observable according to a specified criterion,\n     * and emits these grouped items as `GroupedObservables`, one\n     * {@link GroupedObservable} per group.\n     *\n     * <img src=\"./img/groupBy.png\" width=\"100%\">\n     *\n     * @example <caption>Group objects by id and return as array</caption>\n     * Observable.of<Obj>({id: 1, name: 'aze1'},\n     *                    {id: 2, name: 'sf2'},\n     *                    {id: 2, name: 'dg2'},\n     *                    {id: 1, name: 'erg1'},\n     *                    {id: 1, name: 'df1'},\n     *                    {id: 2, name: 'sfqfb2'},\n     *                    {id: 3, name: 'qfs3'},\n     *                    {id: 2, name: 'qsgqsfg2'}\n     *     )\n     *     .groupBy(p => p.id)\n     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n     *     .subscribe(p => console.log(p));\n     *\n     * // displays:\n     * // [ { id: 1, name: 'aze1' },\n     * //   { id: 1, name: 'erg1' },\n     * //   { id: 1, name: 'df1' } ]\n     * //\n     * // [ { id: 2, name: 'sf2' },\n     * //   { id: 2, name: 'dg2' },\n     * //   { id: 2, name: 'sfqfb2' },\n     * //   { id: 2, name: 'qsgqsfg2' } ]\n     * //\n     * // [ { id: 3, name: 'qfs3' } ]\n     *\n     * @example <caption>Pivot data on the id field</caption>\n     * Observable.of<Obj>({id: 1, name: 'aze1'},\n     *                    {id: 2, name: 'sf2'},\n     *                    {id: 2, name: 'dg2'},\n     *                    {id: 1, name: 'erg1'},\n     *                    {id: 1, name: 'df1'},\n     *                    {id: 2, name: 'sfqfb2'},\n     *                    {id: 3, name: 'qfs1'},\n     *                    {id: 2, name: 'qsgqsfg2'}\n     *                   )\n     *     .groupBy(p => p.id, p => p.name)\n     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n     *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n     *     .subscribe(p => console.log(p));\n     *\n     * // displays:\n     * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n     * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n     * // { id: 3, values: [ 'qfs1' ] }\n     *\n     * @param {function(value: T): K} keySelector A function that extracts the key\n     * for each item.\n     * @param {function(value: T): R} [elementSelector] A function that extracts the\n     * return element for each item.\n     * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n     * A function that returns an Observable to determine how long each group should\n     * exist.\n     * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n     * GroupedObservables, each of which corresponds to a unique key value and each\n     * of which emits those items from the source Observable that share that key\n     * value.\n     * @method groupBy\n     * @owner Observable\n     */\n    function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n        return function (source) {\n            return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));\n        };\n    }\n    exports.groupBy = groupBy;\n    var GroupByOperator = /** @class */ (function () {\n        function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {\n            this.keySelector = keySelector;\n            this.elementSelector = elementSelector;\n            this.durationSelector = durationSelector;\n            this.subjectSelector = subjectSelector;\n        }\n        GroupByOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));\n        };\n        return GroupByOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var GroupBySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(GroupBySubscriber, _super);\n        function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.keySelector = keySelector;\n            _this.elementSelector = elementSelector;\n            _this.durationSelector = durationSelector;\n            _this.subjectSelector = subjectSelector;\n            _this.groups = null;\n            _this.attemptedToUnsubscribe = false;\n            _this.count = 0;\n            return _this;\n        }\n        GroupBySubscriber.prototype._next = function (value) {\n            var key;\n            try {\n                key = this.keySelector(value);\n            }\n            catch (err) {\n                this.error(err);\n                return;\n            }\n            this._group(value, key);\n        };\n        GroupBySubscriber.prototype._group = function (value, key) {\n            var groups = this.groups;\n            if (!groups) {\n                groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();\n            }\n            var group = groups.get(key);\n            var element;\n            if (this.elementSelector) {\n                try {\n                    element = this.elementSelector(value);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            }\n            else {\n                element = value;\n            }\n            if (!group) {\n                group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();\n                groups.set(key, group);\n                var groupedObservable = new GroupedObservable(key, group, this);\n                this.destination.next(groupedObservable);\n                if (this.durationSelector) {\n                    var duration = void 0;\n                    try {\n                        duration = this.durationSelector(new GroupedObservable(key, group));\n                    }\n                    catch (err) {\n                        this.error(err);\n                        return;\n                    }\n                    this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));\n                }\n            }\n            if (!group.closed) {\n                group.next(element);\n            }\n        };\n        GroupBySubscriber.prototype._error = function (err) {\n            var groups = this.groups;\n            if (groups) {\n                groups.forEach(function (group, key) {\n                    group.error(err);\n                });\n                groups.clear();\n            }\n            this.destination.error(err);\n        };\n        GroupBySubscriber.prototype._complete = function () {\n            var groups = this.groups;\n            if (groups) {\n                groups.forEach(function (group, key) {\n                    group.complete();\n                });\n                groups.clear();\n            }\n            this.destination.complete();\n        };\n        GroupBySubscriber.prototype.removeGroup = function (key) {\n            this.groups.delete(key);\n        };\n        GroupBySubscriber.prototype.unsubscribe = function () {\n            if (!this.closed) {\n                this.attemptedToUnsubscribe = true;\n                if (this.count === 0) {\n                    _super.prototype.unsubscribe.call(this);\n                }\n            }\n        };\n        return GroupBySubscriber;\n    }(Subscriber_1.Subscriber));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var GroupDurationSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(GroupDurationSubscriber, _super);\n        function GroupDurationSubscriber(key, group, parent) {\n            var _this = _super.call(this, group) || this;\n            _this.key = key;\n            _this.group = group;\n            _this.parent = parent;\n            return _this;\n        }\n        GroupDurationSubscriber.prototype._next = function (value) {\n            this.complete();\n        };\n        GroupDurationSubscriber.prototype._unsubscribe = function () {\n            var _a = this, parent = _a.parent, key = _a.key;\n            this.key = this.parent = null;\n            if (parent) {\n                parent.removeGroup(key);\n            }\n        };\n        return GroupDurationSubscriber;\n    }(Subscriber_1.Subscriber));\n    /**\n     * An Observable representing values belonging to the same group represented by\n     * a common key. The values emitted by a GroupedObservable come from the source\n     * Observable. The common key is available as the field `key` on a\n     * GroupedObservable instance.\n     *\n     * @class GroupedObservable<K, T>\n     */\n    var GroupedObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(GroupedObservable, _super);\n        function GroupedObservable(key, groupSubject, refCountSubscription) {\n            var _this = _super.call(this) || this;\n            _this.key = key;\n            _this.groupSubject = groupSubject;\n            _this.refCountSubscription = refCountSubscription;\n            return _this;\n        }\n        GroupedObservable.prototype._subscribe = function (subscriber) {\n            var subscription = new Subscription_1.Subscription();\n            var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;\n            if (refCountSubscription && !refCountSubscription.closed) {\n                subscription.add(new InnerRefCountSubscription(refCountSubscription));\n            }\n            subscription.add(groupSubject.subscribe(subscriber));\n            return subscription;\n        };\n        return GroupedObservable;\n    }(Observable_1.Observable));\n    exports.GroupedObservable = GroupedObservable;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var InnerRefCountSubscription = /** @class */ (function (_super) {\n        tslib_1.__extends(InnerRefCountSubscription, _super);\n        function InnerRefCountSubscription(parent) {\n            var _this = _super.call(this) || this;\n            _this.parent = parent;\n            parent.count++;\n            return _this;\n        }\n        InnerRefCountSubscription.prototype.unsubscribe = function () {\n            var parent = this.parent;\n            if (!parent.closed && !this.closed) {\n                _super.prototype.unsubscribe.call(this);\n                parent.count -= 1;\n                if (parent.count === 0 && parent.attemptedToUnsubscribe) {\n                    parent.unsubscribe();\n                }\n            }\n        };\n        return InnerRefCountSubscription;\n    }(Subscription_1.Subscription));\n});\n\ndefine('rxjs/operators/ignoreElements',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/noop\"], function (require, exports, tslib_1, Subscriber_1, noop_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n     *\n     * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n     *\n     * @return {Observable} An empty Observable that only calls `complete`\n     * or `error`, based on which one is called by the source Observable.\n     * @method ignoreElements\n     * @owner Observable\n     */\n    function ignoreElements() {\n        return function ignoreElementsOperatorFunction(source) {\n            return source.lift(new IgnoreElementsOperator());\n        };\n    }\n    exports.ignoreElements = ignoreElements;\n    var IgnoreElementsOperator = /** @class */ (function () {\n        function IgnoreElementsOperator() {\n        }\n        IgnoreElementsOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new IgnoreElementsSubscriber(subscriber));\n        };\n        return IgnoreElementsOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var IgnoreElementsSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(IgnoreElementsSubscriber, _super);\n        function IgnoreElementsSubscriber() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        IgnoreElementsSubscriber.prototype._next = function (unused) {\n            noop_1.noop();\n        };\n        return IgnoreElementsSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/isEmpty',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function isEmpty() {\n        return function (source) { return source.lift(new IsEmptyOperator()); };\n    }\n    exports.isEmpty = isEmpty;\n    var IsEmptyOperator = /** @class */ (function () {\n        function IsEmptyOperator() {\n        }\n        IsEmptyOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new IsEmptySubscriber(observer));\n        };\n        return IsEmptyOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var IsEmptySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(IsEmptySubscriber, _super);\n        function IsEmptySubscriber(destination) {\n            return _super.call(this, destination) || this;\n        }\n        IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {\n            var destination = this.destination;\n            destination.next(isEmpty);\n            destination.complete();\n        };\n        IsEmptySubscriber.prototype._next = function (value) {\n            this.notifyComplete(false);\n        };\n        IsEmptySubscriber.prototype._complete = function () {\n            this.notifyComplete(true);\n        };\n        return IsEmptySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/last',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/EmptyError\"], function (require, exports, tslib_1, Subscriber_1, EmptyError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits only the last item emitted by the source Observable.\n     * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n     * the last item from the source Observable, the resulting Observable will emit the last item\n     * from the source Observable that satisfies the predicate.\n     *\n     * <img src=\"./img/last.png\" width=\"100%\">\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     * @param {function} predicate - The condition any source emitted item has to satisfy.\n     * @return {Observable} An Observable that emits only the last item satisfying the given condition\n     * from the source, or an NoSuchElementException if no such items are emitted.\n     * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n     * @method last\n     * @owner Observable\n     */\n    function last(predicate, resultSelector, defaultValue) {\n        return function (source) { return source.lift(new LastOperator(predicate, resultSelector, defaultValue, source)); };\n    }\n    exports.last = last;\n    var LastOperator = /** @class */ (function () {\n        function LastOperator(predicate, resultSelector, defaultValue, source) {\n            this.predicate = predicate;\n            this.resultSelector = resultSelector;\n            this.defaultValue = defaultValue;\n            this.source = source;\n        }\n        LastOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));\n        };\n        return LastOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var LastSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(LastSubscriber, _super);\n        function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.resultSelector = resultSelector;\n            _this.defaultValue = defaultValue;\n            _this.source = source;\n            _this.hasValue = false;\n            _this.index = 0;\n            if (typeof defaultValue !== 'undefined') {\n                _this.lastValue = defaultValue;\n                _this.hasValue = true;\n            }\n            return _this;\n        }\n        LastSubscriber.prototype._next = function (value) {\n            var index = this.index++;\n            if (this.predicate) {\n                this._tryPredicate(value, index);\n            }\n            else {\n                if (this.resultSelector) {\n                    this._tryResultSelector(value, index);\n                    return;\n                }\n                this.lastValue = value;\n                this.hasValue = true;\n            }\n        };\n        LastSubscriber.prototype._tryPredicate = function (value, index) {\n            var result;\n            try {\n                result = this.predicate(value, index, this.source);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            if (result) {\n                if (this.resultSelector) {\n                    this._tryResultSelector(value, index);\n                    return;\n                }\n                this.lastValue = value;\n                this.hasValue = true;\n            }\n        };\n        LastSubscriber.prototype._tryResultSelector = function (value, index) {\n            var result;\n            try {\n                result = this.resultSelector(value, index);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.lastValue = result;\n            this.hasValue = true;\n        };\n        LastSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            if (this.hasValue) {\n                destination.next(this.lastValue);\n                destination.complete();\n            }\n            else {\n                destination.error(new EmptyError_1.EmptyError);\n            }\n        };\n        return LastSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/mapTo',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the given constant value on the output Observable every time the source\n     * Observable emits a value.\n     *\n     * <span class=\"informal\">Like {@link map}, but it maps every source value to\n     * the same output value every time.</span>\n     *\n     * <img src=\"./img/mapTo.png\" width=\"100%\">\n     *\n     * Takes a constant `value` as argument, and emits that whenever the source\n     * Observable emits a value. In other words, ignores the actual source value,\n     * and simply uses the emission moment to know when to emit the given `value`.\n     *\n     * @example <caption>Map every click to the string 'Hi'</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var greetings = clicks.mapTo('Hi');\n     * greetings.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     *\n     * @param {any} value The value to map each source value to.\n     * @return {Observable} An Observable that emits the given `value` every time\n     * the source Observable emits something.\n     * @method mapTo\n     * @owner Observable\n     */\n    function mapTo(value) {\n        return function (source) { return source.lift(new MapToOperator(value)); };\n    }\n    exports.mapTo = mapTo;\n    var MapToOperator = /** @class */ (function () {\n        function MapToOperator(value) {\n            this.value = value;\n        }\n        MapToOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new MapToSubscriber(subscriber, this.value));\n        };\n        return MapToOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MapToSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MapToSubscriber, _super);\n        function MapToSubscriber(destination, value) {\n            var _this = _super.call(this, destination) || this;\n            _this.value = value;\n            return _this;\n        }\n        MapToSubscriber.prototype._next = function (x) {\n            this.destination.next(this.value);\n        };\n        return MapToSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/materialize',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Notification\"], function (require, exports, tslib_1, Subscriber_1, Notification_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represents all of the notifications from the source Observable as `next`\n     * emissions marked with their original types within {@link Notification}\n     * objects.\n     *\n     * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n     * {@link Notification} objects, emitted as `next` on the output Observable.\n     * </span>\n     *\n     * <img src=\"./img/materialize.png\" width=\"100%\">\n     *\n     * `materialize` returns an Observable that emits a `next` notification for each\n     * `next`, `error`, or `complete` emission of the source Observable. When the\n     * source Observable emits `complete`, the output Observable will emit `next` as\n     * a Notification of type \"complete\", and then it will emit `complete` as well.\n     * When the source Observable emits `error`, the output will emit `next` as a\n     * Notification of type \"error\", and then `complete`.\n     *\n     * This operator is useful for producing metadata of the source Observable, to\n     * be consumed as `next` emissions. Use it in conjunction with\n     * {@link dematerialize}.\n     *\n     * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n     * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n     * var upperCase = letters.map(x => x.toUpperCase());\n     * var materialized = upperCase.materialize();\n     * materialized.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n     * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n     * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n     * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n     * //   [as project] (http://1…, hasValue: false}\n     *\n     * @see {@link Notification}\n     * @see {@link dematerialize}\n     *\n     * @return {Observable<Notification<T>>} An Observable that emits\n     * {@link Notification} objects that wrap the original emissions from the source\n     * Observable with metadata.\n     * @method materialize\n     * @owner Observable\n     */\n    function materialize() {\n        return function materializeOperatorFunction(source) {\n            return source.lift(new MaterializeOperator());\n        };\n    }\n    exports.materialize = materialize;\n    var MaterializeOperator = /** @class */ (function () {\n        function MaterializeOperator() {\n        }\n        MaterializeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new MaterializeSubscriber(subscriber));\n        };\n        return MaterializeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MaterializeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MaterializeSubscriber, _super);\n        function MaterializeSubscriber(destination) {\n            return _super.call(this, destination) || this;\n        }\n        MaterializeSubscriber.prototype._next = function (value) {\n            this.destination.next(Notification_1.Notification.createNext(value));\n        };\n        MaterializeSubscriber.prototype._error = function (err) {\n            var destination = this.destination;\n            destination.next(Notification_1.Notification.createError(err));\n            destination.complete();\n        };\n        MaterializeSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            destination.next(Notification_1.Notification.createComplete());\n            destination.complete();\n        };\n        return MaterializeSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/scan',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Applies an accumulator function over the source Observable, and returns each\n     * intermediate result, with an optional seed value.\n     *\n     * <span class=\"informal\">It's like {@link reduce}, but emits the current\n     * accumulation whenever the source emits a value.</span>\n     *\n     * <img src=\"./img/scan.png\" width=\"100%\">\n     *\n     * Combines together all values emitted on the source, using an accumulator\n     * function that knows how to join a new source value into the accumulation from\n     * the past. Is similar to {@link reduce}, but emits the intermediate\n     * accumulations.\n     *\n     * Returns an Observable that applies a specified `accumulator` function to each\n     * item emitted by the source Observable. If a `seed` value is specified, then\n     * that value will be used as the initial value for the accumulator. If no seed\n     * value is specified, the first item of the source is used as the seed.\n     *\n     * @example <caption>Count the number of click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var ones = clicks.mapTo(1);\n     * var seed = 0;\n     * var count = ones.scan((acc, one) => acc + one, seed);\n     * count.subscribe(x => console.log(x));\n     *\n     * @see {@link expand}\n     * @see {@link mergeScan}\n     * @see {@link reduce}\n     *\n     * @param {function(acc: R, value: T, index: number): R} accumulator\n     * The accumulator function called on each source value.\n     * @param {T|R} [seed] The initial accumulation value.\n     * @return {Observable<R>} An observable of the accumulated values.\n     * @method scan\n     * @owner Observable\n     */\n    function scan(accumulator, seed) {\n        var hasSeed = false;\n        // providing a seed of `undefined` *should* be valid and trigger\n        // hasSeed! so don't use `seed !== undefined` checks!\n        // For this reason, we have to check it here at the original call site\n        // otherwise inside Operator/Subscriber we won't know if `undefined`\n        // means they didn't provide anything or if they literally provided `undefined`\n        if (arguments.length >= 2) {\n            hasSeed = true;\n        }\n        return function scanOperatorFunction(source) {\n            return source.lift(new ScanOperator(accumulator, seed, hasSeed));\n        };\n    }\n    exports.scan = scan;\n    var ScanOperator = /** @class */ (function () {\n        function ScanOperator(accumulator, seed, hasSeed) {\n            if (hasSeed === void 0) { hasSeed = false; }\n            this.accumulator = accumulator;\n            this.seed = seed;\n            this.hasSeed = hasSeed;\n        }\n        ScanOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));\n        };\n        return ScanOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ScanSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ScanSubscriber, _super);\n        function ScanSubscriber(destination, accumulator, _seed, hasSeed) {\n            var _this = _super.call(this, destination) || this;\n            _this.accumulator = accumulator;\n            _this._seed = _seed;\n            _this.hasSeed = hasSeed;\n            _this.index = 0;\n            return _this;\n        }\n        Object.defineProperty(ScanSubscriber.prototype, \"seed\", {\n            get: function () {\n                return this._seed;\n            },\n            set: function (value) {\n                this.hasSeed = true;\n                this._seed = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ScanSubscriber.prototype._next = function (value) {\n            if (!this.hasSeed) {\n                this.seed = value;\n                this.destination.next(value);\n            }\n            else {\n                return this._tryNext(value);\n            }\n        };\n        ScanSubscriber.prototype._tryNext = function (value) {\n            var index = this.index++;\n            var result;\n            try {\n                result = this.accumulator(this.seed, value, index);\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n            this.seed = result;\n            this.destination.next(result);\n        };\n        return ScanSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/takeLast',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/ArgumentOutOfRangeError\", \"../observable/EmptyObservable\"], function (require, exports, tslib_1, Subscriber_1, ArgumentOutOfRangeError_1, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the last `count` values emitted by the source Observable.\n     *\n     * <span class=\"informal\">Remembers the latest `count` values, then emits those\n     * only when the source completes.</span>\n     *\n     * <img src=\"./img/takeLast.png\" width=\"100%\">\n     *\n     * `takeLast` returns an Observable that emits at most the last `count` values\n     * emitted by the source Observable. If the source emits fewer than `count`\n     * values then all of its values are emitted. This operator must wait until the\n     * `complete` notification emission from the source in order to emit the `next`\n     * values on the output Observable, because otherwise it is impossible to know\n     * whether or not more values will be emitted on the source. For this reason,\n     * all values are emitted synchronously, followed by the complete notification.\n     *\n     * @example <caption>Take the last 3 values of an Observable with many values</caption>\n     * var many = Rx.Observable.range(1, 100);\n     * var lastThree = many.takeLast(3);\n     * lastThree.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeUntil}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n     *\n     * @param {number} count The maximum number of values to emit from the end of\n     * the sequence of values emitted by the source Observable.\n     * @return {Observable<T>} An Observable that emits at most the last count\n     * values emitted by the source Observable.\n     * @method takeLast\n     * @owner Observable\n     */\n    function takeLast(count) {\n        return function takeLastOperatorFunction(source) {\n            if (count === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            else {\n                return source.lift(new TakeLastOperator(count));\n            }\n        };\n    }\n    exports.takeLast = takeLast;\n    var TakeLastOperator = /** @class */ (function () {\n        function TakeLastOperator(total) {\n            this.total = total;\n            if (this.total < 0) {\n                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n            }\n        }\n        TakeLastOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TakeLastSubscriber(subscriber, this.total));\n        };\n        return TakeLastOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TakeLastSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TakeLastSubscriber, _super);\n        function TakeLastSubscriber(destination, total) {\n            var _this = _super.call(this, destination) || this;\n            _this.total = total;\n            _this.ring = new Array();\n            _this.count = 0;\n            return _this;\n        }\n        TakeLastSubscriber.prototype._next = function (value) {\n            var ring = this.ring;\n            var total = this.total;\n            var count = this.count++;\n            if (ring.length < total) {\n                ring.push(value);\n            }\n            else {\n                var index = count % total;\n                ring[index] = value;\n            }\n        };\n        TakeLastSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            var count = this.count;\n            if (count > 0) {\n                var total = this.count >= this.total ? this.total : this.count;\n                var ring = this.ring;\n                for (var i = 0; i < total; i++) {\n                    var idx = (count++) % total;\n                    destination.next(ring[idx]);\n                }\n            }\n            destination.complete();\n        };\n        return TakeLastSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/reduce',[\"require\", \"exports\", \"./scan\", \"./takeLast\", \"./defaultIfEmpty\", \"../util/pipe\"], function (require, exports, scan_1, takeLast_1, defaultIfEmpty_1, pipe_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Applies an accumulator function over the source Observable, and returns the\n     * accumulated result when the source completes, given an optional seed value.\n     *\n     * <span class=\"informal\">Combines together all values emitted on the source,\n     * using an accumulator function that knows how to join a new source value into\n     * the accumulation from the past.</span>\n     *\n     * <img src=\"./img/reduce.png\" width=\"100%\">\n     *\n     * Like\n     * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n     * `reduce` applies an `accumulator` function against an accumulation and each\n     * value of the source Observable (from the past) to reduce it to a single\n     * value, emitted on the output Observable. Note that `reduce` will only emit\n     * one value, only when the source Observable completes. It is equivalent to\n     * applying operator {@link scan} followed by operator {@link last}.\n     *\n     * Returns an Observable that applies a specified `accumulator` function to each\n     * item emitted by the source Observable. If a `seed` value is specified, then\n     * that value will be used as the initial value for the accumulator. If no seed\n     * value is specified, the first item of the source is used as the seed.\n     *\n     * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n     * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n     *   .takeUntil(Rx.Observable.interval(5000));\n     * var ones = clicksInFiveSeconds.mapTo(1);\n     * var seed = 0;\n     * var count = ones.reduce((acc, one) => acc + one, seed);\n     * count.subscribe(x => console.log(x));\n     *\n     * @see {@link count}\n     * @see {@link expand}\n     * @see {@link mergeScan}\n     * @see {@link scan}\n     *\n     * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n     * called on each source value.\n     * @param {R} [seed] The initial accumulation value.\n     * @return {Observable<R>} An Observable that emits a single value that is the\n     * result of accumulating the values emitted by the source Observable.\n     * @method reduce\n     * @owner Observable\n     */\n    function reduce(accumulator, seed) {\n        // providing a seed of `undefined` *should* be valid and trigger\n        // hasSeed! so don't use `seed !== undefined` checks!\n        // For this reason, we have to check it here at the original call site\n        // otherwise inside Operator/Subscriber we won't know if `undefined`\n        // means they didn't provide anything or if they literally provided `undefined`\n        if (arguments.length >= 2) {\n            return function reduceOperatorFunctionWithSeed(source) {\n                return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);\n            };\n        }\n        return function reduceOperatorFunction(source) {\n            return pipe_1.pipe(scan_1.scan(function (acc, value, index) {\n                return accumulator(acc, value, index + 1);\n            }), takeLast_1.takeLast(1))(source);\n        };\n    }\n    exports.reduce = reduce;\n});\n\ndefine('rxjs/operators/max',[\"require\", \"exports\", \"./reduce\"], function (require, exports, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n     * and when source Observable completes it emits a single item: the item with the largest value.\n     *\n     * <img src=\"./img/max.png\" width=\"100%\">\n     *\n     * @example <caption>Get the maximal value of a series of numbers</caption>\n     * Rx.Observable.of(5, 4, 7, 2, 8)\n     *   .max()\n     *   .subscribe(x => console.log(x)); // -> 8\n     *\n     * @example <caption>Use a comparer function to get the maximal item</caption>\n     * interface Person {\n     *   age: number,\n     *   name: string\n     * }\n     * Observable.of<Person>({age: 7, name: 'Foo'},\n     *                       {age: 5, name: 'Bar'},\n     *                       {age: 9, name: 'Beer'})\n     *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n     * }\n     *\n     * @see {@link min}\n     *\n     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n     * value of two items.\n     * @return {Observable} An Observable that emits item with the largest value.\n     * @method max\n     * @owner Observable\n     */\n    function max(comparer) {\n        var max = (typeof comparer === 'function')\n            ? function (x, y) { return comparer(x, y) > 0 ? x : y; }\n            : function (x, y) { return x > y ? x : y; };\n        return reduce_1.reduce(max);\n    }\n    exports.max = max;\n});\n\ndefine('rxjs/observable/merge',[\"require\", \"exports\", \"../Observable\", \"./ArrayObservable\", \"../util/isScheduler\", \"../operators/mergeAll\"], function (require, exports, Observable_1, ArrayObservable_1, isScheduler_1, mergeAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which concurrently emits all values from every\n     * given input Observable.\n     *\n     * <span class=\"informal\">Flattens multiple Observables together by blending\n     * their values into one Observable.</span>\n     *\n     * <img src=\"./img/merge.png\" width=\"100%\">\n     *\n     * `merge` subscribes to each given input Observable (as arguments), and simply\n     * forwards (without doing any transformation) all the values from all the input\n     * Observables to the output Observable. The output Observable only completes\n     * once all input Observables have completed. Any error delivered by an input\n     * Observable will be immediately emitted on the output Observable.\n     *\n     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var clicksOrTimer = Rx.Observable.merge(clicks, timer);\n     * clicksOrTimer.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // timer will emit ascending values, one every second(1000ms) to console\n     * // clicks logs MouseEvents to console everytime the \"document\" is clicked\n     * // Since the two streams are merged you see these happening\n     * // as they occur.\n     *\n     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var concurrent = 2; // the argument\n     * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);\n     * merged.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // - First timer1 and timer2 will run concurrently\n     * // - timer1 will emit a value every 1000ms for 10 iterations\n     * // - timer2 will emit a value every 2000ms for 6 iterations\n     * // - after timer1 hits it's max iteration, timer2 will\n     * //   continue, and timer3 will start to run concurrently with timer2\n     * // - when timer2 hits it's max iteration it terminates, and\n     * //   timer3 will continue to emit a value every 500ms until it is complete\n     *\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     *\n     * @param {...ObservableInput} observables Input Observables to merge together.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n     * concurrency of input Observables.\n     * @return {Observable} an Observable that emits items that are the result of\n     * every input Observable.\n     * @static true\n     * @name merge\n     * @owner Observable\n     */\n    function merge() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        var concurrent = Number.POSITIVE_INFINITY;\n        var scheduler = null;\n        var last = observables[observables.length - 1];\n        if (isScheduler_1.isScheduler(last)) {\n            scheduler = observables.pop();\n            if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {\n                concurrent = observables.pop();\n            }\n        }\n        else if (typeof last === 'number') {\n            concurrent = observables.pop();\n        }\n        if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {\n            return observables[0];\n        }\n        return mergeAll_1.mergeAll(concurrent)(new ArrayObservable_1.ArrayObservable(observables, scheduler));\n    }\n    exports.merge = merge;\n});\n\ndefine('rxjs/operators/merge',[\"require\", \"exports\", \"../observable/merge\", \"../observable/merge\"], function (require, exports, merge_1, merge_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.mergeStatic = merge_2.merge;\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which concurrently emits all values from every\n     * given input Observable.\n     *\n     * <span class=\"informal\">Flattens multiple Observables together by blending\n     * their values into one Observable.</span>\n     *\n     * <img src=\"./img/merge.png\" width=\"100%\">\n     *\n     * `merge` subscribes to each given input Observable (either the source or an\n     * Observable given as argument), and simply forwards (without doing any\n     * transformation) all the values from all the input Observables to the output\n     * Observable. The output Observable only completes once all input Observables\n     * have completed. Any error delivered by an input Observable will be immediately\n     * emitted on the output Observable.\n     *\n     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var clicksOrTimer = clicks.merge(timer);\n     * clicksOrTimer.subscribe(x => console.log(x));\n     *\n     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var concurrent = 2; // the argument\n     * var merged = timer1.merge(timer2, timer3, concurrent);\n     * merged.subscribe(x => console.log(x));\n     *\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     *\n     * @param {ObservableInput} other An input Observable to merge with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n     * concurrency of input Observables.\n     * @return {Observable} An Observable that emits items that are the result of\n     * every input Observable.\n     * @method merge\n     * @owner Observable\n     */\n    function merge() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return function (source) { return source.lift.call(merge_1.merge.apply(void 0, [source].concat(observables))); };\n    }\n    exports.merge = merge;\n});\n\ndefine('rxjs/operators/mergeMapTo',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is merged multiple\n     * times in the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n     * to the same inner Observable.</span>\n     *\n     * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then merges those resulting Observables into one\n     * single Observable, which is the output Observable.\n     *\n     * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMapTo}\n     * @see {@link merge}\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeScan}\n     * @see {@link switchMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits items from the given\n     * `innerObservable` (and optionally transformed through `resultSelector`) every\n     * time a value is emitted on the source Observable.\n     * @method mergeMapTo\n     * @owner Observable\n     */\n    function mergeMapTo(innerObservable, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        if (typeof resultSelector === 'number') {\n            concurrent = resultSelector;\n            resultSelector = null;\n        }\n        return function (source) { return source.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent)); };\n    }\n    exports.mergeMapTo = mergeMapTo;\n    // TODO: Figure out correct signature here: an Operator<Observable<T>, R>\n    //       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>\n    var MergeMapToOperator = /** @class */ (function () {\n        function MergeMapToOperator(ish, resultSelector, concurrent) {\n            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n            this.ish = ish;\n            this.resultSelector = resultSelector;\n            this.concurrent = concurrent;\n        }\n        MergeMapToOperator.prototype.call = function (observer, source) {\n            return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));\n        };\n        return MergeMapToOperator;\n    }());\n    exports.MergeMapToOperator = MergeMapToOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MergeMapToSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MergeMapToSubscriber, _super);\n        function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {\n            if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n            var _this = _super.call(this, destination) || this;\n            _this.ish = ish;\n            _this.resultSelector = resultSelector;\n            _this.concurrent = concurrent;\n            _this.hasCompleted = false;\n            _this.buffer = [];\n            _this.active = 0;\n            _this.index = 0;\n            return _this;\n        }\n        MergeMapToSubscriber.prototype._next = function (value) {\n            if (this.active < this.concurrent) {\n                var resultSelector = this.resultSelector;\n                var index = this.index++;\n                var ish = this.ish;\n                var destination = this.destination;\n                this.active++;\n                this._innerSub(ish, destination, resultSelector, value, index);\n            }\n            else {\n                this.buffer.push(value);\n            }\n        };\n        MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {\n            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n        };\n        MergeMapToSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (this.active === 0 && this.buffer.length === 0) {\n                this.destination.complete();\n            }\n        };\n        MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            if (resultSelector) {\n                this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                destination.next(innerValue);\n            }\n        };\n        MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            var result;\n            try {\n                result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            catch (err) {\n                destination.error(err);\n                return;\n            }\n            destination.next(result);\n        };\n        MergeMapToSubscriber.prototype.notifyError = function (err) {\n            this.destination.error(err);\n        };\n        MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n            var buffer = this.buffer;\n            this.remove(innerSub);\n            this.active--;\n            if (buffer.length > 0) {\n                this._next(buffer.shift());\n            }\n            else if (this.active === 0 && this.hasCompleted) {\n                this.destination.complete();\n            }\n        };\n        return MergeMapToSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.MergeMapToSubscriber = MergeMapToSubscriber;\n});\n\ndefine('rxjs/operators/mergeScan',[\"require\", \"exports\", \"tslib\", \"../util/tryCatch\", \"../util/errorObject\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, tryCatch_1, errorObject_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Applies an accumulator function over the source Observable where the\n     * accumulator function itself returns an Observable, then each intermediate\n     * Observable returned is merged into the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n     * by the accumulator are merged into the outer Observable.</span>\n     *\n     * @example <caption>Count the number of click events</caption>\n     * const click$ = Rx.Observable.fromEvent(document, 'click');\n     * const one$ = click$.mapTo(1);\n     * const seed = 0;\n     * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n     * count$.subscribe(x => console.log(x));\n     *\n     * // Results:\n     * 1\n     * 2\n     * 3\n     * 4\n     * // ...and so on for each click\n     *\n     * @param {function(acc: R, value: T): Observable<R>} accumulator\n     * The accumulator function called on each source value.\n     * @param seed The initial accumulation value.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n     * input Observables being subscribed to concurrently.\n     * @return {Observable<R>} An observable of the accumulated values.\n     * @method mergeScan\n     * @owner Observable\n     */\n    function mergeScan(accumulator, seed, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };\n    }\n    exports.mergeScan = mergeScan;\n    var MergeScanOperator = /** @class */ (function () {\n        function MergeScanOperator(accumulator, seed, concurrent) {\n            this.accumulator = accumulator;\n            this.seed = seed;\n            this.concurrent = concurrent;\n        }\n        MergeScanOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));\n        };\n        return MergeScanOperator;\n    }());\n    exports.MergeScanOperator = MergeScanOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var MergeScanSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(MergeScanSubscriber, _super);\n        function MergeScanSubscriber(destination, accumulator, acc, concurrent) {\n            var _this = _super.call(this, destination) || this;\n            _this.accumulator = accumulator;\n            _this.acc = acc;\n            _this.concurrent = concurrent;\n            _this.hasValue = false;\n            _this.hasCompleted = false;\n            _this.buffer = [];\n            _this.active = 0;\n            _this.index = 0;\n            return _this;\n        }\n        MergeScanSubscriber.prototype._next = function (value) {\n            if (this.active < this.concurrent) {\n                var index = this.index++;\n                var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);\n                var destination = this.destination;\n                if (ish === errorObject_1.errorObject) {\n                    destination.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    this.active++;\n                    this._innerSub(ish, value, index);\n                }\n            }\n            else {\n                this.buffer.push(value);\n            }\n        };\n        MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {\n            this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));\n        };\n        MergeScanSubscriber.prototype._complete = function () {\n            this.hasCompleted = true;\n            if (this.active === 0 && this.buffer.length === 0) {\n                if (this.hasValue === false) {\n                    this.destination.next(this.acc);\n                }\n                this.destination.complete();\n            }\n        };\n        MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var destination = this.destination;\n            this.acc = innerValue;\n            this.hasValue = true;\n            destination.next(innerValue);\n        };\n        MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {\n            var buffer = this.buffer;\n            this.remove(innerSub);\n            this.active--;\n            if (buffer.length > 0) {\n                this._next(buffer.shift());\n            }\n            else if (this.active === 0 && this.hasCompleted) {\n                if (this.hasValue === false) {\n                    this.destination.next(this.acc);\n                }\n                this.destination.complete();\n            }\n        };\n        return MergeScanSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.MergeScanSubscriber = MergeScanSubscriber;\n});\n\ndefine('rxjs/operators/min',[\"require\", \"exports\", \"./reduce\"], function (require, exports, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n     * and when source Observable completes it emits a single item: the item with the smallest value.\n     *\n     * <img src=\"./img/min.png\" width=\"100%\">\n     *\n     * @example <caption>Get the minimal value of a series of numbers</caption>\n     * Rx.Observable.of(5, 4, 7, 2, 8)\n     *   .min()\n     *   .subscribe(x => console.log(x)); // -> 2\n     *\n     * @example <caption>Use a comparer function to get the minimal item</caption>\n     * interface Person {\n     *   age: number,\n     *   name: string\n     * }\n     * Observable.of<Person>({age: 7, name: 'Foo'},\n     *                       {age: 5, name: 'Bar'},\n     *                       {age: 9, name: 'Beer'})\n     *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n     * }\n     *\n     * @see {@link max}\n     *\n     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n     * value of two items.\n     * @return {Observable<R>} An Observable that emits item with the smallest value.\n     * @method min\n     * @owner Observable\n     */\n    function min(comparer) {\n        var min = (typeof comparer === 'function')\n            ? function (x, y) { return comparer(x, y) < 0 ? x : y; }\n            : function (x, y) { return x < y ? x : y; };\n        return reduce_1.reduce(min);\n    }\n    exports.min = min;\n});\n\ndefine('rxjs/operators/multicast',[\"require\", \"exports\", \"../observable/ConnectableObservable\"], function (require, exports, ConnectableObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits the results of invoking a specified selector on items\n     * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.\n     *\n     * <img src=\"./img/multicast.png\" width=\"100%\">\n     *\n     * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through\n     * which the source sequence's elements will be multicast to the selector function\n     * or Subject to push source elements into.\n     * @param {Function} [selector] - Optional selector function that can use the multicasted source stream\n     * as many times as needed, without causing multiple subscriptions to the source stream.\n     * Subscribers to the given source will receive all notifications of the source from the\n     * time of the subscription forward.\n     * @return {Observable} An Observable that emits the results of invoking the selector\n     * on the items emitted by a `ConnectableObservable` that shares a single subscription to\n     * the underlying stream.\n     * @method multicast\n     * @owner Observable\n     */\n    function multicast(subjectOrSubjectFactory, selector) {\n        return function multicastOperatorFunction(source) {\n            var subjectFactory;\n            if (typeof subjectOrSubjectFactory === 'function') {\n                subjectFactory = subjectOrSubjectFactory;\n            }\n            else {\n                subjectFactory = function subjectFactory() {\n                    return subjectOrSubjectFactory;\n                };\n            }\n            if (typeof selector === 'function') {\n                return source.lift(new MulticastOperator(subjectFactory, selector));\n            }\n            var connectable = Object.create(source, ConnectableObservable_1.connectableObservableDescriptor);\n            connectable.source = source;\n            connectable.subjectFactory = subjectFactory;\n            return connectable;\n        };\n    }\n    exports.multicast = multicast;\n    var MulticastOperator = /** @class */ (function () {\n        function MulticastOperator(subjectFactory, selector) {\n            this.subjectFactory = subjectFactory;\n            this.selector = selector;\n        }\n        MulticastOperator.prototype.call = function (subscriber, source) {\n            var selector = this.selector;\n            var subject = this.subjectFactory();\n            var subscription = selector(subject).subscribe(subscriber);\n            subscription.add(source.subscribe(subject));\n            return subscription;\n        };\n        return MulticastOperator;\n    }());\n    exports.MulticastOperator = MulticastOperator;\n});\n\ndefine('rxjs/operators/onErrorResumeNext',[\"require\", \"exports\", \"tslib\", \"../observable/FromObservable\", \"../util/isArray\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, FromObservable_1, isArray_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n     * that was passed.\n     *\n     * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n     *\n     * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n     *\n     * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n     * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n     * as the source.\n     *\n     * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n     * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n     * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n     * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n     * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n     * be happening until there is no more Observables left in the series, at which point returned Observable will\n     * complete - even if the last subscribed stream ended with an error.\n     *\n     * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n     * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n     * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n     * an error.\n     *\n     * Note that you do not get any access to errors emitted by the Observables. In particular do not\n     * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n     * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n     *\n     *\n     * @example <caption>Subscribe to the next Observable after map fails</caption>\n     * Rx.Observable.of(1, 2, 3, 0)\n     *   .map(x => {\n     *       if (x === 0) { throw Error(); }\n             return 10 / x;\n     *   })\n     *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n     *   .subscribe(\n     *     val => console.log(val),\n     *     err => console.log(err),          // Will never be called.\n     *     () => console.log('that\\'s it!')\n     *   );\n     *\n     * // Logs:\n     * // 10\n     * // 5\n     * // 3.3333333333333335\n     * // 1\n     * // 2\n     * // 3\n     * // \"that's it!\"\n     *\n     * @see {@link concat}\n     * @see {@link catch}\n     *\n     * @param {...ObservableInput} observables Observables passed either directly or as an array.\n     * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n     * to the next passed Observable and so on, until it completes or runs out of Observables.\n     * @method onErrorResumeNext\n     * @owner Observable\n     */\n    function onErrorResumeNext() {\n        var nextSources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nextSources[_i] = arguments[_i];\n        }\n        if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n            nextSources = nextSources[0];\n        }\n        return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };\n    }\n    exports.onErrorResumeNext = onErrorResumeNext;\n    /* tslint:enable:max-line-length */\n    function onErrorResumeNextStatic() {\n        var nextSources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nextSources[_i] = arguments[_i];\n        }\n        var source = null;\n        if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {\n            nextSources = nextSources[0];\n        }\n        source = nextSources.shift();\n        return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));\n    }\n    exports.onErrorResumeNextStatic = onErrorResumeNextStatic;\n    var OnErrorResumeNextOperator = /** @class */ (function () {\n        function OnErrorResumeNextOperator(nextSources) {\n            this.nextSources = nextSources;\n        }\n        OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));\n        };\n        return OnErrorResumeNextOperator;\n    }());\n    var OnErrorResumeNextSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(OnErrorResumeNextSubscriber, _super);\n        function OnErrorResumeNextSubscriber(destination, nextSources) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.nextSources = nextSources;\n            return _this;\n        }\n        OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {\n            this.subscribeToNextSource();\n        };\n        OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.subscribeToNextSource();\n        };\n        OnErrorResumeNextSubscriber.prototype._error = function (err) {\n            this.subscribeToNextSource();\n        };\n        OnErrorResumeNextSubscriber.prototype._complete = function () {\n            this.subscribeToNextSource();\n        };\n        OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {\n            var next = this.nextSources.shift();\n            if (next) {\n                this.add(subscribeToResult_1.subscribeToResult(this, next));\n            }\n            else {\n                this.destination.complete();\n            }\n        };\n        return OnErrorResumeNextSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/pairwise',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Groups pairs of consecutive emissions together and emits them as an array of\n     * two values.\n     *\n     * <span class=\"informal\">Puts the current value and previous value together as\n     * an array, and emits that.</span>\n     *\n     * <img src=\"./img/pairwise.png\" width=\"100%\">\n     *\n     * The Nth emission from the source Observable will cause the output Observable\n     * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n     * pair. For this reason, `pairwise` emits on the second and subsequent\n     * emissions from the source Observable, but not on the first emission, because\n     * there is no previous value in that case.\n     *\n     * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var pairs = clicks.pairwise();\n     * var distance = pairs.map(pair => {\n     *   var x0 = pair[0].clientX;\n     *   var y0 = pair[0].clientY;\n     *   var x1 = pair[1].clientX;\n     *   var y1 = pair[1].clientY;\n     *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n     * });\n     * distance.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     *\n     * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n     * consecutive values from the source Observable.\n     * @method pairwise\n     * @owner Observable\n     */\n    function pairwise() {\n        return function (source) { return source.lift(new PairwiseOperator()); };\n    }\n    exports.pairwise = pairwise;\n    var PairwiseOperator = /** @class */ (function () {\n        function PairwiseOperator() {\n        }\n        PairwiseOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new PairwiseSubscriber(subscriber));\n        };\n        return PairwiseOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var PairwiseSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(PairwiseSubscriber, _super);\n        function PairwiseSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.hasPrev = false;\n            return _this;\n        }\n        PairwiseSubscriber.prototype._next = function (value) {\n            if (this.hasPrev) {\n                this.destination.next([this.prev, value]);\n            }\n            else {\n                this.hasPrev = true;\n            }\n            this.prev = value;\n        };\n        return PairwiseSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/util/not',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function not(pred, thisArg) {\n        function notPred() {\n            return !(notPred.pred.apply(notPred.thisArg, arguments));\n        }\n        notPred.pred = pred;\n        notPred.thisArg = thisArg;\n        return notPred;\n    }\n    exports.not = not;\n});\n\ndefine('rxjs/operators/partition',[\"require\", \"exports\", \"../util/not\", \"./filter\"], function (require, exports, not_1, filter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Splits the source Observable into two, one with values that satisfy a\n     * predicate, and another with values that don't satisfy the predicate.\n     *\n     * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n     * one like the output of {@link filter}, and the other with values that did not\n     * pass the condition.</span>\n     *\n     * <img src=\"./img/partition.png\" width=\"100%\">\n     *\n     * `partition` outputs an array with two Observables that partition the values\n     * from the source Observable through the given `predicate` function. The first\n     * Observable in that array emits source values for which the predicate argument\n     * returns true. The second Observable emits source values for which the\n     * predicate returns false. The first behaves like {@link filter} and the second\n     * behaves like {@link filter} with the predicate negated.\n     *\n     * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n     * var clicksOnDivs = parts[0];\n     * var clicksElsewhere = parts[1];\n     * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n     * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n     *\n     * @see {@link filter}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates each value emitted by the source Observable. If it returns `true`,\n     * the value is emitted on the first Observable in the returned array, if\n     * `false` the value is emitted on the second Observable in the array. The\n     * `index` parameter is the number `i` for the i-th source emission that has\n     * happened since the subscription, starting from the number `0`.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n     * with values that passed the predicate, and another with values that did not\n     * pass the predicate.\n     * @method partition\n     * @owner Observable\n     */\n    function partition(predicate, thisArg) {\n        return function (source) { return [\n            filter_1.filter(predicate, thisArg)(source),\n            filter_1.filter(not_1.not(predicate, thisArg))(source)\n        ]; };\n    }\n    exports.partition = partition;\n});\n\ndefine('rxjs/operators/pluck',[\"require\", \"exports\", \"./map\"], function (require, exports, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Maps each source value (an object) to its specified nested property.\n     *\n     * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n     * the nested properties of every emitted object.</span>\n     *\n     * <img src=\"./img/pluck.png\" width=\"100%\">\n     *\n     * Given a list of strings describing a path to an object property, retrieves\n     * the value of a specified nested property from all values in the source\n     * Observable. If a property can't be resolved, it will return `undefined` for\n     * that value.\n     *\n     * @example <caption>Map every click to the tagName of the clicked target element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var tagNames = clicks.pluck('target', 'tagName');\n     * tagNames.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     *\n     * @param {...string} properties The nested properties to pluck from each source\n     * value (an object).\n     * @return {Observable} A new Observable of property values from the source values.\n     * @method pluck\n     * @owner Observable\n     */\n    function pluck() {\n        var properties = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            properties[_i] = arguments[_i];\n        }\n        var length = properties.length;\n        if (length === 0) {\n            throw new Error('list of properties cannot be empty.');\n        }\n        return function (source) { return map_1.map(plucker(properties, length))(source); };\n    }\n    exports.pluck = pluck;\n    function plucker(props, length) {\n        var mapper = function (x) {\n            var currentProp = x;\n            for (var i = 0; i < length; i++) {\n                var p = currentProp[props[i]];\n                if (typeof p !== 'undefined') {\n                    currentProp = p;\n                }\n                else {\n                    return undefined;\n                }\n            }\n            return currentProp;\n        };\n        return mapper;\n    }\n});\n\ndefine('rxjs/operators/publish',[\"require\", \"exports\", \"../Subject\", \"./multicast\"], function (require, exports, Subject_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n     * before it begins emitting items to those Observers that have subscribed to it.\n     *\n     * <img src=\"./img/publish.png\" width=\"100%\">\n     *\n     * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n     * as needed, without causing multiple subscriptions to the source sequence.\n     * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n     * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n     * @method publish\n     * @owner Observable\n     */\n    function publish(selector) {\n        return selector ?\n            multicast_1.multicast(function () { return new Subject_1.Subject(); }, selector) :\n            multicast_1.multicast(new Subject_1.Subject());\n    }\n    exports.publish = publish;\n});\n\ndefine('rxjs/operators/publishBehavior',[\"require\", \"exports\", \"../BehaviorSubject\", \"./multicast\"], function (require, exports, BehaviorSubject_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param value\n     * @return {ConnectableObservable<T>}\n     * @method publishBehavior\n     * @owner Observable\n     */\n    function publishBehavior(value) {\n        return function (source) { return multicast_1.multicast(new BehaviorSubject_1.BehaviorSubject(value))(source); };\n    }\n    exports.publishBehavior = publishBehavior;\n});\n\ndefine('rxjs/operators/publishLast',[\"require\", \"exports\", \"../AsyncSubject\", \"./multicast\"], function (require, exports, AsyncSubject_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function publishLast() {\n        return function (source) { return multicast_1.multicast(new AsyncSubject_1.AsyncSubject())(source); };\n    }\n    exports.publishLast = publishLast;\n});\n\ndefine('rxjs/operators/publishReplay',[\"require\", \"exports\", \"../ReplaySubject\", \"./multicast\"], function (require, exports, ReplaySubject_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n        if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {\n            scheduler = selectorOrScheduler;\n        }\n        var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;\n        var subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n        return function (source) { return multicast_1.multicast(function () { return subject; }, selector)(source); };\n    }\n    exports.publishReplay = publishReplay;\n});\n\ndefine('rxjs/observable/race',[\"require\", \"exports\", \"tslib\", \"../util/isArray\", \"../observable/ArrayObservable\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, isArray_1, ArrayObservable_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function race() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        // if the only argument is an array, it was most likely called with\n        // `race([obs1, obs2, ...])`\n        if (observables.length === 1) {\n            if (isArray_1.isArray(observables[0])) {\n                observables = observables[0];\n            }\n            else {\n                return observables[0];\n            }\n        }\n        return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());\n    }\n    exports.race = race;\n    var RaceOperator = /** @class */ (function () {\n        function RaceOperator() {\n        }\n        RaceOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RaceSubscriber(subscriber));\n        };\n        return RaceOperator;\n    }());\n    exports.RaceOperator = RaceOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RaceSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RaceSubscriber, _super);\n        function RaceSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.hasFirst = false;\n            _this.observables = [];\n            _this.subscriptions = [];\n            return _this;\n        }\n        RaceSubscriber.prototype._next = function (observable) {\n            this.observables.push(observable);\n        };\n        RaceSubscriber.prototype._complete = function () {\n            var observables = this.observables;\n            var len = observables.length;\n            if (len === 0) {\n                this.destination.complete();\n            }\n            else {\n                for (var i = 0; i < len && !this.hasFirst; i++) {\n                    var observable = observables[i];\n                    var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);\n                    if (this.subscriptions) {\n                        this.subscriptions.push(subscription);\n                    }\n                    this.add(subscription);\n                }\n                this.observables = null;\n            }\n        };\n        RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            if (!this.hasFirst) {\n                this.hasFirst = true;\n                for (var i = 0; i < this.subscriptions.length; i++) {\n                    if (i !== outerIndex) {\n                        var subscription = this.subscriptions[i];\n                        subscription.unsubscribe();\n                        this.remove(subscription);\n                    }\n                }\n                this.subscriptions = null;\n            }\n            this.destination.next(innerValue);\n        };\n        return RaceSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n    exports.RaceSubscriber = RaceSubscriber;\n});\n\ndefine('rxjs/operators/race',[\"require\", \"exports\", \"../util/isArray\", \"../observable/race\"], function (require, exports, isArray_1, race_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that mirrors the first source Observable to emit an item\n     * from the combination of this Observable and supplied Observables.\n     * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n     * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n     * @method race\n     * @owner Observable\n     */\n    function race() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return function raceOperatorFunction(source) {\n            // if the only argument is an array, it was most likely called with\n            // `pair([obs1, obs2, ...])`\n            if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n                observables = observables[0];\n            }\n            return source.lift.call(race_1.race.apply(void 0, [source].concat(observables)));\n        };\n    }\n    exports.race = race;\n});\n\ndefine('rxjs/operators/repeat',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../observable/EmptyObservable\"], function (require, exports, tslib_1, Subscriber_1, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n     *\n     * <img src=\"./img/repeat.png\" width=\"100%\">\n     *\n     * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n     * an empty Observable.\n     * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n     * count times.\n     * @method repeat\n     * @owner Observable\n     */\n    function repeat(count) {\n        if (count === void 0) { count = -1; }\n        return function (source) {\n            if (count === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            else if (count < 0) {\n                return source.lift(new RepeatOperator(-1, source));\n            }\n            else {\n                return source.lift(new RepeatOperator(count - 1, source));\n            }\n        };\n    }\n    exports.repeat = repeat;\n    var RepeatOperator = /** @class */ (function () {\n        function RepeatOperator(count, source) {\n            this.count = count;\n            this.source = source;\n        }\n        RepeatOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));\n        };\n        return RepeatOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RepeatSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RepeatSubscriber, _super);\n        function RepeatSubscriber(destination, count, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.count = count;\n            _this.source = source;\n            return _this;\n        }\n        RepeatSubscriber.prototype.complete = function () {\n            if (!this.isStopped) {\n                var _a = this, source = _a.source, count = _a.count;\n                if (count === 0) {\n                    return _super.prototype.complete.call(this);\n                }\n                else if (count > -1) {\n                    this.count = count - 1;\n                }\n                source.subscribe(this._unsubscribeAndRecycle());\n            }\n        };\n        return RepeatSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/repeatWhen',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n     * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n     * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n     * this method will resubscribe to the source Observable.\n     *\n     * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n     *\n     * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n     * which a user can `complete` or `error`, aborting the repetition.\n     * @return {Observable} The source Observable modified with repeat logic.\n     * @method repeatWhen\n     * @owner Observable\n     */\n    function repeatWhen(notifier) {\n        return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };\n    }\n    exports.repeatWhen = repeatWhen;\n    var RepeatWhenOperator = /** @class */ (function () {\n        function RepeatWhenOperator(notifier) {\n            this.notifier = notifier;\n        }\n        RepeatWhenOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n        };\n        return RepeatWhenOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RepeatWhenSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RepeatWhenSubscriber, _super);\n        function RepeatWhenSubscriber(destination, notifier, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.notifier = notifier;\n            _this.source = source;\n            _this.sourceIsBeingSubscribedTo = true;\n            return _this;\n        }\n        RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.sourceIsBeingSubscribedTo = true;\n            this.source.subscribe(this);\n        };\n        RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {\n            if (this.sourceIsBeingSubscribedTo === false) {\n                return _super.prototype.complete.call(this);\n            }\n        };\n        RepeatWhenSubscriber.prototype.complete = function () {\n            this.sourceIsBeingSubscribedTo = false;\n            if (!this.isStopped) {\n                if (!this.retries) {\n                    this.subscribeToRetries();\n                }\n                else if (this.retriesSubscription.closed) {\n                    return _super.prototype.complete.call(this);\n                }\n                this._unsubscribeAndRecycle();\n                this.notifications.next();\n            }\n        };\n        RepeatWhenSubscriber.prototype._unsubscribe = function () {\n            var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;\n            if (notifications) {\n                notifications.unsubscribe();\n                this.notifications = null;\n            }\n            if (retriesSubscription) {\n                retriesSubscription.unsubscribe();\n                this.retriesSubscription = null;\n            }\n            this.retries = null;\n        };\n        RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {\n            var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n            this.notifications = null;\n            this.retries = null;\n            this.retriesSubscription = null;\n            _super.prototype._unsubscribeAndRecycle.call(this);\n            this.notifications = notifications;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            return this;\n        };\n        RepeatWhenSubscriber.prototype.subscribeToRetries = function () {\n            this.notifications = new Subject_1.Subject();\n            var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);\n            if (retries === errorObject_1.errorObject) {\n                return _super.prototype.complete.call(this);\n            }\n            this.retries = retries;\n            this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n        };\n        return RepeatWhenSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/retry',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n     * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n     * as a number parameter) rather than propagating the `error` call.\n     *\n     * <img src=\"./img/retry.png\" width=\"100%\">\n     *\n     * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n     * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n     * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n     * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n     * @param {number} count - Number of retry attempts before failing.\n     * @return {Observable} The source Observable modified with the retry logic.\n     * @method retry\n     * @owner Observable\n     */\n    function retry(count) {\n        if (count === void 0) { count = -1; }\n        return function (source) { return source.lift(new RetryOperator(count, source)); };\n    }\n    exports.retry = retry;\n    var RetryOperator = /** @class */ (function () {\n        function RetryOperator(count, source) {\n            this.count = count;\n            this.source = source;\n        }\n        RetryOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));\n        };\n        return RetryOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RetrySubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RetrySubscriber, _super);\n        function RetrySubscriber(destination, count, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.count = count;\n            _this.source = source;\n            return _this;\n        }\n        RetrySubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var _a = this, source = _a.source, count = _a.count;\n                if (count === 0) {\n                    return _super.prototype.error.call(this, err);\n                }\n                else if (count > -1) {\n                    this.count = count - 1;\n                }\n                source.subscribe(this._unsubscribeAndRecycle());\n            }\n        };\n        return RetrySubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/retryWhen',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n     * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n     * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n     * subscription. Otherwise this method will resubscribe to the source Observable.\n     *\n     * <img src=\"./img/retryWhen.png\" width=\"100%\">\n     *\n     * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n     * user can `complete` or `error`, aborting the retry.\n     * @return {Observable} The source Observable modified with retry logic.\n     * @method retryWhen\n     * @owner Observable\n     */\n    function retryWhen(notifier) {\n        return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };\n    }\n    exports.retryWhen = retryWhen;\n    var RetryWhenOperator = /** @class */ (function () {\n        function RetryWhenOperator(notifier, source) {\n            this.notifier = notifier;\n            this.source = source;\n        }\n        RetryWhenOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));\n        };\n        return RetryWhenOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var RetryWhenSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(RetryWhenSubscriber, _super);\n        function RetryWhenSubscriber(destination, notifier, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.notifier = notifier;\n            _this.source = source;\n            return _this;\n        }\n        RetryWhenSubscriber.prototype.error = function (err) {\n            if (!this.isStopped) {\n                var errors = this.errors;\n                var retries = this.retries;\n                var retriesSubscription = this.retriesSubscription;\n                if (!retries) {\n                    errors = new Subject_1.Subject();\n                    retries = tryCatch_1.tryCatch(this.notifier)(errors);\n                    if (retries === errorObject_1.errorObject) {\n                        return _super.prototype.error.call(this, errorObject_1.errorObject.e);\n                    }\n                    retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);\n                }\n                else {\n                    this.errors = null;\n                    this.retriesSubscription = null;\n                }\n                this._unsubscribeAndRecycle();\n                this.errors = errors;\n                this.retries = retries;\n                this.retriesSubscription = retriesSubscription;\n                errors.next(err);\n            }\n        };\n        RetryWhenSubscriber.prototype._unsubscribe = function () {\n            var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;\n            if (errors) {\n                errors.unsubscribe();\n                this.errors = null;\n            }\n            if (retriesSubscription) {\n                retriesSubscription.unsubscribe();\n                this.retriesSubscription = null;\n            }\n            this.retries = null;\n        };\n        RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;\n            this.errors = null;\n            this.retries = null;\n            this.retriesSubscription = null;\n            this._unsubscribeAndRecycle();\n            this.errors = errors;\n            this.retries = retries;\n            this.retriesSubscription = retriesSubscription;\n            this.source.subscribe(this);\n        };\n        return RetryWhenSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/sample',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the most recently emitted value from the source Observable whenever\n     * another Observable, the `notifier`, emits.\n     *\n     * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n     * the `notifier` Observable emits something.</span>\n     *\n     * <img src=\"./img/sample.png\" width=\"100%\">\n     *\n     * Whenever the `notifier` Observable emits a value or completes, `sample`\n     * looks at the source Observable and emits whichever value it has most recently\n     * emitted since the previous sampling, unless the source has not emitted\n     * anything since the previous sampling. The `notifier` is subscribed to as soon\n     * as the output Observable is subscribed.\n     *\n     * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n     * var seconds = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = seconds.sample(clicks);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounce}\n     * @see {@link sampleTime}\n     * @see {@link throttle}\n     *\n     * @param {Observable<any>} notifier The Observable to use for sampling the\n     * source Observable.\n     * @return {Observable<T>} An Observable that emits the results of sampling the\n     * values emitted by the source Observable whenever the notifier Observable\n     * emits value or completes.\n     * @method sample\n     * @owner Observable\n     */\n    function sample(notifier) {\n        return function (source) { return source.lift(new SampleOperator(notifier)); };\n    }\n    exports.sample = sample;\n    var SampleOperator = /** @class */ (function () {\n        function SampleOperator(notifier) {\n            this.notifier = notifier;\n        }\n        SampleOperator.prototype.call = function (subscriber, source) {\n            var sampleSubscriber = new SampleSubscriber(subscriber);\n            var subscription = source.subscribe(sampleSubscriber);\n            subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));\n            return subscription;\n        };\n        return SampleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SampleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SampleSubscriber, _super);\n        function SampleSubscriber() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.hasValue = false;\n            return _this;\n        }\n        SampleSubscriber.prototype._next = function (value) {\n            this.value = value;\n            this.hasValue = true;\n        };\n        SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.emitValue();\n        };\n        SampleSubscriber.prototype.notifyComplete = function () {\n            this.emitValue();\n        };\n        SampleSubscriber.prototype.emitValue = function () {\n            if (this.hasValue) {\n                this.hasValue = false;\n                this.destination.next(this.value);\n            }\n        };\n        return SampleSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/sampleTime',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../scheduler/async\"], function (require, exports, tslib_1, Subscriber_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the most recently emitted value from the source Observable within\n     * periodic time intervals.\n     *\n     * <span class=\"informal\">Samples the source Observable at periodic time\n     * intervals, emitting what it samples.</span>\n     *\n     * <img src=\"./img/sampleTime.png\" width=\"100%\">\n     *\n     * `sampleTime` periodically looks at the source Observable and emits whichever\n     * value it has most recently emitted since the previous sampling, unless the\n     * source has not emitted anything since the previous sampling. The sampling\n     * happens periodically in time every `period` milliseconds (or the time unit\n     * defined by the optional `scheduler` argument). The sampling starts as soon as\n     * the output Observable is subscribed.\n     *\n     * @example <caption>Every second, emit the most recent click at most once</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.sampleTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sample}\n     * @see {@link throttleTime}\n     *\n     * @param {number} period The sampling period expressed in milliseconds or the\n     * time unit determined internally by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the sampling.\n     * @return {Observable<T>} An Observable that emits the results of sampling the\n     * values emitted by the source Observable at the specified time interval.\n     * @method sampleTime\n     * @owner Observable\n     */\n    function sampleTime(period, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };\n    }\n    exports.sampleTime = sampleTime;\n    var SampleTimeOperator = /** @class */ (function () {\n        function SampleTimeOperator(period, scheduler) {\n            this.period = period;\n            this.scheduler = scheduler;\n        }\n        SampleTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));\n        };\n        return SampleTimeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SampleTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SampleTimeSubscriber, _super);\n        function SampleTimeSubscriber(destination, period, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.period = period;\n            _this.scheduler = scheduler;\n            _this.hasValue = false;\n            _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));\n            return _this;\n        }\n        SampleTimeSubscriber.prototype._next = function (value) {\n            this.lastValue = value;\n            this.hasValue = true;\n        };\n        SampleTimeSubscriber.prototype.notifyNext = function () {\n            if (this.hasValue) {\n                this.hasValue = false;\n                this.destination.next(this.lastValue);\n            }\n        };\n        return SampleTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchNotification(state) {\n        var subscriber = state.subscriber, period = state.period;\n        subscriber.notifyNext();\n        this.schedule(state, period);\n    }\n});\n\ndefine('rxjs/operators/sequenceEqual',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/tryCatch\", \"../util/errorObject\"], function (require, exports, tslib_1, Subscriber_1, tryCatch_1, errorObject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Compares all values of two observables in sequence using an optional comparor function\n     * and returns an observable of a single boolean value representing whether or not the two sequences\n     * are equal.\n     *\n     * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n     *\n     * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n     *\n     * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n     * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n     * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n     * observables completes, the operator will wait for the other observable to complete; If the other\n     * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n     * completes or emits after the other complets, the returned observable will never complete.\n     *\n     * @example <caption>figure out if the Konami code matches</caption>\n     * var code = Rx.Observable.from([\n     *  \"ArrowUp\",\n     *  \"ArrowUp\",\n     *  \"ArrowDown\",\n     *  \"ArrowDown\",\n     *  \"ArrowLeft\",\n     *  \"ArrowRight\",\n     *  \"ArrowLeft\",\n     *  \"ArrowRight\",\n     *  \"KeyB\",\n     *  \"KeyA\",\n     *  \"Enter\" // no start key, clearly.\n     * ]);\n     *\n     * var keys = Rx.Observable.fromEvent(document, 'keyup')\n     *  .map(e => e.code);\n     * var matches = keys.bufferCount(11, 1)\n     *  .mergeMap(\n     *    last11 =>\n     *      Rx.Observable.from(last11)\n     *        .sequenceEqual(code)\n     *   );\n     * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n     *\n     * @see {@link combineLatest}\n     * @see {@link zip}\n     * @see {@link withLatestFrom}\n     *\n     * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n     * @param {function} [comparor] An optional function to compare each value pair\n     * @return {Observable} An Observable of a single boolean value representing whether or not\n     * the values emitted by both observables were equal in sequence.\n     * @method sequenceEqual\n     * @owner Observable\n     */\n    function sequenceEqual(compareTo, comparor) {\n        return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparor)); };\n    }\n    exports.sequenceEqual = sequenceEqual;\n    var SequenceEqualOperator = /** @class */ (function () {\n        function SequenceEqualOperator(compareTo, comparor) {\n            this.compareTo = compareTo;\n            this.comparor = comparor;\n        }\n        SequenceEqualOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));\n        };\n        return SequenceEqualOperator;\n    }());\n    exports.SequenceEqualOperator = SequenceEqualOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SequenceEqualSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SequenceEqualSubscriber, _super);\n        function SequenceEqualSubscriber(destination, compareTo, comparor) {\n            var _this = _super.call(this, destination) || this;\n            _this.compareTo = compareTo;\n            _this.comparor = comparor;\n            _this._a = [];\n            _this._b = [];\n            _this._oneComplete = false;\n            _this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));\n            return _this;\n        }\n        SequenceEqualSubscriber.prototype._next = function (value) {\n            if (this._oneComplete && this._b.length === 0) {\n                this.emit(false);\n            }\n            else {\n                this._a.push(value);\n                this.checkValues();\n            }\n        };\n        SequenceEqualSubscriber.prototype._complete = function () {\n            if (this._oneComplete) {\n                this.emit(this._a.length === 0 && this._b.length === 0);\n            }\n            else {\n                this._oneComplete = true;\n            }\n        };\n        SequenceEqualSubscriber.prototype.checkValues = function () {\n            var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;\n            while (_a.length > 0 && _b.length > 0) {\n                var a = _a.shift();\n                var b = _b.shift();\n                var areEqual = false;\n                if (comparor) {\n                    areEqual = tryCatch_1.tryCatch(comparor)(a, b);\n                    if (areEqual === errorObject_1.errorObject) {\n                        this.destination.error(errorObject_1.errorObject.e);\n                    }\n                }\n                else {\n                    areEqual = a === b;\n                }\n                if (!areEqual) {\n                    this.emit(false);\n                }\n            }\n        };\n        SequenceEqualSubscriber.prototype.emit = function (value) {\n            var destination = this.destination;\n            destination.next(value);\n            destination.complete();\n        };\n        SequenceEqualSubscriber.prototype.nextB = function (value) {\n            if (this._oneComplete && this._a.length === 0) {\n                this.emit(false);\n            }\n            else {\n                this._b.push(value);\n                this.checkValues();\n            }\n        };\n        return SequenceEqualSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.SequenceEqualSubscriber = SequenceEqualSubscriber;\n    var SequenceEqualCompareToSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SequenceEqualCompareToSubscriber, _super);\n        function SequenceEqualCompareToSubscriber(destination, parent) {\n            var _this = _super.call(this, destination) || this;\n            _this.parent = parent;\n            return _this;\n        }\n        SequenceEqualCompareToSubscriber.prototype._next = function (value) {\n            this.parent.nextB(value);\n        };\n        SequenceEqualCompareToSubscriber.prototype._error = function (err) {\n            this.parent.error(err);\n        };\n        SequenceEqualCompareToSubscriber.prototype._complete = function () {\n            this.parent._complete();\n        };\n        return SequenceEqualCompareToSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/share',[\"require\", \"exports\", \"./multicast\", \"./refCount\", \"../Subject\"], function (require, exports, multicast_1, refCount_1, Subject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function shareSubjectFactory() {\n        return new Subject_1.Subject();\n    }\n    /**\n     * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n     * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n     * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n     * This is an alias for .multicast(() => new Subject()).refCount().\n     *\n     * <img src=\"./img/share.png\" width=\"100%\">\n     *\n     * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n     * @method share\n     * @owner Observable\n     */\n    function share() {\n        return function (source) { return refCount_1.refCount()(multicast_1.multicast(shareSubjectFactory)(source)); };\n    }\n    exports.share = share;\n    ;\n});\n\ndefine('rxjs/operators/shareReplay',[\"require\", \"exports\", \"../ReplaySubject\"], function (require, exports, ReplaySubject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @method shareReplay\n     * @owner Observable\n     */\n    function shareReplay(bufferSize, windowTime, scheduler) {\n        return function (source) { return source.lift(shareReplayOperator(bufferSize, windowTime, scheduler)); };\n    }\n    exports.shareReplay = shareReplay;\n    function shareReplayOperator(bufferSize, windowTime, scheduler) {\n        var subject;\n        var refCount = 0;\n        var subscription;\n        var hasError = false;\n        var isComplete = false;\n        return function shareReplayOperation(source) {\n            refCount++;\n            if (!subject || hasError) {\n                hasError = false;\n                subject = new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);\n                subscription = source.subscribe({\n                    next: function (value) { subject.next(value); },\n                    error: function (err) {\n                        hasError = true;\n                        subject.error(err);\n                    },\n                    complete: function () {\n                        isComplete = true;\n                        subject.complete();\n                    },\n                });\n            }\n            var innerSub = subject.subscribe(this);\n            return function () {\n                refCount--;\n                innerSub.unsubscribe();\n                if (subscription && refCount === 0 && isComplete) {\n                    subscription.unsubscribe();\n                }\n            };\n        };\n    }\n    ;\n});\n\ndefine('rxjs/operators/single',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/EmptyError\"], function (require, exports, tslib_1, Subscriber_1, EmptyError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n     * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n     * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n     *\n     * <img src=\"./img/single.png\" width=\"100%\">\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n     * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n     * the predicate.\n     .\n     * @method single\n     * @owner Observable\n     */\n    function single(predicate) {\n        return function (source) { return source.lift(new SingleOperator(predicate, source)); };\n    }\n    exports.single = single;\n    var SingleOperator = /** @class */ (function () {\n        function SingleOperator(predicate, source) {\n            this.predicate = predicate;\n            this.source = source;\n        }\n        SingleOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));\n        };\n        return SingleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SingleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SingleSubscriber, _super);\n        function SingleSubscriber(destination, predicate, source) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.source = source;\n            _this.seenValue = false;\n            _this.index = 0;\n            return _this;\n        }\n        SingleSubscriber.prototype.applySingleValue = function (value) {\n            if (this.seenValue) {\n                this.destination.error('Sequence contains more than one element');\n            }\n            else {\n                this.seenValue = true;\n                this.singleValue = value;\n            }\n        };\n        SingleSubscriber.prototype._next = function (value) {\n            var index = this.index++;\n            if (this.predicate) {\n                this.tryNext(value, index);\n            }\n            else {\n                this.applySingleValue(value);\n            }\n        };\n        SingleSubscriber.prototype.tryNext = function (value, index) {\n            try {\n                if (this.predicate(value, index, this.source)) {\n                    this.applySingleValue(value);\n                }\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        SingleSubscriber.prototype._complete = function () {\n            var destination = this.destination;\n            if (this.index > 0) {\n                destination.next(this.seenValue ? this.singleValue : undefined);\n                destination.complete();\n            }\n            else {\n                destination.error(new EmptyError_1.EmptyError);\n            }\n        };\n        return SingleSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/skip',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips the first `count` items emitted by the source Observable.\n     *\n     * <img src=\"./img/skip.png\" width=\"100%\">\n     *\n     * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n     * @return {Observable} An Observable that skips values emitted by the source Observable.\n     *\n     * @method skip\n     * @owner Observable\n     */\n    function skip(count) {\n        return function (source) { return source.lift(new SkipOperator(count)); };\n    }\n    exports.skip = skip;\n    var SkipOperator = /** @class */ (function () {\n        function SkipOperator(total) {\n            this.total = total;\n        }\n        SkipOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SkipSubscriber(subscriber, this.total));\n        };\n        return SkipOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SkipSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SkipSubscriber, _super);\n        function SkipSubscriber(destination, total) {\n            var _this = _super.call(this, destination) || this;\n            _this.total = total;\n            _this.count = 0;\n            return _this;\n        }\n        SkipSubscriber.prototype._next = function (x) {\n            if (++this.count > this.total) {\n                this.destination.next(x);\n            }\n        };\n        return SkipSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/skipLast',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/ArgumentOutOfRangeError\"], function (require, exports, tslib_1, Subscriber_1, ArgumentOutOfRangeError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Skip the last `count` values emitted by the source Observable.\n     *\n     * <img src=\"./img/skipLast.png\" width=\"100%\">\n     *\n     * `skipLast` returns an Observable that accumulates a queue with a length\n     * enough to store the first `count` values. As more values are received,\n     * values are taken from the front of the queue and produced on the result\n     * sequence. This causes values to be delayed.\n     *\n     * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n     * var many = Rx.Observable.range(1, 5);\n     * var skipLastTwo = many.skipLast(2);\n     * skipLastTwo.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // 1 2 3\n     *\n     * @see {@link skip}\n     * @see {@link skipUntil}\n     * @see {@link skipWhile}\n     * @see {@link take}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n     * ArgumentOutOrRangeError if `i < 0`.\n     *\n     * @param {number} count Number of elements to skip from the end of the source Observable.\n     * @returns {Observable<T>} An Observable that skips the last count values\n     * emitted by the source Observable.\n     * @method skipLast\n     * @owner Observable\n     */\n    function skipLast(count) {\n        return function (source) { return source.lift(new SkipLastOperator(count)); };\n    }\n    exports.skipLast = skipLast;\n    var SkipLastOperator = /** @class */ (function () {\n        function SkipLastOperator(_skipCount) {\n            this._skipCount = _skipCount;\n            if (this._skipCount < 0) {\n                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n            }\n        }\n        SkipLastOperator.prototype.call = function (subscriber, source) {\n            if (this._skipCount === 0) {\n                // If we don't want to skip any values then just subscribe\n                // to Subscriber without any further logic.\n                return source.subscribe(new Subscriber_1.Subscriber(subscriber));\n            }\n            else {\n                return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));\n            }\n        };\n        return SkipLastOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SkipLastSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SkipLastSubscriber, _super);\n        function SkipLastSubscriber(destination, _skipCount) {\n            var _this = _super.call(this, destination) || this;\n            _this._skipCount = _skipCount;\n            _this._count = 0;\n            _this._ring = new Array(_skipCount);\n            return _this;\n        }\n        SkipLastSubscriber.prototype._next = function (value) {\n            var skipCount = this._skipCount;\n            var count = this._count++;\n            if (count < skipCount) {\n                this._ring[count] = value;\n            }\n            else {\n                var currentIndex = count % skipCount;\n                var ring = this._ring;\n                var oldValue = ring[currentIndex];\n                ring[currentIndex] = value;\n                this.destination.next(oldValue);\n            }\n        };\n        return SkipLastSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/skipUntil',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n     *\n     * <img src=\"./img/skipUntil.png\" width=\"100%\">\n     *\n     * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n     * be mirrored by the resulting Observable.\n     * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n     * an item, then emits the remaining items.\n     * @method skipUntil\n     * @owner Observable\n     */\n    function skipUntil(notifier) {\n        return function (source) { return source.lift(new SkipUntilOperator(notifier)); };\n    }\n    exports.skipUntil = skipUntil;\n    var SkipUntilOperator = /** @class */ (function () {\n        function SkipUntilOperator(notifier) {\n            this.notifier = notifier;\n        }\n        SkipUntilOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));\n        };\n        return SkipUntilOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SkipUntilSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SkipUntilSubscriber, _super);\n        function SkipUntilSubscriber(destination, notifier) {\n            var _this = _super.call(this, destination) || this;\n            _this.hasValue = false;\n            _this.isInnerStopped = false;\n            _this.add(subscribeToResult_1.subscribeToResult(_this, notifier));\n            return _this;\n        }\n        SkipUntilSubscriber.prototype._next = function (value) {\n            if (this.hasValue) {\n                _super.prototype._next.call(this, value);\n            }\n        };\n        SkipUntilSubscriber.prototype._complete = function () {\n            if (this.isInnerStopped) {\n                _super.prototype._complete.call(this);\n            }\n            else {\n                this.unsubscribe();\n            }\n        };\n        SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.hasValue = true;\n        };\n        SkipUntilSubscriber.prototype.notifyComplete = function () {\n            this.isInnerStopped = true;\n            if (this.isStopped) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        return SkipUntilSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/skipWhile',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n     * true, but emits all further source items as soon as the condition becomes false.\n     *\n     * <img src=\"./img/skipWhile.png\" width=\"100%\">\n     *\n     * @param {Function} predicate - A function to test each item emitted from the source Observable.\n     * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n     * specified predicate becomes false.\n     * @method skipWhile\n     * @owner Observable\n     */\n    function skipWhile(predicate) {\n        return function (source) { return source.lift(new SkipWhileOperator(predicate)); };\n    }\n    exports.skipWhile = skipWhile;\n    var SkipWhileOperator = /** @class */ (function () {\n        function SkipWhileOperator(predicate) {\n            this.predicate = predicate;\n        }\n        SkipWhileOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));\n        };\n        return SkipWhileOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SkipWhileSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SkipWhileSubscriber, _super);\n        function SkipWhileSubscriber(destination, predicate) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.skipping = true;\n            _this.index = 0;\n            return _this;\n        }\n        SkipWhileSubscriber.prototype._next = function (value) {\n            var destination = this.destination;\n            if (this.skipping) {\n                this.tryCallPredicate(value);\n            }\n            if (!this.skipping) {\n                destination.next(value);\n            }\n        };\n        SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {\n            try {\n                var result = this.predicate(value, this.index++);\n                this.skipping = Boolean(result);\n            }\n            catch (err) {\n                this.destination.error(err);\n            }\n        };\n        return SkipWhileSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/startWith',[\"require\", \"exports\", \"../observable/ArrayObservable\", \"../observable/ScalarObservable\", \"../observable/EmptyObservable\", \"../observable/concat\", \"../util/isScheduler\"], function (require, exports, ArrayObservable_1, ScalarObservable_1, EmptyObservable_1, concat_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits the items you specify as arguments before it begins to emit\n     * items emitted by the source Observable.\n     *\n     * <img src=\"./img/startWith.png\" width=\"100%\">\n     *\n     * @param {...T} values - Items you want the modified Observable to emit first.\n     * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n     * emitted by the source Observable.\n     * @method startWith\n     * @owner Observable\n     */\n    function startWith() {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i] = arguments[_i];\n        }\n        return function (source) {\n            var scheduler = array[array.length - 1];\n            if (isScheduler_1.isScheduler(scheduler)) {\n                array.pop();\n            }\n            else {\n                scheduler = null;\n            }\n            var len = array.length;\n            if (len === 1) {\n                return concat_1.concat(new ScalarObservable_1.ScalarObservable(array[0], scheduler), source);\n            }\n            else if (len > 1) {\n                return concat_1.concat(new ArrayObservable_1.ArrayObservable(array, scheduler), source);\n            }\n            else {\n                return concat_1.concat(new EmptyObservable_1.EmptyObservable(scheduler), source);\n            }\n        };\n    }\n    exports.startWith = startWith;\n});\n\ndefine('rxjs/operators/switchMap',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable, emitting values only from the most recently projected Observable.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link switch}.</span>\n     *\n     * <img src=\"./img/switchMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. Each time it observes one of these\n     * inner Observables, the output Observable begins emitting the items emitted by\n     * that inner Observable. When a new inner Observable is emitted, `switchMap`\n     * stops emitting items from the earlier-emitted inner Observable and begins\n     * emitting items from the new one. It continues to behave like this for\n     * subsequent inner Observables.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaustMap}\n     * @see {@link mergeMap}\n     * @see {@link switch}\n     * @see {@link switchMapTo}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and taking only the values from the most recently\n     * projected inner Observable.\n     * @method switchMap\n     * @owner Observable\n     */\n    function switchMap(project, resultSelector) {\n        return function switchMapOperatorFunction(source) {\n            return source.lift(new SwitchMapOperator(project, resultSelector));\n        };\n    }\n    exports.switchMap = switchMap;\n    var SwitchMapOperator = /** @class */ (function () {\n        function SwitchMapOperator(project, resultSelector) {\n            this.project = project;\n            this.resultSelector = resultSelector;\n        }\n        SwitchMapOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));\n        };\n        return SwitchMapOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SwitchMapSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SwitchMapSubscriber, _super);\n        function SwitchMapSubscriber(destination, project, resultSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.project = project;\n            _this.resultSelector = resultSelector;\n            _this.index = 0;\n            return _this;\n        }\n        SwitchMapSubscriber.prototype._next = function (value) {\n            var result;\n            var index = this.index++;\n            try {\n                result = this.project(value, index);\n            }\n            catch (error) {\n                this.destination.error(error);\n                return;\n            }\n            this._innerSub(result, value, index);\n        };\n        SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n            var innerSubscription = this.innerSubscription;\n            if (innerSubscription) {\n                innerSubscription.unsubscribe();\n            }\n            this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));\n        };\n        SwitchMapSubscriber.prototype._complete = function () {\n            var innerSubscription = this.innerSubscription;\n            if (!innerSubscription || innerSubscription.closed) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        SwitchMapSubscriber.prototype._unsubscribe = function () {\n            this.innerSubscription = null;\n        };\n        SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.remove(innerSub);\n            this.innerSubscription = null;\n            if (this.isStopped) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            if (this.resultSelector) {\n                this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                this.destination.next(innerValue);\n            }\n        };\n        SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var result;\n            try {\n                result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return SwitchMapSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/switchAll',[\"require\", \"exports\", \"./switchMap\", \"../util/identity\"], function (require, exports, switchMap_1, identity_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function switchAll() {\n        return switchMap_1.switchMap(identity_1.identity);\n    }\n    exports.switchAll = switchAll;\n});\n\ndefine('rxjs/operators/switchMapTo',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is flattened multiple\n     * times with {@link switch} in the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n     * always to the same inner Observable.</span>\n     *\n     * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then flattens those resulting Observables into one\n     * single Observable, which is the output Observable. The output Observables\n     * emits values only from the most recently emitted instance of\n     * `innerObservable`.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMapTo}\n     * @see {@link switch}\n     * @see {@link switchMap}\n     * @see {@link mergeMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits items from the given\n     * `innerObservable` (and optionally transformed through `resultSelector`) every\n     * time a value is emitted on the source Observable, and taking only the values\n     * from the most recently projected inner Observable.\n     * @method switchMapTo\n     * @owner Observable\n     */\n    function switchMapTo(innerObservable, resultSelector) {\n        return function (source) { return source.lift(new SwitchMapToOperator(innerObservable, resultSelector)); };\n    }\n    exports.switchMapTo = switchMapTo;\n    var SwitchMapToOperator = /** @class */ (function () {\n        function SwitchMapToOperator(observable, resultSelector) {\n            this.observable = observable;\n            this.resultSelector = resultSelector;\n        }\n        SwitchMapToOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));\n        };\n        return SwitchMapToOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var SwitchMapToSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(SwitchMapToSubscriber, _super);\n        function SwitchMapToSubscriber(destination, inner, resultSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.inner = inner;\n            _this.resultSelector = resultSelector;\n            _this.index = 0;\n            return _this;\n        }\n        SwitchMapToSubscriber.prototype._next = function (value) {\n            var innerSubscription = this.innerSubscription;\n            if (innerSubscription) {\n                innerSubscription.unsubscribe();\n            }\n            this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));\n        };\n        SwitchMapToSubscriber.prototype._complete = function () {\n            var innerSubscription = this.innerSubscription;\n            if (!innerSubscription || innerSubscription.closed) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        SwitchMapToSubscriber.prototype._unsubscribe = function () {\n            this.innerSubscription = null;\n        };\n        SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.remove(innerSub);\n            this.innerSubscription = null;\n            if (this.isStopped) {\n                _super.prototype._complete.call(this);\n            }\n        };\n        SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            if (resultSelector) {\n                this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            else {\n                destination.next(innerValue);\n            }\n        };\n        SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {\n            var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;\n            var result;\n            try {\n                result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);\n            }\n            catch (err) {\n                destination.error(err);\n                return;\n            }\n            destination.next(result);\n        };\n        return SwitchMapToSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/take',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../util/ArgumentOutOfRangeError\", \"../observable/EmptyObservable\"], function (require, exports, tslib_1, Subscriber_1, ArgumentOutOfRangeError_1, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first `count` values emitted by the source Observable.\n     *\n     * <span class=\"informal\">Takes the first `count` values from the source, then\n     * completes.</span>\n     *\n     * <img src=\"./img/take.png\" width=\"100%\">\n     *\n     * `take` returns an Observable that emits only the first `count` values emitted\n     * by the source Observable. If the source emits fewer than `count` values then\n     * all of its values are emitted. After that, it completes, regardless if the\n     * source completes.\n     *\n     * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var five = interval.take(5);\n     * five.subscribe(x => console.log(x));\n     *\n     * @see {@link takeLast}\n     * @see {@link takeUntil}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n     *\n     * @param {number} count The maximum number of `next` values to emit.\n     * @return {Observable<T>} An Observable that emits only the first `count`\n     * values emitted by the source Observable, or all of the values from the source\n     * if the source emits fewer than `count` values.\n     * @method take\n     * @owner Observable\n     */\n    function take(count) {\n        return function (source) {\n            if (count === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            else {\n                return source.lift(new TakeOperator(count));\n            }\n        };\n    }\n    exports.take = take;\n    var TakeOperator = /** @class */ (function () {\n        function TakeOperator(total) {\n            this.total = total;\n            if (this.total < 0) {\n                throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n            }\n        }\n        TakeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TakeSubscriber(subscriber, this.total));\n        };\n        return TakeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TakeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TakeSubscriber, _super);\n        function TakeSubscriber(destination, total) {\n            var _this = _super.call(this, destination) || this;\n            _this.total = total;\n            _this.count = 0;\n            return _this;\n        }\n        TakeSubscriber.prototype._next = function (value) {\n            var total = this.total;\n            var count = ++this.count;\n            if (count <= total) {\n                this.destination.next(value);\n                if (count === total) {\n                    this.destination.complete();\n                    this.unsubscribe();\n                }\n            }\n        };\n        return TakeSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/takeUntil',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the values emitted by the source Observable until a `notifier`\n     * Observable emits a value.\n     *\n     * <span class=\"informal\">Lets values pass until a second Observable,\n     * `notifier`, emits something. Then, it completes.</span>\n     *\n     * <img src=\"./img/takeUntil.png\" width=\"100%\">\n     *\n     * `takeUntil` subscribes and begins mirroring the source Observable. It also\n     * monitors a second Observable, `notifier` that you provide. If the `notifier`\n     * emits a value or a complete notification, the output Observable stops\n     * mirroring the source Observable and completes.\n     *\n     * @example <caption>Tick every second until the first click happens</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = interval.takeUntil(clicks);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeLast}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @param {Observable} notifier The Observable whose first emitted value will\n     * cause the output Observable of `takeUntil` to stop emitting values from the\n     * source Observable.\n     * @return {Observable<T>} An Observable that emits the values from the source\n     * Observable until such time as `notifier` emits its first value.\n     * @method takeUntil\n     * @owner Observable\n     */\n    function takeUntil(notifier) {\n        return function (source) { return source.lift(new TakeUntilOperator(notifier)); };\n    }\n    exports.takeUntil = takeUntil;\n    var TakeUntilOperator = /** @class */ (function () {\n        function TakeUntilOperator(notifier) {\n            this.notifier = notifier;\n        }\n        TakeUntilOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));\n        };\n        return TakeUntilOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TakeUntilSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TakeUntilSubscriber, _super);\n        function TakeUntilSubscriber(destination, notifier) {\n            var _this = _super.call(this, destination) || this;\n            _this.notifier = notifier;\n            _this.add(subscribeToResult_1.subscribeToResult(_this, notifier));\n            return _this;\n        }\n        TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.complete();\n        };\n        TakeUntilSubscriber.prototype.notifyComplete = function () {\n            // noop\n        };\n        return TakeUntilSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/takeWhile',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits values emitted by the source Observable so long as each value satisfies\n     * the given `predicate`, and then completes as soon as this `predicate` is not\n     * satisfied.\n     *\n     * <span class=\"informal\">Takes values from the source only while they pass the\n     * condition given. When the first value does not satisfy, it completes.</span>\n     *\n     * <img src=\"./img/takeWhile.png\" width=\"100%\">\n     *\n     * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n     * emitted on the source is given to the `predicate` function which returns a\n     * boolean, representing a condition to be satisfied by the source values. The\n     * output Observable emits the source values until such time as the `predicate`\n     * returns false, at which point `takeWhile` stops mirroring the source\n     * Observable and completes the output Observable.\n     *\n     * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.takeWhile(ev => ev.clientX > 200);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeLast}\n     * @see {@link takeUntil}\n     * @see {@link skip}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates a value emitted by the source Observable and returns a boolean.\n     * Also takes the (zero-based) index as the second argument.\n     * @return {Observable<T>} An Observable that emits the values from the source\n     * Observable so long as each value satisfies the condition defined by the\n     * `predicate`, then completes.\n     * @method takeWhile\n     * @owner Observable\n     */\n    function takeWhile(predicate) {\n        return function (source) { return source.lift(new TakeWhileOperator(predicate)); };\n    }\n    exports.takeWhile = takeWhile;\n    var TakeWhileOperator = /** @class */ (function () {\n        function TakeWhileOperator(predicate) {\n            this.predicate = predicate;\n        }\n        TakeWhileOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));\n        };\n        return TakeWhileOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TakeWhileSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TakeWhileSubscriber, _super);\n        function TakeWhileSubscriber(destination, predicate) {\n            var _this = _super.call(this, destination) || this;\n            _this.predicate = predicate;\n            _this.index = 0;\n            return _this;\n        }\n        TakeWhileSubscriber.prototype._next = function (value) {\n            var destination = this.destination;\n            var result;\n            try {\n                result = this.predicate(value, this.index++);\n            }\n            catch (err) {\n                destination.error(err);\n                return;\n            }\n            this.nextOrComplete(value, result);\n        };\n        TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {\n            var destination = this.destination;\n            if (Boolean(predicateResult)) {\n                destination.next(value);\n            }\n            else {\n                destination.complete();\n            }\n        };\n        return TakeWhileSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/tap',[\"require\", \"exports\", \"tslib\", \"../Subscriber\"], function (require, exports, tslib_1, Subscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Perform a side effect for every emission on the source Observable, but return\n     * an Observable that is identical to the source.\n     *\n     * <span class=\"informal\">Intercepts each emission on the source and runs a\n     * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n     *\n     * <img src=\"./img/do.png\" width=\"100%\">\n     *\n     * Returns a mirrored Observable of the source Observable, but modified so that\n     * the provided Observer is called to perform a side effect for every value,\n     * error, and completion emitted by the source. Any errors that are thrown in\n     * the aforementioned Observer or handlers are safely sent down the error path\n     * of the output Observable.\n     *\n     * This operator is useful for debugging your Observables for the correct values\n     * or performing other side effects.\n     *\n     * Note: this is different to a `subscribe` on the Observable. If the Observable\n     * returned by `do` is not subscribed, the side effects specified by the\n     * Observer will never happen. `do` therefore simply spies on existing\n     * execution, it does not trigger an execution to happen like `subscribe` does.\n     *\n     * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var positions = clicks\n     *   .do(ev => console.log(ev))\n     *   .map(ev => ev.clientX);\n     * positions.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     * @see {@link subscribe}\n     *\n     * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n     * callback for `next`.\n     * @param {function} [error] Callback for errors in the source.\n     * @param {function} [complete] Callback for the completion of the source.\n     * @return {Observable} An Observable identical to the source, but runs the\n     * specified Observer or callback(s) for each item.\n     * @name tap\n     */\n    function tap(nextOrObserver, error, complete) {\n        return function tapOperatorFunction(source) {\n            return source.lift(new DoOperator(nextOrObserver, error, complete));\n        };\n    }\n    exports.tap = tap;\n    var DoOperator = /** @class */ (function () {\n        function DoOperator(nextOrObserver, error, complete) {\n            this.nextOrObserver = nextOrObserver;\n            this.error = error;\n            this.complete = complete;\n        }\n        DoOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));\n        };\n        return DoOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var DoSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DoSubscriber, _super);\n        function DoSubscriber(destination, nextOrObserver, error, complete) {\n            var _this = _super.call(this, destination) || this;\n            var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);\n            safeSubscriber.syncErrorThrowable = true;\n            _this.add(safeSubscriber);\n            _this.safeSubscriber = safeSubscriber;\n            return _this;\n        }\n        DoSubscriber.prototype._next = function (value) {\n            var safeSubscriber = this.safeSubscriber;\n            safeSubscriber.next(value);\n            if (safeSubscriber.syncErrorThrown) {\n                this.destination.error(safeSubscriber.syncErrorValue);\n            }\n            else {\n                this.destination.next(value);\n            }\n        };\n        DoSubscriber.prototype._error = function (err) {\n            var safeSubscriber = this.safeSubscriber;\n            safeSubscriber.error(err);\n            if (safeSubscriber.syncErrorThrown) {\n                this.destination.error(safeSubscriber.syncErrorValue);\n            }\n            else {\n                this.destination.error(err);\n            }\n        };\n        DoSubscriber.prototype._complete = function () {\n            var safeSubscriber = this.safeSubscriber;\n            safeSubscriber.complete();\n            if (safeSubscriber.syncErrorThrown) {\n                this.destination.error(safeSubscriber.syncErrorValue);\n            }\n            else {\n                this.destination.complete();\n            }\n        };\n        return DoSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/throttle',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.defaultThrottleConfig = {\n        leading: true,\n        trailing: false\n    };\n    /**\n     * Emits a value from the source Observable, then ignores subsequent source\n     * values for a duration determined by another Observable, then repeats this\n     * process.\n     *\n     * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n     * duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/throttle.png\" width=\"100%\">\n     *\n     * `throttle` emits the source Observable values on the output Observable\n     * when its internal timer is disabled, and ignores source values when the timer\n     * is enabled. Initially, the timer is disabled. As soon as the first source\n     * value arrives, it is forwarded to the output Observable, and then the timer\n     * is enabled by calling the `durationSelector` function with the source value,\n     * which returns the \"duration\" Observable. When the duration Observable emits a\n     * value or completes, the timer is disabled, and this process repeats for the\n     * next source value.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounce}\n     * @see {@link delayWhen}\n     * @see {@link sample}\n     * @see {@link throttleTime}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the silencing\n     * duration for each source value, returned as an Observable or a Promise.\n     * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n     * to `{ leading: true, trailing: false }`.\n     * @return {Observable<T>} An Observable that performs the throttle operation to\n     * limit the rate of emissions from the source.\n     * @method throttle\n     * @owner Observable\n     */\n    function throttle(durationSelector, config) {\n        if (config === void 0) { config = exports.defaultThrottleConfig; }\n        return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };\n    }\n    exports.throttle = throttle;\n    var ThrottleOperator = /** @class */ (function () {\n        function ThrottleOperator(durationSelector, leading, trailing) {\n            this.durationSelector = durationSelector;\n            this.leading = leading;\n            this.trailing = trailing;\n        }\n        ThrottleOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));\n        };\n        return ThrottleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ThrottleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ThrottleSubscriber, _super);\n        function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.durationSelector = durationSelector;\n            _this._leading = _leading;\n            _this._trailing = _trailing;\n            _this._hasTrailingValue = false;\n            return _this;\n        }\n        ThrottleSubscriber.prototype._next = function (value) {\n            if (this.throttled) {\n                if (this._trailing) {\n                    this._hasTrailingValue = true;\n                    this._trailingValue = value;\n                }\n            }\n            else {\n                var duration = this.tryDurationSelector(value);\n                if (duration) {\n                    this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));\n                }\n                if (this._leading) {\n                    this.destination.next(value);\n                    if (this._trailing) {\n                        this._hasTrailingValue = true;\n                        this._trailingValue = value;\n                    }\n                }\n            }\n        };\n        ThrottleSubscriber.prototype.tryDurationSelector = function (value) {\n            try {\n                return this.durationSelector(value);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return null;\n            }\n        };\n        ThrottleSubscriber.prototype._unsubscribe = function () {\n            var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;\n            this._trailingValue = null;\n            this._hasTrailingValue = false;\n            if (throttled) {\n                this.remove(throttled);\n                this.throttled = null;\n                throttled.unsubscribe();\n            }\n        };\n        ThrottleSubscriber.prototype._sendTrailing = function () {\n            var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;\n            if (throttled && _trailing && _hasTrailingValue) {\n                destination.next(_trailingValue);\n                this._trailingValue = null;\n                this._hasTrailingValue = false;\n            }\n        };\n        ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this._sendTrailing();\n            this._unsubscribe();\n        };\n        ThrottleSubscriber.prototype.notifyComplete = function () {\n            this._sendTrailing();\n            this._unsubscribe();\n        };\n        return ThrottleSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/throttleTime',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../scheduler/async\", \"./throttle\"], function (require, exports, tslib_1, Subscriber_1, async_1, throttle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable, then ignores subsequent source\n     * values for `duration` milliseconds, then repeats this process.\n     *\n     * <span class=\"informal\">Lets a value pass, then ignores source values for the\n     * next `duration` milliseconds.</span>\n     *\n     * <img src=\"./img/throttleTime.png\" width=\"100%\">\n     *\n     * `throttleTime` emits the source Observable values on the output Observable\n     * when its internal timer is disabled, and ignores source values when the timer\n     * is enabled. Initially, the timer is disabled. As soon as the first source\n     * value arrives, it is forwarded to the output Observable, and then the timer\n     * is enabled. After `duration` milliseconds (or the time unit determined\n     * internally by the optional `scheduler`) has passed, the timer is disabled,\n     * and this process repeats for the next source value. Optionally takes a\n     * {@link IScheduler} for managing timers.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.throttleTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttle}\n     *\n     * @param {number} duration Time to wait before emitting another value after\n     * emitting the last value, measured in milliseconds or the time unit determined\n     * internally by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the throttling.\n     * @return {Observable<T>} An Observable that performs the throttle operation to\n     * limit the rate of emissions from the source.\n     * @method throttleTime\n     * @owner Observable\n     */\n    function throttleTime(duration, scheduler, config) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n        return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };\n    }\n    exports.throttleTime = throttleTime;\n    var ThrottleTimeOperator = /** @class */ (function () {\n        function ThrottleTimeOperator(duration, scheduler, leading, trailing) {\n            this.duration = duration;\n            this.scheduler = scheduler;\n            this.leading = leading;\n            this.trailing = trailing;\n        }\n        ThrottleTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));\n        };\n        return ThrottleTimeOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ThrottleTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ThrottleTimeSubscriber, _super);\n        function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {\n            var _this = _super.call(this, destination) || this;\n            _this.duration = duration;\n            _this.scheduler = scheduler;\n            _this.leading = leading;\n            _this.trailing = trailing;\n            _this._hasTrailingValue = false;\n            _this._trailingValue = null;\n            return _this;\n        }\n        ThrottleTimeSubscriber.prototype._next = function (value) {\n            if (this.throttled) {\n                if (this.trailing) {\n                    this._trailingValue = value;\n                    this._hasTrailingValue = true;\n                }\n            }\n            else {\n                this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));\n                if (this.leading) {\n                    this.destination.next(value);\n                }\n            }\n        };\n        ThrottleTimeSubscriber.prototype.clearThrottle = function () {\n            var throttled = this.throttled;\n            if (throttled) {\n                if (this.trailing && this._hasTrailingValue) {\n                    this.destination.next(this._trailingValue);\n                    this._trailingValue = null;\n                    this._hasTrailingValue = false;\n                }\n                throttled.unsubscribe();\n                this.remove(throttled);\n                this.throttled = null;\n            }\n        };\n        return ThrottleTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchNext(arg) {\n        var subscriber = arg.subscriber;\n        subscriber.clearThrottle();\n    }\n});\n\ndefine('rxjs/operators/timeout',[\"require\", \"exports\", \"tslib\", \"../scheduler/async\", \"../util/isDate\", \"../Subscriber\", \"../util/TimeoutError\"], function (require, exports, tslib_1, async_1, isDate_1, Subscriber_1, TimeoutError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Errors if Observable does not emit a value in given time span.\n     *\n     * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n     *\n     * <img src=\"./img/timeout.png\" width=\"100%\">\n     *\n     * `timeout` operator accepts as an argument either a number or a Date.\n     *\n     * If number was provided, it returns an Observable that behaves like a source\n     * Observable, unless there is a period of time where there is no value emitted.\n     * So if you provide `100` as argument and first value comes after 50ms from\n     * the moment of subscription, this value will be simply re-emitted by the resulting\n     * Observable. If however after that 100ms passes without a second value being emitted,\n     * stream will end with an error and source Observable will be unsubscribed.\n     * These checks are performed throughout whole lifecycle of Observable - from the moment\n     * it was subscribed to, until it completes or errors itself. Thus every value must be\n     * emitted within specified period since previous value.\n     *\n     * If provided argument was Date, returned Observable behaves differently. It throws\n     * if Observable did not complete before provided Date. This means that periods between\n     * emission of particular values do not matter in this case. If Observable did not complete\n     * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n     * stream behaves just as source Observable.\n     *\n     * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n     * when returned Observable will check if source stream emitted value or completed.\n     *\n     * @example <caption>Check if ticks are emitted within certain timespan</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n     *                       // since `interval` might fire a bit later then scheduled.\n     * .subscribe(\n     *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n     *     err => console.log(err) // Will never be called.\n     * );\n     *\n     * seconds.timeout(900).subscribe(\n     *     value => console.log(value), // Will never be called.\n     *     err => console.log(err) // Will emit error before even first value is emitted,\n     *                             // since it did not arrive within 900ms period.\n     * );\n     *\n     * @example <caption>Use Date to check if Observable completed</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n     * .subscribe(\n     *     value => console.log(value), // Will emit values as regular `interval` would\n     *                                  // until December 17, 2020 at 03:24:00.\n     *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n     *                             // since Observable did not complete by then.\n     * );\n     *\n     * @see {@link timeoutWith}\n     *\n     * @param {number|Date} due Number specifying period within which Observable must emit values\n     *                          or Date specifying before when Observable should complete\n     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n     * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n     * @method timeout\n     * @owner Observable\n     */\n    function timeout(due, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        var absoluteTimeout = isDate_1.isDate(due);\n        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n        return function (source) { return source.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError())); };\n    }\n    exports.timeout = timeout;\n    var TimeoutOperator = /** @class */ (function () {\n        function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {\n            this.waitFor = waitFor;\n            this.absoluteTimeout = absoluteTimeout;\n            this.scheduler = scheduler;\n            this.errorInstance = errorInstance;\n        }\n        TimeoutOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));\n        };\n        return TimeoutOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TimeoutSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeoutSubscriber, _super);\n        function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {\n            var _this = _super.call(this, destination) || this;\n            _this.absoluteTimeout = absoluteTimeout;\n            _this.waitFor = waitFor;\n            _this.scheduler = scheduler;\n            _this.errorInstance = errorInstance;\n            _this.action = null;\n            _this.scheduleTimeout();\n            return _this;\n        }\n        TimeoutSubscriber.dispatchTimeout = function (subscriber) {\n            subscriber.error(subscriber.errorInstance);\n        };\n        TimeoutSubscriber.prototype.scheduleTimeout = function () {\n            var action = this.action;\n            if (action) {\n                // Recycle the action if we've already scheduled one. All the production\n                // Scheduler Actions mutate their state/delay time and return themeselves.\n                // VirtualActions are immutable, so they create and return a clone. In this\n                // case, we need to set the action reference to the most recent VirtualAction,\n                // to ensure that's the one we clone from next time.\n                this.action = action.schedule(this, this.waitFor);\n            }\n            else {\n                this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));\n            }\n        };\n        TimeoutSubscriber.prototype._next = function (value) {\n            if (!this.absoluteTimeout) {\n                this.scheduleTimeout();\n            }\n            _super.prototype._next.call(this, value);\n        };\n        TimeoutSubscriber.prototype._unsubscribe = function () {\n            this.action = null;\n            this.scheduler = null;\n            this.errorInstance = null;\n        };\n        return TimeoutSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/timeoutWith',[\"require\", \"exports\", \"tslib\", \"../scheduler/async\", \"../util/isDate\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, async_1, isDate_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     *\n     * Errors if Observable does not emit a value in given time span, in case of which\n     * subscribes to the second Observable.\n     *\n     * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n     *\n     * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n     *\n     * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n     * still accepting as a first argument either a number or a Date, which control - respectively -\n     * when values of source Observable should be emitted or when it should complete.\n     *\n     * The only difference is that it accepts a second, required parameter. This parameter\n     * should be an Observable which will be subscribed when source Observable fails any timeout check.\n     * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n     * values from second Observable. Note that this fallback Observable is not checked for timeouts\n     * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n     * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n     * stream completes, it completes as well.\n     *\n     * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n     * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n     * as a consequence - when second Observable will be subscribed, since subscription happens\n     * immediately after failing check.\n     *\n     * @example <caption>Add fallback observable</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     * const minutes = Rx.Observable.interval(60 * 1000);\n     *\n     * seconds.timeoutWith(900, minutes)\n     *     .subscribe(\n     *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n     *                                      // since first value of `seconds` will not arrive fast enough.\n     *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n     *                                 // but here will never be called.\n     *     );\n     *\n     * @param {number|Date} due Number specifying period within which Observable must emit values\n     *                          or Date specifying before when Observable should complete\n     * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n     * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n     *                          passed as a second parameter.\n     * @method timeoutWith\n     * @owner Observable\n     */\n    function timeoutWith(due, withObservable, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return function (source) {\n            var absoluteTimeout = isDate_1.isDate(due);\n            var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);\n            return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n        };\n    }\n    exports.timeoutWith = timeoutWith;\n    var TimeoutWithOperator = /** @class */ (function () {\n        function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n            this.waitFor = waitFor;\n            this.absoluteTimeout = absoluteTimeout;\n            this.withObservable = withObservable;\n            this.scheduler = scheduler;\n        }\n        TimeoutWithOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n        };\n        return TimeoutWithOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var TimeoutWithSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(TimeoutWithSubscriber, _super);\n        function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.absoluteTimeout = absoluteTimeout;\n            _this.waitFor = waitFor;\n            _this.withObservable = withObservable;\n            _this.scheduler = scheduler;\n            _this.action = null;\n            _this.scheduleTimeout();\n            return _this;\n        }\n        TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n            var withObservable = subscriber.withObservable;\n            subscriber._unsubscribeAndRecycle();\n            subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));\n        };\n        TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n            var action = this.action;\n            if (action) {\n                // Recycle the action if we've already scheduled one. All the production\n                // Scheduler Actions mutate their state/delay time and return themeselves.\n                // VirtualActions are immutable, so they create and return a clone. In this\n                // case, we need to set the action reference to the most recent VirtualAction,\n                // to ensure that's the one we clone from next time.\n                this.action = action.schedule(this, this.waitFor);\n            }\n            else {\n                this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n            }\n        };\n        TimeoutWithSubscriber.prototype._next = function (value) {\n            if (!this.absoluteTimeout) {\n                this.scheduleTimeout();\n            }\n            _super.prototype._next.call(this, value);\n        };\n        TimeoutWithSubscriber.prototype._unsubscribe = function () {\n            this.action = null;\n            this.scheduler = null;\n            this.withObservable = null;\n        };\n        return TimeoutWithSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/toArray',[\"require\", \"exports\", \"./reduce\"], function (require, exports, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function toArrayReducer(arr, item, index) {\n        arr.push(item);\n        return arr;\n    }\n    function toArray() {\n        return reduce_1.reduce(toArrayReducer, []);\n    }\n    exports.toArray = toArray;\n});\n\ndefine('rxjs/operators/window',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable whenever\n     * `windowBoundaries` emits.\n     *\n     * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n     * instead of an array.</span>\n     *\n     * <img src=\"./img/window.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits connected, non-overlapping\n     * windows. It emits the current window and opens a new one whenever the\n     * Observable `windowBoundaries` emits an item. Because each window is an\n     * Observable, the output is a higher-order Observable.\n     *\n     * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = clicks.window(interval)\n     *   .map(win => win.take(2)) // each window has at most 2 emissions\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link windowWhen}\n     * @see {@link buffer}\n     *\n     * @param {Observable<any>} windowBoundaries An Observable that completes the\n     * previous window and starts a new window.\n     * @return {Observable<Observable<T>>} An Observable of windows, which are\n     * Observables emitting values of the source Observable.\n     * @method window\n     * @owner Observable\n     */\n    function window(windowBoundaries) {\n        return function windowOperatorFunction(source) {\n            return source.lift(new WindowOperator(windowBoundaries));\n        };\n    }\n    exports.window = window;\n    var WindowOperator = /** @class */ (function () {\n        function WindowOperator(windowBoundaries) {\n            this.windowBoundaries = windowBoundaries;\n        }\n        WindowOperator.prototype.call = function (subscriber, source) {\n            var windowSubscriber = new WindowSubscriber(subscriber);\n            var sourceSubscription = source.subscribe(windowSubscriber);\n            if (!sourceSubscription.closed) {\n                windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));\n            }\n            return sourceSubscription;\n        };\n        return WindowOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowSubscriber, _super);\n        function WindowSubscriber(destination) {\n            var _this = _super.call(this, destination) || this;\n            _this.window = new Subject_1.Subject();\n            destination.next(_this.window);\n            return _this;\n        }\n        WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.openWindow();\n        };\n        WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n            this._error(error);\n        };\n        WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n            this._complete();\n        };\n        WindowSubscriber.prototype._next = function (value) {\n            this.window.next(value);\n        };\n        WindowSubscriber.prototype._error = function (err) {\n            this.window.error(err);\n            this.destination.error(err);\n        };\n        WindowSubscriber.prototype._complete = function () {\n            this.window.complete();\n            this.destination.complete();\n        };\n        WindowSubscriber.prototype._unsubscribe = function () {\n            this.window = null;\n        };\n        WindowSubscriber.prototype.openWindow = function () {\n            var prevWindow = this.window;\n            if (prevWindow) {\n                prevWindow.complete();\n            }\n            var destination = this.destination;\n            var newWindow = this.window = new Subject_1.Subject();\n            destination.next(newWindow);\n        };\n        return WindowSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/windowCount',[\"require\", \"exports\", \"tslib\", \"../Subscriber\", \"../Subject\"], function (require, exports, tslib_1, Subscriber_1, Subject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable with each\n     * nested Observable emitting at most `windowSize` values.\n     *\n     * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowCount.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits windows every `startWindowEvery`\n     * items, each containing no more than `windowSize` items. When the source\n     * Observable completes or encounters an error, the output Observable emits\n     * the current window and propagates the notification from the source\n     * Observable. If `startWindowEvery` is not provided, then new windows are\n     * started immediately at the start of the source and when each window completes\n     * with size `windowSize`.\n     *\n     * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.windowCount(3)\n     *   .map(win => win.skip(1)) // skip first of every 3 clicks\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.windowCount(2, 3)\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link windowWhen}\n     * @see {@link bufferCount}\n     *\n     * @param {number} windowSize The maximum number of values emitted by each\n     * window.\n     * @param {number} [startWindowEvery] Interval at which to start a new window.\n     * For example if `startWindowEvery` is `2`, then a new window will be started\n     * on every other value from the source. A new window is started at the\n     * beginning of the source by default.\n     * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n     * are Observable of values.\n     * @method windowCount\n     * @owner Observable\n     */\n    function windowCount(windowSize, startWindowEvery) {\n        if (startWindowEvery === void 0) { startWindowEvery = 0; }\n        return function windowCountOperatorFunction(source) {\n            return source.lift(new WindowCountOperator(windowSize, startWindowEvery));\n        };\n    }\n    exports.windowCount = windowCount;\n    var WindowCountOperator = /** @class */ (function () {\n        function WindowCountOperator(windowSize, startWindowEvery) {\n            this.windowSize = windowSize;\n            this.startWindowEvery = startWindowEvery;\n        }\n        WindowCountOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));\n        };\n        return WindowCountOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowCountSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowCountSubscriber, _super);\n        function WindowCountSubscriber(destination, windowSize, startWindowEvery) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.windowSize = windowSize;\n            _this.startWindowEvery = startWindowEvery;\n            _this.windows = [new Subject_1.Subject()];\n            _this.count = 0;\n            destination.next(_this.windows[0]);\n            return _this;\n        }\n        WindowCountSubscriber.prototype._next = function (value) {\n            var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;\n            var destination = this.destination;\n            var windowSize = this.windowSize;\n            var windows = this.windows;\n            var len = windows.length;\n            for (var i = 0; i < len && !this.closed; i++) {\n                windows[i].next(value);\n            }\n            var c = this.count - windowSize + 1;\n            if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {\n                windows.shift().complete();\n            }\n            if (++this.count % startWindowEvery === 0 && !this.closed) {\n                var window_1 = new Subject_1.Subject();\n                windows.push(window_1);\n                destination.next(window_1);\n            }\n        };\n        WindowCountSubscriber.prototype._error = function (err) {\n            var windows = this.windows;\n            if (windows) {\n                while (windows.length > 0 && !this.closed) {\n                    windows.shift().error(err);\n                }\n            }\n            this.destination.error(err);\n        };\n        WindowCountSubscriber.prototype._complete = function () {\n            var windows = this.windows;\n            if (windows) {\n                while (windows.length > 0 && !this.closed) {\n                    windows.shift().complete();\n                }\n            }\n            this.destination.complete();\n        };\n        WindowCountSubscriber.prototype._unsubscribe = function () {\n            this.count = 0;\n            this.windows = null;\n        };\n        return WindowCountSubscriber;\n    }(Subscriber_1.Subscriber));\n});\n\ndefine('rxjs/operators/windowTime',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../scheduler/async\", \"../Subscriber\", \"../util/isNumeric\", \"../util/isScheduler\"], function (require, exports, tslib_1, Subject_1, async_1, Subscriber_1, isNumeric_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function windowTime(windowTimeSpan) {\n        var scheduler = async_1.async;\n        var windowCreationInterval = null;\n        var maxWindowSize = Number.POSITIVE_INFINITY;\n        if (isScheduler_1.isScheduler(arguments[3])) {\n            scheduler = arguments[3];\n        }\n        if (isScheduler_1.isScheduler(arguments[2])) {\n            scheduler = arguments[2];\n        }\n        else if (isNumeric_1.isNumeric(arguments[2])) {\n            maxWindowSize = arguments[2];\n        }\n        if (isScheduler_1.isScheduler(arguments[1])) {\n            scheduler = arguments[1];\n        }\n        else if (isNumeric_1.isNumeric(arguments[1])) {\n            windowCreationInterval = arguments[1];\n        }\n        return function windowTimeOperatorFunction(source) {\n            return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));\n        };\n    }\n    exports.windowTime = windowTime;\n    var WindowTimeOperator = /** @class */ (function () {\n        function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n            this.windowTimeSpan = windowTimeSpan;\n            this.windowCreationInterval = windowCreationInterval;\n            this.maxWindowSize = maxWindowSize;\n            this.scheduler = scheduler;\n        }\n        WindowTimeOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));\n        };\n        return WindowTimeOperator;\n    }());\n    var CountedSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(CountedSubject, _super);\n        function CountedSubject() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._numberOfNextedValues = 0;\n            return _this;\n        }\n        CountedSubject.prototype.next = function (value) {\n            this._numberOfNextedValues++;\n            _super.prototype.next.call(this, value);\n        };\n        Object.defineProperty(CountedSubject.prototype, \"numberOfNextedValues\", {\n            get: function () {\n                return this._numberOfNextedValues;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return CountedSubject;\n    }(Subject_1.Subject));\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowTimeSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowTimeSubscriber, _super);\n        function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.windowTimeSpan = windowTimeSpan;\n            _this.windowCreationInterval = windowCreationInterval;\n            _this.maxWindowSize = maxWindowSize;\n            _this.scheduler = scheduler;\n            _this.windows = [];\n            var window = _this.openWindow();\n            if (windowCreationInterval !== null && windowCreationInterval >= 0) {\n                var closeState = { subscriber: _this, window: window, context: null };\n                var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };\n                _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));\n                _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));\n            }\n            else {\n                var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };\n                _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));\n            }\n            return _this;\n        }\n        WindowTimeSubscriber.prototype._next = function (value) {\n            var windows = this.windows;\n            var len = windows.length;\n            for (var i = 0; i < len; i++) {\n                var window_1 = windows[i];\n                if (!window_1.closed) {\n                    window_1.next(value);\n                    if (window_1.numberOfNextedValues >= this.maxWindowSize) {\n                        this.closeWindow(window_1);\n                    }\n                }\n            }\n        };\n        WindowTimeSubscriber.prototype._error = function (err) {\n            var windows = this.windows;\n            while (windows.length > 0) {\n                windows.shift().error(err);\n            }\n            this.destination.error(err);\n        };\n        WindowTimeSubscriber.prototype._complete = function () {\n            var windows = this.windows;\n            while (windows.length > 0) {\n                var window_2 = windows.shift();\n                if (!window_2.closed) {\n                    window_2.complete();\n                }\n            }\n            this.destination.complete();\n        };\n        WindowTimeSubscriber.prototype.openWindow = function () {\n            var window = new CountedSubject();\n            this.windows.push(window);\n            var destination = this.destination;\n            destination.next(window);\n            return window;\n        };\n        WindowTimeSubscriber.prototype.closeWindow = function (window) {\n            window.complete();\n            var windows = this.windows;\n            windows.splice(windows.indexOf(window), 1);\n        };\n        return WindowTimeSubscriber;\n    }(Subscriber_1.Subscriber));\n    function dispatchWindowTimeSpanOnly(state) {\n        var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;\n        if (window) {\n            subscriber.closeWindow(window);\n        }\n        state.window = subscriber.openWindow();\n        this.schedule(state, windowTimeSpan);\n    }\n    function dispatchWindowCreation(state) {\n        var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;\n        var window = subscriber.openWindow();\n        var action = this;\n        var context = { action: action, subscription: null };\n        var timeSpanState = { subscriber: subscriber, window: window, context: context };\n        context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);\n        action.add(context.subscription);\n        action.schedule(state, windowCreationInterval);\n    }\n    function dispatchWindowClose(state) {\n        var subscriber = state.subscriber, window = state.window, context = state.context;\n        if (context && context.action && context.subscription) {\n            context.action.remove(context.subscription);\n        }\n        subscriber.closeWindow(window);\n    }\n});\n\ndefine('rxjs/operators/windowToggle',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../Subscription\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, Subscription_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable starting from\n     * an emission from `openings` and ending when the output of `closingSelector`\n     * emits.\n     *\n     * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowToggle.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits windows that contain those items\n     * emitted by the source Observable between the time when the `openings`\n     * Observable emits an item and when the Observable returned by\n     * `closingSelector` emits an item.\n     *\n     * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var openings = Rx.Observable.interval(1000);\n     * var result = clicks.windowToggle(openings, i =>\n     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n     * ).mergeAll();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowWhen}\n     * @see {@link bufferToggle}\n     *\n     * @param {Observable<O>} openings An observable of notifications to start new\n     * windows.\n     * @param {function(value: O): Observable} closingSelector A function that takes\n     * the value emitted by the `openings` observable and returns an Observable,\n     * which, when it emits (either `next` or `complete`), signals that the\n     * associated window should complete.\n     * @return {Observable<Observable<T>>} An observable of windows, which in turn\n     * are Observables.\n     * @method windowToggle\n     * @owner Observable\n     */\n    function windowToggle(openings, closingSelector) {\n        return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };\n    }\n    exports.windowToggle = windowToggle;\n    var WindowToggleOperator = /** @class */ (function () {\n        function WindowToggleOperator(openings, closingSelector) {\n            this.openings = openings;\n            this.closingSelector = closingSelector;\n        }\n        WindowToggleOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));\n        };\n        return WindowToggleOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowToggleSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowToggleSubscriber, _super);\n        function WindowToggleSubscriber(destination, openings, closingSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.openings = openings;\n            _this.closingSelector = closingSelector;\n            _this.contexts = [];\n            _this.add(_this.openSubscription = subscribeToResult_1.subscribeToResult(_this, openings, openings));\n            return _this;\n        }\n        WindowToggleSubscriber.prototype._next = function (value) {\n            var contexts = this.contexts;\n            if (contexts) {\n                var len = contexts.length;\n                for (var i = 0; i < len; i++) {\n                    contexts[i].window.next(value);\n                }\n            }\n        };\n        WindowToggleSubscriber.prototype._error = function (err) {\n            var contexts = this.contexts;\n            this.contexts = null;\n            if (contexts) {\n                var len = contexts.length;\n                var index = -1;\n                while (++index < len) {\n                    var context = contexts[index];\n                    context.window.error(err);\n                    context.subscription.unsubscribe();\n                }\n            }\n            _super.prototype._error.call(this, err);\n        };\n        WindowToggleSubscriber.prototype._complete = function () {\n            var contexts = this.contexts;\n            this.contexts = null;\n            if (contexts) {\n                var len = contexts.length;\n                var index = -1;\n                while (++index < len) {\n                    var context = contexts[index];\n                    context.window.complete();\n                    context.subscription.unsubscribe();\n                }\n            }\n            _super.prototype._complete.call(this);\n        };\n        WindowToggleSubscriber.prototype._unsubscribe = function () {\n            var contexts = this.contexts;\n            this.contexts = null;\n            if (contexts) {\n                var len = contexts.length;\n                var index = -1;\n                while (++index < len) {\n                    var context = contexts[index];\n                    context.window.unsubscribe();\n                    context.subscription.unsubscribe();\n                }\n            }\n        };\n        WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            if (outerValue === this.openings) {\n                var closingSelector = this.closingSelector;\n                var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);\n                if (closingNotifier === errorObject_1.errorObject) {\n                    return this.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    var window_1 = new Subject_1.Subject();\n                    var subscription = new Subscription_1.Subscription();\n                    var context = { window: window_1, subscription: subscription };\n                    this.contexts.push(context);\n                    var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);\n                    if (innerSubscription.closed) {\n                        this.closeWindow(this.contexts.length - 1);\n                    }\n                    else {\n                        innerSubscription.context = context;\n                        subscription.add(innerSubscription);\n                    }\n                    this.destination.next(window_1);\n                }\n            }\n            else {\n                this.closeWindow(this.contexts.indexOf(outerValue));\n            }\n        };\n        WindowToggleSubscriber.prototype.notifyError = function (err) {\n            this.error(err);\n        };\n        WindowToggleSubscriber.prototype.notifyComplete = function (inner) {\n            if (inner !== this.openSubscription) {\n                this.closeWindow(this.contexts.indexOf(inner.context));\n            }\n        };\n        WindowToggleSubscriber.prototype.closeWindow = function (index) {\n            if (index === -1) {\n                return;\n            }\n            var contexts = this.contexts;\n            var context = contexts[index];\n            var window = context.window, subscription = context.subscription;\n            contexts.splice(index, 1);\n            window.complete();\n            subscription.unsubscribe();\n        };\n        return WindowToggleSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/windowWhen',[\"require\", \"exports\", \"tslib\", \"../Subject\", \"../util/tryCatch\", \"../util/errorObject\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, Subject_1, tryCatch_1, errorObject_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable using a\n     * factory function of closing Observables to determine when to start a new\n     * window.\n     *\n     * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowWhen.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits connected, non-overlapping windows.\n     * It emits the current window and opens a new one whenever the Observable\n     * produced by the specified `closingSelector` function emits an item. The first\n     * window is opened immediately when subscribing to the output Observable.\n     *\n     * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks\n     *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n     *   .map(win => win.take(2)) // each window has at most 2 emissions\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link bufferWhen}\n     *\n     * @param {function(): Observable} closingSelector A function that takes no\n     * arguments and returns an Observable that signals (on either `next` or\n     * `complete`) when to close the previous window and start a new one.\n     * @return {Observable<Observable<T>>} An observable of windows, which in turn\n     * are Observables.\n     * @method windowWhen\n     * @owner Observable\n     */\n    function windowWhen(closingSelector) {\n        return function windowWhenOperatorFunction(source) {\n            return source.lift(new WindowOperator(closingSelector));\n        };\n    }\n    exports.windowWhen = windowWhen;\n    var WindowOperator = /** @class */ (function () {\n        function WindowOperator(closingSelector) {\n            this.closingSelector = closingSelector;\n        }\n        WindowOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));\n        };\n        return WindowOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WindowSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WindowSubscriber, _super);\n        function WindowSubscriber(destination, closingSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.destination = destination;\n            _this.closingSelector = closingSelector;\n            _this.openWindow();\n            return _this;\n        }\n        WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.openWindow(innerSub);\n        };\n        WindowSubscriber.prototype.notifyError = function (error, innerSub) {\n            this._error(error);\n        };\n        WindowSubscriber.prototype.notifyComplete = function (innerSub) {\n            this.openWindow(innerSub);\n        };\n        WindowSubscriber.prototype._next = function (value) {\n            this.window.next(value);\n        };\n        WindowSubscriber.prototype._error = function (err) {\n            this.window.error(err);\n            this.destination.error(err);\n            this.unsubscribeClosingNotification();\n        };\n        WindowSubscriber.prototype._complete = function () {\n            this.window.complete();\n            this.destination.complete();\n            this.unsubscribeClosingNotification();\n        };\n        WindowSubscriber.prototype.unsubscribeClosingNotification = function () {\n            if (this.closingNotification) {\n                this.closingNotification.unsubscribe();\n            }\n        };\n        WindowSubscriber.prototype.openWindow = function (innerSub) {\n            if (innerSub === void 0) { innerSub = null; }\n            if (innerSub) {\n                this.remove(innerSub);\n                innerSub.unsubscribe();\n            }\n            var prevWindow = this.window;\n            if (prevWindow) {\n                prevWindow.complete();\n            }\n            var window = this.window = new Subject_1.Subject();\n            this.destination.next(window);\n            var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();\n            if (closingNotifier === errorObject_1.errorObject) {\n                var err = errorObject_1.errorObject.e;\n                this.destination.error(err);\n                this.window.error(err);\n            }\n            else {\n                this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));\n            }\n        };\n        return WindowSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/withLatestFrom',[\"require\", \"exports\", \"tslib\", \"../OuterSubscriber\", \"../util/subscribeToResult\"], function (require, exports, tslib_1, OuterSubscriber_1, subscribeToResult_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines the source Observable with other Observables to create an Observable\n     * whose values are calculated from the latest values of each, only when the\n     * source emits.\n     *\n     * <span class=\"informal\">Whenever the source Observable emits a value, it\n     * computes a formula using that value plus the latest values from other input\n     * Observables, then emits the output of that formula.</span>\n     *\n     * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n     *\n     * `withLatestFrom` combines each value from the source Observable (the\n     * instance) with the latest values from the other input Observables only when\n     * the source emits a value, optionally using a `project` function to determine\n     * the value to be emitted on the output Observable. All input Observables must\n     * emit at least one value before the output Observable will emit a value.\n     *\n     * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var result = clicks.withLatestFrom(timer);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineLatest}\n     *\n     * @param {ObservableInput} other An input Observable to combine with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {Function} [project] Projection function for combining values\n     * together. Receives all values in order of the Observables passed, where the\n     * first parameter is a value from the source Observable. (e.g.\n     * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n     * passed, arrays will be emitted on the output Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @method withLatestFrom\n     * @owner Observable\n     */\n    function withLatestFrom() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return function (source) {\n            var project;\n            if (typeof args[args.length - 1] === 'function') {\n                project = args.pop();\n            }\n            var observables = args;\n            return source.lift(new WithLatestFromOperator(observables, project));\n        };\n    }\n    exports.withLatestFrom = withLatestFrom;\n    var WithLatestFromOperator = /** @class */ (function () {\n        function WithLatestFromOperator(observables, project) {\n            this.observables = observables;\n            this.project = project;\n        }\n        WithLatestFromOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));\n        };\n        return WithLatestFromOperator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var WithLatestFromSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(WithLatestFromSubscriber, _super);\n        function WithLatestFromSubscriber(destination, observables, project) {\n            var _this = _super.call(this, destination) || this;\n            _this.observables = observables;\n            _this.project = project;\n            _this.toRespond = [];\n            var len = observables.length;\n            _this.values = new Array(len);\n            for (var i = 0; i < len; i++) {\n                _this.toRespond.push(i);\n            }\n            for (var i = 0; i < len; i++) {\n                var observable = observables[i];\n                _this.add(subscribeToResult_1.subscribeToResult(_this, observable, observable, i));\n            }\n            return _this;\n        }\n        WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.values[outerIndex] = innerValue;\n            var toRespond = this.toRespond;\n            if (toRespond.length > 0) {\n                var found = toRespond.indexOf(outerIndex);\n                if (found !== -1) {\n                    toRespond.splice(found, 1);\n                }\n            }\n        };\n        WithLatestFromSubscriber.prototype.notifyComplete = function () {\n            // noop\n        };\n        WithLatestFromSubscriber.prototype._next = function (value) {\n            if (this.toRespond.length === 0) {\n                var args = [value].concat(this.values);\n                if (this.project) {\n                    this._tryProject(args);\n                }\n                else {\n                    this.destination.next(args);\n                }\n            }\n        };\n        WithLatestFromSubscriber.prototype._tryProject = function (args) {\n            var result;\n            try {\n                result = this.project.apply(this, args);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return WithLatestFromSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/zip',[\"require\", \"exports\", \"tslib\", \"../observable/ArrayObservable\", \"../util/isArray\", \"../Subscriber\", \"../OuterSubscriber\", \"../util/subscribeToResult\", \"../symbol/iterator\"], function (require, exports, tslib_1, ArrayObservable_1, isArray_1, Subscriber_1, OuterSubscriber_1, subscribeToResult_1, iterator_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * @param observables\n     * @return {Observable<R>}\n     * @method zip\n     * @owner Observable\n     */\n    function zip() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return function zipOperatorFunction(source) {\n            return source.lift.call(zipStatic.apply(void 0, [source].concat(observables)));\n        };\n    }\n    exports.zip = zip;\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each\n     * of its input Observables.\n     *\n     * If the latest parameter is a function, this function is used to compute the created value from the input values.\n     * Otherwise, an array of the input values is returned.\n     *\n     * @example <caption>Combine age and name from different sources</caption>\n     *\n     * let age$ = Observable.of<number>(27, 25, 29);\n     * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');\n     * let isDev$ = Observable.of<boolean>(true, true, false);\n     *\n     * Observable\n     *     .zip(age$,\n     *          name$,\n     *          isDev$,\n     *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))\n     *     .subscribe(x => console.log(x));\n     *\n     * // outputs\n     * // { age: 27, name: 'Foo', isDev: true }\n     * // { age: 25, name: 'Bar', isDev: true }\n     * // { age: 29, name: 'Beer', isDev: false }\n     *\n     * @param observables\n     * @return {Observable<R>}\n     * @static true\n     * @name zip\n     * @owner Observable\n     */\n    function zipStatic() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        var project = observables[observables.length - 1];\n        if (typeof project === 'function') {\n            observables.pop();\n        }\n        return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));\n    }\n    exports.zipStatic = zipStatic;\n    var ZipOperator = /** @class */ (function () {\n        function ZipOperator(project) {\n            this.project = project;\n        }\n        ZipOperator.prototype.call = function (subscriber, source) {\n            return source.subscribe(new ZipSubscriber(subscriber, this.project));\n        };\n        return ZipOperator;\n    }());\n    exports.ZipOperator = ZipOperator;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ZipSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ZipSubscriber, _super);\n        function ZipSubscriber(destination, project, values) {\n            if (values === void 0) { values = Object.create(null); }\n            var _this = _super.call(this, destination) || this;\n            _this.iterators = [];\n            _this.active = 0;\n            _this.project = (typeof project === 'function') ? project : null;\n            _this.values = values;\n            return _this;\n        }\n        ZipSubscriber.prototype._next = function (value) {\n            var iterators = this.iterators;\n            if (isArray_1.isArray(value)) {\n                iterators.push(new StaticArrayIterator(value));\n            }\n            else if (typeof value[iterator_1.iterator] === 'function') {\n                iterators.push(new StaticIterator(value[iterator_1.iterator]()));\n            }\n            else {\n                iterators.push(new ZipBufferIterator(this.destination, this, value));\n            }\n        };\n        ZipSubscriber.prototype._complete = function () {\n            var iterators = this.iterators;\n            var len = iterators.length;\n            if (len === 0) {\n                this.destination.complete();\n                return;\n            }\n            this.active = len;\n            for (var i = 0; i < len; i++) {\n                var iterator = iterators[i];\n                if (iterator.stillUnsubscribed) {\n                    this.add(iterator.subscribe(iterator, i));\n                }\n                else {\n                    this.active--; // not an observable\n                }\n            }\n        };\n        ZipSubscriber.prototype.notifyInactive = function () {\n            this.active--;\n            if (this.active === 0) {\n                this.destination.complete();\n            }\n        };\n        ZipSubscriber.prototype.checkIterators = function () {\n            var iterators = this.iterators;\n            var len = iterators.length;\n            var destination = this.destination;\n            // abort if not all of them have values\n            for (var i = 0; i < len; i++) {\n                var iterator = iterators[i];\n                if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {\n                    return;\n                }\n            }\n            var shouldComplete = false;\n            var args = [];\n            for (var i = 0; i < len; i++) {\n                var iterator = iterators[i];\n                var result = iterator.next();\n                // check to see if it's completed now that you've gotten\n                // the next value.\n                if (iterator.hasCompleted()) {\n                    shouldComplete = true;\n                }\n                if (result.done) {\n                    destination.complete();\n                    return;\n                }\n                args.push(result.value);\n            }\n            if (this.project) {\n                this._tryProject(args);\n            }\n            else {\n                destination.next(args);\n            }\n            if (shouldComplete) {\n                destination.complete();\n            }\n        };\n        ZipSubscriber.prototype._tryProject = function (args) {\n            var result;\n            try {\n                result = this.project.apply(this, args);\n            }\n            catch (err) {\n                this.destination.error(err);\n                return;\n            }\n            this.destination.next(result);\n        };\n        return ZipSubscriber;\n    }(Subscriber_1.Subscriber));\n    exports.ZipSubscriber = ZipSubscriber;\n    var StaticIterator = /** @class */ (function () {\n        function StaticIterator(iterator) {\n            this.iterator = iterator;\n            this.nextResult = iterator.next();\n        }\n        StaticIterator.prototype.hasValue = function () {\n            return true;\n        };\n        StaticIterator.prototype.next = function () {\n            var result = this.nextResult;\n            this.nextResult = this.iterator.next();\n            return result;\n        };\n        StaticIterator.prototype.hasCompleted = function () {\n            var nextResult = this.nextResult;\n            return nextResult && nextResult.done;\n        };\n        return StaticIterator;\n    }());\n    var StaticArrayIterator = /** @class */ (function () {\n        function StaticArrayIterator(array) {\n            this.array = array;\n            this.index = 0;\n            this.length = 0;\n            this.length = array.length;\n        }\n        StaticArrayIterator.prototype[iterator_1.iterator] = function () {\n            return this;\n        };\n        StaticArrayIterator.prototype.next = function (value) {\n            var i = this.index++;\n            var array = this.array;\n            return i < this.length ? { value: array[i], done: false } : { value: null, done: true };\n        };\n        StaticArrayIterator.prototype.hasValue = function () {\n            return this.array.length > this.index;\n        };\n        StaticArrayIterator.prototype.hasCompleted = function () {\n            return this.array.length === this.index;\n        };\n        return StaticArrayIterator;\n    }());\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ZipBufferIterator = /** @class */ (function (_super) {\n        tslib_1.__extends(ZipBufferIterator, _super);\n        function ZipBufferIterator(destination, parent, observable) {\n            var _this = _super.call(this, destination) || this;\n            _this.parent = parent;\n            _this.observable = observable;\n            _this.stillUnsubscribed = true;\n            _this.buffer = [];\n            _this.isComplete = false;\n            return _this;\n        }\n        ZipBufferIterator.prototype[iterator_1.iterator] = function () {\n            return this;\n        };\n        // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next\n        //    this is legit because `next()` will never be called by a subscription in this case.\n        ZipBufferIterator.prototype.next = function () {\n            var buffer = this.buffer;\n            if (buffer.length === 0 && this.isComplete) {\n                return { value: null, done: true };\n            }\n            else {\n                return { value: buffer.shift(), done: false };\n            }\n        };\n        ZipBufferIterator.prototype.hasValue = function () {\n            return this.buffer.length > 0;\n        };\n        ZipBufferIterator.prototype.hasCompleted = function () {\n            return this.buffer.length === 0 && this.isComplete;\n        };\n        ZipBufferIterator.prototype.notifyComplete = function () {\n            if (this.buffer.length > 0) {\n                this.isComplete = true;\n                this.parent.notifyInactive();\n            }\n            else {\n                this.destination.complete();\n            }\n        };\n        ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.buffer.push(innerValue);\n            this.parent.checkIterators();\n        };\n        ZipBufferIterator.prototype.subscribe = function (value, index) {\n            return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);\n        };\n        return ZipBufferIterator;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/operators/zipAll',[\"require\", \"exports\", \"./zip\"], function (require, exports, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function zipAll(project) {\n        return function (source) { return source.lift(new zip_1.ZipOperator(project)); };\n    }\n    exports.zipAll = zipAll;\n});\n\ndefine('rxjs/operators',[\"require\", \"exports\", \"./operators/audit\", \"./operators/auditTime\", \"./operators/buffer\", \"./operators/bufferCount\", \"./operators/bufferTime\", \"./operators/bufferToggle\", \"./operators/bufferWhen\", \"./operators/catchError\", \"./operators/combineAll\", \"./operators/combineLatest\", \"./operators/concat\", \"./operators/concatAll\", \"./operators/concatMap\", \"./operators/concatMapTo\", \"./operators/count\", \"./operators/debounce\", \"./operators/debounceTime\", \"./operators/defaultIfEmpty\", \"./operators/delay\", \"./operators/delayWhen\", \"./operators/dematerialize\", \"./operators/distinct\", \"./operators/distinctUntilChanged\", \"./operators/distinctUntilKeyChanged\", \"./operators/elementAt\", \"./operators/every\", \"./operators/exhaust\", \"./operators/exhaustMap\", \"./operators/expand\", \"./operators/filter\", \"./operators/finalize\", \"./operators/find\", \"./operators/findIndex\", \"./operators/first\", \"./operators/groupBy\", \"./operators/ignoreElements\", \"./operators/isEmpty\", \"./operators/last\", \"./operators/map\", \"./operators/mapTo\", \"./operators/materialize\", \"./operators/max\", \"./operators/merge\", \"./operators/mergeAll\", \"./operators/mergeMap\", \"./operators/mergeMap\", \"./operators/mergeMapTo\", \"./operators/mergeScan\", \"./operators/min\", \"./operators/multicast\", \"./operators/observeOn\", \"./operators/onErrorResumeNext\", \"./operators/pairwise\", \"./operators/partition\", \"./operators/pluck\", \"./operators/publish\", \"./operators/publishBehavior\", \"./operators/publishLast\", \"./operators/publishReplay\", \"./operators/race\", \"./operators/reduce\", \"./operators/repeat\", \"./operators/repeatWhen\", \"./operators/retry\", \"./operators/retryWhen\", \"./operators/refCount\", \"./operators/sample\", \"./operators/sampleTime\", \"./operators/scan\", \"./operators/sequenceEqual\", \"./operators/share\", \"./operators/shareReplay\", \"./operators/single\", \"./operators/skip\", \"./operators/skipLast\", \"./operators/skipUntil\", \"./operators/skipWhile\", \"./operators/startWith\", \"./operators/switchAll\", \"./operators/switchMap\", \"./operators/switchMapTo\", \"./operators/take\", \"./operators/takeLast\", \"./operators/takeUntil\", \"./operators/takeWhile\", \"./operators/tap\", \"./operators/throttle\", \"./operators/throttleTime\", \"./operators/timeInterval\", \"./operators/timeout\", \"./operators/timeoutWith\", \"./operators/timestamp\", \"./operators/toArray\", \"./operators/window\", \"./operators/windowCount\", \"./operators/windowTime\", \"./operators/windowToggle\", \"./operators/windowWhen\", \"./operators/withLatestFrom\", \"./operators/zip\", \"./operators/zipAll\"], function (require, exports, audit_1, auditTime_1, buffer_1, bufferCount_1, bufferTime_1, bufferToggle_1, bufferWhen_1, catchError_1, combineAll_1, combineLatest_1, concat_1, concatAll_1, concatMap_1, concatMapTo_1, count_1, debounce_1, debounceTime_1, defaultIfEmpty_1, delay_1, delayWhen_1, dematerialize_1, distinct_1, distinctUntilChanged_1, distinctUntilKeyChanged_1, elementAt_1, every_1, exhaust_1, exhaustMap_1, expand_1, filter_1, finalize_1, find_1, findIndex_1, first_1, groupBy_1, ignoreElements_1, isEmpty_1, last_1, map_1, mapTo_1, materialize_1, max_1, merge_1, mergeAll_1, mergeMap_1, mergeMap_2, mergeMapTo_1, mergeScan_1, min_1, multicast_1, observeOn_1, onErrorResumeNext_1, pairwise_1, partition_1, pluck_1, publish_1, publishBehavior_1, publishLast_1, publishReplay_1, race_1, reduce_1, repeat_1, repeatWhen_1, retry_1, retryWhen_1, refCount_1, sample_1, sampleTime_1, scan_1, sequenceEqual_1, share_1, shareReplay_1, single_1, skip_1, skipLast_1, skipUntil_1, skipWhile_1, startWith_1, switchAll_1, switchMap_1, switchMapTo_1, take_1, takeLast_1, takeUntil_1, takeWhile_1, tap_1, throttle_1, throttleTime_1, timeInterval_1, timeout_1, timeoutWith_1, timestamp_1, toArray_1, window_1, windowCount_1, windowTime_1, windowToggle_1, windowWhen_1, withLatestFrom_1, zip_1, zipAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.audit = audit_1.audit;\n    exports.auditTime = auditTime_1.auditTime;\n    exports.buffer = buffer_1.buffer;\n    exports.bufferCount = bufferCount_1.bufferCount;\n    exports.bufferTime = bufferTime_1.bufferTime;\n    exports.bufferToggle = bufferToggle_1.bufferToggle;\n    exports.bufferWhen = bufferWhen_1.bufferWhen;\n    exports.catchError = catchError_1.catchError;\n    exports.combineAll = combineAll_1.combineAll;\n    exports.combineLatest = combineLatest_1.combineLatest;\n    exports.concat = concat_1.concat;\n    exports.concatAll = concatAll_1.concatAll;\n    exports.concatMap = concatMap_1.concatMap;\n    exports.concatMapTo = concatMapTo_1.concatMapTo;\n    exports.count = count_1.count;\n    exports.debounce = debounce_1.debounce;\n    exports.debounceTime = debounceTime_1.debounceTime;\n    exports.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n    exports.delay = delay_1.delay;\n    exports.delayWhen = delayWhen_1.delayWhen;\n    exports.dematerialize = dematerialize_1.dematerialize;\n    exports.distinct = distinct_1.distinct;\n    exports.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n    exports.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n    exports.elementAt = elementAt_1.elementAt;\n    exports.every = every_1.every;\n    exports.exhaust = exhaust_1.exhaust;\n    exports.exhaustMap = exhaustMap_1.exhaustMap;\n    exports.expand = expand_1.expand;\n    exports.filter = filter_1.filter;\n    exports.finalize = finalize_1.finalize;\n    exports.find = find_1.find;\n    exports.findIndex = findIndex_1.findIndex;\n    exports.first = first_1.first;\n    exports.groupBy = groupBy_1.groupBy;\n    exports.ignoreElements = ignoreElements_1.ignoreElements;\n    exports.isEmpty = isEmpty_1.isEmpty;\n    exports.last = last_1.last;\n    exports.map = map_1.map;\n    exports.mapTo = mapTo_1.mapTo;\n    exports.materialize = materialize_1.materialize;\n    exports.max = max_1.max;\n    exports.merge = merge_1.merge;\n    exports.mergeAll = mergeAll_1.mergeAll;\n    exports.mergeMap = mergeMap_1.mergeMap;\n    exports.flatMap = mergeMap_2.mergeMap;\n    exports.mergeMapTo = mergeMapTo_1.mergeMapTo;\n    exports.mergeScan = mergeScan_1.mergeScan;\n    exports.min = min_1.min;\n    exports.multicast = multicast_1.multicast;\n    exports.observeOn = observeOn_1.observeOn;\n    exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n    exports.pairwise = pairwise_1.pairwise;\n    exports.partition = partition_1.partition;\n    exports.pluck = pluck_1.pluck;\n    exports.publish = publish_1.publish;\n    exports.publishBehavior = publishBehavior_1.publishBehavior;\n    exports.publishLast = publishLast_1.publishLast;\n    exports.publishReplay = publishReplay_1.publishReplay;\n    exports.race = race_1.race;\n    exports.reduce = reduce_1.reduce;\n    exports.repeat = repeat_1.repeat;\n    exports.repeatWhen = repeatWhen_1.repeatWhen;\n    exports.retry = retry_1.retry;\n    exports.retryWhen = retryWhen_1.retryWhen;\n    exports.refCount = refCount_1.refCount;\n    exports.sample = sample_1.sample;\n    exports.sampleTime = sampleTime_1.sampleTime;\n    exports.scan = scan_1.scan;\n    exports.sequenceEqual = sequenceEqual_1.sequenceEqual;\n    exports.share = share_1.share;\n    exports.shareReplay = shareReplay_1.shareReplay;\n    exports.single = single_1.single;\n    exports.skip = skip_1.skip;\n    exports.skipLast = skipLast_1.skipLast;\n    exports.skipUntil = skipUntil_1.skipUntil;\n    exports.skipWhile = skipWhile_1.skipWhile;\n    exports.startWith = startWith_1.startWith;\n    exports.switchAll = switchAll_1.switchAll;\n    exports.switchMap = switchMap_1.switchMap;\n    exports.switchMapTo = switchMapTo_1.switchMapTo;\n    exports.take = take_1.take;\n    exports.takeLast = takeLast_1.takeLast;\n    exports.takeUntil = takeUntil_1.takeUntil;\n    exports.takeWhile = takeWhile_1.takeWhile;\n    exports.tap = tap_1.tap;\n    exports.throttle = throttle_1.throttle;\n    exports.throttleTime = throttleTime_1.throttleTime;\n    exports.timeInterval = timeInterval_1.timeInterval;\n    exports.timeout = timeout_1.timeout;\n    exports.timeoutWith = timeoutWith_1.timeoutWith;\n    exports.timestamp = timestamp_1.timestamp;\n    exports.toArray = toArray_1.toArray;\n    exports.window = window_1.window;\n    exports.windowCount = windowCount_1.windowCount;\n    exports.windowTime = windowTime_1.windowTime;\n    exports.windowToggle = windowToggle_1.windowToggle;\n    exports.windowWhen = windowWhen_1.windowWhen;\n    exports.withLatestFrom = withLatestFrom_1.withLatestFrom;\n    exports.zip = zip_1.zip;\n    exports.zipAll = zipAll_1.zipAll;\n});\n\ndefine('rxjs/observable/BoundCallbackObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/tryCatch\", \"../util/errorObject\", \"../AsyncSubject\"], function (require, exports, tslib_1, Observable_1, tryCatch_1, errorObject_1, AsyncSubject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var BoundCallbackObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(BoundCallbackObservable, _super);\n        function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.callbackFunc = callbackFunc;\n            _this.selector = selector;\n            _this.args = args;\n            _this.context = context;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /* tslint:enable:max-line-length */\n        /**\n         * Converts a callback API to a function that returns an Observable.\n         *\n         * <span class=\"informal\">Give it a function `f` of type `f(x, callback)` and\n         * it will return a function `g` that when called as `g(x)` will output an\n         * Observable.</span>\n         *\n         * `bindCallback` is not an operator because its input and output are not\n         * Observables. The input is a function `func` with some parameters, the\n         * last parameter must be a callback function that `func` calls when it is\n         * done.\n         *\n         * The output of `bindCallback` is a function that takes the same parameters\n         * as `func`, except the last one (the callback). When the output function\n         * is called with arguments it will return an Observable. If function `func`\n         * calls its callback with one argument the Observable will emit that value.\n         * If on the other hand the callback is called with multiple values the resulting\n         * Observable will emit an array with said values as arguments.\n         *\n         * It is very important to remember that input function `func` is not called\n         * when the output function is, but rather when the Observable returned by the output\n         * function is subscribed. This means if `func` makes an AJAX request, that request\n         * will be made every time someone subscribes to the resulting Observable, but not before.\n         *\n         * Optionally, a selector function can be passed to `bindObservable`. The selector function\n         * takes the same arguments as the callback and returns the value that will be emitted by the Observable.\n         * Even though by default multiple arguments passed to callback appear in the stream as an array\n         * the selector function will be called with arguments directly, just as the callback would.\n         * This means you can imagine the default selector (when one is not provided explicitly)\n         * as a function that aggregates all its arguments into an array, or simply returns first argument\n         * if there is only one.\n         *\n         * The last optional parameter - {@link Scheduler} - can be used to control when the call\n         * to `func` happens after someone subscribes to Observable, as well as when results\n         * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`\n         * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,\n         * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler\n         * and call `subscribe` on the output Observable all function calls that are currently executing\n         * will end before `func` is invoked.\n         *\n         * By default results passed to the callback are emitted immediately after `func` invokes the callback.\n         * In particular, if the callback is called synchronously the subscription of the resulting Observable\n         * will call the `next` function synchronously as well.  If you want to defer that call,\n         * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can\n         * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.\n         *\n         * Note that the Observable created by the output function will always emit a single value\n         * and then complete immediately. If `func` calls the callback multiple times, values from subsequent\n         * calls will not appear in the stream. If you need to listen for multiple calls,\n         *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.\n         *\n         * If `func` depends on some context (`this` property) and is not already bound the context of `func`\n         * will be the context that the output function has at call time. In particular, if `func`\n         * is called as a method of some objec and if `func` is not already bound, in order to preserve the context\n         * it is recommended that the context of the output function is set to that object as well.\n         *\n         * If the input function calls its callback in the \"node style\" (i.e. first argument to callback is\n         * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}\n         * provides convenient error handling and probably is a better choice.\n         * `bindCallback` will treat such functions the same as any other and error parameters\n         * (whether passed or not) will always be interpreted as regular callback argument.\n         *\n         *\n         * @example <caption>Convert jQuery's getJSON to an Observable API</caption>\n         * // Suppose we have jQuery.getJSON('/my/url', callback)\n         * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);\n         * var result = getJSONAsObservable('/my/url');\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         *\n         * @example <caption>Receive an array of arguments passed to a callback</caption>\n         * someFunction((a, b, c) => {\n         *   console.log(a); // 5\n         *   console.log(b); // 'some string'\n         *   console.log(c); // {someProperty: 'someValue'}\n         * });\n         *\n         * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);\n         * boundSomeFunction().subscribe(values => {\n         *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]\n         * });\n         *\n         *\n         * @example <caption>Use bindCallback with a selector function</caption>\n         * someFunction((a, b, c) => {\n         *   console.log(a); // 'a'\n         *   console.log(b); // 'b'\n         *   console.log(c); // 'c'\n         * });\n         *\n         * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);\n         * boundSomeFunction().subscribe(value => {\n         *   console.log(value) // 'abc'\n         * });\n         *\n         *\n         * @example <caption>Compare behaviour with and without async Scheduler</caption>\n         * function iCallMyCallbackSynchronously(cb) {\n         *   cb();\n         * }\n         *\n         * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);\n         * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);\n         *\n         * boundSyncFn().subscribe(() => console.log('I was sync!'));\n         * boundAsyncFn().subscribe(() => console.log('I was async!'));\n         * console.log('This happened...');\n         *\n         * // Logs:\n         * // I was sync!\n         * // This happened...\n         * // I was async!\n         *\n         *\n         * @example <caption>Use bindCallback on an object method</caption>\n         * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);\n         * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject\n         * .subscribe(subscriber);\n         *\n         *\n         * @see {@link bindNodeCallback}\n         * @see {@link from}\n         * @see {@link fromPromise}\n         *\n         * @param {function} func A function with a callback as the last parameter.\n         * @param {function} [selector] A function which takes the arguments from the\n         * callback and maps them to a value that is emitted on the output Observable.\n         * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n         * callbacks.\n         * @return {function(...params: *): Observable} A function which returns the\n         * Observable that delivers the same values the callback would deliver.\n         * @static true\n         * @name bindCallback\n         * @owner Observable\n         */\n        BoundCallbackObservable.create = function (func, selector, scheduler) {\n            if (selector === void 0) { selector = undefined; }\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return new BoundCallbackObservable(func, selector, args, this, scheduler);\n            };\n        };\n        BoundCallbackObservable.prototype._subscribe = function (subscriber) {\n            var callbackFunc = this.callbackFunc;\n            var args = this.args;\n            var scheduler = this.scheduler;\n            var subject = this.subject;\n            if (!scheduler) {\n                if (!subject) {\n                    subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                    var handler = function handlerFn() {\n                        var innerArgs = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            innerArgs[_i] = arguments[_i];\n                        }\n                        var source = handlerFn.source;\n                        var selector = source.selector, subject = source.subject;\n                        if (selector) {\n                            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                            if (result_1 === errorObject_1.errorObject) {\n                                subject.error(errorObject_1.errorObject.e);\n                            }\n                            else {\n                                subject.next(result_1);\n                                subject.complete();\n                            }\n                        }\n                        else {\n                            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                            subject.complete();\n                        }\n                    };\n                    // use named function instance to avoid closure.\n                    handler.source = this;\n                    var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                    if (result === errorObject_1.errorObject) {\n                        subject.error(errorObject_1.errorObject.e);\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n            }\n        };\n        BoundCallbackObservable.dispatch = function (state) {\n            var self = this;\n            var source = state.source, subscriber = state.subscriber, context = state.context;\n            var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;\n            var subject = source.subject;\n            if (!subject) {\n                subject = source.subject = new AsyncSubject_1.AsyncSubject();\n                var handler = function handlerFn() {\n                    var innerArgs = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        innerArgs[_i] = arguments[_i];\n                    }\n                    var source = handlerFn.source;\n                    var selector = source.selector, subject = source.subject;\n                    if (selector) {\n                        var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                        if (result_2 === errorObject_1.errorObject) {\n                            self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                        }\n                        else {\n                            self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                        }\n                    }\n                    else {\n                        var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                    }\n                };\n                // use named function to pass values in without closure\n                handler.source = source;\n                var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n                if (result === errorObject_1.errorObject) {\n                    subject.error(errorObject_1.errorObject.e);\n                }\n            }\n            self.add(subject.subscribe(subscriber));\n        };\n        return BoundCallbackObservable;\n    }(Observable_1.Observable));\n    exports.BoundCallbackObservable = BoundCallbackObservable;\n    function dispatchNext(arg) {\n        var value = arg.value, subject = arg.subject;\n        subject.next(value);\n        subject.complete();\n    }\n    function dispatchError(arg) {\n        var err = arg.err, subject = arg.subject;\n        subject.error(err);\n    }\n});\n\ndefine('rxjs/observable/bindCallback',[\"require\", \"exports\", \"./BoundCallbackObservable\"], function (require, exports, BoundCallbackObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;\n});\n\ndefine('rxjs/add/observable/bindCallback',[\"require\", \"exports\", \"../../Observable\", \"../../observable/bindCallback\"], function (require, exports, Observable_1, bindCallback_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.bindCallback = bindCallback_1.bindCallback;\n});\n\ndefine('rxjs/observable/BoundNodeCallbackObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/tryCatch\", \"../util/errorObject\", \"../AsyncSubject\"], function (require, exports, tslib_1, Observable_1, tryCatch_1, errorObject_1, AsyncSubject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var BoundNodeCallbackObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(BoundNodeCallbackObservable, _super);\n        function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.callbackFunc = callbackFunc;\n            _this.selector = selector;\n            _this.args = args;\n            _this.context = context;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /* tslint:enable:max-line-length */\n        /**\n         * Converts a Node.js-style callback API to a function that returns an\n         * Observable.\n         *\n         * <span class=\"informal\">It's just like {@link bindCallback}, but the\n         * callback is expected to be of type `callback(error, result)`.</span>\n         *\n         * `bindNodeCallback` is not an operator because its input and output are not\n         * Observables. The input is a function `func` with some parameters, but the\n         * last parameter must be a callback function that `func` calls when it is\n         * done. The callback function is expected to follow Node.js conventions,\n         * where the first argument to the callback is an error object, signaling\n         * whether call was successful. If that object is passed to callback, it means\n         * something went wrong.\n         *\n         * The output of `bindNodeCallback` is a function that takes the same\n         * parameters as `func`, except the last one (the callback). When the output\n         * function is called with arguments, it will return an Observable.\n         * If `func` calls its callback with error parameter present, Observable will\n         * error with that value as well. If error parameter is not passed, Observable will emit\n         * second parameter. If there are more parameters (third and so on),\n         * Observable will emit an array with all arguments, except first error argument.\n         *\n         * Optionally `bindNodeCallback` accepts selector function, which allows you to\n         * make resulting Observable emit value computed by selector, instead of regular\n         * callback arguments. It works similarly to {@link bindCallback} selector, but\n         * Node.js-style error argument will never be passed to that function.\n         *\n         * Note that `func` will not be called at the same time output function is,\n         * but rather whenever resulting Observable is subscribed. By default call to\n         * `func` will happen synchronously after subscription, but that can be changed\n         * with proper {@link Scheduler} provided as optional third parameter. Scheduler\n         * can also control when values from callback will be emitted by Observable.\n         * To find out more, check out documentation for {@link bindCallback}, where\n         * Scheduler works exactly the same.\n         *\n         * As in {@link bindCallback}, context (`this` property) of input function will be set to context\n         * of returned function, when it is called.\n         *\n         * After Observable emits value, it will complete immediately. This means\n         * even if `func` calls callback again, values from second and consecutive\n         * calls will never appear on the stream. If you need to handle functions\n         * that call callbacks multiple times, check out {@link fromEvent} or\n         * {@link fromEventPattern} instead.\n         *\n         * Note that `bindNodeCallback` can be used in non-Node.js environments as well.\n         * \"Node.js-style\" callbacks are just a convention, so if you write for\n         * browsers or any other environment and API you use implements that callback style,\n         * `bindNodeCallback` can be safely used on that API functions as well.\n         *\n         * Remember that Error object passed to callback does not have to be an instance\n         * of JavaScript built-in `Error` object. In fact, it does not even have to an object.\n         * Error parameter of callback function is interpreted as \"present\", when value\n         * of that parameter is truthy. It could be, for example, non-zero number, non-empty\n         * string or boolean `true`. In all of these cases resulting Observable would error\n         * with that value. This means usually regular style callbacks will fail very often when\n         * `bindNodeCallback` is used. If your Observable errors much more often then you\n         * would expect, check if callback really is called in Node.js-style and, if not,\n         * switch to {@link bindCallback} instead.\n         *\n         * Note that even if error parameter is technically present in callback, but its value\n         * is falsy, it still won't appear in array emitted by Observable or in selector function.\n         *\n         *\n         * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>\n         * import * as fs from 'fs';\n         * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);\n         * var result = readFileAsObservable('./roadNames.txt', 'utf8');\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         *\n         * @example <caption>Use on function calling callback with multiple arguments</caption>\n         * someFunction((err, a, b) => {\n         *   console.log(err); // null\n         *   console.log(a); // 5\n         *   console.log(b); // \"some string\"\n         * });\n         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n         * boundSomeFunction()\n         * .subscribe(value => {\n         *   console.log(value); // [5, \"some string\"]\n         * });\n         *\n         *\n         * @example <caption>Use with selector function</caption>\n         * someFunction((err, a, b) => {\n         *   console.log(err); // undefined\n         *   console.log(a); // \"abc\"\n         *   console.log(b); // \"DEF\"\n         * });\n         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);\n         * boundSomeFunction()\n         * .subscribe(value => {\n         *   console.log(value); // \"abcDEF\"\n         * });\n         *\n         *\n         * @example <caption>Use on function calling callback in regular style</caption>\n         * someFunction(a => {\n         *   console.log(a); // 5\n         * });\n         * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);\n         * boundSomeFunction()\n         * .subscribe(\n         *   value => {}             // never gets called\n         *   err => console.log(err) // 5\n         *);\n         *\n         *\n         * @see {@link bindCallback}\n         * @see {@link from}\n         * @see {@link fromPromise}\n         *\n         * @param {function} func Function with a Node.js-style callback as the last parameter.\n         * @param {function} [selector] A function which takes the arguments from the\n         * callback and maps those to a value to emit on the output Observable.\n         * @param {Scheduler} [scheduler] The scheduler on which to schedule the\n         * callbacks.\n         * @return {function(...params: *): Observable} A function which returns the\n         * Observable that delivers the same values the Node.js callback would\n         * deliver.\n         * @static true\n         * @name bindNodeCallback\n         * @owner Observable\n         */\n        BoundNodeCallbackObservable.create = function (func, selector, scheduler) {\n            if (selector === void 0) { selector = undefined; }\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);\n            };\n        };\n        BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {\n            var callbackFunc = this.callbackFunc;\n            var args = this.args;\n            var scheduler = this.scheduler;\n            var subject = this.subject;\n            if (!scheduler) {\n                if (!subject) {\n                    subject = this.subject = new AsyncSubject_1.AsyncSubject();\n                    var handler = function handlerFn() {\n                        var innerArgs = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            innerArgs[_i] = arguments[_i];\n                        }\n                        var source = handlerFn.source;\n                        var selector = source.selector, subject = source.subject;\n                        var err = innerArgs.shift();\n                        if (err) {\n                            subject.error(err);\n                        }\n                        else if (selector) {\n                            var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                            if (result_1 === errorObject_1.errorObject) {\n                                subject.error(errorObject_1.errorObject.e);\n                            }\n                            else {\n                                subject.next(result_1);\n                                subject.complete();\n                            }\n                        }\n                        else {\n                            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);\n                            subject.complete();\n                        }\n                    };\n                    // use named function instance to avoid closure.\n                    handler.source = this;\n                    var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));\n                    if (result === errorObject_1.errorObject) {\n                        subject.error(errorObject_1.errorObject.e);\n                    }\n                }\n                return subject.subscribe(subscriber);\n            }\n            else {\n                return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });\n            }\n        };\n        return BoundNodeCallbackObservable;\n    }(Observable_1.Observable));\n    exports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;\n    function dispatch(state) {\n        var self = this;\n        var source = state.source, subscriber = state.subscriber, context = state.context;\n        // XXX: cast to `any` to access to the private field in `source`.\n        var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;\n        var subject = source.subject;\n        if (!subject) {\n            subject = source.subject = new AsyncSubject_1.AsyncSubject();\n            var handler = function handlerFn() {\n                var innerArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    innerArgs[_i] = arguments[_i];\n                }\n                var source = handlerFn.source;\n                var selector = source.selector, subject = source.subject;\n                var err = innerArgs.shift();\n                if (err) {\n                    self.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));\n                }\n                else if (selector) {\n                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);\n                    if (result_2 === errorObject_1.errorObject) {\n                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n                    }\n                    else {\n                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));\n                    }\n                }\n                else {\n                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;\n                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));\n                }\n            };\n            // use named function to pass values in without closure\n            handler.source = source;\n            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));\n            if (result === errorObject_1.errorObject) {\n                self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));\n            }\n        }\n        self.add(subject.subscribe(subscriber));\n    }\n    function dispatchNext(arg) {\n        var value = arg.value, subject = arg.subject;\n        subject.next(value);\n        subject.complete();\n    }\n    function dispatchError(arg) {\n        var err = arg.err, subject = arg.subject;\n        subject.error(err);\n    }\n});\n\ndefine('rxjs/observable/bindNodeCallback',[\"require\", \"exports\", \"./BoundNodeCallbackObservable\"], function (require, exports, BoundNodeCallbackObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;\n});\n\ndefine('rxjs/add/observable/bindNodeCallback',[\"require\", \"exports\", \"../../Observable\", \"../../observable/bindNodeCallback\"], function (require, exports, Observable_1, bindNodeCallback_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;\n});\n\ndefine('rxjs/observable/combineLatest',[\"require\", \"exports\", \"../util/isScheduler\", \"../util/isArray\", \"./ArrayObservable\", \"../operators/combineLatest\"], function (require, exports, isScheduler_1, isArray_1, ArrayObservable_1, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines multiple Observables to create an Observable whose values are\n     * calculated from the latest values of each of its input Observables.\n     *\n     * <span class=\"informal\">Whenever any input Observable emits a value, it\n     * computes a formula using the latest values from all the inputs, then emits\n     * the output of that formula.</span>\n     *\n     * <img src=\"./img/combineLatest.png\" width=\"100%\">\n     *\n     * `combineLatest` combines the values from all the Observables passed as\n     * arguments. This is done by subscribing to each Observable in order and,\n     * whenever any Observable emits, collecting an array of the most recent\n     * values from each Observable. So if you pass `n` Observables to operator,\n     * returned Observable will always emit an array of `n` values, in order\n     * corresponding to order of passed Observables (value from the first Observable\n     * on the first place and so on).\n     *\n     * Static version of `combineLatest` accepts either an array of Observables\n     * or each Observable can be put directly as an argument. Note that array of\n     * Observables is good choice, if you don't know beforehand how many Observables\n     * you will combine. Passing empty array will result in Observable that\n     * completes immediately.\n     *\n     * To ensure output array has always the same length, `combineLatest` will\n     * actually wait for all input Observables to emit at least once,\n     * before it starts emitting results. This means if some Observable emits\n     * values before other Observables started emitting, all that values but last\n     * will be lost. On the other hand, is some Observable does not emit value but\n     * completes, resulting Observable will complete at the same moment without\n     * emitting anything, since it will be now impossible to include value from\n     * completed Observable in resulting array. Also, if some input Observable does\n     * not emit any value and never completes, `combineLatest` will also never emit\n     * and never complete, since, again, it will wait for all streams to emit some\n     * value.\n     *\n     * If at least one Observable was passed to `combineLatest` and all passed Observables\n     * emitted something, resulting Observable will complete when all combined\n     * streams complete. So even if some Observable completes, result of\n     * `combineLatest` will still emit values when other Observables do. In case\n     * of completed Observable, its value from now on will always be the last\n     * emitted value. On the other hand, if any Observable errors, `combineLatest`\n     * will error immediately as well, and all other Observables will be unsubscribed.\n     *\n     * `combineLatest` accepts as optional parameter `project` function, which takes\n     * as arguments all values that would normally be emitted by resulting Observable.\n     * `project` can return any kind of value, which will be then emitted by Observable\n     * instead of default array. Note that `project` does not take as argument that array\n     * of values, but values themselves. That means default `project` can be imagined\n     * as function that takes all its arguments and puts them into an array.\n     *\n     *\n     * @example <caption>Combine two timer Observables</caption>\n     * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now\n     * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now\n     * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);\n     * combinedTimers.subscribe(value => console.log(value));\n     * // Logs\n     * // [0, 0] after 0.5s\n     * // [1, 0] after 1s\n     * // [1, 1] after 1.5s\n     * // [2, 1] after 2s\n     *\n     *\n     * @example <caption>Combine an array of Observables</caption>\n     * const observables = [1, 5, 10].map(\n     *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds\n     * );\n     * const combined = Rx.Observable.combineLatest(observables);\n     * combined.subscribe(value => console.log(value));\n     * // Logs\n     * // [0, 0, 0] immediately\n     * // [1, 0, 0] after 1s\n     * // [1, 5, 0] after 5s\n     * // [1, 5, 10] after 10s\n     *\n     *\n     * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>\n     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n     * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n     * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));\n     * bmi.subscribe(x => console.log('BMI is ' + x));\n     *\n     * // With output to console:\n     * // BMI is 24.212293388429753\n     * // BMI is 23.93948099205209\n     * // BMI is 23.671253629592222\n     *\n     *\n     * @see {@link combineAll}\n     * @see {@link merge}\n     * @see {@link withLatestFrom}\n     *\n     * @param {ObservableInput} observable1 An input Observable to combine with other Observables.\n     * @param {ObservableInput} observable2 An input Observable to combine with other Observables.\n     * More than one input Observables may be given as arguments\n     * or an array of Observables may be given as the first argument.\n     * @param {function} [project] An optional function to project the values from\n     * the combined latest values into a new value on the output Observable.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n     * each input Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @static true\n     * @name combineLatest\n     * @owner Observable\n     */\n    function combineLatest() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        var project = null;\n        var scheduler = null;\n        if (isScheduler_1.isScheduler(observables[observables.length - 1])) {\n            scheduler = observables.pop();\n        }\n        if (typeof observables[observables.length - 1] === 'function') {\n            project = observables.pop();\n        }\n        // if the first and only other argument besides the resultSelector is an array\n        // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`\n        if (observables.length === 1 && isArray_1.isArray(observables[0])) {\n            observables = observables[0];\n        }\n        return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));\n    }\n    exports.combineLatest = combineLatest;\n});\n\ndefine('rxjs/add/observable/combineLatest',[\"require\", \"exports\", \"../../Observable\", \"../../observable/combineLatest\"], function (require, exports, Observable_1, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;\n});\n\ndefine('rxjs/add/observable/concat',[\"require\", \"exports\", \"../../Observable\", \"../../observable/concat\"], function (require, exports, Observable_1, concat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.concat = concat_1.concat;\n});\n\ndefine('rxjs/observable/DeferObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Observable_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var DeferObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(DeferObservable, _super);\n        function DeferObservable(observableFactory) {\n            var _this = _super.call(this) || this;\n            _this.observableFactory = observableFactory;\n            return _this;\n        }\n        /**\n         * Creates an Observable that, on subscribe, calls an Observable factory to\n         * make an Observable for each new Observer.\n         *\n         * <span class=\"informal\">Creates the Observable lazily, that is, only when it\n         * is subscribed.\n         * </span>\n         *\n         * <img src=\"./img/defer.png\" width=\"100%\">\n         *\n         * `defer` allows you to create the Observable only when the Observer\n         * subscribes, and create a fresh Observable for each Observer. It waits until\n         * an Observer subscribes to it, and then it generates an Observable,\n         * typically with an Observable factory function. It does this afresh for each\n         * subscriber, so although each subscriber may think it is subscribing to the\n         * same Observable, in fact each subscriber gets its own individual\n         * Observable.\n         *\n         * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>\n         * var clicksOrInterval = Rx.Observable.defer(function () {\n         *   if (Math.random() > 0.5) {\n         *     return Rx.Observable.fromEvent(document, 'click');\n         *   } else {\n         *     return Rx.Observable.interval(1000);\n         *   }\n         * });\n         * clicksOrInterval.subscribe(x => console.log(x));\n         *\n         * // Results in the following behavior:\n         * // If the result of Math.random() is greater than 0.5 it will listen\n         * // for clicks anywhere on the \"document\"; when document is clicked it\n         * // will log a MouseEvent object to the console. If the result is less\n         * // than 0.5 it will emit ascending numbers, one every second(1000ms).\n         *\n         * @see {@link create}\n         *\n         * @param {function(): SubscribableOrPromise} observableFactory The Observable\n         * factory function to invoke for each Observer that subscribes to the output\n         * Observable. May also return a Promise, which will be converted on the fly\n         * to an Observable.\n         * @return {Observable} An Observable whose Observers' subscriptions trigger\n         * an invocation of the given Observable factory function.\n         * @static true\n         * @name defer\n         * @owner Observable\n         */\n        DeferObservable.create = function (observableFactory) {\n            return new DeferObservable(observableFactory);\n        };\n        DeferObservable.prototype._subscribe = function (subscriber) {\n            return new DeferSubscriber(subscriber, this.observableFactory);\n        };\n        return DeferObservable;\n    }(Observable_1.Observable));\n    exports.DeferObservable = DeferObservable;\n    var DeferSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(DeferSubscriber, _super);\n        function DeferSubscriber(destination, factory) {\n            var _this = _super.call(this, destination) || this;\n            _this.factory = factory;\n            _this.tryDefer();\n            return _this;\n        }\n        DeferSubscriber.prototype.tryDefer = function () {\n            try {\n                this._callFactory();\n            }\n            catch (err) {\n                this._error(err);\n            }\n        };\n        DeferSubscriber.prototype._callFactory = function () {\n            var result = this.factory();\n            if (result) {\n                this.add(subscribeToResult_1.subscribeToResult(this, result));\n            }\n        };\n        return DeferSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/defer',[\"require\", \"exports\", \"./DeferObservable\"], function (require, exports, DeferObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.defer = DeferObservable_1.DeferObservable.create;\n});\n\ndefine('rxjs/add/observable/defer',[\"require\", \"exports\", \"../../Observable\", \"../../observable/defer\"], function (require, exports, Observable_1, defer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.defer = defer_1.defer;\n});\n\ndefine('rxjs/observable/empty',[\"require\", \"exports\", \"./EmptyObservable\"], function (require, exports, EmptyObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.empty = EmptyObservable_1.EmptyObservable.create;\n});\n\ndefine('rxjs/add/observable/empty',[\"require\", \"exports\", \"../../Observable\", \"../../observable/empty\"], function (require, exports, Observable_1, empty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.empty = empty_1.empty;\n});\n\ndefine('rxjs/observable/ForkJoinObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"./EmptyObservable\", \"../util/isArray\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Observable_1, EmptyObservable_1, isArray_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ForkJoinObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ForkJoinObservable, _super);\n        function ForkJoinObservable(sources, resultSelector) {\n            var _this = _super.call(this) || this;\n            _this.sources = sources;\n            _this.resultSelector = resultSelector;\n            return _this;\n        }\n        /* tslint:enable:max-line-length */\n        /**\n         * Joins last values emitted by passed Observables.\n         *\n         * <span class=\"informal\">Wait for Observables to complete and then combine last values they emitted.</span>\n         *\n         * <img src=\"./img/forkJoin.png\" width=\"100%\">\n         *\n         * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array\n         * or directly as arguments. If no input Observables are provided, resulting stream will complete\n         * immediately.\n         *\n         * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last\n         * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting\n         * array will have `n` values, where first value is the last thing emitted by the first Observable,\n         * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will\n         * not emit more than once and it will complete after that. If you need to emit combined values not only\n         * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}\n         * or {@link zip} instead.\n         *\n         * In order for resulting array to have the same length as the number of input Observables, whenever any of\n         * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well\n         * and it will not emit anything either, even if it already has some last values from other Observables.\n         * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,\n         * unless at any point some other Observable completes without emitting value, which brings us back to\n         * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments\n         * have to emit something at least once and complete.\n         *\n         * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables\n         * will be immediately unsubscribed.\n         *\n         * Optionally `forkJoin` accepts project function, that will be called with values which normally\n         * would land in emitted array. Whatever is returned by project function, will appear in output\n         * Observable instead. This means that default project can be thought of as a function that takes\n         * all its arguments and puts them into an array. Note that project function will be called only\n         * when output Observable is supposed to emit a result.\n         *\n         * @example <caption>Use forkJoin with operator emitting immediately</caption>\n         * const observable = Rx.Observable.forkJoin(\n         *   Rx.Observable.of(1, 2, 3, 4),\n         *   Rx.Observable.of(5, 6, 7, 8)\n         * );\n         * observable.subscribe(\n         *   value => console.log(value),\n         *   err => {},\n         *   () => console.log('This is how it ends!')\n         * );\n         *\n         * // Logs:\n         * // [4, 8]\n         * // \"This is how it ends!\"\n         *\n         *\n         * @example <caption>Use forkJoin with operator emitting after some time</caption>\n         * const observable = Rx.Observable.forkJoin(\n         *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n         *   Rx.Observable.interval(500).take(4) // emit 0, 1, 2, 3 every half a second and complete\n         * );\n         * observable.subscribe(\n         *   value => console.log(value),\n         *   err => {},\n         *   () => console.log('This is how it ends!')\n         * );\n         *\n         * // Logs:\n         * // [2, 3] after 3 seconds\n         * // \"This is how it ends!\" immediately after\n         *\n         *\n         * @example <caption>Use forkJoin with project function</caption>\n         * const observable = Rx.Observable.forkJoin(\n         *   Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n         *   Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n         *   (n, m) => n + m\n         * );\n         * observable.subscribe(\n         *   value => console.log(value),\n         *   err => {},\n         *   () => console.log('This is how it ends!')\n         * );\n         *\n         * // Logs:\n         * // 5 after 3 seconds\n         * // \"This is how it ends!\" immediately after\n         *\n         * @see {@link combineLatest}\n         * @see {@link zip}\n         *\n         * @param {...SubscribableOrPromise} sources Any number of Observables provided either as an array or as an arguments\n         * passed directly to the operator.\n         * @param {function} [project] Function that takes values emitted by input Observables and returns value\n         * that will appear in resulting Observable instead of default array.\n         * @return {Observable} Observable emitting either an array of last values emitted by passed Observables\n         * or value from project function.\n         * @static true\n         * @name forkJoin\n         * @owner Observable\n         */\n        ForkJoinObservable.create = function () {\n            var sources = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                sources[_i] = arguments[_i];\n            }\n            if (sources === null || arguments.length === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            var resultSelector = null;\n            if (typeof sources[sources.length - 1] === 'function') {\n                resultSelector = sources.pop();\n            }\n            // if the first and only other argument besides the resultSelector is an array\n            // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`\n            if (sources.length === 1 && isArray_1.isArray(sources[0])) {\n                sources = sources[0];\n            }\n            if (sources.length === 0) {\n                return new EmptyObservable_1.EmptyObservable();\n            }\n            return new ForkJoinObservable(sources, resultSelector);\n        };\n        ForkJoinObservable.prototype._subscribe = function (subscriber) {\n            return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);\n        };\n        return ForkJoinObservable;\n    }(Observable_1.Observable));\n    exports.ForkJoinObservable = ForkJoinObservable;\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @ignore\n     * @extends {Ignored}\n     */\n    var ForkJoinSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(ForkJoinSubscriber, _super);\n        function ForkJoinSubscriber(destination, sources, resultSelector) {\n            var _this = _super.call(this, destination) || this;\n            _this.sources = sources;\n            _this.resultSelector = resultSelector;\n            _this.completed = 0;\n            _this.haveValues = 0;\n            var len = sources.length;\n            _this.total = len;\n            _this.values = new Array(len);\n            for (var i = 0; i < len; i++) {\n                var source = sources[i];\n                var innerSubscription = subscribeToResult_1.subscribeToResult(_this, source, null, i);\n                if (innerSubscription) {\n                    innerSubscription.outerIndex = i;\n                    _this.add(innerSubscription);\n                }\n            }\n            return _this;\n        }\n        ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n            this.values[outerIndex] = innerValue;\n            if (!innerSub._hasValue) {\n                innerSub._hasValue = true;\n                this.haveValues++;\n            }\n        };\n        ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {\n            var destination = this.destination;\n            var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;\n            var len = values.length;\n            if (!innerSub._hasValue) {\n                destination.complete();\n                return;\n            }\n            this.completed++;\n            if (this.completed !== len) {\n                return;\n            }\n            if (haveValues === len) {\n                var value = resultSelector ? resultSelector.apply(this, values) : values;\n                destination.next(value);\n            }\n            destination.complete();\n        };\n        return ForkJoinSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/forkJoin',[\"require\", \"exports\", \"./ForkJoinObservable\"], function (require, exports, ForkJoinObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;\n});\n\ndefine('rxjs/add/observable/forkJoin',[\"require\", \"exports\", \"../../Observable\", \"../../observable/forkJoin\"], function (require, exports, Observable_1, forkJoin_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.forkJoin = forkJoin_1.forkJoin;\n});\n\ndefine('rxjs/add/observable/from',[\"require\", \"exports\", \"../../Observable\", \"../../observable/from\"], function (require, exports, Observable_1, from_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.from = from_1.from;\n});\n\ndefine('rxjs/observable/FromEventObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/tryCatch\", \"../util/isFunction\", \"../util/errorObject\", \"../Subscription\"], function (require, exports, tslib_1, Observable_1, tryCatch_1, isFunction_1, errorObject_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var toString = Object.prototype.toString;\n    function isNodeStyleEventEmitter(sourceObj) {\n        return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n    }\n    function isJQueryStyleEventEmitter(sourceObj) {\n        return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n    }\n    function isNodeList(sourceObj) {\n        return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';\n    }\n    function isHTMLCollection(sourceObj) {\n        return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';\n    }\n    function isEventTarget(sourceObj) {\n        return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n    }\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var FromEventObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(FromEventObservable, _super);\n        function FromEventObservable(sourceObj, eventName, selector, options) {\n            var _this = _super.call(this) || this;\n            _this.sourceObj = sourceObj;\n            _this.eventName = eventName;\n            _this.selector = selector;\n            _this.options = options;\n            return _this;\n        }\n        /* tslint:enable:max-line-length */\n        /**\n         * Creates an Observable that emits events of a specific type coming from the\n         * given event target.\n         *\n         * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n         * EventEmitter events or others.</span>\n         *\n         * <img src=\"./img/fromEvent.png\" width=\"100%\">\n         *\n         * `fromEvent` accepts as a first argument event target, which is an object with methods\n         * for registering event handler functions. As a second argument it takes string that indicates\n         * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n         * which are described in detail below. If your event target does not match any of the ones listed,\n         * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n         * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n         * handler functions have different names, but they all accept a string describing event type\n         * and function itself, which will be called whenever said event happens.\n         *\n         * Every time resulting Observable is subscribed, event handler function will be registered\n         * to event target on given event type. When that event fires, value\n         * passed as a first argument to registered function will be emitted by output Observable.\n         * When Observable is unsubscribed, function will be unregistered from event target.\n         *\n         * Note that if event target calls registered function with more than one argument, second\n         * and following arguments will not appear in resulting stream. In order to get access to them,\n         * you can pass to `fromEvent` optional project function, which will be called with all arguments\n         * passed to event handler. Output Observable will then emit value returned by project function,\n         * instead of the usual value.\n         *\n         * Remember that event targets listed below are checked via duck typing. It means that\n         * no matter what kind of object you have and no matter what environment you work in,\n         * you can safely use `fromEvent` on that object if it exposes described methods (provided\n         * of course they behave as was described above). So for example if Node.js library exposes\n         * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n         * a good choice.\n         *\n         * If the API you use is more callback then event handler oriented (subscribed\n         * callback function fires only once and thus there is no need to manually\n         * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n         * instead.\n         *\n         * `fromEvent` supports following types of event targets:\n         *\n         * **DOM EventTarget**\n         *\n         * This is an object with `addEventListener` and `removeEventListener` methods.\n         *\n         * In the browser, `addEventListener` accepts - apart from event type string and event\n         * handler function arguments - optional third parameter, which is either an object or boolean,\n         * both used for additional configuration how and when passed function will be called. When\n         * `fromEvent` is used with event target of that type, you can provide this values\n         * as third parameter as well.\n         *\n         * **Node.js EventEmitter**\n         *\n         * An object with `addListener` and `removeListener` methods.\n         *\n         * **JQuery-style event target**\n         *\n         * An object with `on` and `off` methods\n         *\n         * **DOM NodeList**\n         *\n         * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n         *\n         * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n         * it contains and install event handler function in every of them. When returned Observable\n         * is unsubscribed, function will be removed from all Nodes.\n         *\n         * **DOM HtmlCollection**\n         *\n         * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n         * installed and removed in each of elements.\n         *\n         *\n         * @example <caption>Emits clicks happening on the DOM document</caption>\n         * var clicks = Rx.Observable.fromEvent(document, 'click');\n         * clicks.subscribe(x => console.log(x));\n         *\n         * // Results in:\n         * // MouseEvent object logged to console every time a click\n         * // occurs on the document.\n         *\n         *\n         * @example <caption>Use addEventListener with capture option</caption>\n         * var clicksInDocument = Rx.Observable.fromEvent(document, 'click', true); // note optional configuration parameter\n         *                                                                          // which will be passed to addEventListener\n         * var clicksInDiv = Rx.Observable.fromEvent(someDivInDocument, 'click');\n         *\n         * clicksInDocument.subscribe(() => console.log('document'));\n         * clicksInDiv.subscribe(() => console.log('div'));\n         *\n         * // By default events bubble UP in DOM tree, so normally\n         * // when we would click on div in document\n         * // \"div\" would be logged first and then \"document\".\n         * // Since we specified optional `capture` option, document\n         * // will catch event when it goes DOWN DOM tree, so console\n         * // will log \"document\" and then \"div\".\n         *\n         * @see {@link bindCallback}\n         * @see {@link bindNodeCallback}\n         * @see {@link fromEventPattern}\n         *\n         * @param {EventTargetLike} target The DOM EventTarget, Node.js\n         * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.\n         * @param {string} eventName The event name of interest, being emitted by the\n         * `target`.\n         * @param {EventListenerOptions} [options] Options to pass through to addEventListener\n         * @param {SelectorMethodSignature<T>} [selector] An optional function to\n         * post-process results. It takes the arguments from the event handler and\n         * should return a single value.\n         * @return {Observable<T>}\n         * @static true\n         * @name fromEvent\n         * @owner Observable\n         */\n        FromEventObservable.create = function (target, eventName, options, selector) {\n            if (isFunction_1.isFunction(options)) {\n                selector = options;\n                options = undefined;\n            }\n            return new FromEventObservable(target, eventName, selector, options);\n        };\n        FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {\n            var unsubscribe;\n            if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {\n                for (var i = 0, len = sourceObj.length; i < len; i++) {\n                    FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n                }\n            }\n            else if (isEventTarget(sourceObj)) {\n                var source_1 = sourceObj;\n                sourceObj.addEventListener(eventName, handler, options);\n                unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };\n            }\n            else if (isJQueryStyleEventEmitter(sourceObj)) {\n                var source_2 = sourceObj;\n                sourceObj.on(eventName, handler);\n                unsubscribe = function () { return source_2.off(eventName, handler); };\n            }\n            else if (isNodeStyleEventEmitter(sourceObj)) {\n                var source_3 = sourceObj;\n                sourceObj.addListener(eventName, handler);\n                unsubscribe = function () { return source_3.removeListener(eventName, handler); };\n            }\n            else {\n                throw new TypeError('Invalid event target');\n            }\n            subscriber.add(new Subscription_1.Subscription(unsubscribe));\n        };\n        FromEventObservable.prototype._subscribe = function (subscriber) {\n            var sourceObj = this.sourceObj;\n            var eventName = this.eventName;\n            var options = this.options;\n            var selector = this.selector;\n            var handler = selector ? function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var result = tryCatch_1.tryCatch(selector).apply(void 0, args);\n                if (result === errorObject_1.errorObject) {\n                    subscriber.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    subscriber.next(result);\n                }\n            } : function (e) { return subscriber.next(e); };\n            FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);\n        };\n        return FromEventObservable;\n    }(Observable_1.Observable));\n    exports.FromEventObservable = FromEventObservable;\n});\n\ndefine('rxjs/observable/fromEvent',[\"require\", \"exports\", \"./FromEventObservable\"], function (require, exports, FromEventObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.fromEvent = FromEventObservable_1.FromEventObservable.create;\n});\n\ndefine('rxjs/add/observable/fromEvent',[\"require\", \"exports\", \"../../Observable\", \"../../observable/fromEvent\"], function (require, exports, Observable_1, fromEvent_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;\n});\n\ndefine('rxjs/observable/FromEventPatternObservable',[\"require\", \"exports\", \"tslib\", \"../util/isFunction\", \"../Observable\", \"../Subscription\"], function (require, exports, tslib_1, isFunction_1, Observable_1, Subscription_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var FromEventPatternObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(FromEventPatternObservable, _super);\n        function FromEventPatternObservable(addHandler, removeHandler, selector) {\n            var _this = _super.call(this) || this;\n            _this.addHandler = addHandler;\n            _this.removeHandler = removeHandler;\n            _this.selector = selector;\n            return _this;\n        }\n        /**\n         * Creates an Observable from an API based on addHandler/removeHandler\n         * functions.\n         *\n         * <span class=\"informal\">Converts any addHandler/removeHandler API to an\n         * Observable.</span>\n         *\n         * <img src=\"./img/fromEventPattern.png\" width=\"100%\">\n         *\n         * Creates an Observable by using the `addHandler` and `removeHandler`\n         * functions to add and remove the handlers, with an optional selector\n         * function to project the event arguments to a result. The `addHandler` is\n         * called when the output Observable is subscribed, and `removeHandler` is\n         * called when the Subscription is unsubscribed.\n         *\n         * @example <caption>Emits clicks happening on the DOM document</caption>\n         * function addClickHandler(handler) {\n         *   document.addEventListener('click', handler);\n         * }\n         *\n         * function removeClickHandler(handler) {\n         *   document.removeEventListener('click', handler);\n         * }\n         *\n         * var clicks = Rx.Observable.fromEventPattern(\n         *   addClickHandler,\n         *   removeClickHandler\n         * );\n         * clicks.subscribe(x => console.log(x));\n         *\n         * @see {@link from}\n         * @see {@link fromEvent}\n         *\n         * @param {function(handler: Function): any} addHandler A function that takes\n         * a `handler` function as argument and attaches it somehow to the actual\n         * source of events.\n         * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that\n         * takes a `handler` function as argument and removes it in case it was\n         * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,\n         * removeHandler function will forward it.\n         * @param {function(...args: any): T} [selector] An optional function to\n         * post-process results. It takes the arguments from the event handler and\n         * should return a single value.\n         * @return {Observable<T>}\n         * @static true\n         * @name fromEventPattern\n         * @owner Observable\n         */\n        FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {\n            return new FromEventPatternObservable(addHandler, removeHandler, selector);\n        };\n        FromEventPatternObservable.prototype._subscribe = function (subscriber) {\n            var _this = this;\n            var removeHandler = this.removeHandler;\n            var handler = !!this.selector ? function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                _this._callSelector(subscriber, args);\n            } : function (e) { subscriber.next(e); };\n            var retValue = this._callAddHandler(handler, subscriber);\n            if (!isFunction_1.isFunction(removeHandler)) {\n                return;\n            }\n            subscriber.add(new Subscription_1.Subscription(function () {\n                //TODO: determine whether or not to forward to error handler\n                removeHandler(handler, retValue);\n            }));\n        };\n        FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {\n            try {\n                var result = this.selector.apply(this, args);\n                subscriber.next(result);\n            }\n            catch (e) {\n                subscriber.error(e);\n            }\n        };\n        FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {\n            try {\n                return this.addHandler(handler) || null;\n            }\n            catch (e) {\n                errorSubscriber.error(e);\n            }\n        };\n        return FromEventPatternObservable;\n    }(Observable_1.Observable));\n    exports.FromEventPatternObservable = FromEventPatternObservable;\n});\n\ndefine('rxjs/observable/fromEventPattern',[\"require\", \"exports\", \"./FromEventPatternObservable\"], function (require, exports, FromEventPatternObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;\n});\n\ndefine('rxjs/add/observable/fromEventPattern',[\"require\", \"exports\", \"../../Observable\", \"../../observable/fromEventPattern\"], function (require, exports, Observable_1, fromEventPattern_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;\n});\n\ndefine('rxjs/observable/fromPromise',[\"require\", \"exports\", \"./PromiseObservable\"], function (require, exports, PromiseObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.fromPromise = PromiseObservable_1.PromiseObservable.create;\n});\n\ndefine('rxjs/add/observable/fromPromise',[\"require\", \"exports\", \"../../Observable\", \"../../observable/fromPromise\"], function (require, exports, Observable_1, fromPromise_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;\n});\n\ndefine('rxjs/observable/GenerateObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/isScheduler\"], function (require, exports, tslib_1, Observable_1, isScheduler_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var selfSelector = function (value) { return value; };\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var GenerateObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(GenerateObservable, _super);\n        function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.initialState = initialState;\n            _this.condition = condition;\n            _this.iterate = iterate;\n            _this.resultSelector = resultSelector;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {\n            if (arguments.length == 1) {\n                return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);\n            }\n            if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {\n                return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);\n            }\n            return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);\n        };\n        GenerateObservable.prototype._subscribe = function (subscriber) {\n            var state = this.initialState;\n            if (this.scheduler) {\n                return this.scheduler.schedule(GenerateObservable.dispatch, 0, {\n                    subscriber: subscriber,\n                    iterate: this.iterate,\n                    condition: this.condition,\n                    resultSelector: this.resultSelector,\n                    state: state\n                });\n            }\n            var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;\n            do {\n                if (condition) {\n                    var conditionResult = void 0;\n                    try {\n                        conditionResult = condition(state);\n                    }\n                    catch (err) {\n                        subscriber.error(err);\n                        return;\n                    }\n                    if (!conditionResult) {\n                        subscriber.complete();\n                        break;\n                    }\n                }\n                var value = void 0;\n                try {\n                    value = resultSelector(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    break;\n                }\n                try {\n                    state = iterate(state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n            } while (true);\n        };\n        GenerateObservable.dispatch = function (state) {\n            var subscriber = state.subscriber, condition = state.condition;\n            if (subscriber.closed) {\n                return;\n            }\n            if (state.needIterate) {\n                try {\n                    state.state = state.iterate(state.state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n            }\n            else {\n                state.needIterate = true;\n            }\n            if (condition) {\n                var conditionResult = void 0;\n                try {\n                    conditionResult = condition(state.state);\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (!conditionResult) {\n                    subscriber.complete();\n                    return;\n                }\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n            var value;\n            try {\n                value = state.resultSelector(state.state);\n            }\n            catch (err) {\n                subscriber.error(err);\n                return;\n            }\n            if (subscriber.closed) {\n                return;\n            }\n            subscriber.next(value);\n            if (subscriber.closed) {\n                return;\n            }\n            return this.schedule(state);\n        };\n        return GenerateObservable;\n    }(Observable_1.Observable));\n    exports.GenerateObservable = GenerateObservable;\n});\n\ndefine('rxjs/observable/generate',[\"require\", \"exports\", \"./GenerateObservable\"], function (require, exports, GenerateObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.generate = GenerateObservable_1.GenerateObservable.create;\n});\n\ndefine('rxjs/add/observable/generate',[\"require\", \"exports\", \"../../Observable\", \"../../observable/generate\"], function (require, exports, Observable_1, generate_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.generate = generate_1.generate;\n});\n\ndefine('rxjs/observable/IfObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Observable_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var IfObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(IfObservable, _super);\n        function IfObservable(condition, thenSource, elseSource) {\n            var _this = _super.call(this) || this;\n            _this.condition = condition;\n            _this.thenSource = thenSource;\n            _this.elseSource = elseSource;\n            return _this;\n        }\n        IfObservable.create = function (condition, thenSource, elseSource) {\n            return new IfObservable(condition, thenSource, elseSource);\n        };\n        IfObservable.prototype._subscribe = function (subscriber) {\n            var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n            return new IfSubscriber(subscriber, condition, thenSource, elseSource);\n        };\n        return IfObservable;\n    }(Observable_1.Observable));\n    exports.IfObservable = IfObservable;\n    var IfSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(IfSubscriber, _super);\n        function IfSubscriber(destination, condition, thenSource, elseSource) {\n            var _this = _super.call(this, destination) || this;\n            _this.condition = condition;\n            _this.thenSource = thenSource;\n            _this.elseSource = elseSource;\n            _this.tryIf();\n            return _this;\n        }\n        IfSubscriber.prototype.tryIf = function () {\n            var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;\n            var result;\n            try {\n                result = condition();\n                var source = result ? thenSource : elseSource;\n                if (source) {\n                    this.add(subscribeToResult_1.subscribeToResult(this, source));\n                }\n                else {\n                    this._complete();\n                }\n            }\n            catch (err) {\n                this._error(err);\n            }\n        };\n        return IfSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/if',[\"require\", \"exports\", \"./IfObservable\"], function (require, exports, IfObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports._if = IfObservable_1.IfObservable.create;\n});\n\ndefine('rxjs/add/observable/if',[\"require\", \"exports\", \"../../Observable\", \"../../observable/if\"], function (require, exports, Observable_1, if_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.if = if_1._if;\n});\n\ndefine('rxjs/observable/IntervalObservable',[\"require\", \"exports\", \"tslib\", \"../util/isNumeric\", \"../Observable\", \"../scheduler/async\"], function (require, exports, tslib_1, isNumeric_1, Observable_1, async_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var IntervalObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(IntervalObservable, _super);\n        function IntervalObservable(period, scheduler) {\n            if (period === void 0) { period = 0; }\n            if (scheduler === void 0) { scheduler = async_1.async; }\n            var _this = _super.call(this) || this;\n            _this.period = period;\n            _this.scheduler = scheduler;\n            if (!isNumeric_1.isNumeric(period) || period < 0) {\n                _this.period = 0;\n            }\n            if (!scheduler || typeof scheduler.schedule !== 'function') {\n                _this.scheduler = async_1.async;\n            }\n            return _this;\n        }\n        /**\n         * Creates an Observable that emits sequential numbers every specified\n         * interval of time, on a specified IScheduler.\n         *\n         * <span class=\"informal\">Emits incremental numbers periodically in time.\n         * </span>\n         *\n         * <img src=\"./img/interval.png\" width=\"100%\">\n         *\n         * `interval` returns an Observable that emits an infinite sequence of\n         * ascending integers, with a constant interval of time of your choosing\n         * between those emissions. The first emission is not sent immediately, but\n         * only after the first period has passed. By default, this operator uses the\n         * `async` IScheduler to provide a notion of time, but you may pass any\n         * IScheduler to it.\n         *\n         * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>\n         * var numbers = Rx.Observable.interval(1000);\n         * numbers.subscribe(x => console.log(x));\n         *\n         * @see {@link timer}\n         * @see {@link delay}\n         *\n         * @param {number} [period=0] The interval size in milliseconds (by default)\n         * or the time unit determined by the scheduler's clock.\n         * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling\n         * the emission of values, and providing a notion of \"time\".\n         * @return {Observable} An Observable that emits a sequential number each time\n         * interval.\n         * @static true\n         * @name interval\n         * @owner Observable\n         */\n        IntervalObservable.create = function (period, scheduler) {\n            if (period === void 0) { period = 0; }\n            if (scheduler === void 0) { scheduler = async_1.async; }\n            return new IntervalObservable(period, scheduler);\n        };\n        IntervalObservable.dispatch = function (state) {\n            var index = state.index, subscriber = state.subscriber, period = state.period;\n            subscriber.next(index);\n            if (subscriber.closed) {\n                return;\n            }\n            state.index += 1;\n            this.schedule(state, period);\n        };\n        IntervalObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var period = this.period;\n            var scheduler = this.scheduler;\n            subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {\n                index: index, subscriber: subscriber, period: period\n            }));\n        };\n        return IntervalObservable;\n    }(Observable_1.Observable));\n    exports.IntervalObservable = IntervalObservable;\n});\n\ndefine('rxjs/observable/interval',[\"require\", \"exports\", \"./IntervalObservable\"], function (require, exports, IntervalObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.interval = IntervalObservable_1.IntervalObservable.create;\n});\n\ndefine('rxjs/add/observable/interval',[\"require\", \"exports\", \"../../Observable\", \"../../observable/interval\"], function (require, exports, Observable_1, interval_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.interval = interval_1.interval;\n});\n\ndefine('rxjs/add/observable/merge',[\"require\", \"exports\", \"../../Observable\", \"../../observable/merge\"], function (require, exports, Observable_1, merge_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.merge = merge_1.merge;\n});\n\ndefine('rxjs/add/observable/race',[\"require\", \"exports\", \"../../Observable\", \"../../observable/race\"], function (require, exports, Observable_1, race_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.race = race_1.race;\n});\n\ndefine('rxjs/observable/NeverObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/noop\"], function (require, exports, tslib_1, Observable_1, noop_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var NeverObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(NeverObservable, _super);\n        function NeverObservable() {\n            return _super.call(this) || this;\n        }\n        /**\n         * Creates an Observable that emits no items to the Observer.\n         *\n         * <span class=\"informal\">An Observable that never emits anything.</span>\n         *\n         * <img src=\"./img/never.png\" width=\"100%\">\n         *\n         * This static operator is useful for creating a simple Observable that emits\n         * neither values nor errors nor the completion notification. It can be used\n         * for testing purposes or for composing with other Observables. Please note\n         * that by never emitting a complete notification, this Observable keeps the\n         * subscription from being disposed automatically. Subscriptions need to be\n         * manually disposed.\n         *\n         * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>\n         * function info() {\n         *   console.log('Will not be called');\n         * }\n         * var result = Rx.Observable.never().startWith(7);\n         * result.subscribe(x => console.log(x), info, info);\n         *\n         * @see {@link create}\n         * @see {@link empty}\n         * @see {@link of}\n         * @see {@link throw}\n         *\n         * @return {Observable} A \"never\" Observable: never emits anything.\n         * @static true\n         * @name never\n         * @owner Observable\n         */\n        NeverObservable.create = function () {\n            return new NeverObservable();\n        };\n        NeverObservable.prototype._subscribe = function (subscriber) {\n            noop_1.noop();\n        };\n        return NeverObservable;\n    }(Observable_1.Observable));\n    exports.NeverObservable = NeverObservable;\n});\n\ndefine('rxjs/observable/never',[\"require\", \"exports\", \"./NeverObservable\"], function (require, exports, NeverObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.never = NeverObservable_1.NeverObservable.create;\n});\n\ndefine('rxjs/add/observable/never',[\"require\", \"exports\", \"../../Observable\", \"../../observable/never\"], function (require, exports, Observable_1, never_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.never = never_1.never;\n});\n\ndefine('rxjs/add/observable/of',[\"require\", \"exports\", \"../../Observable\", \"../../observable/of\"], function (require, exports, Observable_1, of_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.of = of_1.of;\n});\n\ndefine('rxjs/observable/onErrorResumeNext',[\"require\", \"exports\", \"../operators/onErrorResumeNext\"], function (require, exports, onErrorResumeNext_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;\n});\n\ndefine('rxjs/add/observable/onErrorResumeNext',[\"require\", \"exports\", \"../../Observable\", \"../../observable/onErrorResumeNext\"], function (require, exports, Observable_1, onErrorResumeNext_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n});\n\ndefine('rxjs/observable/PairsObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function dispatch(state) {\n        var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;\n        if (index === length) {\n            subscriber.complete();\n            return;\n        }\n        var key = keys[index];\n        subscriber.next([key, obj[key]]);\n        state.index = index + 1;\n        this.schedule(state);\n    }\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var PairsObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(PairsObservable, _super);\n        function PairsObservable(obj, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.obj = obj;\n            _this.scheduler = scheduler;\n            _this.keys = Object.keys(obj);\n            return _this;\n        }\n        /**\n         * Convert an object into an observable sequence of [key, value] pairs\n         * using an optional IScheduler to enumerate the object.\n         *\n         * @example <caption>Converts a javascript object to an Observable</caption>\n         * var obj = {\n         *   foo: 42,\n         *   bar: 56,\n         *   baz: 78\n         * };\n         *\n         * var source = Rx.Observable.pairs(obj);\n         *\n         * var subscription = source.subscribe(\n         *   function (x) {\n         *     console.log('Next: %s', x);\n         *   },\n         *   function (err) {\n         *     console.log('Error: %s', err);\n         *   },\n         *   function () {\n         *     console.log('Completed');\n         *   });\n         *\n         * @param {Object} obj The object to inspect and turn into an\n         * Observable sequence.\n         * @param {Scheduler} [scheduler] An optional IScheduler to run the\n         * enumeration of the input sequence on.\n         * @returns {(Observable<Array<string | T>>)} An observable sequence of\n         * [key, value] pairs from the object.\n         */\n        PairsObservable.create = function (obj, scheduler) {\n            return new PairsObservable(obj, scheduler);\n        };\n        PairsObservable.prototype._subscribe = function (subscriber) {\n            var _a = this, keys = _a.keys, scheduler = _a.scheduler;\n            var length = keys.length;\n            if (scheduler) {\n                return scheduler.schedule(dispatch, 0, {\n                    obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber\n                });\n            }\n            else {\n                for (var idx = 0; idx < length; idx++) {\n                    var key = keys[idx];\n                    subscriber.next([key, this.obj[key]]);\n                }\n                subscriber.complete();\n            }\n        };\n        return PairsObservable;\n    }(Observable_1.Observable));\n    exports.PairsObservable = PairsObservable;\n});\n\ndefine('rxjs/observable/pairs',[\"require\", \"exports\", \"./PairsObservable\"], function (require, exports, PairsObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.pairs = PairsObservable_1.PairsObservable.create;\n});\n\ndefine('rxjs/add/observable/pairs',[\"require\", \"exports\", \"../../Observable\", \"../../observable/pairs\"], function (require, exports, Observable_1, pairs_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.pairs = pairs_1.pairs;\n});\n\ndefine('rxjs/observable/RangeObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var RangeObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(RangeObservable, _super);\n        function RangeObservable(start, count, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.start = start;\n            _this._count = count;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Creates an Observable that emits a sequence of numbers within a specified\n         * range.\n         *\n         * <span class=\"informal\">Emits a sequence of numbers in a range.</span>\n         *\n         * <img src=\"./img/range.png\" width=\"100%\">\n         *\n         * `range` operator emits a range of sequential integers, in order, where you\n         * select the `start` of the range and its `length`. By default, uses no\n         * IScheduler and just delivers the notifications synchronously, but may use\n         * an optional IScheduler to regulate those deliveries.\n         *\n         * @example <caption>Emits the numbers 1 to 10</caption>\n         * var numbers = Rx.Observable.range(1, 10);\n         * numbers.subscribe(x => console.log(x));\n         *\n         * @see {@link timer}\n         * @see {@link interval}\n         *\n         * @param {number} [start=0] The value of the first integer in the sequence.\n         * @param {number} [count=0] The number of sequential integers to generate.\n         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n         * the emissions of the notifications.\n         * @return {Observable} An Observable of numbers that emits a finite range of\n         * sequential integers.\n         * @static true\n         * @name range\n         * @owner Observable\n         */\n        RangeObservable.create = function (start, count, scheduler) {\n            if (start === void 0) { start = 0; }\n            if (count === void 0) { count = 0; }\n            return new RangeObservable(start, count, scheduler);\n        };\n        RangeObservable.dispatch = function (state) {\n            var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;\n            if (index >= count) {\n                subscriber.complete();\n                return;\n            }\n            subscriber.next(start);\n            if (subscriber.closed) {\n                return;\n            }\n            state.index = index + 1;\n            state.start = start + 1;\n            this.schedule(state);\n        };\n        RangeObservable.prototype._subscribe = function (subscriber) {\n            var index = 0;\n            var start = this.start;\n            var count = this._count;\n            var scheduler = this.scheduler;\n            if (scheduler) {\n                return scheduler.schedule(RangeObservable.dispatch, 0, {\n                    index: index, count: count, start: start, subscriber: subscriber\n                });\n            }\n            else {\n                do {\n                    if (index++ >= count) {\n                        subscriber.complete();\n                        break;\n                    }\n                    subscriber.next(start++);\n                    if (subscriber.closed) {\n                        break;\n                    }\n                } while (true);\n            }\n        };\n        return RangeObservable;\n    }(Observable_1.Observable));\n    exports.RangeObservable = RangeObservable;\n});\n\ndefine('rxjs/observable/range',[\"require\", \"exports\", \"./RangeObservable\"], function (require, exports, RangeObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.range = RangeObservable_1.RangeObservable.create;\n});\n\ndefine('rxjs/add/observable/range',[\"require\", \"exports\", \"../../Observable\", \"../../observable/range\"], function (require, exports, Observable_1, range_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.range = range_1.range;\n});\n\ndefine('rxjs/observable/UsingObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../util/subscribeToResult\", \"../OuterSubscriber\"], function (require, exports, tslib_1, Observable_1, subscribeToResult_1, OuterSubscriber_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var UsingObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(UsingObservable, _super);\n        function UsingObservable(resourceFactory, observableFactory) {\n            var _this = _super.call(this) || this;\n            _this.resourceFactory = resourceFactory;\n            _this.observableFactory = observableFactory;\n            return _this;\n        }\n        UsingObservable.create = function (resourceFactory, observableFactory) {\n            return new UsingObservable(resourceFactory, observableFactory);\n        };\n        UsingObservable.prototype._subscribe = function (subscriber) {\n            var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;\n            var resource;\n            try {\n                resource = resourceFactory();\n                return new UsingSubscriber(subscriber, resource, observableFactory);\n            }\n            catch (err) {\n                subscriber.error(err);\n            }\n        };\n        return UsingObservable;\n    }(Observable_1.Observable));\n    exports.UsingObservable = UsingObservable;\n    var UsingSubscriber = /** @class */ (function (_super) {\n        tslib_1.__extends(UsingSubscriber, _super);\n        function UsingSubscriber(destination, resource, observableFactory) {\n            var _this = _super.call(this, destination) || this;\n            _this.resource = resource;\n            _this.observableFactory = observableFactory;\n            destination.add(resource);\n            _this.tryUse();\n            return _this;\n        }\n        UsingSubscriber.prototype.tryUse = function () {\n            try {\n                var source = this.observableFactory.call(this, this.resource);\n                if (source) {\n                    this.add(subscribeToResult_1.subscribeToResult(this, source));\n                }\n            }\n            catch (err) {\n                this._error(err);\n            }\n        };\n        return UsingSubscriber;\n    }(OuterSubscriber_1.OuterSubscriber));\n});\n\ndefine('rxjs/observable/using',[\"require\", \"exports\", \"./UsingObservable\"], function (require, exports, UsingObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.using = UsingObservable_1.UsingObservable.create;\n});\n\ndefine('rxjs/add/observable/using',[\"require\", \"exports\", \"../../Observable\", \"../../observable/using\"], function (require, exports, Observable_1, using_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.using = using_1.using;\n});\n\ndefine('rxjs/observable/ErrorObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\"], function (require, exports, tslib_1, Observable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var ErrorObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(ErrorObservable, _super);\n        function ErrorObservable(error, scheduler) {\n            var _this = _super.call(this) || this;\n            _this.error = error;\n            _this.scheduler = scheduler;\n            return _this;\n        }\n        /**\n         * Creates an Observable that emits no items to the Observer and immediately\n         * emits an error notification.\n         *\n         * <span class=\"informal\">Just emits 'error', and nothing else.\n         * </span>\n         *\n         * <img src=\"./img/throw.png\" width=\"100%\">\n         *\n         * This static operator is useful for creating a simple Observable that only\n         * emits the error notification. It can be used for composing with other\n         * Observables, such as in a {@link mergeMap}.\n         *\n         * @example <caption>Emit the number 7, then emit an error.</caption>\n         * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>\n         * var interval = Rx.Observable.interval(1000);\n         * var result = interval.mergeMap(x =>\n         *   x === 13 ?\n         *     Rx.Observable.throw('Thirteens are bad') :\n         *     Rx.Observable.of('a', 'b', 'c')\n         * );\n         * result.subscribe(x => console.log(x), e => console.error(e));\n         *\n         * @see {@link create}\n         * @see {@link empty}\n         * @see {@link never}\n         * @see {@link of}\n         *\n         * @param {any} error The particular Error to pass to the error notification.\n         * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n         * the emission of the error notification.\n         * @return {Observable} An error Observable: emits only the error notification\n         * using the given error argument.\n         * @static true\n         * @name throw\n         * @owner Observable\n         */\n        ErrorObservable.create = function (error, scheduler) {\n            return new ErrorObservable(error, scheduler);\n        };\n        ErrorObservable.dispatch = function (arg) {\n            var error = arg.error, subscriber = arg.subscriber;\n            subscriber.error(error);\n        };\n        ErrorObservable.prototype._subscribe = function (subscriber) {\n            var error = this.error;\n            var scheduler = this.scheduler;\n            subscriber.syncErrorThrowable = true;\n            if (scheduler) {\n                return scheduler.schedule(ErrorObservable.dispatch, 0, {\n                    error: error, subscriber: subscriber\n                });\n            }\n            else {\n                subscriber.error(error);\n            }\n        };\n        return ErrorObservable;\n    }(Observable_1.Observable));\n    exports.ErrorObservable = ErrorObservable;\n});\n\ndefine('rxjs/observable/throw',[\"require\", \"exports\", \"./ErrorObservable\"], function (require, exports, ErrorObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports._throw = ErrorObservable_1.ErrorObservable.create;\n});\n\ndefine('rxjs/add/observable/throw',[\"require\", \"exports\", \"../../Observable\", \"../../observable/throw\"], function (require, exports, Observable_1, throw_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.throw = throw_1._throw;\n});\n\ndefine('rxjs/add/observable/timer',[\"require\", \"exports\", \"../../Observable\", \"../../observable/timer\"], function (require, exports, Observable_1, timer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.timer = timer_1.timer;\n});\n\ndefine('rxjs/observable/zip',[\"require\", \"exports\", \"../operators/zip\"], function (require, exports, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.zip = zip_1.zipStatic;\n});\n\ndefine('rxjs/add/observable/zip',[\"require\", \"exports\", \"../../Observable\", \"../../observable/zip\"], function (require, exports, Observable_1, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.zip = zip_1.zip;\n});\n\ndefine('rxjs/observable/dom/ajax',[\"require\", \"exports\", \"./AjaxObservable\"], function (require, exports, AjaxObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.ajax = AjaxObservable_1.AjaxObservable.create;\n});\n\ndefine('rxjs/add/observable/dom/ajax',[\"require\", \"exports\", \"../../../Observable\", \"../../../observable/dom/ajax\"], function (require, exports, Observable_1, ajax_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.ajax = ajax_1.ajax;\n});\n\ndefine('rxjs/util/assign',[\"require\", \"exports\", \"./root\"], function (require, exports, root_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function assignImpl(target) {\n        var sources = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            sources[_i - 1] = arguments[_i];\n        }\n        var len = sources.length;\n        for (var i = 0; i < len; i++) {\n            var source = sources[i];\n            for (var k in source) {\n                if (source.hasOwnProperty(k)) {\n                    target[k] = source[k];\n                }\n            }\n        }\n        return target;\n    }\n    exports.assignImpl = assignImpl;\n    ;\n    function getAssign(root) {\n        return root.Object.assign || assignImpl;\n    }\n    exports.getAssign = getAssign;\n    exports.assign = getAssign(root_1.root);\n});\n\ndefine('rxjs/observable/dom/WebSocketSubject',[\"require\", \"exports\", \"tslib\", \"../../Subject\", \"../../Subscriber\", \"../../Observable\", \"../../Subscription\", \"../../util/root\", \"../../ReplaySubject\", \"../../util/tryCatch\", \"../../util/errorObject\", \"../../util/assign\"], function (require, exports, tslib_1, Subject_1, Subscriber_1, Observable_1, Subscription_1, root_1, ReplaySubject_1, tryCatch_1, errorObject_1, assign_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var WebSocketSubject = /** @class */ (function (_super) {\n        tslib_1.__extends(WebSocketSubject, _super);\n        function WebSocketSubject(urlConfigOrSource, destination) {\n            var _this = this;\n            if (urlConfigOrSource instanceof Observable_1.Observable) {\n                _this = _super.call(this, destination, urlConfigOrSource) || this;\n            }\n            else {\n                _this = _super.call(this) || this;\n                _this.WebSocketCtor = root_1.root.WebSocket;\n                _this._output = new Subject_1.Subject();\n                if (typeof urlConfigOrSource === 'string') {\n                    _this.url = urlConfigOrSource;\n                }\n                else {\n                    // WARNING: config object could override important members here.\n                    assign_1.assign(_this, urlConfigOrSource);\n                }\n                if (!_this.WebSocketCtor) {\n                    throw new Error('no WebSocket constructor can be found');\n                }\n                _this.destination = new ReplaySubject_1.ReplaySubject();\n            }\n            return _this;\n        }\n        WebSocketSubject.prototype.resultSelector = function (e) {\n            return JSON.parse(e.data);\n        };\n        /**\n         * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n         *\n         * @example <caption>Wraps browser WebSocket</caption>\n         *\n         * let socket$ = Observable.webSocket('ws://localhost:8081');\n         *\n         * socket$.subscribe(\n         *    (msg) => console.log('message received: ' + msg),\n         *    (err) => console.log(err),\n         *    () => console.log('complete')\n         *  );\n         *\n         * socket$.next(JSON.stringify({ op: 'hello' }));\n         *\n         * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>\n         *\n         * import { w3cwebsocket } from 'websocket';\n         *\n         * let socket$ = Observable.webSocket({\n         *   url: 'ws://localhost:8081',\n         *   WebSocketCtor: w3cwebsocket\n         * });\n         *\n         * socket$.subscribe(\n         *    (msg) => console.log('message received: ' + msg),\n         *    (err) => console.log(err),\n         *    () => console.log('complete')\n         *  );\n         *\n         * socket$.next(JSON.stringify({ op: 'hello' }));\n         *\n         * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object\n         * @return {WebSocketSubject}\n         * @static true\n         * @name webSocket\n         * @owner Observable\n         */\n        WebSocketSubject.create = function (urlConfigOrSource) {\n            return new WebSocketSubject(urlConfigOrSource);\n        };\n        WebSocketSubject.prototype.lift = function (operator) {\n            var sock = new WebSocketSubject(this, this.destination);\n            sock.operator = operator;\n            return sock;\n        };\n        WebSocketSubject.prototype._resetState = function () {\n            this.socket = null;\n            if (!this.source) {\n                this.destination = new ReplaySubject_1.ReplaySubject();\n            }\n            this._output = new Subject_1.Subject();\n        };\n        // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n        WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {\n            var self = this;\n            return new Observable_1.Observable(function (observer) {\n                var result = tryCatch_1.tryCatch(subMsg)();\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    self.next(result);\n                }\n                var subscription = self.subscribe(function (x) {\n                    var result = tryCatch_1.tryCatch(messageFilter)(x);\n                    if (result === errorObject_1.errorObject) {\n                        observer.error(errorObject_1.errorObject.e);\n                    }\n                    else if (result) {\n                        observer.next(x);\n                    }\n                }, function (err) { return observer.error(err); }, function () { return observer.complete(); });\n                return function () {\n                    var result = tryCatch_1.tryCatch(unsubMsg)();\n                    if (result === errorObject_1.errorObject) {\n                        observer.error(errorObject_1.errorObject.e);\n                    }\n                    else {\n                        self.next(result);\n                    }\n                    subscription.unsubscribe();\n                };\n            });\n        };\n        WebSocketSubject.prototype._connectSocket = function () {\n            var _this = this;\n            var WebSocketCtor = this.WebSocketCtor;\n            var observer = this._output;\n            var socket = null;\n            try {\n                socket = this.protocol ?\n                    new WebSocketCtor(this.url, this.protocol) :\n                    new WebSocketCtor(this.url);\n                this.socket = socket;\n                if (this.binaryType) {\n                    this.socket.binaryType = this.binaryType;\n                }\n            }\n            catch (e) {\n                observer.error(e);\n                return;\n            }\n            var subscription = new Subscription_1.Subscription(function () {\n                _this.socket = null;\n                if (socket && socket.readyState === 1) {\n                    socket.close();\n                }\n            });\n            socket.onopen = function (e) {\n                var openObserver = _this.openObserver;\n                if (openObserver) {\n                    openObserver.next(e);\n                }\n                var queue = _this.destination;\n                _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {\n                    var closingObserver = _this.closingObserver;\n                    if (closingObserver) {\n                        closingObserver.next(undefined);\n                    }\n                    if (e && e.code) {\n                        socket.close(e.code, e.reason);\n                    }\n                    else {\n                        observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +\n                            'and an optional reason: { code: number, reason: string }'));\n                    }\n                    _this._resetState();\n                }, function () {\n                    var closingObserver = _this.closingObserver;\n                    if (closingObserver) {\n                        closingObserver.next(undefined);\n                    }\n                    socket.close();\n                    _this._resetState();\n                });\n                if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {\n                    subscription.add(queue.subscribe(_this.destination));\n                }\n            };\n            socket.onerror = function (e) {\n                _this._resetState();\n                observer.error(e);\n            };\n            socket.onclose = function (e) {\n                _this._resetState();\n                var closeObserver = _this.closeObserver;\n                if (closeObserver) {\n                    closeObserver.next(e);\n                }\n                if (e.wasClean) {\n                    observer.complete();\n                }\n                else {\n                    observer.error(e);\n                }\n            };\n            socket.onmessage = function (e) {\n                var result = tryCatch_1.tryCatch(_this.resultSelector)(e);\n                if (result === errorObject_1.errorObject) {\n                    observer.error(errorObject_1.errorObject.e);\n                }\n                else {\n                    observer.next(result);\n                }\n            };\n        };\n        WebSocketSubject.prototype._subscribe = function (subscriber) {\n            var _this = this;\n            var source = this.source;\n            if (source) {\n                return source.subscribe(subscriber);\n            }\n            if (!this.socket) {\n                this._connectSocket();\n            }\n            var subscription = new Subscription_1.Subscription();\n            subscription.add(this._output.subscribe(subscriber));\n            subscription.add(function () {\n                var socket = _this.socket;\n                if (_this._output.observers.length === 0) {\n                    if (socket && socket.readyState === 1) {\n                        socket.close();\n                    }\n                    _this._resetState();\n                }\n            });\n            return subscription;\n        };\n        WebSocketSubject.prototype.unsubscribe = function () {\n            var _a = this, source = _a.source, socket = _a.socket;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n                this._resetState();\n            }\n            _super.prototype.unsubscribe.call(this);\n            if (!source) {\n                this.destination = new ReplaySubject_1.ReplaySubject();\n            }\n        };\n        return WebSocketSubject;\n    }(Subject_1.AnonymousSubject));\n    exports.WebSocketSubject = WebSocketSubject;\n});\n\ndefine('rxjs/observable/dom/webSocket',[\"require\", \"exports\", \"./WebSocketSubject\"], function (require, exports, WebSocketSubject_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.webSocket = WebSocketSubject_1.WebSocketSubject.create;\n});\n\ndefine('rxjs/add/observable/dom/webSocket',[\"require\", \"exports\", \"../../../Observable\", \"../../../observable/dom/webSocket\"], function (require, exports, Observable_1, webSocket_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.webSocket = webSocket_1.webSocket;\n});\n\ndefine('rxjs/operator/buffer',[\"require\", \"exports\", \"../operators/buffer\"], function (require, exports, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values until `closingNotifier` emits.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * that array only when another Observable emits.</span>\n     *\n     * <img src=\"./img/buffer.png\" width=\"100%\">\n     *\n     * Buffers the incoming Observable values until the given `closingNotifier`\n     * Observable emits a value, at which point it emits the buffer on the output\n     * Observable and starts a new buffer internally, awaiting the next time\n     * `closingNotifier` emits.\n     *\n     * @example <caption>On every click, emit array of most recent interval events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var interval = Rx.Observable.interval(1000);\n     * var buffered = interval.buffer(clicks);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link window}\n     *\n     * @param {Observable<any>} closingNotifier An Observable that signals the\n     * buffer to be emitted on the output Observable.\n     * @return {Observable<T[]>} An Observable of buffers, which are arrays of\n     * values.\n     * @method buffer\n     * @owner Observable\n     */\n    function buffer(closingNotifier) {\n        return buffer_1.buffer(closingNotifier)(this);\n    }\n    exports.buffer = buffer;\n});\n\ndefine('rxjs/add/operator/buffer',[\"require\", \"exports\", \"../../Observable\", \"../../operator/buffer\"], function (require, exports, Observable_1, buffer_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.buffer = buffer_1.buffer;\n});\n\ndefine('rxjs/operator/bufferCount',[\"require\", \"exports\", \"../operators/bufferCount\"], function (require, exports, bufferCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values until the size hits the maximum\n     * `bufferSize` given.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * that array only when its size reaches `bufferSize`.</span>\n     *\n     * <img src=\"./img/bufferCount.png\" width=\"100%\">\n     *\n     * Buffers a number of values from the source Observable by `bufferSize` then\n     * emits the buffer and clears it, and starts a new buffer each\n     * `startBufferEvery` values. If `startBufferEvery` is not provided or is\n     * `null`, then new buffers are started immediately at the start of the source\n     * and when each buffer closes and is emitted.\n     *\n     * @example <caption>Emit the last two click events as an array</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferCount(2);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @example <caption>On every click, emit the last two click events as an array</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferCount(2, 1);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link pairwise}\n     * @see {@link windowCount}\n     *\n     * @param {number} bufferSize The maximum size of the buffer emitted.\n     * @param {number} [startBufferEvery] Interval at which to start a new buffer.\n     * For example if `startBufferEvery` is `2`, then a new buffer will be started\n     * on every other value from the source. A new buffer is started at the\n     * beginning of the source by default.\n     * @return {Observable<T[]>} An Observable of arrays of buffered values.\n     * @method bufferCount\n     * @owner Observable\n     */\n    function bufferCount(bufferSize, startBufferEvery) {\n        if (startBufferEvery === void 0) { startBufferEvery = null; }\n        return bufferCount_1.bufferCount(bufferSize, startBufferEvery)(this);\n    }\n    exports.bufferCount = bufferCount;\n});\n\ndefine('rxjs/add/operator/bufferCount',[\"require\", \"exports\", \"../../Observable\", \"../../operator/bufferCount\"], function (require, exports, Observable_1, bufferCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;\n});\n\ndefine('rxjs/operator/bufferTime',[\"require\", \"exports\", \"../scheduler/async\", \"../util/isScheduler\", \"../operators/bufferTime\"], function (require, exports, async_1, isScheduler_1, bufferTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Buffers the source Observable values for a specific time period.\n     *\n     * <span class=\"informal\">Collects values from the past as an array, and emits\n     * those arrays periodically in time.</span>\n     *\n     * <img src=\"./img/bufferTime.png\" width=\"100%\">\n     *\n     * Buffers values from the source for a specific time duration `bufferTimeSpan`.\n     * Unless the optional argument `bufferCreationInterval` is given, it emits and\n     * resets the buffer every `bufferTimeSpan` milliseconds. If\n     * `bufferCreationInterval` is given, this operator opens the buffer every\n     * `bufferCreationInterval` milliseconds and closes (emits and resets) the\n     * buffer every `bufferTimeSpan` milliseconds. When the optional argument\n     * `maxBufferSize` is specified, the buffer will be closed either after\n     * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.\n     *\n     * @example <caption>Every second, emit an array of the recent click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferTime(1000);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferTime(2000, 5000);\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferToggle}\n     * @see {@link bufferWhen}\n     * @see {@link windowTime}\n     *\n     * @param {number} bufferTimeSpan The amount of time to fill each buffer array.\n     * @param {number} [bufferCreationInterval] The interval at which to start new\n     * buffers.\n     * @param {number} [maxBufferSize] The maximum buffer size.\n     * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the\n     * intervals that determine buffer boundaries.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferTime\n     * @owner Observable\n     */\n    function bufferTime(bufferTimeSpan) {\n        var length = arguments.length;\n        var scheduler = async_1.async;\n        if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {\n            scheduler = arguments[arguments.length - 1];\n            length--;\n        }\n        var bufferCreationInterval = null;\n        if (length >= 2) {\n            bufferCreationInterval = arguments[1];\n        }\n        var maxBufferSize = Number.POSITIVE_INFINITY;\n        if (length >= 3) {\n            maxBufferSize = arguments[2];\n        }\n        return bufferTime_1.bufferTime(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler)(this);\n    }\n    exports.bufferTime = bufferTime;\n});\n\ndefine('rxjs/add/operator/bufferTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/bufferTime\"], function (require, exports, Observable_1, bufferTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;\n});\n\ndefine('rxjs/operator/bufferToggle',[\"require\", \"exports\", \"../operators/bufferToggle\"], function (require, exports, bufferToggle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values starting from an emission from\n     * `openings` and ending when the output of `closingSelector` emits.\n     *\n     * <span class=\"informal\">Collects values from the past as an array. Starts\n     * collecting only when `opening` emits, and calls the `closingSelector`\n     * function to get an Observable that tells when to close the buffer.</span>\n     *\n     * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n     *\n     * Buffers values from the source by opening the buffer via signals from an\n     * Observable provided to `openings`, and closing and sending the buffers when\n     * a Subscribable or Promise returned by the `closingSelector` function emits.\n     *\n     * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var openings = Rx.Observable.interval(1000);\n     * var buffered = clicks.bufferToggle(openings, i =>\n     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n     * );\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferWhen}\n     * @see {@link windowToggle}\n     *\n     * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n     * buffers.\n     * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n     * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n     * which, when it emits, signals that the associated buffer should be emitted\n     * and cleared.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferToggle\n     * @owner Observable\n     */\n    function bufferToggle(openings, closingSelector) {\n        return bufferToggle_1.bufferToggle(openings, closingSelector)(this);\n    }\n    exports.bufferToggle = bufferToggle;\n});\n\ndefine('rxjs/add/operator/bufferToggle',[\"require\", \"exports\", \"../../Observable\", \"../../operator/bufferToggle\"], function (require, exports, Observable_1, bufferToggle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;\n});\n\ndefine('rxjs/operator/bufferWhen',[\"require\", \"exports\", \"../operators/bufferWhen\"], function (require, exports, bufferWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Buffers the source Observable values, using a factory function of closing\n     * Observables to determine when to close, emit, and reset the buffer.\n     *\n     * <span class=\"informal\">Collects values from the past as an array. When it\n     * starts collecting values, it calls a function that returns an Observable that\n     * tells when to close the buffer and restart collecting.</span>\n     *\n     * <img src=\"./img/bufferWhen.png\" width=\"100%\">\n     *\n     * Opens a buffer immediately, then closes the buffer when the observable\n     * returned by calling `closingSelector` function emits a value. When it closes\n     * the buffer, it immediately opens a new buffer and repeats the process.\n     *\n     * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var buffered = clicks.bufferWhen(() =>\n     *   Rx.Observable.interval(1000 + Math.random() * 4000)\n     * );\n     * buffered.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     * @see {@link bufferTime}\n     * @see {@link bufferToggle}\n     * @see {@link windowWhen}\n     *\n     * @param {function(): Observable} closingSelector A function that takes no\n     * arguments and returns an Observable that signals buffer closure.\n     * @return {Observable<T[]>} An observable of arrays of buffered values.\n     * @method bufferWhen\n     * @owner Observable\n     */\n    function bufferWhen(closingSelector) {\n        return bufferWhen_1.bufferWhen(closingSelector)(this);\n    }\n    exports.bufferWhen = bufferWhen;\n});\n\ndefine('rxjs/add/operator/bufferWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/bufferWhen\"], function (require, exports, Observable_1, bufferWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;\n});\n\ndefine('rxjs/operator/catch',[\"require\", \"exports\", \"../operators/catchError\"], function (require, exports, catchError_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Catches errors on the observable to be handled by returning a new observable or throwing an error.\n     *\n     * <img src=\"./img/catch.png\" width=\"100%\">\n     *\n     * @example <caption>Continues with a different Observable when there's an error</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     * \t   if (n == 4) {\n     * \t     throw 'four!';\n     *     }\n     *\t   return n;\n     *   })\n     *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))\n     *   .subscribe(x => console.log(x));\n     *   // 1, 2, 3, I, II, III, IV, V\n     *\n     * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     * \t   if (n === 4) {\n     * \t     throw 'four!';\n     *     }\n     * \t   return n;\n     *   })\n     *   .catch((err, caught) => caught)\n     *   .take(30)\n     *   .subscribe(x => console.log(x));\n     *   // 1, 2, 3, 1, 2, 3, ...\n     *\n     * @example <caption>Throws a new error when the source Observable throws an error</caption>\n     *\n     * Observable.of(1, 2, 3, 4, 5)\n     *   .map(n => {\n     *     if (n == 4) {\n     *       throw 'four!';\n     *     }\n     *     return n;\n     *   })\n     *   .catch(err => {\n     *     throw 'error in source. Details: ' + err;\n     *   })\n     *   .subscribe(\n     *     x => console.log(x),\n     *     err => console.log(err)\n     *   );\n     *   // 1, 2, 3, error in source. Details: four!\n     *\n     * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which\n     *  is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable\n     *  is returned by the `selector` will be used to continue the observable chain.\n     * @return {Observable} An observable that originates from either the source or the observable returned by the\n     *  catch `selector` function.\n     * @method catch\n     * @name catch\n     * @owner Observable\n     */\n    function _catch(selector) {\n        return catchError_1.catchError(selector)(this);\n    }\n    exports._catch = _catch;\n});\n\ndefine('rxjs/add/operator/catch',[\"require\", \"exports\", \"../../Observable\", \"../../operator/catch\"], function (require, exports, Observable_1, catch_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.catch = catch_1._catch;\n    Observable_1.Observable.prototype._catch = catch_1._catch;\n});\n\ndefine('rxjs/operator/combineAll',[\"require\", \"exports\", \"../operators/combineAll\"], function (require, exports, combineAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by waiting\n     * for the outer Observable to complete, then applying {@link combineLatest}.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by applying\n     * {@link combineLatest} when the Observable-of-Observables completes.</span>\n     *\n     * <img src=\"./img/combineAll.png\" width=\"100%\">\n     *\n     * Takes an Observable of Observables, and collects all Observables from it.\n     * Once the outer Observable completes, it subscribes to all collected\n     * Observables and combines their values using the {@link combineLatest}\n     * strategy, such that:\n     * - Every time an inner Observable emits, the output Observable emits.\n     * - When the returned observable emits, it emits all of the latest values by:\n     *   - If a `project` function is provided, it is called with each recent value\n     *     from each inner Observable in whatever order they arrived, and the result\n     *     of the `project` function is what is emitted by the output Observable.\n     *   - If there is no `project` function, an array of all of the most recent\n     *     values is emitted by the output Observable.\n     *\n     * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map(ev =>\n     *   Rx.Observable.interval(Math.random()*2000).take(3)\n     * ).take(2);\n     * var result = higherOrder.combineAll();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineLatest}\n     * @see {@link mergeAll}\n     *\n     * @param {function} [project] An optional function to map the most recent\n     * values from each inner Observable into a new result. Takes each of the most\n     * recent values from each collected inner Observable as arguments, in order.\n     * @return {Observable} An Observable of projected results or arrays of recent\n     * values.\n     * @method combineAll\n     * @owner Observable\n     */\n    function combineAll(project) {\n        return combineAll_1.combineAll(project)(this);\n    }\n    exports.combineAll = combineAll;\n});\n\ndefine('rxjs/add/operator/combineAll',[\"require\", \"exports\", \"../../Observable\", \"../../operator/combineAll\"], function (require, exports, Observable_1, combineAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.combineAll = combineAll_1.combineAll;\n});\n\ndefine('rxjs/operator/combineLatest',[\"require\", \"exports\", \"../operators/combineLatest\"], function (require, exports, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines multiple Observables to create an Observable whose values are\n     * calculated from the latest values of each of its input Observables.\n     *\n     * <span class=\"informal\">Whenever any input Observable emits a value, it\n     * computes a formula using the latest values from all the inputs, then emits\n     * the output of that formula.</span>\n     *\n     * <img src=\"./img/combineLatest.png\" width=\"100%\">\n     *\n     * `combineLatest` combines the values from this Observable with values from\n     * Observables passed as arguments. This is done by subscribing to each\n     * Observable, in order, and collecting an array of each of the most recent\n     * values any time any of the input Observables emits, then either taking that\n     * array and passing it as arguments to an optional `project` function and\n     * emitting the return value of that, or just emitting the array of recent\n     * values directly if there is no `project` function.\n     *\n     * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>\n     * var weight = Rx.Observable.of(70, 72, 76, 79, 75);\n     * var height = Rx.Observable.of(1.76, 1.77, 1.78);\n     * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));\n     * bmi.subscribe(x => console.log('BMI is ' + x));\n     *\n     * // With output to console:\n     * // BMI is 24.212293388429753\n     * // BMI is 23.93948099205209\n     * // BMI is 23.671253629592222\n     *\n     * @see {@link combineAll}\n     * @see {@link merge}\n     * @see {@link withLatestFrom}\n     *\n     * @param {ObservableInput} other An input Observable to combine with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {function} [project] An optional function to project the values from\n     * the combined latest values into a new value on the output Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @method combineLatest\n     * @owner Observable\n     */\n    function combineLatest() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return combineLatest_1.combineLatest.apply(void 0, observables)(this);\n    }\n    exports.combineLatest = combineLatest;\n});\n\ndefine('rxjs/add/operator/combineLatest',[\"require\", \"exports\", \"../../Observable\", \"../../operator/combineLatest\"], function (require, exports, Observable_1, combineLatest_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;\n});\n\ndefine('rxjs/operator/concat',[\"require\", \"exports\", \"../operators/concat\", \"../observable/concat\"], function (require, exports, concat_1, concat_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.concatStatic = concat_2.concat;\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which sequentially emits all values from every\n     * given input Observable after the current Observable.\n     *\n     * <span class=\"informal\">Concatenates multiple Observables together by\n     * sequentially emitting their values, one Observable after the other.</span>\n     *\n     * <img src=\"./img/concat.png\" width=\"100%\">\n     *\n     * Joins this Observable with multiple other Observables by subscribing to them\n     * one at a time, starting with the source, and merging their results into the\n     * output Observable. Will wait for each Observable to complete before moving\n     * on to the next.\n     *\n     * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>\n     * var timer = Rx.Observable.interval(1000).take(4);\n     * var sequence = Rx.Observable.range(1, 10);\n     * var result = timer.concat(sequence);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in:\n     * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n     *\n     * @example <caption>Concatenate 3 Observables</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var result = timer1.concat(timer2, timer3);\n     * result.subscribe(x => console.log(x));\n     *\n     * // results in the following:\n     * // (Prints to console sequentially)\n     * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n     * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n     * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n     *\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     *\n     * @param {ObservableInput} other An input Observable to concatenate after the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each\n     * Observable subscription on.\n     * @return {Observable} All values of each passed Observable merged into a\n     * single Observable, in order, in serial fashion.\n     * @method concat\n     * @owner Observable\n     */\n    function concat() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return concat_1.concat.apply(void 0, observables)(this);\n    }\n    exports.concat = concat;\n});\n\ndefine('rxjs/add/operator/concat',[\"require\", \"exports\", \"../../Observable\", \"../../operator/concat\"], function (require, exports, Observable_1, concat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.concat = concat_1.concat;\n});\n\ndefine('rxjs/operator/concatAll',[\"require\", \"exports\", \"../operators/concatAll\"], function (require, exports, concatAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Converts a higher-order Observable into a first-order Observable by\n     * concatenating the inner Observables in order.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n     * inner Observable after the other.</span>\n     *\n     * <img src=\"./img/concatAll.png\" width=\"100%\">\n     *\n     * Joins every Observable emitted by the source (a higher-order Observable), in\n     * a serial fashion. It subscribes to each inner Observable only after the\n     * previous inner Observable has completed, and merges all of their values into\n     * the returned observable.\n     *\n     * __Warning:__ If the source Observable emits Observables quickly and\n     * endlessly, and the inner Observables it emits generally complete slower than\n     * the source emits, you can run into memory issues as the incoming Observables\n     * collect in an unbounded buffer.\n     *\n     * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n     * to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));\n     * var firstOrder = higherOrder.concatAll();\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link combineAll}\n     * @see {@link concat}\n     * @see {@link concatMap}\n     * @see {@link concatMapTo}\n     * @see {@link exhaust}\n     * @see {@link mergeAll}\n     * @see {@link switch}\n     * @see {@link zipAll}\n     *\n     * @return {Observable} An Observable emitting values from all the inner\n     * Observables concatenated.\n     * @method concatAll\n     * @owner Observable\n     */\n    function concatAll() {\n        return concatAll_1.concatAll()(this);\n    }\n    exports.concatAll = concatAll;\n});\n\ndefine('rxjs/add/operator/concatAll',[\"require\", \"exports\", \"../../Observable\", \"../../operator/concatAll\"], function (require, exports, Observable_1, concatAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;\n});\n\ndefine('rxjs/operator/concatMap',[\"require\", \"exports\", \"../operators/concatMap\"], function (require, exports, concatMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable, in a serialized fashion waiting for each one to complete before\n     * merging the next.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link concatAll}.</span>\n     *\n     * <img src=\"./img/concatMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. Each new inner Observable is\n     * concatenated with the previous inner Observable.\n     *\n     * __Warning:__ if source values arrive endlessly and faster than their\n     * corresponding inner Observables can complete, it will result in memory issues\n     * as inner Observables amass in an unbounded buffer waiting for their turn to\n     * be subscribed to.\n     *\n     * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n     * to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link concat}\n     * @see {@link concatAll}\n     * @see {@link concatMapTo}\n     * @see {@link exhaustMap}\n     * @see {@link mergeMap}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and taking values from each projected inner\n     * Observable sequentially.\n     * @method concatMap\n     * @owner Observable\n     */\n    function concatMap(project, resultSelector) {\n        return concatMap_1.concatMap(project, resultSelector)(this);\n    }\n    exports.concatMap = concatMap;\n});\n\ndefine('rxjs/add/operator/concatMap',[\"require\", \"exports\", \"../../Observable\", \"../../operator/concatMap\"], function (require, exports, Observable_1, concatMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;\n});\n\ndefine('rxjs/operator/concatMapTo',[\"require\", \"exports\", \"../operators/concatMapTo\"], function (require, exports, concatMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is merged multiple\n     * times in a serialized fashion on the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link concatMap}, but maps each value\n     * always to the same inner Observable.</span>\n     *\n     * <img src=\"./img/concatMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then flattens those resulting Observables into one\n     * single Observable, which is the output Observable. Each new `innerObservable`\n     * instance emitted on the output Observable is concatenated with the previous\n     * `innerObservable` instance.\n     *\n     * __Warning:__ if source values arrive endlessly and faster than their\n     * corresponding inner Observables can complete, it will result in memory issues\n     * as inner Observables amass in an unbounded buffer waiting for their turn to\n     * be subscribed to.\n     *\n     * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter\n     * set to `1`.\n     *\n     * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // (results are not concurrent)\n     * // For every click on the \"document\" it will emit values 0 to 3 spaced\n     * // on a 1000ms interval\n     * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n     *\n     * @see {@link concat}\n     * @see {@link concatAll}\n     * @see {@link concatMap}\n     * @see {@link mergeMapTo}\n     * @see {@link switchMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An observable of values merged together by joining the\n     * passed observable with itself, one after the other, for each value emitted\n     * from the source.\n     * @method concatMapTo\n     * @owner Observable\n     */\n    function concatMapTo(innerObservable, resultSelector) {\n        return concatMapTo_1.concatMapTo(innerObservable, resultSelector)(this);\n    }\n    exports.concatMapTo = concatMapTo;\n});\n\ndefine('rxjs/add/operator/concatMapTo',[\"require\", \"exports\", \"../../Observable\", \"../../operator/concatMapTo\"], function (require, exports, Observable_1, concatMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;\n});\n\ndefine('rxjs/operator/count',[\"require\", \"exports\", \"../operators/count\"], function (require, exports, count_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Counts the number of emissions on the source and emits that number when the\n     * source completes.\n     *\n     * <span class=\"informal\">Tells how many values were emitted, when the source\n     * completes.</span>\n     *\n     * <img src=\"./img/count.png\" width=\"100%\">\n     *\n     * `count` transforms an Observable that emits values into an Observable that\n     * emits a single value that represents the number of values emitted by the\n     * source Observable. If the source Observable terminates with an error, `count`\n     * will pass this error notification along without emitting a value first. If\n     * the source Observable does not terminate at all, `count` will neither emit\n     * a value nor terminate. This operator takes an optional `predicate` function\n     * as argument, in which case the output emission will represent the number of\n     * source values that matched `true` with the `predicate`.\n     *\n     * @example <caption>Counts how many seconds have passed before the first click happened</caption>\n     * var seconds = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var secondsBeforeClick = seconds.takeUntil(clicks);\n     * var result = secondsBeforeClick.count();\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>\n     * var numbers = Rx.Observable.range(1, 7);\n     * var result = numbers.count(i => i % 2 === 1);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // 4\n     *\n     * @see {@link max}\n     * @see {@link min}\n     * @see {@link reduce}\n     *\n     * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A\n     * boolean function to select what values are to be counted. It is provided with\n     * arguments of:\n     * - `value`: the value from the source Observable.\n     * - `index`: the (zero-based) \"index\" of the value from the source Observable.\n     * - `source`: the source Observable instance itself.\n     * @return {Observable} An Observable of one number that represents the count as\n     * described above.\n     * @method count\n     * @owner Observable\n     */\n    function count(predicate) {\n        return count_1.count(predicate)(this);\n    }\n    exports.count = count;\n});\n\ndefine('rxjs/add/operator/count',[\"require\", \"exports\", \"../../Observable\", \"../../operator/count\"], function (require, exports, Observable_1, count_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.count = count_1.count;\n});\n\ndefine('rxjs/operator/dematerialize',[\"require\", \"exports\", \"../operators/dematerialize\"], function (require, exports, dematerialize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts an Observable of {@link Notification} objects into the emissions\n     * that they represent.\n     *\n     * <span class=\"informal\">Unwraps {@link Notification} objects as actual `next`,\n     * `error` and `complete` emissions. The opposite of {@link materialize}.</span>\n     *\n     * <img src=\"./img/dematerialize.png\" width=\"100%\">\n     *\n     * `dematerialize` is assumed to operate an Observable that only emits\n     * {@link Notification} objects as `next` emissions, and does not emit any\n     * `error`. Such Observable is the output of a `materialize` operation. Those\n     * notifications are then unwrapped using the metadata they contain, and emitted\n     * as `next`, `error`, and `complete` on the output Observable.\n     *\n     * Use this operator in conjunction with {@link materialize}.\n     *\n     * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>\n     * var notifA = new Rx.Notification('N', 'A');\n     * var notifB = new Rx.Notification('N', 'B');\n     * var notifE = new Rx.Notification('E', void 0,\n     *   new TypeError('x.toUpperCase is not a function')\n     * );\n     * var materialized = Rx.Observable.of(notifA, notifB, notifE);\n     * var upperCase = materialized.dematerialize();\n     * upperCase.subscribe(x => console.log(x), e => console.error(e));\n     *\n     * // Results in:\n     * // A\n     * // B\n     * // TypeError: x.toUpperCase is not a function\n     *\n     * @see {@link Notification}\n     * @see {@link materialize}\n     *\n     * @return {Observable} An Observable that emits items and notifications\n     * embedded in Notification objects emitted by the source Observable.\n     * @method dematerialize\n     * @owner Observable\n     */\n    function dematerialize() {\n        return dematerialize_1.dematerialize()(this);\n    }\n    exports.dematerialize = dematerialize;\n});\n\ndefine('rxjs/add/operator/dematerialize',[\"require\", \"exports\", \"../../Observable\", \"../../operator/dematerialize\"], function (require, exports, Observable_1, dematerialize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;\n});\n\ndefine('rxjs/operator/debounce',[\"require\", \"exports\", \"../operators/debounce\"], function (require, exports, debounce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable only after a particular time span\n     * determined by another Observable has passed without another source emission.\n     *\n     * <span class=\"informal\">It's like {@link debounceTime}, but the time span of\n     * emission silence is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/debounce.png\" width=\"100%\">\n     *\n     * `debounce` delays values emitted by the source Observable, but drops previous\n     * pending delayed emissions if a new value arrives on the source Observable.\n     * This operator keeps track of the most recent value from the source\n     * Observable, and spawns a duration Observable by calling the\n     * `durationSelector` function. The value is emitted only when the duration\n     * Observable emits a value or completes, and if no other value was emitted on\n     * the source Observable since the duration Observable was spawned. If a new\n     * value appears before the duration Observable emits, the previous value will\n     * be dropped and will not be emitted on the output Observable.\n     *\n     * Like {@link debounceTime}, this is a rate-limiting operator, and also a\n     * delay-like operator since output emissions do not necessarily occur at the\n     * same time as they did on the source Observable.\n     *\n     * @example <caption>Emit the most recent click after a burst of clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.debounce(() => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounceTime}\n     * @see {@link delayWhen}\n     * @see {@link throttle}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the timeout\n     * duration for each source value, returned as an Observable or a Promise.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified duration Observable returned by\n     * `durationSelector`, and may drop some values if they occur too frequently.\n     * @method debounce\n     * @owner Observable\n     */\n    function debounce(durationSelector) {\n        return debounce_1.debounce(durationSelector)(this);\n    }\n    exports.debounce = debounce;\n});\n\ndefine('rxjs/add/operator/debounce',[\"require\", \"exports\", \"../../Observable\", \"../../operator/debounce\"], function (require, exports, Observable_1, debounce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.debounce = debounce_1.debounce;\n});\n\ndefine('rxjs/operator/debounceTime',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/debounceTime\"], function (require, exports, async_1, debounceTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable only after a particular time span\n     * has passed without another source emission.\n     *\n     * <span class=\"informal\">It's like {@link delay}, but passes only the most\n     * recent value from each burst of emissions.</span>\n     *\n     * <img src=\"./img/debounceTime.png\" width=\"100%\">\n     *\n     * `debounceTime` delays values emitted by the source Observable, but drops\n     * previous pending delayed emissions if a new value arrives on the source\n     * Observable. This operator keeps track of the most recent value from the\n     * source Observable, and emits that only when `dueTime` enough time has passed\n     * without any other value appearing on the source Observable. If a new value\n     * appears before `dueTime` silence occurs, the previous value will be dropped\n     * and will not be emitted on the output Observable.\n     *\n     * This is a rate-limiting operator, because it is impossible for more than one\n     * value to be emitted in any time window of duration `dueTime`, but it is also\n     * a delay-like operator since output emissions do not occur at the same time as\n     * they did on the source Observable. Optionally takes a {@link IScheduler} for\n     * managing timers.\n     *\n     * @example <caption>Emit the most recent click after a burst of clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.debounceTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounce}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttleTime}\n     *\n     * @param {number} dueTime The timeout duration in milliseconds (or the time\n     * unit determined internally by the optional `scheduler`) for the window of\n     * time required to wait for emission silence before emitting the most recent\n     * source value.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the timeout for each value.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified `dueTime`, and may drop some values if they occur\n     * too frequently.\n     * @method debounceTime\n     * @owner Observable\n     */\n    function debounceTime(dueTime, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return debounceTime_1.debounceTime(dueTime, scheduler)(this);\n    }\n    exports.debounceTime = debounceTime;\n});\n\ndefine('rxjs/add/operator/debounceTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/debounceTime\"], function (require, exports, Observable_1, debounceTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;\n});\n\ndefine('rxjs/operator/defaultIfEmpty',[\"require\", \"exports\", \"../operators/defaultIfEmpty\"], function (require, exports, defaultIfEmpty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Emits a given value if the source Observable completes without emitting any\n     * `next` value, otherwise mirrors the source Observable.\n     *\n     * <span class=\"informal\">If the source Observable turns out to be empty, then\n     * this operator will emit a default value.</span>\n     *\n     * <img src=\"./img/defaultIfEmpty.png\" width=\"100%\">\n     *\n     * `defaultIfEmpty` emits the values emitted by the source Observable or a\n     * specified default value if the source Observable is empty (completes without\n     * having emitted any `next` value).\n     *\n     * @example <caption>If no clicks happen in 5 seconds, then emit \"no clicks\"</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));\n     * var result = clicksBeforeFive.defaultIfEmpty('no clicks');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link empty}\n     * @see {@link last}\n     *\n     * @param {any} [defaultValue=null] The default value used if the source\n     * Observable is empty.\n     * @return {Observable} An Observable that emits either the specified\n     * `defaultValue` if the source Observable emits no items, or the values emitted\n     * by the source Observable.\n     * @method defaultIfEmpty\n     * @owner Observable\n     */\n    function defaultIfEmpty(defaultValue) {\n        if (defaultValue === void 0) { defaultValue = null; }\n        return defaultIfEmpty_1.defaultIfEmpty(defaultValue)(this);\n    }\n    exports.defaultIfEmpty = defaultIfEmpty;\n});\n\ndefine('rxjs/add/operator/defaultIfEmpty',[\"require\", \"exports\", \"../../Observable\", \"../../operator/defaultIfEmpty\"], function (require, exports, Observable_1, defaultIfEmpty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;\n});\n\ndefine('rxjs/operator/delay',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/delay\"], function (require, exports, async_1, delay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Delays the emission of items from the source Observable by a given timeout or\n     * until a given Date.\n     *\n     * <span class=\"informal\">Time shifts each item by some specified amount of\n     * milliseconds.</span>\n     *\n     * <img src=\"./img/delay.png\" width=\"100%\">\n     *\n     * If the delay argument is a Number, this operator time shifts the source\n     * Observable by that amount of time expressed in milliseconds. The relative\n     * time intervals between the values are preserved.\n     *\n     * If the delay argument is a Date, this operator time shifts the start of the\n     * Observable execution until the given date occurs.\n     *\n     * @example <caption>Delay each click by one second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @example <caption>Delay all clicks until a future date happens</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var date = new Date('March 15, 2050 12:00:00'); // in the future\n     * var delayedClicks = clicks.delay(date); // click emitted only after that date\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @see {@link debounceTime}\n     * @see {@link delayWhen}\n     *\n     * @param {number|Date} delay The delay duration in milliseconds (a `number`) or\n     * a `Date` until which the emission of the source items is delayed.\n     * @param {Scheduler} [scheduler=async] The IScheduler to use for\n     * managing the timers that handle the time-shift for each item.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by the specified timeout or Date.\n     * @method delay\n     * @owner Observable\n     */\n    function delay(delay, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return delay_1.delay(delay, scheduler)(this);\n    }\n    exports.delay = delay;\n});\n\ndefine('rxjs/add/operator/delay',[\"require\", \"exports\", \"../../Observable\", \"../../operator/delay\"], function (require, exports, Observable_1, delay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.delay = delay_1.delay;\n});\n\ndefine('rxjs/operator/delayWhen',[\"require\", \"exports\", \"../operators/delayWhen\"], function (require, exports, delayWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Delays the emission of items from the source Observable by a given time span\n     * determined by the emissions of another Observable.\n     *\n     * <span class=\"informal\">It's like {@link delay}, but the time span of the\n     * delay duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/delayWhen.png\" width=\"100%\">\n     *\n     * `delayWhen` time shifts each emitted value from the source Observable by a\n     * time span determined by another Observable. When the source emits a value,\n     * the `delayDurationSelector` function is called with the source value as\n     * argument, and should return an Observable, called the \"duration\" Observable.\n     * The source value is emitted on the output Observable only when the duration\n     * Observable emits a value or completes.\n     *\n     * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n     * is an Observable. When `subscriptionDelay` emits its first value or\n     * completes, the source Observable is subscribed to and starts behaving like\n     * described in the previous paragraph. If `subscriptionDelay` is not provided,\n     * `delayWhen` will subscribe to the source Observable as soon as the output\n     * Observable is subscribed.\n     *\n     * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var delayedClicks = clicks.delayWhen(event =>\n     *   Rx.Observable.interval(Math.random() * 5000)\n     * );\n     * delayedClicks.subscribe(x => console.log(x));\n     *\n     * @see {@link debounce}\n     * @see {@link delay}\n     *\n     * @param {function(value: T): Observable} delayDurationSelector A function that\n     * returns an Observable for each value emitted by the source Observable, which\n     * is then used to delay the emission of that item on the output Observable\n     * until the Observable returned from this function emits a value.\n     * @param {Observable} subscriptionDelay An Observable that triggers the\n     * subscription to the source Observable once it emits any value.\n     * @return {Observable} An Observable that delays the emissions of the source\n     * Observable by an amount of time specified by the Observable returned by\n     * `delayDurationSelector`.\n     * @method delayWhen\n     * @owner Observable\n     */\n    function delayWhen(delayDurationSelector, subscriptionDelay) {\n        return delayWhen_1.delayWhen(delayDurationSelector, subscriptionDelay)(this);\n    }\n    exports.delayWhen = delayWhen;\n});\n\ndefine('rxjs/add/operator/delayWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/delayWhen\"], function (require, exports, Observable_1, delayWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;\n});\n\ndefine('rxjs/operator/distinct',[\"require\", \"exports\", \"../operators/distinct\"], function (require, exports, distinct_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.\n     *\n     * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will\n     * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the\n     * source observable directly with an equality check against previous values.\n     *\n     * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.\n     *\n     * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the\n     * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`\n     * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so\n     * that the internal `Set` can be \"flushed\", basically clearing it of values.\n     *\n     * @example <caption>A simple example with numbers</caption>\n     * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)\n     *   .distinct()\n     *   .subscribe(x => console.log(x)); // 1, 2, 3, 4\n     *\n     * @example <caption>An example using a keySelector function</caption>\n     * interface Person {\n     *    age: number,\n     *    name: string\n     * }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'})\n     *     .distinct((p: Person) => p.name)\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     *\n     * @see {@link distinctUntilChanged}\n     * @see {@link distinctUntilKeyChanged}\n     *\n     * @param {function} [keySelector] Optional function to select which value you want to check as distinct.\n     * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n     * @method distinct\n     * @owner Observable\n     */\n    function distinct(keySelector, flushes) {\n        return distinct_1.distinct(keySelector, flushes)(this);\n    }\n    exports.distinct = distinct;\n});\n\ndefine('rxjs/add/operator/distinct',[\"require\", \"exports\", \"../../Observable\", \"../../operator/distinct\"], function (require, exports, Observable_1, distinct_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.distinct = distinct_1.distinct;\n});\n\ndefine('rxjs/operator/distinctUntilChanged',[\"require\", \"exports\", \"../operators/distinctUntilChanged\"], function (require, exports, distinctUntilChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n     *\n     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n     *\n     * If a comparator function is not provided, an equality check is used by default.\n     *\n     * @example <caption>A simple example with numbers</caption>\n     * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n     *   .distinctUntilChanged()\n     *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4\n     *\n     * @example <caption>An example using a compare function</caption>\n     * interface Person {\n     *    age: number,\n     *    name: string\n     * }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'})\n     *     { age: 6, name: 'Foo'})\n     *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo' }\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilKeyChanged}\n     *\n     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values.\n     * @method distinctUntilChanged\n     * @owner Observable\n     */\n    function distinctUntilChanged(compare, keySelector) {\n        return distinctUntilChanged_1.distinctUntilChanged(compare, keySelector)(this);\n    }\n    exports.distinctUntilChanged = distinctUntilChanged;\n});\n\ndefine('rxjs/add/operator/distinctUntilChanged',[\"require\", \"exports\", \"../../Observable\", \"../../operator/distinctUntilChanged\"], function (require, exports, Observable_1, distinctUntilChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;\n});\n\ndefine('rxjs/operator/distinctUntilKeyChanged',[\"require\", \"exports\", \"../operators/distinctUntilKeyChanged\"], function (require, exports, distinctUntilKeyChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,\n     * using a property accessed by using the key provided to check if the two items are distinct.\n     *\n     * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n     *\n     * If a comparator function is not provided, an equality check is used by default.\n     *\n     * @example <caption>An example comparing the name of persons</caption>\n     *\n     *  interface Person {\n     *     age: number,\n     *     name: string\n     *  }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo'},\n     *     { age: 6, name: 'Foo'})\n     *     .distinctUntilKeyChanged('name')\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo' }\n     *\n     * @example <caption>An example comparing the first letters of the name</caption>\n     *\n     * interface Person {\n     *     age: number,\n     *     name: string\n     *  }\n     *\n     * Observable.of<Person>(\n     *     { age: 4, name: 'Foo1'},\n     *     { age: 7, name: 'Bar'},\n     *     { age: 5, name: 'Foo2'},\n     *     { age: 6, name: 'Foo3'})\n     *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))\n     *     .subscribe(x => console.log(x));\n     *\n     * // displays:\n     * // { age: 4, name: 'Foo1' }\n     * // { age: 7, name: 'Bar' }\n     * // { age: 5, name: 'Foo2' }\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilChanged}\n     *\n     * @param {string} key String key for object property lookup on each item.\n     * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.\n     * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.\n     * @method distinctUntilKeyChanged\n     * @owner Observable\n     */\n    function distinctUntilKeyChanged(key, compare) {\n        return distinctUntilKeyChanged_1.distinctUntilKeyChanged(key, compare)(this);\n    }\n    exports.distinctUntilKeyChanged = distinctUntilKeyChanged;\n});\n\ndefine('rxjs/add/operator/distinctUntilKeyChanged',[\"require\", \"exports\", \"../../Observable\", \"../../operator/distinctUntilKeyChanged\"], function (require, exports, Observable_1, distinctUntilKeyChanged_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;\n});\n\ndefine('rxjs/operator/do',[\"require\", \"exports\", \"../operators/tap\"], function (require, exports, tap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Perform a side effect for every emission on the source Observable, but return\n     * an Observable that is identical to the source.\n     *\n     * <span class=\"informal\">Intercepts each emission on the source and runs a\n     * function, but returns an output which is identical to the source as long as errors don't occur.</span>\n     *\n     * <img src=\"./img/do.png\" width=\"100%\">\n     *\n     * Returns a mirrored Observable of the source Observable, but modified so that\n     * the provided Observer is called to perform a side effect for every value,\n     * error, and completion emitted by the source. Any errors that are thrown in\n     * the aforementioned Observer or handlers are safely sent down the error path\n     * of the output Observable.\n     *\n     * This operator is useful for debugging your Observables for the correct values\n     * or performing other side effects.\n     *\n     * Note: this is different to a `subscribe` on the Observable. If the Observable\n     * returned by `do` is not subscribed, the side effects specified by the\n     * Observer will never happen. `do` therefore simply spies on existing\n     * execution, it does not trigger an execution to happen like `subscribe` does.\n     *\n     * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var positions = clicks\n     *   .do(ev => console.log(ev))\n     *   .map(ev => ev.clientX);\n     * positions.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     * @see {@link subscribe}\n     *\n     * @param {Observer|function} [nextOrObserver] A normal Observer object or a\n     * callback for `next`.\n     * @param {function} [error] Callback for errors in the source.\n     * @param {function} [complete] Callback for the completion of the source.\n     * @return {Observable} An Observable identical to the source, but runs the\n     * specified Observer or callback(s) for each item.\n     * @method do\n     * @name do\n     * @owner Observable\n     */\n    function _do(nextOrObserver, error, complete) {\n        return tap_1.tap(nextOrObserver, error, complete)(this);\n    }\n    exports._do = _do;\n});\n\ndefine('rxjs/add/operator/do',[\"require\", \"exports\", \"../../Observable\", \"../../operator/do\"], function (require, exports, Observable_1, do_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.do = do_1._do;\n    Observable_1.Observable.prototype._do = do_1._do;\n});\n\ndefine('rxjs/operator/exhaust',[\"require\", \"exports\", \"../operators/exhaust\"], function (require, exports, exhaust_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by dropping\n     * inner Observables while the previous inner Observable has not yet completed.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n     * next inner Observables while the current inner is still executing.</span>\n     *\n     * <img src=\"./img/exhaust.png\" width=\"100%\">\n     *\n     * `exhaust` subscribes to an Observable that emits Observables, also known as a\n     * higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, the output Observable begins emitting the items emitted by that\n     * inner Observable. So far, it behaves like {@link mergeAll}. However,\n     * `exhaust` ignores every new inner Observable if the previous Observable has\n     * not yet completed. Once that one completes, it will accept and flatten the\n     * next inner Observable and repeat this process.\n     *\n     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));\n     * var result = higherOrder.exhaust();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link switch}\n     * @see {@link mergeAll}\n     * @see {@link exhaustMap}\n     * @see {@link zipAll}\n     *\n     * @return {Observable} An Observable that takes a source of Observables and propagates the first observable\n     * exclusively until it completes before subscribing to the next.\n     * @method exhaust\n     * @owner Observable\n     */\n    function exhaust() {\n        return exhaust_1.exhaust()(this);\n    }\n    exports.exhaust = exhaust;\n});\n\ndefine('rxjs/add/operator/exhaust',[\"require\", \"exports\", \"../../Observable\", \"../../operator/exhaust\"], function (require, exports, Observable_1, exhaust_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.exhaust = exhaust_1.exhaust;\n});\n\ndefine('rxjs/operator/exhaustMap',[\"require\", \"exports\", \"../operators/exhaustMap\"], function (require, exports, exhaustMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable only if the previous projected Observable has completed.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link exhaust}.</span>\n     *\n     * <img src=\"./img/exhaustMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. When it projects a source value to\n     * an Observable, the output Observable begins emitting the items emitted by\n     * that projected Observable. However, `exhaustMap` ignores every new projected\n     * Observable if the previous projected Observable has not yet completed. Once\n     * that one completes, it will accept and flatten the next projected Observable\n     * and repeat this process.\n     *\n     * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaust}\n     * @see {@link mergeMap}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable containing projected Observables\n     * of each item of the source, ignoring projected Observables that start before\n     * their preceding Observable has completed.\n     * @method exhaustMap\n     * @owner Observable\n     */\n    function exhaustMap(project, resultSelector) {\n        return exhaustMap_1.exhaustMap(project, resultSelector)(this);\n    }\n    exports.exhaustMap = exhaustMap;\n});\n\ndefine('rxjs/add/operator/exhaustMap',[\"require\", \"exports\", \"../../Observable\", \"../../operator/exhaustMap\"], function (require, exports, Observable_1, exhaustMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;\n});\n\ndefine('rxjs/operator/expand',[\"require\", \"exports\", \"../operators/expand\"], function (require, exports, expand_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Recursively projects each source value to an Observable which is merged in\n     * the output Observable.\n     *\n     * <span class=\"informal\">It's similar to {@link mergeMap}, but applies the\n     * projection function to every source value as well as every output value.\n     * It's recursive.</span>\n     *\n     * <img src=\"./img/expand.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an Observable, and then merging those resulting Observables and\n     * emitting the results of this merger. *Expand* will re-emit on the output\n     * Observable every source value. Then, each output value is given to the\n     * `project` function which returns an inner Observable to be merged on the\n     * output Observable. Those output values resulting from the projection are also\n     * given to the `project` function to produce new output values. This is how\n     * *expand* behaves recursively.\n     *\n     * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var powersOfTwo = clicks\n     *   .mapTo(1)\n     *   .expand(x => Rx.Observable.of(2 * x).delay(1000))\n     *   .take(10);\n     * powersOfTwo.subscribe(x => console.log(x));\n     *\n     * @see {@link mergeMap}\n     * @see {@link mergeScan}\n     *\n     * @param {function(value: T, index: number) => Observable} project A function\n     * that, when applied to an item emitted by the source or the output Observable,\n     * returns an Observable.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to\n     * each projected inner Observable.\n     * @return {Observable} An Observable that emits the source values and also\n     * result of applying the projection function to each value emitted on the\n     * output Observable and and merging the results of the Observables obtained\n     * from this transformation.\n     * @method expand\n     * @owner Observable\n     */\n    function expand(project, concurrent, scheduler) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        if (scheduler === void 0) { scheduler = undefined; }\n        concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;\n        return expand_1.expand(project, concurrent, scheduler)(this);\n    }\n    exports.expand = expand;\n});\n\ndefine('rxjs/add/operator/expand',[\"require\", \"exports\", \"../../Observable\", \"../../operator/expand\"], function (require, exports, Observable_1, expand_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.expand = expand_1.expand;\n});\n\ndefine('rxjs/operator/elementAt',[\"require\", \"exports\", \"../operators/elementAt\"], function (require, exports, elementAt_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the single value at the specified `index` in a sequence of emissions\n     * from the source Observable.\n     *\n     * <span class=\"informal\">Emits only the i-th value, then completes.</span>\n     *\n     * <img src=\"./img/elementAt.png\" width=\"100%\">\n     *\n     * `elementAt` returns an Observable that emits the item at the specified\n     * `index` in the source Observable, or a default value if that `index` is out\n     * of range and the `default` argument is provided. If the `default` argument is\n     * not given and the `index` is out of range, the output Observable will emit an\n     * `ArgumentOutOfRangeError` error.\n     *\n     * @example <caption>Emit only the third click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.elementAt(2);\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // click 1 = nothing\n     * // click 2 = nothing\n     * // click 3 = MouseEvent object logged to console\n     *\n     * @see {@link first}\n     * @see {@link last}\n     * @see {@link skip}\n     * @see {@link single}\n     * @see {@link take}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the\n     * Observable has completed before emitting the i-th `next` notification.\n     *\n     * @param {number} index Is the number `i` for the i-th source emission that has\n     * happened since the subscription, starting from the number `0`.\n     * @param {T} [defaultValue] The default value returned for missing indices.\n     * @return {Observable} An Observable that emits a single item, if it is found.\n     * Otherwise, will emit the default value if given. If not, then emits an error.\n     * @method elementAt\n     * @owner Observable\n     */\n    function elementAt(index, defaultValue) {\n        return elementAt_1.elementAt(index, defaultValue)(this);\n    }\n    exports.elementAt = elementAt;\n});\n\ndefine('rxjs/add/operator/elementAt',[\"require\", \"exports\", \"../../Observable\", \"../../operator/elementAt\"], function (require, exports, Observable_1, elementAt_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.elementAt = elementAt_1.elementAt;\n});\n\ndefine('rxjs/operator/filter',[\"require\", \"exports\", \"../operators/filter\"], function (require, exports, filter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Filter items emitted by the source Observable by only emitting those that\n     * satisfy a specified predicate.\n     *\n     * <span class=\"informal\">Like\n     * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n     * it only emits a value from the source if it passes a criterion function.</span>\n     *\n     * <img src=\"./img/filter.png\" width=\"100%\">\n     *\n     * Similar to the well-known `Array.prototype.filter` method, this operator\n     * takes values from the source Observable, passes them through a `predicate`\n     * function and only emits those values that yielded `true`.\n     *\n     * @example <caption>Emit only click events whose target was a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');\n     * clicksOnDivs.subscribe(x => console.log(x));\n     *\n     * @see {@link distinct}\n     * @see {@link distinctUntilChanged}\n     * @see {@link distinctUntilKeyChanged}\n     * @see {@link ignoreElements}\n     * @see {@link partition}\n     * @see {@link skip}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates each value emitted by the source Observable. If it returns `true`,\n     * the value is emitted, if `false` the value is not passed to the output\n     * Observable. The `index` parameter is the number `i` for the i-th source\n     * emission that has happened since the subscription, starting from the number\n     * `0`.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable} An Observable of values from the source that were\n     * allowed by the `predicate` function.\n     * @method filter\n     * @owner Observable\n     */\n    function filter(predicate, thisArg) {\n        return filter_1.filter(predicate, thisArg)(this);\n    }\n    exports.filter = filter;\n});\n\ndefine('rxjs/add/operator/filter',[\"require\", \"exports\", \"../../Observable\", \"../../operator/filter\"], function (require, exports, Observable_1, filter_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.filter = filter_1.filter;\n});\n\ndefine('rxjs/operator/finally',[\"require\", \"exports\", \"../operators/finalize\"], function (require, exports, finalize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable, but will call a specified function when\n     * the source terminates on complete or error.\n     * @param {function} callback Function to be called when source terminates.\n     * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.\n     * @method finally\n     * @owner Observable\n     */\n    function _finally(callback) {\n        return finalize_1.finalize(callback)(this);\n    }\n    exports._finally = _finally;\n});\n\ndefine('rxjs/add/operator/finally',[\"require\", \"exports\", \"../../Observable\", \"../../operator/finally\"], function (require, exports, Observable_1, finally_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.finally = finally_1._finally;\n    Observable_1.Observable.prototype._finally = finally_1._finally;\n});\n\ndefine('rxjs/operator/find',[\"require\", \"exports\", \"../operators/find\"], function (require, exports, find_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Emits only the first value emitted by the source Observable that meets some\n     * condition.\n     *\n     * <span class=\"informal\">Finds the first value that passes some test and emits\n     * that.</span>\n     *\n     * <img src=\"./img/find.png\" width=\"100%\">\n     *\n     * `find` searches for the first item in the source Observable that matches the\n     * specified condition embodied by the `predicate`, and returns the first\n     * occurrence in the source. Unlike {@link first}, the `predicate` is required\n     * in `find`, and does not emit an error if a valid value is not found.\n     *\n     * @example <caption>Find and emit the first click that happens on a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.find(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link first}\n     * @see {@link findIndex}\n     * @see {@link take}\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n     * A function called with each item to test for condition matching.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable<T>} An Observable of the first item that matches the\n     * condition.\n     * @method find\n     * @owner Observable\n     */\n    function find(predicate, thisArg) {\n        return find_1.find(predicate, thisArg)(this);\n    }\n    exports.find = find;\n});\n\ndefine('rxjs/add/operator/find',[\"require\", \"exports\", \"../../Observable\", \"../../operator/find\"], function (require, exports, Observable_1, find_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.find = find_1.find;\n});\n\ndefine('rxjs/operator/findIndex',[\"require\", \"exports\", \"../operators/findIndex\"], function (require, exports, findIndex_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the index of the first value emitted by the source Observable that\n     * meets some condition.\n     *\n     * <span class=\"informal\">It's like {@link find}, but emits the index of the\n     * found value, not the value itself.</span>\n     *\n     * <img src=\"./img/findIndex.png\" width=\"100%\">\n     *\n     * `findIndex` searches for the first item in the source Observable that matches\n     * the specified condition embodied by the `predicate`, and returns the\n     * (zero-based) index of the first occurrence in the source. Unlike\n     * {@link first}, the `predicate` is required in `findIndex`, and does not emit\n     * an error if a valid value is not found.\n     *\n     * @example <caption>Emit the index of first click that happens on a DIV element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link find}\n     * @see {@link first}\n     * @see {@link take}\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate\n     * A function called with each item to test for condition matching.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {Observable} An Observable of the index of the first item that\n     * matches the condition.\n     * @method find\n     * @owner Observable\n     */\n    function findIndex(predicate, thisArg) {\n        return findIndex_1.findIndex(predicate, thisArg)(this);\n    }\n    exports.findIndex = findIndex;\n});\n\ndefine('rxjs/add/operator/findIndex',[\"require\", \"exports\", \"../../Observable\", \"../../operator/findIndex\"], function (require, exports, Observable_1, findIndex_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.findIndex = findIndex_1.findIndex;\n});\n\ndefine('rxjs/operator/first',[\"require\", \"exports\", \"../operators/first\"], function (require, exports, first_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first value (or the first value that meets some condition)\n     * emitted by the source Observable.\n     *\n     * <span class=\"informal\">Emits only the first value. Or emits only the first\n     * value that passes some test.</span>\n     *\n     * <img src=\"./img/first.png\" width=\"100%\">\n     *\n     * If called with no arguments, `first` emits the first value of the source\n     * Observable, then completes. If called with a `predicate` function, `first`\n     * emits the first value of the source that matches the specified condition. It\n     * may also take a `resultSelector` function to produce the output value from\n     * the input value, and a `defaultValue` to emit in case the source completes\n     * before it is able to emit a valid value. Throws an error if `defaultValue`\n     * was not provided and a matching element is not found.\n     *\n     * @example <caption>Emit only the first click that happens on the DOM</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.first();\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Emits the first click that happens on a DIV</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.first(ev => ev.target.tagName === 'DIV');\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link filter}\n     * @see {@link find}\n     * @see {@link take}\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     *\n     * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]\n     * An optional function called with each item to test for condition matching.\n     * @param {function(value: T, index: number): R} [resultSelector] A function to\n     * produce the value on the output Observable based on the values\n     * and the indices of the source Observable. The arguments passed to this\n     * function are:\n     * - `value`: the value that was emitted on the source.\n     * - `index`: the \"index\" of the value from the source.\n     * @param {R} [defaultValue] The default value emitted in case no valid value\n     * was found on the source.\n     * @return {Observable<T|R>} An Observable of the first item that matches the\n     * condition.\n     * @method first\n     * @owner Observable\n     */\n    function first(predicate, resultSelector, defaultValue) {\n        return first_1.first(predicate, resultSelector, defaultValue)(this);\n    }\n    exports.first = first;\n});\n\ndefine('rxjs/add/operator/first',[\"require\", \"exports\", \"../../Observable\", \"../../operator/first\"], function (require, exports, Observable_1, first_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.first = first_1.first;\n});\n\ndefine('rxjs/operator/groupBy',[\"require\", \"exports\", \"../operators/groupBy\"], function (require, exports, groupBy_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.GroupedObservable = groupBy_1.GroupedObservable;\n    /* tslint:enable:max-line-length */\n    /**\n     * Groups the items emitted by an Observable according to a specified criterion,\n     * and emits these grouped items as `GroupedObservables`, one\n     * {@link GroupedObservable} per group.\n     *\n     * <img src=\"./img/groupBy.png\" width=\"100%\">\n     *\n     * @example <caption>Group objects by id and return as array</caption>\n     * Observable.of<Obj>({id: 1, name: 'aze1'},\n     *                    {id: 2, name: 'sf2'},\n     *                    {id: 2, name: 'dg2'},\n     *                    {id: 1, name: 'erg1'},\n     *                    {id: 1, name: 'df1'},\n     *                    {id: 2, name: 'sfqfb2'},\n     *                    {id: 3, name: 'qfs3'},\n     *                    {id: 2, name: 'qsgqsfg2'}\n     *     )\n     *     .groupBy(p => p.id)\n     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n     *     .subscribe(p => console.log(p));\n     *\n     * // displays:\n     * // [ { id: 1, name: 'aze1' },\n     * //   { id: 1, name: 'erg1' },\n     * //   { id: 1, name: 'df1' } ]\n     * //\n     * // [ { id: 2, name: 'sf2' },\n     * //   { id: 2, name: 'dg2' },\n     * //   { id: 2, name: 'sfqfb2' },\n     * //   { id: 2, name: 'qsgqsfg2' } ]\n     * //\n     * // [ { id: 3, name: 'qfs3' } ]\n     *\n     * @example <caption>Pivot data on the id field</caption>\n     * Observable.of<Obj>({id: 1, name: 'aze1'},\n     *                    {id: 2, name: 'sf2'},\n     *                    {id: 2, name: 'dg2'},\n     *                    {id: 1, name: 'erg1'},\n     *                    {id: 1, name: 'df1'},\n     *                    {id: 2, name: 'sfqfb2'},\n     *                    {id: 3, name: 'qfs1'},\n     *                    {id: 2, name: 'qsgqsfg2'}\n     *                   )\n     *     .groupBy(p => p.id, p => p.name)\n     *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n     *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n     *     .subscribe(p => console.log(p));\n     *\n     * // displays:\n     * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n     * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n     * // { id: 3, values: [ 'qfs1' ] }\n     *\n     * @param {function(value: T): K} keySelector A function that extracts the key\n     * for each item.\n     * @param {function(value: T): R} [elementSelector] A function that extracts the\n     * return element for each item.\n     * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]\n     * A function that returns an Observable to determine how long each group should\n     * exist.\n     * @return {Observable<GroupedObservable<K,R>>} An Observable that emits\n     * GroupedObservables, each of which corresponds to a unique key value and each\n     * of which emits those items from the source Observable that share that key\n     * value.\n     * @method groupBy\n     * @owner Observable\n     */\n    function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {\n        return groupBy_1.groupBy(keySelector, elementSelector, durationSelector, subjectSelector)(this);\n    }\n    exports.groupBy = groupBy;\n});\n\ndefine('rxjs/add/operator/groupBy',[\"require\", \"exports\", \"../../Observable\", \"../../operator/groupBy\"], function (require, exports, Observable_1, groupBy_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.groupBy = groupBy_1.groupBy;\n});\n\ndefine('rxjs/operator/ignoreElements',[\"require\", \"exports\", \"../operators/ignoreElements\"], function (require, exports, ignoreElements_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n     *\n     * <img src=\"./img/ignoreElements.png\" width=\"100%\">\n     *\n     * @return {Observable} An empty Observable that only calls `complete`\n     * or `error`, based on which one is called by the source Observable.\n     * @method ignoreElements\n     * @owner Observable\n     */\n    function ignoreElements() {\n        return ignoreElements_1.ignoreElements()(this);\n    }\n    exports.ignoreElements = ignoreElements;\n    ;\n});\n\ndefine('rxjs/add/operator/ignoreElements',[\"require\", \"exports\", \"../../Observable\", \"../../operator/ignoreElements\"], function (require, exports, Observable_1, ignoreElements_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;\n});\n\ndefine('rxjs/operator/isEmpty',[\"require\", \"exports\", \"../operators/isEmpty\"], function (require, exports, isEmpty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.\n     *\n     * <img src=\"./img/isEmpty.png\" width=\"100%\">\n     *\n     * @return {Observable} An Observable that emits a Boolean.\n     * @method isEmpty\n     * @owner Observable\n     */\n    function isEmpty() {\n        return isEmpty_1.isEmpty()(this);\n    }\n    exports.isEmpty = isEmpty;\n});\n\ndefine('rxjs/add/operator/isEmpty',[\"require\", \"exports\", \"../../Observable\", \"../../operator/isEmpty\"], function (require, exports, Observable_1, isEmpty_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;\n});\n\ndefine('rxjs/operator/audit',[\"require\", \"exports\", \"../operators/audit\"], function (require, exports, audit_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores source values for a duration determined by another Observable, then\n     * emits the most recent value from the source Observable, then repeats this\n     * process.\n     *\n     * <span class=\"informal\">It's like {@link auditTime}, but the silencing\n     * duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/audit.png\" width=\"100%\">\n     *\n     * `audit` is similar to `throttle`, but emits the last value from the silenced\n     * time window, instead of the first value. `audit` emits the most recent value\n     * from the source Observable on the output Observable as soon as its internal\n     * timer becomes disabled, and ignores source values while the timer is enabled.\n     * Initially, the timer is disabled. As soon as the first source value arrives,\n     * the timer is enabled by calling the `durationSelector` function with the\n     * source value, which returns the \"duration\" Observable. When the duration\n     * Observable emits a value or completes, the timer is disabled, then the most\n     * recent source value is emitted on the output Observable, and this process\n     * repeats for the next source value.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.audit(ev => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounce}\n     * @see {@link delayWhen}\n     * @see {@link sample}\n     * @see {@link throttle}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the silencing\n     * duration, returned as an Observable or a Promise.\n     * @return {Observable<T>} An Observable that performs rate-limiting of\n     * emissions from the source Observable.\n     * @method audit\n     * @owner Observable\n     */\n    function audit(durationSelector) {\n        return audit_1.audit(durationSelector)(this);\n    }\n    exports.audit = audit;\n});\n\ndefine('rxjs/add/operator/audit',[\"require\", \"exports\", \"../../Observable\", \"../../operator/audit\"], function (require, exports, Observable_1, audit_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.audit = audit_1.audit;\n});\n\ndefine('rxjs/operator/auditTime',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/auditTime\"], function (require, exports, async_1, auditTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Ignores source values for `duration` milliseconds, then emits the most recent\n     * value from the source Observable, then repeats this process.\n     *\n     * <span class=\"informal\">When it sees a source values, it ignores that plus\n     * the next ones for `duration` milliseconds, and then it emits the most recent\n     * value from the source.</span>\n     *\n     * <img src=\"./img/auditTime.png\" width=\"100%\">\n     *\n     * `auditTime` is similar to `throttleTime`, but emits the last value from the\n     * silenced time window, instead of the first value. `auditTime` emits the most\n     * recent value from the source Observable on the output Observable as soon as\n     * its internal timer becomes disabled, and ignores source values while the\n     * timer is enabled. Initially, the timer is disabled. As soon as the first\n     * source value arrives, the timer is enabled. After `duration` milliseconds (or\n     * the time unit determined internally by the optional `scheduler`) has passed,\n     * the timer is disabled, then the most recent source value is emitted on the\n     * output Observable, and this process repeats for the next source value.\n     * Optionally takes a {@link IScheduler} for managing timers.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.auditTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttleTime}\n     *\n     * @param {number} duration Time to wait before emitting the most recent source\n     * value, measured in milliseconds or the time unit determined internally\n     * by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the rate-limiting behavior.\n     * @return {Observable<T>} An Observable that performs rate-limiting of\n     * emissions from the source Observable.\n     * @method auditTime\n     * @owner Observable\n     */\n    function auditTime(duration, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return auditTime_1.auditTime(duration, scheduler)(this);\n    }\n    exports.auditTime = auditTime;\n});\n\ndefine('rxjs/add/operator/auditTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/auditTime\"], function (require, exports, Observable_1, auditTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.auditTime = auditTime_1.auditTime;\n});\n\ndefine('rxjs/operator/last',[\"require\", \"exports\", \"../operators/last\"], function (require, exports, last_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits only the last item emitted by the source Observable.\n     * It optionally takes a predicate function as a parameter, in which case, rather than emitting\n     * the last item from the source Observable, the resulting Observable will emit the last item\n     * from the source Observable that satisfies the predicate.\n     *\n     * <img src=\"./img/last.png\" width=\"100%\">\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     * @param {function} predicate - The condition any source emitted item has to satisfy.\n     * @return {Observable} An Observable that emits only the last item satisfying the given condition\n     * from the source, or an NoSuchElementException if no such items are emitted.\n     * @throws - Throws if no items that match the predicate are emitted by the source Observable.\n     * @method last\n     * @owner Observable\n     */\n    function last(predicate, resultSelector, defaultValue) {\n        return last_1.last(predicate, resultSelector, defaultValue)(this);\n    }\n    exports.last = last;\n});\n\ndefine('rxjs/add/operator/last',[\"require\", \"exports\", \"../../Observable\", \"../../operator/last\"], function (require, exports, Observable_1, last_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.last = last_1.last;\n});\n\ndefine('rxjs/operator/let',[\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param func\n     * @return {Observable<R>}\n     * @method let\n     * @owner Observable\n     */\n    function letProto(func) {\n        return func(this);\n    }\n    exports.letProto = letProto;\n});\n\ndefine('rxjs/add/operator/let',[\"require\", \"exports\", \"../../Observable\", \"../../operator/let\"], function (require, exports, Observable_1, let_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.let = let_1.letProto;\n    Observable_1.Observable.prototype.letBind = let_1.letProto;\n});\n\ndefine('rxjs/operator/every',[\"require\", \"exports\", \"../operators/every\"], function (require, exports, every_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.\n     *\n     * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>\n     *  Observable.of(1, 2, 3, 4, 5, 6)\n     *     .every(x => x < 5)\n     *     .subscribe(x => console.log(x)); // -> false\n     *\n     * @param {function} predicate A function for determining if an item meets a specified condition.\n     * @param {any} [thisArg] Optional object to use for `this` in the callback.\n     * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.\n     * @method every\n     * @owner Observable\n     */\n    function every(predicate, thisArg) {\n        return every_1.every(predicate, thisArg)(this);\n    }\n    exports.every = every;\n});\n\ndefine('rxjs/add/operator/every',[\"require\", \"exports\", \"../../Observable\", \"../../operator/every\"], function (require, exports, Observable_1, every_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.every = every_1.every;\n});\n\ndefine('rxjs/operator/map',[\"require\", \"exports\", \"../operators/map\"], function (require, exports, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Applies a given `project` function to each value emitted by the source\n     * Observable, and emits the resulting values as an Observable.\n     *\n     * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n     * it passes each source value through a transformation function to get\n     * corresponding output values.</span>\n     *\n     * <img src=\"./img/map.png\" width=\"100%\">\n     *\n     * Similar to the well known `Array.prototype.map` function, this operator\n     * applies a projection to each value and emits that projection in the output\n     * Observable.\n     *\n     * @example <caption>Map every click to the clientX position of that click</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var positions = clicks.map(ev => ev.clientX);\n     * positions.subscribe(x => console.log(x));\n     *\n     * @see {@link mapTo}\n     * @see {@link pluck}\n     *\n     * @param {function(value: T, index: number): R} project The function to apply\n     * to each `value` emitted by the source Observable. The `index` parameter is\n     * the number `i` for the i-th emission that has happened since the\n     * subscription, starting from the number `0`.\n     * @param {any} [thisArg] An optional argument to define what `this` is in the\n     * `project` function.\n     * @return {Observable<R>} An Observable that emits the values from the source\n     * Observable transformed by the given `project` function.\n     * @method map\n     * @owner Observable\n     */\n    function map(project, thisArg) {\n        return map_1.map(project, thisArg)(this);\n    }\n    exports.map = map;\n});\n\ndefine('rxjs/add/operator/map',[\"require\", \"exports\", \"../../Observable\", \"../../operator/map\"], function (require, exports, Observable_1, map_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.map = map_1.map;\n});\n\ndefine('rxjs/operator/mapTo',[\"require\", \"exports\", \"../operators/mapTo\"], function (require, exports, mapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the given constant value on the output Observable every time the source\n     * Observable emits a value.\n     *\n     * <span class=\"informal\">Like {@link map}, but it maps every source value to\n     * the same output value every time.</span>\n     *\n     * <img src=\"./img/mapTo.png\" width=\"100%\">\n     *\n     * Takes a constant `value` as argument, and emits that whenever the source\n     * Observable emits a value. In other words, ignores the actual source value,\n     * and simply uses the emission moment to know when to emit the given `value`.\n     *\n     * @example <caption>Map every click to the string 'Hi'</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var greetings = clicks.mapTo('Hi');\n     * greetings.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     *\n     * @param {any} value The value to map each source value to.\n     * @return {Observable} An Observable that emits the given `value` every time\n     * the source Observable emits something.\n     * @method mapTo\n     * @owner Observable\n     */\n    function mapTo(value) {\n        return mapTo_1.mapTo(value)(this);\n    }\n    exports.mapTo = mapTo;\n});\n\ndefine('rxjs/add/operator/mapTo',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mapTo\"], function (require, exports, Observable_1, mapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;\n});\n\ndefine('rxjs/operator/materialize',[\"require\", \"exports\", \"../operators/materialize\"], function (require, exports, materialize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Represents all of the notifications from the source Observable as `next`\n     * emissions marked with their original types within {@link Notification}\n     * objects.\n     *\n     * <span class=\"informal\">Wraps `next`, `error` and `complete` emissions in\n     * {@link Notification} objects, emitted as `next` on the output Observable.\n     * </span>\n     *\n     * <img src=\"./img/materialize.png\" width=\"100%\">\n     *\n     * `materialize` returns an Observable that emits a `next` notification for each\n     * `next`, `error`, or `complete` emission of the source Observable. When the\n     * source Observable emits `complete`, the output Observable will emit `next` as\n     * a Notification of type \"complete\", and then it will emit `complete` as well.\n     * When the source Observable emits `error`, the output will emit `next` as a\n     * Notification of type \"error\", and then `complete`.\n     *\n     * This operator is useful for producing metadata of the source Observable, to\n     * be consumed as `next` emissions. Use it in conjunction with\n     * {@link dematerialize}.\n     *\n     * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>\n     * var letters = Rx.Observable.of('a', 'b', 13, 'd');\n     * var upperCase = letters.map(x => x.toUpperCase());\n     * var materialized = upperCase.materialize();\n     * materialized.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // - Notification {kind: \"N\", value: \"A\", error: undefined, hasValue: true}\n     * // - Notification {kind: \"N\", value: \"B\", error: undefined, hasValue: true}\n     * // - Notification {kind: \"E\", value: undefined, error: TypeError:\n     * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x\n     * //   [as project] (http://1…, hasValue: false}\n     *\n     * @see {@link Notification}\n     * @see {@link dematerialize}\n     *\n     * @return {Observable<Notification<T>>} An Observable that emits\n     * {@link Notification} objects that wrap the original emissions from the source\n     * Observable with metadata.\n     * @method materialize\n     * @owner Observable\n     */\n    function materialize() {\n        return materialize_1.materialize()(this);\n    }\n    exports.materialize = materialize;\n});\n\ndefine('rxjs/add/operator/materialize',[\"require\", \"exports\", \"../../Observable\", \"../../operator/materialize\"], function (require, exports, Observable_1, materialize_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.materialize = materialize_1.materialize;\n});\n\ndefine('rxjs/operator/max',[\"require\", \"exports\", \"../operators/max\"], function (require, exports, max_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n     * and when source Observable completes it emits a single item: the item with the largest value.\n     *\n     * <img src=\"./img/max.png\" width=\"100%\">\n     *\n     * @example <caption>Get the maximal value of a series of numbers</caption>\n     * Rx.Observable.of(5, 4, 7, 2, 8)\n     *   .max()\n     *   .subscribe(x => console.log(x)); // -> 8\n     *\n     * @example <caption>Use a comparer function to get the maximal item</caption>\n     * interface Person {\n     *   age: number,\n     *   name: string\n     * }\n     * Observable.of<Person>({age: 7, name: 'Foo'},\n     *                       {age: 5, name: 'Bar'},\n     *                       {age: 9, name: 'Beer'})\n     *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)\n     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'\n     * }\n     *\n     * @see {@link min}\n     *\n     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n     * value of two items.\n     * @return {Observable} An Observable that emits item with the largest value.\n     * @method max\n     * @owner Observable\n     */\n    function max(comparer) {\n        return max_1.max(comparer)(this);\n    }\n    exports.max = max;\n});\n\ndefine('rxjs/add/operator/max',[\"require\", \"exports\", \"../../Observable\", \"../../operator/max\"], function (require, exports, Observable_1, max_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.max = max_1.max;\n});\n\ndefine('rxjs/operator/merge',[\"require\", \"exports\", \"../operators/merge\", \"../observable/merge\"], function (require, exports, merge_1, merge_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.mergeStatic = merge_2.merge;\n    /* tslint:enable:max-line-length */\n    /**\n     * Creates an output Observable which concurrently emits all values from every\n     * given input Observable.\n     *\n     * <span class=\"informal\">Flattens multiple Observables together by blending\n     * their values into one Observable.</span>\n     *\n     * <img src=\"./img/merge.png\" width=\"100%\">\n     *\n     * `merge` subscribes to each given input Observable (either the source or an\n     * Observable given as argument), and simply forwards (without doing any\n     * transformation) all the values from all the input Observables to the output\n     * Observable. The output Observable only completes once all input Observables\n     * have completed. Any error delivered by an input Observable will be immediately\n     * emitted on the output Observable.\n     *\n     * @example <caption>Merge together two Observables: 1s interval and clicks</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var clicksOrTimer = clicks.merge(timer);\n     * clicksOrTimer.subscribe(x => console.log(x));\n     *\n     * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>\n     * var timer1 = Rx.Observable.interval(1000).take(10);\n     * var timer2 = Rx.Observable.interval(2000).take(6);\n     * var timer3 = Rx.Observable.interval(500).take(10);\n     * var concurrent = 2; // the argument\n     * var merged = timer1.merge(timer2, timer3, concurrent);\n     * merged.subscribe(x => console.log(x));\n     *\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     *\n     * @param {ObservableInput} other An input Observable to merge with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @param {Scheduler} [scheduler=null] The IScheduler to use for managing\n     * concurrency of input Observables.\n     * @return {Observable} An Observable that emits items that are the result of\n     * every input Observable.\n     * @method merge\n     * @owner Observable\n     */\n    function merge() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return merge_1.merge.apply(void 0, observables)(this);\n    }\n    exports.merge = merge;\n});\n\ndefine('rxjs/add/operator/merge',[\"require\", \"exports\", \"../../Observable\", \"../../operator/merge\"], function (require, exports, Observable_1, merge_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.merge = merge_1.merge;\n});\n\ndefine('rxjs/operator/mergeAll',[\"require\", \"exports\", \"../operators/mergeAll\"], function (require, exports, mergeAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable which\n     * concurrently delivers all values that are emitted on the inner Observables.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n     *\n     * <img src=\"./img/mergeAll.png\" width=\"100%\">\n     *\n     * `mergeAll` subscribes to an Observable that emits Observables, also known as\n     * a higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, it subscribes to that and delivers all the values from the\n     * inner Observable on the output Observable. The output Observable only\n     * completes once all inner Observables have completed. Any error delivered by\n     * a inner Observable will be immediately emitted on the output Observable.\n     *\n     * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n     * var firstOrder = higherOrder.mergeAll();\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));\n     * var firstOrder = higherOrder.mergeAll(2);\n     * firstOrder.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link exhaust}\n     * @see {@link merge}\n     * @see {@link mergeMap}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     * @see {@link switch}\n     * @see {@link zipAll}\n     *\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits values coming from all the\n     * inner Observables emitted by the source Observable.\n     * @method mergeAll\n     * @owner Observable\n     */\n    function mergeAll(concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeAll_1.mergeAll(concurrent)(this);\n    }\n    exports.mergeAll = mergeAll;\n});\n\ndefine('rxjs/add/operator/mergeAll',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mergeAll\"], function (require, exports, Observable_1, mergeAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;\n});\n\ndefine('rxjs/operator/mergeMap',[\"require\", \"exports\", \"../operators/mergeMap\"], function (require, exports, mergeMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link mergeAll}.</span>\n     *\n     * <img src=\"./img/mergeMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an Observable, and then merging those resulting Observables and\n     * emitting the results of this merger.\n     *\n     * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>\n     * var letters = Rx.Observable.of('a', 'b', 'c');\n     * var result = letters.mergeMap(x =>\n     *   Rx.Observable.interval(1000).map(i => x+i)\n     * );\n     * result.subscribe(x => console.log(x));\n     *\n     * // Results in the following:\n     * // a0\n     * // b0\n     * // c0\n     * // a1\n     * // b1\n     * // c1\n     * // continues to list a,b,c with respective ascending integers\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaustMap}\n     * @see {@link merge}\n     * @see {@link mergeAll}\n     * @see {@link mergeMapTo}\n     * @see {@link mergeScan}\n     * @see {@link switchMap}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and merging the results of the Observables obtained\n     * from this transformation.\n     * @method mergeMap\n     * @owner Observable\n     */\n    function mergeMap(project, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeMap_1.mergeMap(project, resultSelector, concurrent)(this);\n    }\n    exports.mergeMap = mergeMap;\n});\n\ndefine('rxjs/add/operator/mergeMap',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mergeMap\"], function (require, exports, Observable_1, mergeMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;\n    Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;\n});\n\ndefine('rxjs/operator/mergeMapTo',[\"require\", \"exports\", \"../operators/mergeMapTo\"], function (require, exports, mergeMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is merged multiple\n     * times in the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link mergeMap}, but maps each value always\n     * to the same inner Observable.</span>\n     *\n     * <img src=\"./img/mergeMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then merges those resulting Observables into one\n     * single Observable, which is the output Observable.\n     *\n     * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMapTo}\n     * @see {@link merge}\n     * @see {@link mergeAll}\n     * @see {@link mergeMap}\n     * @see {@link mergeScan}\n     * @see {@link switchMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input\n     * Observables being subscribed to concurrently.\n     * @return {Observable} An Observable that emits items from the given\n     * `innerObservable` (and optionally transformed through `resultSelector`) every\n     * time a value is emitted on the source Observable.\n     * @method mergeMapTo\n     * @owner Observable\n     */\n    function mergeMapTo(innerObservable, resultSelector, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeMapTo_1.mergeMapTo(innerObservable, resultSelector, concurrent)(this);\n    }\n    exports.mergeMapTo = mergeMapTo;\n});\n\ndefine('rxjs/add/operator/mergeMapTo',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mergeMapTo\"], function (require, exports, Observable_1, mergeMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;\n    Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;\n});\n\ndefine('rxjs/operator/mergeScan',[\"require\", \"exports\", \"../operators/mergeScan\"], function (require, exports, mergeScan_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Applies an accumulator function over the source Observable where the\n     * accumulator function itself returns an Observable, then each intermediate\n     * Observable returned is merged into the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link scan}, but the Observables returned\n     * by the accumulator are merged into the outer Observable.</span>\n     *\n     * @example <caption>Count the number of click events</caption>\n     * const click$ = Rx.Observable.fromEvent(document, 'click');\n     * const one$ = click$.mapTo(1);\n     * const seed = 0;\n     * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);\n     * count$.subscribe(x => console.log(x));\n     *\n     * // Results:\n     * 1\n     * 2\n     * 3\n     * 4\n     * // ...and so on for each click\n     *\n     * @param {function(acc: R, value: T): Observable<R>} accumulator\n     * The accumulator function called on each source value.\n     * @param seed The initial accumulation value.\n     * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of\n     * input Observables being subscribed to concurrently.\n     * @return {Observable<R>} An observable of the accumulated values.\n     * @method mergeScan\n     * @owner Observable\n     */\n    function mergeScan(accumulator, seed, concurrent) {\n        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }\n        return mergeScan_1.mergeScan(accumulator, seed, concurrent)(this);\n    }\n    exports.mergeScan = mergeScan;\n});\n\ndefine('rxjs/add/operator/mergeScan',[\"require\", \"exports\", \"../../Observable\", \"../../operator/mergeScan\"], function (require, exports, Observable_1, mergeScan_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;\n});\n\ndefine('rxjs/operator/min',[\"require\", \"exports\", \"../operators/min\"], function (require, exports, min_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),\n     * and when source Observable completes it emits a single item: the item with the smallest value.\n     *\n     * <img src=\"./img/min.png\" width=\"100%\">\n     *\n     * @example <caption>Get the minimal value of a series of numbers</caption>\n     * Rx.Observable.of(5, 4, 7, 2, 8)\n     *   .min()\n     *   .subscribe(x => console.log(x)); // -> 2\n     *\n     * @example <caption>Use a comparer function to get the minimal item</caption>\n     * interface Person {\n     *   age: number,\n     *   name: string\n     * }\n     * Observable.of<Person>({age: 7, name: 'Foo'},\n     *                       {age: 5, name: 'Bar'},\n     *                       {age: 9, name: 'Beer'})\n     *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)\n     *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'\n     * }\n     *\n     * @see {@link max}\n     *\n     * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the\n     * value of two items.\n     * @return {Observable<R>} An Observable that emits item with the smallest value.\n     * @method min\n     * @owner Observable\n     */\n    function min(comparer) {\n        return min_1.min(comparer)(this);\n    }\n    exports.min = min;\n});\n\ndefine('rxjs/add/operator/min',[\"require\", \"exports\", \"../../Observable\", \"../../operator/min\"], function (require, exports, Observable_1, min_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.min = min_1.min;\n});\n\ndefine('rxjs/operator/multicast',[\"require\", \"exports\", \"../operators/multicast\"], function (require, exports, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Allows source Observable to be subscribed only once with a Subject of choice,\n     * while still sharing its values between multiple subscribers.\n     *\n     * <span class=\"informal\">Subscribe to Observable once, but send its values to multiple subscribers.</span>\n     *\n     * <img src=\"./img/multicast.png\" width=\"100%\">\n     *\n     * `multicast` is an operator that works in two modes.\n     *\n     * In the first mode you provide a single argument to it, which can be either an initialized Subject or a Subject\n     * factory. As a result you will get a special kind of an Observable - a {@link ConnectableObservable}. It can be\n     * subscribed multiple times, just as regular Observable, but it won't subscribe to the source Observable at that\n     * moment. It will do it only if you call its `connect` method. This means you can essentially control by hand, when\n     * source Observable will be actually subscribed. What is more, ConnectableObservable will share this one subscription\n     * between all of its subscribers. This means that, for example, `ajax` Observable will only send a request once,\n     * even though usually it would send a request per every subscriber. Since it sends a request at the moment of\n     * subscription, here request would be sent when the `connect` method of a ConnectableObservable is called.\n     *\n     * The most common pattern of using ConnectableObservable is calling `connect` when the first consumer subscribes,\n     * keeping the subscription alive while several consumers come and go and finally unsubscribing from the source\n     * Observable, when the last consumer unsubscribes. To not implement that logic over and over again,\n     * ConnectableObservable has a special operator, `refCount`. When called, it returns an Observable, which will count\n     * the number of consumers subscribed to it and keep ConnectableObservable connected as long as there is at least\n     * one consumer. So if you don't actually need to decide yourself when to connect and disconnect a\n     * ConnectableObservable, use `refCount`.\n     *\n     * The second mode is invoked by calling `multicast` with an additional, second argument - selector function.\n     * This function accepts an Observable - which basically mirrors the source Observable - and returns Observable\n     * as well, which should be the input stream modified by any operators you want. Note that in this\n     * mode you cannot provide initialized Subject as a first argument - it has to be a Subject factory. If\n     * you provide selector function, `multicast` returns just a regular Observable, instead of ConnectableObservable.\n     * Thus, as usual, each subscription to this stream triggers subscription to the source Observable. However,\n     * if inside the selector function you subscribe to the input Observable multiple times, actual source stream\n     * will be subscribed only once. So if you have a chain of operators that use some Observable many times,\n     * but you want to subscribe to that Observable only once, this is the mode you would use.\n     *\n     * Subject provided as a first parameter of `multicast` is used as a proxy for the single subscription to the\n     * source Observable. It means that all values from the source stream go through that Subject. Thus, if a Subject\n     * has some special properties, Observable returned by `multicast` will have them as well. If you want to use\n     * `multicast` with a Subject that is one of the ones included in RxJS by default - {@link Subject},\n     * {@link AsyncSubject}, {@link BehaviorSubject}, or {@link ReplaySubject} - simply use {@link publish},\n     * {@link publishLast}, {@link publishBehavior} or {@link publishReplay} respectively. These are actually\n     * just wrappers around `multicast`, with a specific Subject hardcoded inside.\n     *\n     * Also, if you use {@link publish} or {@link publishReplay} with a ConnectableObservables `refCount` operator,\n     * you can simply use {@link share} and {@link shareReplay} respectively, which chain these two.\n     *\n     * @example <caption>Use ConnectableObservable</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     * const connectableSeconds = seconds.multicast(new Subject());\n     *\n     * connectableSeconds.subscribe(value => console.log('first: ' + value));\n     * connectableSeconds.subscribe(value => console.log('second: ' + value));\n     *\n     * // At this point still nothing happens, even though we subscribed twice.\n     *\n     * connectableSeconds.connect();\n     *\n     * // From now on `seconds` are being logged to the console,\n     * // twice per every second. `seconds` Observable was however only subscribed once,\n     * // so under the hood Observable.interval had only one clock started.\n     *\n     * @example <caption>Use selector</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds\n     *     .multicast(\n     *         () => new Subject(),\n     *         seconds => seconds.zip(seconds) // Usually zip would subscribe to `seconds` twice.\n     *                                         // Because we are inside selector, `seconds` is subscribed once,\n     *     )                                   // thus starting only one clock used internally by Observable.interval.\n     *     .subscribe();\n     *\n     * @see {@link publish}\n     * @see {@link publishLast}\n     * @see {@link publishBehavior}\n     * @see {@link publishReplay}\n     * @see {@link share}\n     * @see {@link shareReplay}\n     *\n     * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate Subject through\n     * which the source sequence's elements will be multicast to the selector function input Observable or\n     * ConnectableObservable returned by the operator.\n     * @param {Function} [selector] - Optional selector function that can use the input stream\n     * as many times as needed, without causing multiple subscriptions to the source stream.\n     * Subscribers to the input source will receive all notifications of the source from the\n     * time of the subscription forward.\n     * @return {Observable<T>|ConnectableObservable<T>} An Observable that emits the results of invoking the selector\n     * on the source stream or a special {@link ConnectableObservable}, if selector was not provided.\n     *\n     * @method multicast\n     * @owner Observable\n     */\n    function multicast(subjectOrSubjectFactory, selector) {\n        return multicast_1.multicast(subjectOrSubjectFactory, selector)(this);\n    }\n    exports.multicast = multicast;\n});\n\ndefine('rxjs/add/operator/multicast',[\"require\", \"exports\", \"../../Observable\", \"../../operator/multicast\"], function (require, exports, Observable_1, multicast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.multicast = multicast_1.multicast;\n});\n\ndefine('rxjs/operator/observeOn',[\"require\", \"exports\", \"../operators/observeOn\"], function (require, exports, observeOn_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Re-emits all notifications from source Observable with specified scheduler.\n     *\n     * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n     *\n     * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n     * notifications emitted by the source Observable. It might be useful, if you do not have control over\n     * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n     *\n     * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n     * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n     * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n     * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n     * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n     * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n     * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n     * little bit more, to ensure that they are emitted at expected moments.\n     *\n     * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n     * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n     * will delay all notifications - including error notifications - while `delay` will pass through error\n     * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n     * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n     * for notification emissions in general.\n     *\n     * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>\n     * const intervals = Rx.Observable.interval(10); // Intervals are scheduled\n     *                                               // with async scheduler by default...\n     *\n     * intervals\n     * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame\n     * .subscribe(val => {                           // scheduler to ensure smooth animation.\n     *   someDiv.style.height = val + 'px';\n     * });\n     *\n     * @see {@link delay}\n     *\n     * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.\n     * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.\n     * @return {Observable<T>} Observable that emits the same notifications as the source Observable,\n     * but with provided scheduler.\n     *\n     * @method observeOn\n     * @owner Observable\n     */\n    function observeOn(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        return observeOn_1.observeOn(scheduler, delay)(this);\n    }\n    exports.observeOn = observeOn;\n});\n\ndefine('rxjs/add/operator/observeOn',[\"require\", \"exports\", \"../../Observable\", \"../../operator/observeOn\"], function (require, exports, Observable_1, observeOn_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.observeOn = observeOn_1.observeOn;\n});\n\ndefine('rxjs/operator/onErrorResumeNext',[\"require\", \"exports\", \"../operators/onErrorResumeNext\"], function (require, exports, onErrorResumeNext_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one\n     * that was passed.\n     *\n     * <span class=\"informal\">Execute series of Observables no matter what, even if it means swallowing errors.</span>\n     *\n     * <img src=\"./img/onErrorResumeNext.png\" width=\"100%\">\n     *\n     * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as\n     * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same\n     * as the source.\n     *\n     * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.\n     * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`\n     * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting\n     * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another\n     * Observable in provided series, no matter if previous Observable completed or ended with an error. This will\n     * be happening until there is no more Observables left in the series, at which point returned Observable will\n     * complete - even if the last subscribed stream ended with an error.\n     *\n     * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive\n     * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable\n     * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with\n     * an error.\n     *\n     * Note that you do not get any access to errors emitted by the Observables. In particular do not\n     * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take\n     * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.\n     *\n     *\n     * @example <caption>Subscribe to the next Observable after map fails</caption>\n     * Rx.Observable.of(1, 2, 3, 0)\n     *   .map(x => {\n     *       if (x === 0) { throw Error(); }\n             return 10 / x;\n     *   })\n     *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))\n     *   .subscribe(\n     *     val => console.log(val),\n     *     err => console.log(err),          // Will never be called.\n     *     () => console.log('that\\'s it!')\n     *   );\n     *\n     * // Logs:\n     * // 10\n     * // 5\n     * // 3.3333333333333335\n     * // 1\n     * // 2\n     * // 3\n     * // \"that's it!\"\n     *\n     * @see {@link concat}\n     * @see {@link catch}\n     *\n     * @param {...ObservableInput} observables Observables passed either directly or as an array.\n     * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes\n     * to the next passed Observable and so on, until it completes or runs out of Observables.\n     * @method onErrorResumeNext\n     * @owner Observable\n     */\n    function onErrorResumeNext() {\n        var nextSources = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nextSources[_i] = arguments[_i];\n        }\n        return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, nextSources)(this);\n    }\n    exports.onErrorResumeNext = onErrorResumeNext;\n});\n\ndefine('rxjs/add/operator/onErrorResumeNext',[\"require\", \"exports\", \"../../Observable\", \"../../operator/onErrorResumeNext\"], function (require, exports, Observable_1, onErrorResumeNext_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;\n});\n\ndefine('rxjs/operator/pairwise',[\"require\", \"exports\", \"../operators/pairwise\"], function (require, exports, pairwise_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Groups pairs of consecutive emissions together and emits them as an array of\n     * two values.\n     *\n     * <span class=\"informal\">Puts the current value and previous value together as\n     * an array, and emits that.</span>\n     *\n     * <img src=\"./img/pairwise.png\" width=\"100%\">\n     *\n     * The Nth emission from the source Observable will cause the output Observable\n     * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n     * pair. For this reason, `pairwise` emits on the second and subsequent\n     * emissions from the source Observable, but not on the first emission, because\n     * there is no previous value in that case.\n     *\n     * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var pairs = clicks.pairwise();\n     * var distance = pairs.map(pair => {\n     *   var x0 = pair[0].clientX;\n     *   var y0 = pair[0].clientY;\n     *   var x1 = pair[1].clientX;\n     *   var y1 = pair[1].clientY;\n     *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n     * });\n     * distance.subscribe(x => console.log(x));\n     *\n     * @see {@link buffer}\n     * @see {@link bufferCount}\n     *\n     * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of\n     * consecutive values from the source Observable.\n     * @method pairwise\n     * @owner Observable\n     */\n    function pairwise() {\n        return pairwise_1.pairwise()(this);\n    }\n    exports.pairwise = pairwise;\n});\n\ndefine('rxjs/add/operator/pairwise',[\"require\", \"exports\", \"../../Observable\", \"../../operator/pairwise\"], function (require, exports, Observable_1, pairwise_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;\n});\n\ndefine('rxjs/operator/partition',[\"require\", \"exports\", \"../operators/partition\"], function (require, exports, partition_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Splits the source Observable into two, one with values that satisfy a\n     * predicate, and another with values that don't satisfy the predicate.\n     *\n     * <span class=\"informal\">It's like {@link filter}, but returns two Observables:\n     * one like the output of {@link filter}, and the other with values that did not\n     * pass the condition.</span>\n     *\n     * <img src=\"./img/partition.png\" width=\"100%\">\n     *\n     * `partition` outputs an array with two Observables that partition the values\n     * from the source Observable through the given `predicate` function. The first\n     * Observable in that array emits source values for which the predicate argument\n     * returns true. The second Observable emits source values for which the\n     * predicate returns false. The first behaves like {@link filter} and the second\n     * behaves like {@link filter} with the predicate negated.\n     *\n     * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');\n     * var clicksOnDivs = parts[0];\n     * var clicksElsewhere = parts[1];\n     * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n     * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n     *\n     * @see {@link filter}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates each value emitted by the source Observable. If it returns `true`,\n     * the value is emitted on the first Observable in the returned array, if\n     * `false` the value is emitted on the second Observable in the array. The\n     * `index` parameter is the number `i` for the i-th source emission that has\n     * happened since the subscription, starting from the number `0`.\n     * @param {any} [thisArg] An optional argument to determine the value of `this`\n     * in the `predicate` function.\n     * @return {[Observable<T>, Observable<T>]} An array with two Observables: one\n     * with values that passed the predicate, and another with values that did not\n     * pass the predicate.\n     * @method partition\n     * @owner Observable\n     */\n    function partition(predicate, thisArg) {\n        return partition_1.partition(predicate, thisArg)(this);\n    }\n    exports.partition = partition;\n});\n\ndefine('rxjs/add/operator/partition',[\"require\", \"exports\", \"../../Observable\", \"../../operator/partition\"], function (require, exports, Observable_1, partition_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.partition = partition_1.partition;\n});\n\ndefine('rxjs/operator/pluck',[\"require\", \"exports\", \"../operators/pluck\"], function (require, exports, pluck_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Maps each source value (an object) to its specified nested property.\n     *\n     * <span class=\"informal\">Like {@link map}, but meant only for picking one of\n     * the nested properties of every emitted object.</span>\n     *\n     * <img src=\"./img/pluck.png\" width=\"100%\">\n     *\n     * Given a list of strings describing a path to an object property, retrieves\n     * the value of a specified nested property from all values in the source\n     * Observable. If a property can't be resolved, it will return `undefined` for\n     * that value.\n     *\n     * @example <caption>Map every click to the tagName of the clicked target element</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var tagNames = clicks.pluck('target', 'tagName');\n     * tagNames.subscribe(x => console.log(x));\n     *\n     * @see {@link map}\n     *\n     * @param {...string} properties The nested properties to pluck from each source\n     * value (an object).\n     * @return {Observable} A new Observable of property values from the source values.\n     * @method pluck\n     * @owner Observable\n     */\n    function pluck() {\n        var properties = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            properties[_i] = arguments[_i];\n        }\n        return pluck_1.pluck.apply(void 0, properties)(this);\n    }\n    exports.pluck = pluck;\n});\n\ndefine('rxjs/add/operator/pluck',[\"require\", \"exports\", \"../../Observable\", \"../../operator/pluck\"], function (require, exports, Observable_1, pluck_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.pluck = pluck_1.pluck;\n});\n\ndefine('rxjs/operator/publish',[\"require\", \"exports\", \"../operators/publish\"], function (require, exports, publish_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called\n     * before it begins emitting items to those Observers that have subscribed to it.\n     *\n     * <img src=\"./img/publish.png\" width=\"100%\">\n     *\n     * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times\n     * as needed, without causing multiple subscriptions to the source sequence.\n     * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.\n     * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.\n     * @method publish\n     * @owner Observable\n     */\n    function publish(selector) {\n        return publish_1.publish(selector)(this);\n    }\n    exports.publish = publish;\n});\n\ndefine('rxjs/add/operator/publish',[\"require\", \"exports\", \"../../Observable\", \"../../operator/publish\"], function (require, exports, Observable_1, publish_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.publish = publish_1.publish;\n});\n\ndefine('rxjs/operator/publishBehavior',[\"require\", \"exports\", \"../operators/publishBehavior\"], function (require, exports, publishBehavior_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param value\n     * @return {ConnectableObservable<T>}\n     * @method publishBehavior\n     * @owner Observable\n     */\n    function publishBehavior(value) {\n        return publishBehavior_1.publishBehavior(value)(this);\n    }\n    exports.publishBehavior = publishBehavior;\n});\n\ndefine('rxjs/add/operator/publishBehavior',[\"require\", \"exports\", \"../../Observable\", \"../../operator/publishBehavior\"], function (require, exports, Observable_1, publishBehavior_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;\n});\n\ndefine('rxjs/operator/publishReplay',[\"require\", \"exports\", \"../operators/publishReplay\"], function (require, exports, publishReplay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * @param bufferSize\n     * @param windowTime\n     * @param selectorOrScheduler\n     * @param scheduler\n     * @return {Observable<T> | ConnectableObservable<T>}\n     * @method publishReplay\n     * @owner Observable\n     */\n    function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {\n        return publishReplay_1.publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler)(this);\n    }\n    exports.publishReplay = publishReplay;\n});\n\ndefine('rxjs/add/operator/publishReplay',[\"require\", \"exports\", \"../../Observable\", \"../../operator/publishReplay\"], function (require, exports, Observable_1, publishReplay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;\n});\n\ndefine('rxjs/operator/publishLast',[\"require\", \"exports\", \"../operators/publishLast\"], function (require, exports, publishLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @return {ConnectableObservable<T>}\n     * @method publishLast\n     * @owner Observable\n     */\n    function publishLast() {\n        //TODO(benlesh): correct type-flow through here.\n        return publishLast_1.publishLast()(this);\n    }\n    exports.publishLast = publishLast;\n});\n\ndefine('rxjs/add/operator/publishLast',[\"require\", \"exports\", \"../../Observable\", \"../../operator/publishLast\"], function (require, exports, Observable_1, publishLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.publishLast = publishLast_1.publishLast;\n});\n\ndefine('rxjs/operator/race',[\"require\", \"exports\", \"../operators/race\", \"../observable/race\"], function (require, exports, race_1, race_2) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.raceStatic = race_2.race;\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that mirrors the first source Observable to emit an item\n     * from the combination of this Observable and supplied Observables.\n     * @param {...Observables} ...observables Sources used to race for which Observable emits first.\n     * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.\n     * @method race\n     * @owner Observable\n     */\n    function race() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return race_1.race.apply(void 0, observables)(this);\n    }\n    exports.race = race;\n});\n\ndefine('rxjs/add/operator/race',[\"require\", \"exports\", \"../../Observable\", \"../../operator/race\"], function (require, exports, Observable_1, race_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.race = race_1.race;\n});\n\ndefine('rxjs/operator/reduce',[\"require\", \"exports\", \"../operators/reduce\"], function (require, exports, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Applies an accumulator function over the source Observable, and returns the\n     * accumulated result when the source completes, given an optional seed value.\n     *\n     * <span class=\"informal\">Combines together all values emitted on the source,\n     * using an accumulator function that knows how to join a new source value into\n     * the accumulation from the past.</span>\n     *\n     * <img src=\"./img/reduce.png\" width=\"100%\">\n     *\n     * Like\n     * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),\n     * `reduce` applies an `accumulator` function against an accumulation and each\n     * value of the source Observable (from the past) to reduce it to a single\n     * value, emitted on the output Observable. Note that `reduce` will only emit\n     * one value, only when the source Observable completes. It is equivalent to\n     * applying operator {@link scan} followed by operator {@link last}.\n     *\n     * Returns an Observable that applies a specified `accumulator` function to each\n     * item emitted by the source Observable. If a `seed` value is specified, then\n     * that value will be used as the initial value for the accumulator. If no seed\n     * value is specified, the first item of the source is used as the seed.\n     *\n     * @example <caption>Count the number of click events that happened in 5 seconds</caption>\n     * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')\n     *   .takeUntil(Rx.Observable.interval(5000));\n     * var ones = clicksInFiveSeconds.mapTo(1);\n     * var seed = 0;\n     * var count = ones.reduce((acc, one) => acc + one, seed);\n     * count.subscribe(x => console.log(x));\n     *\n     * @see {@link count}\n     * @see {@link expand}\n     * @see {@link mergeScan}\n     * @see {@link scan}\n     *\n     * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function\n     * called on each source value.\n     * @param {R} [seed] The initial accumulation value.\n     * @return {Observable<R>} An Observable that emits a single value that is the\n     * result of accumulating the values emitted by the source Observable.\n     * @method reduce\n     * @owner Observable\n     */\n    function reduce(accumulator, seed) {\n        // providing a seed of `undefined` *should* be valid and trigger\n        // hasSeed! so don't use `seed !== undefined` checks!\n        // For this reason, we have to check it here at the original call site\n        // otherwise inside Operator/Subscriber we won't know if `undefined`\n        // means they didn't provide anything or if they literally provided `undefined`\n        if (arguments.length >= 2) {\n            return reduce_1.reduce(accumulator, seed)(this);\n        }\n        return reduce_1.reduce(accumulator)(this);\n    }\n    exports.reduce = reduce;\n});\n\ndefine('rxjs/add/operator/reduce',[\"require\", \"exports\", \"../../Observable\", \"../../operator/reduce\"], function (require, exports, Observable_1, reduce_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.reduce = reduce_1.reduce;\n});\n\ndefine('rxjs/operator/repeat',[\"require\", \"exports\", \"../operators/repeat\"], function (require, exports, repeat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.\n     *\n     * <img src=\"./img/repeat.png\" width=\"100%\">\n     *\n     * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield\n     * an empty Observable.\n     * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most\n     * count times.\n     * @method repeat\n     * @owner Observable\n     */\n    function repeat(count) {\n        if (count === void 0) { count = -1; }\n        return repeat_1.repeat(count)(this);\n    }\n    exports.repeat = repeat;\n});\n\ndefine('rxjs/add/operator/repeat',[\"require\", \"exports\", \"../../Observable\", \"../../operator/repeat\"], function (require, exports, Observable_1, repeat_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.repeat = repeat_1.repeat;\n});\n\ndefine('rxjs/operator/repeatWhen',[\"require\", \"exports\", \"../operators/repeatWhen\"], function (require, exports, repeatWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n     * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n     * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n     * this method will resubscribe to the source Observable.\n     *\n     * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n     *\n     * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n     * which a user can `complete` or `error`, aborting the repetition.\n     * @return {Observable} The source Observable modified with repeat logic.\n     * @method repeatWhen\n     * @owner Observable\n     */\n    function repeatWhen(notifier) {\n        return repeatWhen_1.repeatWhen(notifier)(this);\n    }\n    exports.repeatWhen = repeatWhen;\n});\n\ndefine('rxjs/add/operator/repeatWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/repeatWhen\"], function (require, exports, Observable_1, repeatWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;\n});\n\ndefine('rxjs/operator/retry',[\"require\", \"exports\", \"../operators/retry\"], function (require, exports, retry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n     * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given\n     * as a number parameter) rather than propagating the `error` call.\n     *\n     * <img src=\"./img/retry.png\" width=\"100%\">\n     *\n     * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted\n     * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second\n     * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications\n     * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].\n     * @param {number} count - Number of retry attempts before failing.\n     * @return {Observable} The source Observable modified with the retry logic.\n     * @method retry\n     * @owner Observable\n     */\n    function retry(count) {\n        if (count === void 0) { count = -1; }\n        return retry_1.retry(count)(this);\n    }\n    exports.retry = retry;\n});\n\ndefine('rxjs/add/operator/retry',[\"require\", \"exports\", \"../../Observable\", \"../../operator/retry\"], function (require, exports, Observable_1, retry_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.retry = retry_1.retry;\n});\n\ndefine('rxjs/operator/retryWhen',[\"require\", \"exports\", \"../operators/retryWhen\"], function (require, exports, retryWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable\n     * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.\n     * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child\n     * subscription. Otherwise this method will resubscribe to the source Observable.\n     *\n     * <img src=\"./img/retryWhen.png\" width=\"100%\">\n     *\n     * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a\n     * user can `complete` or `error`, aborting the retry.\n     * @return {Observable} The source Observable modified with retry logic.\n     * @method retryWhen\n     * @owner Observable\n     */\n    function retryWhen(notifier) {\n        return retryWhen_1.retryWhen(notifier)(this);\n    }\n    exports.retryWhen = retryWhen;\n});\n\ndefine('rxjs/add/operator/retryWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/retryWhen\"], function (require, exports, Observable_1, retryWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;\n});\n\ndefine('rxjs/operator/sample',[\"require\", \"exports\", \"../operators/sample\"], function (require, exports, sample_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the most recently emitted value from the source Observable whenever\n     * another Observable, the `notifier`, emits.\n     *\n     * <span class=\"informal\">It's like {@link sampleTime}, but samples whenever\n     * the `notifier` Observable emits something.</span>\n     *\n     * <img src=\"./img/sample.png\" width=\"100%\">\n     *\n     * Whenever the `notifier` Observable emits a value or completes, `sample`\n     * looks at the source Observable and emits whichever value it has most recently\n     * emitted since the previous sampling, unless the source has not emitted\n     * anything since the previous sampling. The `notifier` is subscribed to as soon\n     * as the output Observable is subscribed.\n     *\n     * @example <caption>On every click, sample the most recent \"seconds\" timer</caption>\n     * var seconds = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = seconds.sample(clicks);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounce}\n     * @see {@link sampleTime}\n     * @see {@link throttle}\n     *\n     * @param {Observable<any>} notifier The Observable to use for sampling the\n     * source Observable.\n     * @return {Observable<T>} An Observable that emits the results of sampling the\n     * values emitted by the source Observable whenever the notifier Observable\n     * emits value or completes.\n     * @method sample\n     * @owner Observable\n     */\n    function sample(notifier) {\n        return sample_1.sample(notifier)(this);\n    }\n    exports.sample = sample;\n});\n\ndefine('rxjs/add/operator/sample',[\"require\", \"exports\", \"../../Observable\", \"../../operator/sample\"], function (require, exports, Observable_1, sample_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.sample = sample_1.sample;\n});\n\ndefine('rxjs/operator/sampleTime',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/sampleTime\"], function (require, exports, async_1, sampleTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the most recently emitted value from the source Observable within\n     * periodic time intervals.\n     *\n     * <span class=\"informal\">Samples the source Observable at periodic time\n     * intervals, emitting what it samples.</span>\n     *\n     * <img src=\"./img/sampleTime.png\" width=\"100%\">\n     *\n     * `sampleTime` periodically looks at the source Observable and emits whichever\n     * value it has most recently emitted since the previous sampling, unless the\n     * source has not emitted anything since the previous sampling. The sampling\n     * happens periodically in time every `period` milliseconds (or the time unit\n     * defined by the optional `scheduler` argument). The sampling starts as soon as\n     * the output Observable is subscribed.\n     *\n     * @example <caption>Every second, emit the most recent click at most once</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.sampleTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sample}\n     * @see {@link throttleTime}\n     *\n     * @param {number} period The sampling period expressed in milliseconds or the\n     * time unit determined internally by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the sampling.\n     * @return {Observable<T>} An Observable that emits the results of sampling the\n     * values emitted by the source Observable at the specified time interval.\n     * @method sampleTime\n     * @owner Observable\n     */\n    function sampleTime(period, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return sampleTime_1.sampleTime(period, scheduler)(this);\n    }\n    exports.sampleTime = sampleTime;\n});\n\ndefine('rxjs/add/operator/sampleTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/sampleTime\"], function (require, exports, Observable_1, sampleTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;\n});\n\ndefine('rxjs/operator/scan',[\"require\", \"exports\", \"../operators/scan\"], function (require, exports, scan_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Applies an accumulator function over the source Observable, and returns each\n     * intermediate result, with an optional seed value.\n     *\n     * <span class=\"informal\">It's like {@link reduce}, but emits the current\n     * accumulation whenever the source emits a value.</span>\n     *\n     * <img src=\"./img/scan.png\" width=\"100%\">\n     *\n     * Combines together all values emitted on the source, using an accumulator\n     * function that knows how to join a new source value into the accumulation from\n     * the past. Is similar to {@link reduce}, but emits the intermediate\n     * accumulations.\n     *\n     * Returns an Observable that applies a specified `accumulator` function to each\n     * item emitted by the source Observable. If a `seed` value is specified, then\n     * that value will be used as the initial value for the accumulator. If no seed\n     * value is specified, the first item of the source is used as the seed.\n     *\n     * @example <caption>Count the number of click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var ones = clicks.mapTo(1);\n     * var seed = 0;\n     * var count = ones.scan((acc, one) => acc + one, seed);\n     * count.subscribe(x => console.log(x));\n     *\n     * @see {@link expand}\n     * @see {@link mergeScan}\n     * @see {@link reduce}\n     *\n     * @param {function(acc: R, value: T, index: number): R} accumulator\n     * The accumulator function called on each source value.\n     * @param {T|R} [seed] The initial accumulation value.\n     * @return {Observable<R>} An observable of the accumulated values.\n     * @method scan\n     * @owner Observable\n     */\n    function scan(accumulator, seed) {\n        if (arguments.length >= 2) {\n            return scan_1.scan(accumulator, seed)(this);\n        }\n        return scan_1.scan(accumulator)(this);\n    }\n    exports.scan = scan;\n});\n\ndefine('rxjs/add/operator/scan',[\"require\", \"exports\", \"../../Observable\", \"../../operator/scan\"], function (require, exports, Observable_1, scan_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.scan = scan_1.scan;\n});\n\ndefine('rxjs/operator/sequenceEqual',[\"require\", \"exports\", \"../operators/sequenceEqual\"], function (require, exports, sequenceEqual_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Compares all values of two observables in sequence using an optional comparor function\n     * and returns an observable of a single boolean value representing whether or not the two sequences\n     * are equal.\n     *\n     * <span class=\"informal\">Checks to see of all values emitted by both observables are equal, in order.</span>\n     *\n     * <img src=\"./img/sequenceEqual.png\" width=\"100%\">\n     *\n     * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either\n     * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom\n     * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the\n     * observables completes, the operator will wait for the other observable to complete; If the other\n     * observable emits before completing, the returned observable will emit `false` and complete. If one observable never\n     * completes or emits after the other complets, the returned observable will never complete.\n     *\n     * @example <caption>figure out if the Konami code matches</caption>\n     * var code = Rx.Observable.from([\n     *  \"ArrowUp\",\n     *  \"ArrowUp\",\n     *  \"ArrowDown\",\n     *  \"ArrowDown\",\n     *  \"ArrowLeft\",\n     *  \"ArrowRight\",\n     *  \"ArrowLeft\",\n     *  \"ArrowRight\",\n     *  \"KeyB\",\n     *  \"KeyA\",\n     *  \"Enter\" // no start key, clearly.\n     * ]);\n     *\n     * var keys = Rx.Observable.fromEvent(document, 'keyup')\n     *  .map(e => e.code);\n     * var matches = keys.bufferCount(11, 1)\n     *  .mergeMap(\n     *    last11 =>\n     *      Rx.Observable.from(last11)\n     *        .sequenceEqual(code)\n     *   );\n     * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));\n     *\n     * @see {@link combineLatest}\n     * @see {@link zip}\n     * @see {@link withLatestFrom}\n     *\n     * @param {Observable} compareTo The observable sequence to compare the source sequence to.\n     * @param {function} [comparor] An optional function to compare each value pair\n     * @return {Observable} An Observable of a single boolean value representing whether or not\n     * the values emitted by both observables were equal in sequence.\n     * @method sequenceEqual\n     * @owner Observable\n     */\n    function sequenceEqual(compareTo, comparor) {\n        return sequenceEqual_1.sequenceEqual(compareTo, comparor)(this);\n    }\n    exports.sequenceEqual = sequenceEqual;\n});\n\ndefine('rxjs/add/operator/sequenceEqual',[\"require\", \"exports\", \"../../Observable\", \"../../operator/sequenceEqual\"], function (require, exports, Observable_1, sequenceEqual_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;\n});\n\ndefine('rxjs/operator/share',[\"require\", \"exports\", \"../operators/share\"], function (require, exports, share_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n     * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n     * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n     *\n     * This behaves similarly to .publish().refCount(), with a behavior difference when the source observable emits complete.\n     * .publish().refCount() will not resubscribe to the original source, however .share() will resubscribe to the original source.\n     * Observable.of(\"test\").publish().refCount() will not re-emit \"test\" on new subscriptions, Observable.of(\"test\").share() will\n     * re-emit \"test\" to new subscriptions.\n     *\n     * <img src=\"./img/share.png\" width=\"100%\">\n     *\n     * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.\n     * @method share\n     * @owner Observable\n     */\n    function share() {\n        return share_1.share()(this);\n    }\n    exports.share = share;\n    ;\n});\n\ndefine('rxjs/add/operator/share',[\"require\", \"exports\", \"../../Observable\", \"../../operator/share\"], function (require, exports, Observable_1, share_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.share = share_1.share;\n});\n\ndefine('rxjs/operator/shareReplay',[\"require\", \"exports\", \"../operators/shareReplay\"], function (require, exports, shareReplay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @method shareReplay\n     * @owner Observable\n     */\n    function shareReplay(bufferSize, windowTime, scheduler) {\n        return shareReplay_1.shareReplay(bufferSize, windowTime, scheduler)(this);\n    }\n    exports.shareReplay = shareReplay;\n    ;\n});\n\ndefine('rxjs/add/operator/shareReplay',[\"require\", \"exports\", \"../../Observable\", \"../../operator/shareReplay\"], function (require, exports, Observable_1, shareReplay_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.shareReplay = shareReplay_1.shareReplay;\n});\n\ndefine('rxjs/operator/single',[\"require\", \"exports\", \"../operators/single\"], function (require, exports, single_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that emits the single item emitted by the source Observable that matches a specified\n     * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no\n     * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.\n     *\n     * <img src=\"./img/single.png\" width=\"100%\">\n     *\n     * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`\n     * callback if the Observable completes before any `next` notification was sent.\n     * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.\n     * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches\n     * the predicate.\n     .\n     * @method single\n     * @owner Observable\n     */\n    function single(predicate) {\n        return single_1.single(predicate)(this);\n    }\n    exports.single = single;\n});\n\ndefine('rxjs/add/operator/single',[\"require\", \"exports\", \"../../Observable\", \"../../operator/single\"], function (require, exports, Observable_1, single_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.single = single_1.single;\n});\n\ndefine('rxjs/operator/skip',[\"require\", \"exports\", \"../operators/skip\"], function (require, exports, skip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips the first `count` items emitted by the source Observable.\n     *\n     * <img src=\"./img/skip.png\" width=\"100%\">\n     *\n     * @param {Number} count - The number of times, items emitted by source Observable should be skipped.\n     * @return {Observable} An Observable that skips values emitted by the source Observable.\n     *\n     * @method skip\n     * @owner Observable\n     */\n    function skip(count) {\n        return skip_1.skip(count)(this);\n    }\n    exports.skip = skip;\n});\n\ndefine('rxjs/add/operator/skip',[\"require\", \"exports\", \"../../Observable\", \"../../operator/skip\"], function (require, exports, Observable_1, skip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.skip = skip_1.skip;\n});\n\ndefine('rxjs/operator/skipLast',[\"require\", \"exports\", \"../operators/skipLast\"], function (require, exports, skipLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Skip the last `count` values emitted by the source Observable.\n     *\n     * <img src=\"./img/skipLast.png\" width=\"100%\">\n     *\n     * `skipLast` returns an Observable that accumulates a queue with a length\n     * enough to store the first `count` values. As more values are received,\n     * values are taken from the front of the queue and produced on the result\n     * sequence. This causes values to be delayed.\n     *\n     * @example <caption>Skip the last 2 values of an Observable with many values</caption>\n     * var many = Rx.Observable.range(1, 5);\n     * var skipLastTwo = many.skipLast(2);\n     * skipLastTwo.subscribe(x => console.log(x));\n     *\n     * // Results in:\n     * // 1 2 3\n     *\n     * @see {@link skip}\n     * @see {@link skipUntil}\n     * @see {@link skipWhile}\n     * @see {@link take}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws\n     * ArgumentOutOrRangeError if `i < 0`.\n     *\n     * @param {number} count Number of elements to skip from the end of the source Observable.\n     * @returns {Observable<T>} An Observable that skips the last count values\n     * emitted by the source Observable.\n     * @method skipLast\n     * @owner Observable\n     */\n    function skipLast(count) {\n        return skipLast_1.skipLast(count)(this);\n    }\n    exports.skipLast = skipLast;\n});\n\ndefine('rxjs/add/operator/skipLast',[\"require\", \"exports\", \"../../Observable\", \"../../operator/skipLast\"], function (require, exports, Observable_1, skipLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.skipLast = skipLast_1.skipLast;\n});\n\ndefine('rxjs/operator/skipUntil',[\"require\", \"exports\", \"../operators/skipUntil\"], function (require, exports, skipUntil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.\n     *\n     * <img src=\"./img/skipUntil.png\" width=\"100%\">\n     *\n     * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to\n     * be mirrored by the resulting Observable.\n     * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits\n     * an item, then emits the remaining items.\n     * @method skipUntil\n     * @owner Observable\n     */\n    function skipUntil(notifier) {\n        return skipUntil_1.skipUntil(notifier)(this);\n    }\n    exports.skipUntil = skipUntil;\n});\n\ndefine('rxjs/add/operator/skipUntil',[\"require\", \"exports\", \"../../Observable\", \"../../operator/skipUntil\"], function (require, exports, Observable_1, skipUntil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;\n});\n\ndefine('rxjs/operator/skipWhile',[\"require\", \"exports\", \"../operators/skipWhile\"], function (require, exports, skipWhile_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds\n     * true, but emits all further source items as soon as the condition becomes false.\n     *\n     * <img src=\"./img/skipWhile.png\" width=\"100%\">\n     *\n     * @param {Function} predicate - A function to test each item emitted from the source Observable.\n     * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the\n     * specified predicate becomes false.\n     * @method skipWhile\n     * @owner Observable\n     */\n    function skipWhile(predicate) {\n        return skipWhile_1.skipWhile(predicate)(this);\n    }\n    exports.skipWhile = skipWhile;\n});\n\ndefine('rxjs/add/operator/skipWhile',[\"require\", \"exports\", \"../../Observable\", \"../../operator/skipWhile\"], function (require, exports, Observable_1, skipWhile_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;\n});\n\ndefine('rxjs/operator/startWith',[\"require\", \"exports\", \"../operators/startWith\"], function (require, exports, startWith_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Returns an Observable that emits the items you specify as arguments before it begins to emit\n     * items emitted by the source Observable.\n     *\n     * <img src=\"./img/startWith.png\" width=\"100%\">\n     *\n     * @param {...T} values - Items you want the modified Observable to emit first.\n     * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling\n     * the emissions of the `next` notifications.\n     * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items\n     * emitted by the source Observable.\n     * @method startWith\n     * @owner Observable\n     */\n    function startWith() {\n        var array = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            array[_i] = arguments[_i];\n        }\n        return startWith_1.startWith.apply(void 0, array)(this);\n    }\n    exports.startWith = startWith;\n});\n\ndefine('rxjs/add/operator/startWith',[\"require\", \"exports\", \"../../Observable\", \"../../operator/startWith\"], function (require, exports, Observable_1, startWith_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.startWith = startWith_1.startWith;\n});\n\ndefine('rxjs/observable/SubscribeOnObservable',[\"require\", \"exports\", \"tslib\", \"../Observable\", \"../scheduler/asap\", \"../util/isNumeric\"], function (require, exports, tslib_1, Observable_1, asap_1, isNumeric_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * We need this JSDoc comment for affecting ESDoc.\n     * @extends {Ignored}\n     * @hide true\n     */\n    var SubscribeOnObservable = /** @class */ (function (_super) {\n        tslib_1.__extends(SubscribeOnObservable, _super);\n        function SubscribeOnObservable(source, delayTime, scheduler) {\n            if (delayTime === void 0) { delayTime = 0; }\n            if (scheduler === void 0) { scheduler = asap_1.asap; }\n            var _this = _super.call(this) || this;\n            _this.source = source;\n            _this.delayTime = delayTime;\n            _this.scheduler = scheduler;\n            if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {\n                _this.delayTime = 0;\n            }\n            if (!scheduler || typeof scheduler.schedule !== 'function') {\n                _this.scheduler = asap_1.asap;\n            }\n            return _this;\n        }\n        SubscribeOnObservable.create = function (source, delay, scheduler) {\n            if (delay === void 0) { delay = 0; }\n            if (scheduler === void 0) { scheduler = asap_1.asap; }\n            return new SubscribeOnObservable(source, delay, scheduler);\n        };\n        SubscribeOnObservable.dispatch = function (arg) {\n            var source = arg.source, subscriber = arg.subscriber;\n            return this.add(source.subscribe(subscriber));\n        };\n        SubscribeOnObservable.prototype._subscribe = function (subscriber) {\n            var delay = this.delayTime;\n            var source = this.source;\n            var scheduler = this.scheduler;\n            return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {\n                source: source, subscriber: subscriber\n            });\n        };\n        return SubscribeOnObservable;\n    }(Observable_1.Observable));\n    exports.SubscribeOnObservable = SubscribeOnObservable;\n});\n\ndefine('rxjs/operators/subscribeOn',[\"require\", \"exports\", \"../observable/SubscribeOnObservable\"], function (require, exports, SubscribeOnObservable_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n     *\n     * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n     *\n     * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n     * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n     .\n     * @method subscribeOn\n     * @owner Observable\n     */\n    function subscribeOn(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        return function subscribeOnOperatorFunction(source) {\n            return source.lift(new SubscribeOnOperator(scheduler, delay));\n        };\n    }\n    exports.subscribeOn = subscribeOn;\n    var SubscribeOnOperator = /** @class */ (function () {\n        function SubscribeOnOperator(scheduler, delay) {\n            this.scheduler = scheduler;\n            this.delay = delay;\n        }\n        SubscribeOnOperator.prototype.call = function (subscriber, source) {\n            return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);\n        };\n        return SubscribeOnOperator;\n    }());\n});\n\ndefine('rxjs/operator/subscribeOn',[\"require\", \"exports\", \"../operators/subscribeOn\"], function (require, exports, subscribeOn_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Asynchronously subscribes Observers to this Observable on the specified IScheduler.\n     *\n     * <img src=\"./img/subscribeOn.png\" width=\"100%\">\n     *\n     * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.\n     * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.\n     .\n     * @method subscribeOn\n     * @owner Observable\n     */\n    function subscribeOn(scheduler, delay) {\n        if (delay === void 0) { delay = 0; }\n        return subscribeOn_1.subscribeOn(scheduler, delay)(this);\n    }\n    exports.subscribeOn = subscribeOn;\n});\n\ndefine('rxjs/add/operator/subscribeOn',[\"require\", \"exports\", \"../../Observable\", \"../../operator/subscribeOn\"], function (require, exports, Observable_1, subscribeOn_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;\n});\n\ndefine('rxjs/operator/switch',[\"require\", \"exports\", \"../operators/switchAll\"], function (require, exports, switchAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Converts a higher-order Observable into a first-order Observable by\n     * subscribing to only the most recently emitted of those inner Observables.\n     *\n     * <span class=\"informal\">Flattens an Observable-of-Observables by dropping the\n     * previous inner Observable once a new one appears.</span>\n     *\n     * <img src=\"./img/switch.png\" width=\"100%\">\n     *\n     * `switch` subscribes to an Observable that emits Observables, also known as a\n     * higher-order Observable. Each time it observes one of these emitted inner\n     * Observables, the output Observable subscribes to the inner Observable and\n     * begins emitting the items emitted by that. So far, it behaves\n     * like {@link mergeAll}. However, when a new inner Observable is emitted,\n     * `switch` unsubscribes from the earlier-emitted inner Observable and\n     * subscribes to the new inner Observable and begins emitting items from it. It\n     * continues to behave like this for subsequent inner Observables.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * // Each click event is mapped to an Observable that ticks every second\n     * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));\n     * var switched = higherOrder.switch();\n     * // The outcome is that `switched` is essentially a timer that restarts\n     * // on every click. The interval Observables from older clicks do not merge\n     * // with the current interval Observable.\n     * switched.subscribe(x => console.log(x));\n     *\n     * @see {@link combineAll}\n     * @see {@link concatAll}\n     * @see {@link exhaust}\n     * @see {@link mergeAll}\n     * @see {@link switchMap}\n     * @see {@link switchMapTo}\n     * @see {@link zipAll}\n     *\n     * @return {Observable<T>} An Observable that emits the items emitted by the\n     * Observable most recently emitted by the source Observable.\n     * @method switch\n     * @name switch\n     * @owner Observable\n     */\n    function _switch() {\n        return switchAll_1.switchAll()(this);\n    }\n    exports._switch = _switch;\n});\n\ndefine('rxjs/add/operator/switch',[\"require\", \"exports\", \"../../Observable\", \"../../operator/switch\"], function (require, exports, Observable_1, switch_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.switch = switch_1._switch;\n    Observable_1.Observable.prototype._switch = switch_1._switch;\n});\n\ndefine('rxjs/operator/switchMap',[\"require\", \"exports\", \"../operators/switchMap\"], function (require, exports, switchMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to an Observable which is merged in the output\n     * Observable, emitting values only from the most recently projected Observable.\n     *\n     * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n     * these inner Observables using {@link switch}.</span>\n     *\n     * <img src=\"./img/switchMap.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits items based on applying a function that you\n     * supply to each item emitted by the source Observable, where that function\n     * returns an (so-called \"inner\") Observable. Each time it observes one of these\n     * inner Observables, the output Observable begins emitting the items emitted by\n     * that inner Observable. When a new inner Observable is emitted, `switchMap`\n     * stops emitting items from the earlier-emitted inner Observable and begins\n     * emitting items from the new one. It continues to behave like this for\n     * subsequent inner Observables.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMap}\n     * @see {@link exhaustMap}\n     * @see {@link mergeMap}\n     * @see {@link switch}\n     * @see {@link switchMapTo}\n     *\n     * @param {function(value: T, ?index: number): ObservableInput} project A function\n     * that, when applied to an item emitted by the source Observable, returns an\n     * Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits the result of applying the\n     * projection function (and the optional `resultSelector`) to each item emitted\n     * by the source Observable and taking only the values from the most recently\n     * projected inner Observable.\n     * @method switchMap\n     * @owner Observable\n     */\n    function switchMap(project, resultSelector) {\n        return switchMap_1.switchMap(project, resultSelector)(this);\n    }\n    exports.switchMap = switchMap;\n});\n\ndefine('rxjs/add/operator/switchMap',[\"require\", \"exports\", \"../../Observable\", \"../../operator/switchMap\"], function (require, exports, Observable_1, switchMap_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;\n});\n\ndefine('rxjs/operator/switchMapTo',[\"require\", \"exports\", \"../operators/switchMapTo\"], function (require, exports, switchMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Projects each source value to the same Observable which is flattened multiple\n     * times with {@link switch} in the output Observable.\n     *\n     * <span class=\"informal\">It's like {@link switchMap}, but maps each value\n     * always to the same inner Observable.</span>\n     *\n     * <img src=\"./img/switchMapTo.png\" width=\"100%\">\n     *\n     * Maps each source value to the given Observable `innerObservable` regardless\n     * of the source value, and then flattens those resulting Observables into one\n     * single Observable, which is the output Observable. The output Observables\n     * emits values only from the most recently emitted instance of\n     * `innerObservable`.\n     *\n     * @example <caption>Rerun an interval Observable on every click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.switchMapTo(Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link concatMapTo}\n     * @see {@link switch}\n     * @see {@link switchMap}\n     * @see {@link mergeMapTo}\n     *\n     * @param {ObservableInput} innerObservable An Observable to replace each value from\n     * the source Observable.\n     * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]\n     * A function to produce the value on the output Observable based on the values\n     * and the indices of the source (outer) emission and the inner Observable\n     * emission. The arguments passed to this function are:\n     * - `outerValue`: the value that came from the source\n     * - `innerValue`: the value that came from the projected Observable\n     * - `outerIndex`: the \"index\" of the value that came from the source\n     * - `innerIndex`: the \"index\" of the value from the projected Observable\n     * @return {Observable} An Observable that emits items from the given\n     * `innerObservable` (and optionally transformed through `resultSelector`) every\n     * time a value is emitted on the source Observable, and taking only the values\n     * from the most recently projected inner Observable.\n     * @method switchMapTo\n     * @owner Observable\n     */\n    function switchMapTo(innerObservable, resultSelector) {\n        return switchMapTo_1.switchMapTo(innerObservable, resultSelector)(this);\n    }\n    exports.switchMapTo = switchMapTo;\n});\n\ndefine('rxjs/add/operator/switchMapTo',[\"require\", \"exports\", \"../../Observable\", \"../../operator/switchMapTo\"], function (require, exports, Observable_1, switchMapTo_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;\n});\n\ndefine('rxjs/operator/take',[\"require\", \"exports\", \"../operators/take\"], function (require, exports, take_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the first `count` values emitted by the source Observable.\n     *\n     * <span class=\"informal\">Takes the first `count` values from the source, then\n     * completes.</span>\n     *\n     * <img src=\"./img/take.png\" width=\"100%\">\n     *\n     * `take` returns an Observable that emits only the first `count` values emitted\n     * by the source Observable. If the source emits fewer than `count` values then\n     * all of its values are emitted. After that, it completes, regardless if the\n     * source completes.\n     *\n     * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var five = interval.take(5);\n     * five.subscribe(x => console.log(x));\n     *\n     * @see {@link takeLast}\n     * @see {@link takeUntil}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n     *\n     * @param {number} count The maximum number of `next` values to emit.\n     * @return {Observable<T>} An Observable that emits only the first `count`\n     * values emitted by the source Observable, or all of the values from the source\n     * if the source emits fewer than `count` values.\n     * @method take\n     * @owner Observable\n     */\n    function take(count) {\n        return take_1.take(count)(this);\n    }\n    exports.take = take;\n});\n\ndefine('rxjs/add/operator/take',[\"require\", \"exports\", \"../../Observable\", \"../../operator/take\"], function (require, exports, Observable_1, take_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.take = take_1.take;\n});\n\ndefine('rxjs/operator/takeLast',[\"require\", \"exports\", \"../operators/takeLast\"], function (require, exports, takeLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits only the last `count` values emitted by the source Observable.\n     *\n     * <span class=\"informal\">Remembers the latest `count` values, then emits those\n     * only when the source completes.</span>\n     *\n     * <img src=\"./img/takeLast.png\" width=\"100%\">\n     *\n     * `takeLast` returns an Observable that emits at most the last `count` values\n     * emitted by the source Observable. If the source emits fewer than `count`\n     * values then all of its values are emitted. This operator must wait until the\n     * `complete` notification emission from the source in order to emit the `next`\n     * values on the output Observable, because otherwise it is impossible to know\n     * whether or not more values will be emitted on the source. For this reason,\n     * all values are emitted synchronously, followed by the complete notification.\n     *\n     * @example <caption>Take the last 3 values of an Observable with many values</caption>\n     * var many = Rx.Observable.range(1, 100);\n     * var lastThree = many.takeLast(3);\n     * lastThree.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeUntil}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an\n     * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.\n     *\n     * @param {number} count The maximum number of values to emit from the end of\n     * the sequence of values emitted by the source Observable.\n     * @return {Observable<T>} An Observable that emits at most the last count\n     * values emitted by the source Observable.\n     * @method takeLast\n     * @owner Observable\n     */\n    function takeLast(count) {\n        return takeLast_1.takeLast(count)(this);\n    }\n    exports.takeLast = takeLast;\n});\n\ndefine('rxjs/add/operator/takeLast',[\"require\", \"exports\", \"../../Observable\", \"../../operator/takeLast\"], function (require, exports, Observable_1, takeLast_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.takeLast = takeLast_1.takeLast;\n});\n\ndefine('rxjs/operator/takeUntil',[\"require\", \"exports\", \"../operators/takeUntil\"], function (require, exports, takeUntil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits the values emitted by the source Observable until a `notifier`\n     * Observable emits a value.\n     *\n     * <span class=\"informal\">Lets values pass until a second Observable,\n     * `notifier`, emits something. Then, it completes.</span>\n     *\n     * <img src=\"./img/takeUntil.png\" width=\"100%\">\n     *\n     * `takeUntil` subscribes and begins mirroring the source Observable. It also\n     * monitors a second Observable, `notifier` that you provide. If the `notifier`\n     * emits a value, the output Observable stops mirroring the source Observable\n     * and completes.\n     *\n     * @example <caption>Tick every second until the first click happens</caption>\n     * var interval = Rx.Observable.interval(1000);\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = interval.takeUntil(clicks);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeLast}\n     * @see {@link takeWhile}\n     * @see {@link skip}\n     *\n     * @param {Observable} notifier The Observable whose first emitted value will\n     * cause the output Observable of `takeUntil` to stop emitting values from the\n     * source Observable.\n     * @return {Observable<T>} An Observable that emits the values from the source\n     * Observable until such time as `notifier` emits its first value.\n     * @method takeUntil\n     * @owner Observable\n     */\n    function takeUntil(notifier) {\n        return takeUntil_1.takeUntil(notifier)(this);\n    }\n    exports.takeUntil = takeUntil;\n});\n\ndefine('rxjs/add/operator/takeUntil',[\"require\", \"exports\", \"../../Observable\", \"../../operator/takeUntil\"], function (require, exports, Observable_1, takeUntil_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;\n});\n\ndefine('rxjs/operator/takeWhile',[\"require\", \"exports\", \"../operators/takeWhile\"], function (require, exports, takeWhile_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits values emitted by the source Observable so long as each value satisfies\n     * the given `predicate`, and then completes as soon as this `predicate` is not\n     * satisfied.\n     *\n     * <span class=\"informal\">Takes values from the source only while they pass the\n     * condition given. When the first value does not satisfy, it completes.</span>\n     *\n     * <img src=\"./img/takeWhile.png\" width=\"100%\">\n     *\n     * `takeWhile` subscribes and begins mirroring the source Observable. Each value\n     * emitted on the source is given to the `predicate` function which returns a\n     * boolean, representing a condition to be satisfied by the source values. The\n     * output Observable emits the source values until such time as the `predicate`\n     * returns false, at which point `takeWhile` stops mirroring the source\n     * Observable and completes the output Observable.\n     *\n     * @example <caption>Emit click events only while the clientX property is greater than 200</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.takeWhile(ev => ev.clientX > 200);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link take}\n     * @see {@link takeLast}\n     * @see {@link takeUntil}\n     * @see {@link skip}\n     *\n     * @param {function(value: T, index: number): boolean} predicate A function that\n     * evaluates a value emitted by the source Observable and returns a boolean.\n     * Also takes the (zero-based) index as the second argument.\n     * @return {Observable<T>} An Observable that emits the values from the source\n     * Observable so long as each value satisfies the condition defined by the\n     * `predicate`, then completes.\n     * @method takeWhile\n     * @owner Observable\n     */\n    function takeWhile(predicate) {\n        return takeWhile_1.takeWhile(predicate)(this);\n    }\n    exports.takeWhile = takeWhile;\n});\n\ndefine('rxjs/add/operator/takeWhile',[\"require\", \"exports\", \"../../Observable\", \"../../operator/takeWhile\"], function (require, exports, Observable_1, takeWhile_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;\n});\n\ndefine('rxjs/operator/throttle',[\"require\", \"exports\", \"../operators/throttle\"], function (require, exports, throttle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable, then ignores subsequent source\n     * values for a duration determined by another Observable, then repeats this\n     * process.\n     *\n     * <span class=\"informal\">It's like {@link throttleTime}, but the silencing\n     * duration is determined by a second Observable.</span>\n     *\n     * <img src=\"./img/throttle.png\" width=\"100%\">\n     *\n     * `throttle` emits the source Observable values on the output Observable\n     * when its internal timer is disabled, and ignores source values when the timer\n     * is enabled. Initially, the timer is disabled. As soon as the first source\n     * value arrives, it is forwarded to the output Observable, and then the timer\n     * is enabled by calling the `durationSelector` function with the source value,\n     * which returns the \"duration\" Observable. When the duration Observable emits a\n     * value or completes, the timer is disabled, and this process repeats for the\n     * next source value.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.throttle(ev => Rx.Observable.interval(1000));\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link audit}\n     * @see {@link debounce}\n     * @see {@link delayWhen}\n     * @see {@link sample}\n     * @see {@link throttleTime}\n     *\n     * @param {function(value: T): SubscribableOrPromise} durationSelector A function\n     * that receives a value from the source Observable, for computing the silencing\n     * duration for each source value, returned as an Observable or a Promise.\n     * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults\n     * to `{ leading: true, trailing: false }`.\n     * @return {Observable<T>} An Observable that performs the throttle operation to\n     * limit the rate of emissions from the source.\n     * @method throttle\n     * @owner Observable\n     */\n    function throttle(durationSelector, config) {\n        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n        return throttle_1.throttle(durationSelector, config)(this);\n    }\n    exports.throttle = throttle;\n});\n\ndefine('rxjs/add/operator/throttle',[\"require\", \"exports\", \"../../Observable\", \"../../operator/throttle\"], function (require, exports, Observable_1, throttle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.throttle = throttle_1.throttle;\n});\n\ndefine('rxjs/operator/throttleTime',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/throttle\", \"../operators/throttleTime\"], function (require, exports, async_1, throttle_1, throttleTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Emits a value from the source Observable, then ignores subsequent source\n     * values for `duration` milliseconds, then repeats this process.\n     *\n     * <span class=\"informal\">Lets a value pass, then ignores source values for the\n     * next `duration` milliseconds.</span>\n     *\n     * <img src=\"./img/throttleTime.png\" width=\"100%\">\n     *\n     * `throttleTime` emits the source Observable values on the output Observable\n     * when its internal timer is disabled, and ignores source values when the timer\n     * is enabled. Initially, the timer is disabled. As soon as the first source\n     * value arrives, it is forwarded to the output Observable, and then the timer\n     * is enabled. After `duration` milliseconds (or the time unit determined\n     * internally by the optional `scheduler`) has passed, the timer is disabled,\n     * and this process repeats for the next source value. Optionally takes a\n     * {@link IScheduler} for managing timers.\n     *\n     * @example <caption>Emit clicks at a rate of at most one click per second</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.throttleTime(1000);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link auditTime}\n     * @see {@link debounceTime}\n     * @see {@link delay}\n     * @see {@link sampleTime}\n     * @see {@link throttle}\n     *\n     * @param {number} duration Time to wait before emitting another value after\n     * emitting the last value, measured in milliseconds or the time unit determined\n     * internally by the optional `scheduler`.\n     * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for\n     * managing the timers that handle the throttling.\n     * @return {Observable<T>} An Observable that performs the throttle operation to\n     * limit the rate of emissions from the source.\n     * @method throttleTime\n     * @owner Observable\n     */\n    function throttleTime(duration, scheduler, config) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        if (config === void 0) { config = throttle_1.defaultThrottleConfig; }\n        return throttleTime_1.throttleTime(duration, scheduler, config)(this);\n    }\n    exports.throttleTime = throttleTime;\n});\n\ndefine('rxjs/add/operator/throttleTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/throttleTime\"], function (require, exports, Observable_1, throttleTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;\n});\n\ndefine('rxjs/add/operator/timeInterval',[\"require\", \"exports\", \"../../Observable\", \"../../operator/timeInterval\"], function (require, exports, Observable_1, timeInterval_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;\n});\n\ndefine('rxjs/operator/timeout',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/timeout\"], function (require, exports, async_1, timeout_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     *\n     * Errors if Observable does not emit a value in given time span.\n     *\n     * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n     *\n     * <img src=\"./img/timeout.png\" width=\"100%\">\n     *\n     * `timeout` operator accepts as an argument either a number or a Date.\n     *\n     * If number was provided, it returns an Observable that behaves like a source\n     * Observable, unless there is a period of time where there is no value emitted.\n     * So if you provide `100` as argument and first value comes after 50ms from\n     * the moment of subscription, this value will be simply re-emitted by the resulting\n     * Observable. If however after that 100ms passes without a second value being emitted,\n     * stream will end with an error and source Observable will be unsubscribed.\n     * These checks are performed throughout whole lifecycle of Observable - from the moment\n     * it was subscribed to, until it completes or errors itself. Thus every value must be\n     * emitted within specified period since previous value.\n     *\n     * If provided argument was Date, returned Observable behaves differently. It throws\n     * if Observable did not complete before provided Date. This means that periods between\n     * emission of particular values do not matter in this case. If Observable did not complete\n     * before provided Date, source Observable will be unsubscribed. Other than that, resulting\n     * stream behaves just as source Observable.\n     *\n     * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)\n     * when returned Observable will check if source stream emitted value or completed.\n     *\n     * @example <caption>Check if ticks are emitted within certain timespan</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds.timeout(1100) // Let's use bigger timespan to be safe,\n     *                       // since `interval` might fire a bit later then scheduled.\n     * .subscribe(\n     *     value => console.log(value), // Will emit numbers just as regular `interval` would.\n     *     err => console.log(err) // Will never be called.\n     * );\n     *\n     * seconds.timeout(900).subscribe(\n     *     value => console.log(value), // Will never be called.\n     *     err => console.log(err) // Will emit error before even first value is emitted,\n     *                             // since it did not arrive within 900ms period.\n     * );\n     *\n     * @example <caption>Use Date to check if Observable completed</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     *\n     * seconds.timeout(new Date(\"December 17, 2020 03:24:00\"))\n     * .subscribe(\n     *     value => console.log(value), // Will emit values as regular `interval` would\n     *                                  // until December 17, 2020 at 03:24:00.\n     *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,\n     *                             // since Observable did not complete by then.\n     * );\n     *\n     * @see {@link timeoutWith}\n     *\n     * @param {number|Date} due Number specifying period within which Observable must emit values\n     *                          or Date specifying before when Observable should complete\n     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n     * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.\n     * @method timeout\n     * @owner Observable\n     */\n    function timeout(due, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return timeout_1.timeout(due, scheduler)(this);\n    }\n    exports.timeout = timeout;\n});\n\ndefine('rxjs/add/operator/timeout',[\"require\", \"exports\", \"../../Observable\", \"../../operator/timeout\"], function (require, exports, Observable_1, timeout_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.timeout = timeout_1.timeout;\n});\n\ndefine('rxjs/operator/timeoutWith',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/timeoutWith\"], function (require, exports, async_1, timeoutWith_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     *\n     * Errors if Observable does not emit a value in given time span, in case of which\n     * subscribes to the second Observable.\n     *\n     * <span class=\"informal\">It's a version of `timeout` operator that let's you specify fallback Observable.</span>\n     *\n     * <img src=\"./img/timeoutWith.png\" width=\"100%\">\n     *\n     * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,\n     * still accepting as a first argument either a number or a Date, which control - respectively -\n     * when values of source Observable should be emitted or when it should complete.\n     *\n     * The only difference is that it accepts a second, required parameter. This parameter\n     * should be an Observable which will be subscribed when source Observable fails any timeout check.\n     * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting\n     * values from second Observable. Note that this fallback Observable is not checked for timeouts\n     * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second\n     * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that\n     * stream completes, it completes as well.\n     *\n     * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided\n     * here - as a third, optional parameter. It still is used to schedule timeout checks and -\n     * as a consequence - when second Observable will be subscribed, since subscription happens\n     * immediately after failing check.\n     *\n     * @example <caption>Add fallback observable</caption>\n     * const seconds = Rx.Observable.interval(1000);\n     * const minutes = Rx.Observable.interval(60 * 1000);\n     *\n     * seconds.timeoutWith(900, minutes)\n     *     .subscribe(\n     *         value => console.log(value), // After 900ms, will start emitting `minutes`,\n     *                                      // since first value of `seconds` will not arrive fast enough.\n     *         err => console.log(err) // Would be called after 900ms in case of `timeout`,\n     *                                 // but here will never be called.\n     *     );\n     *\n     * @param {number|Date} due Number specifying period within which Observable must emit values\n     *                          or Date specifying before when Observable should complete\n     * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.\n     * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.\n     * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable\n     *                          passed as a second parameter.\n     * @method timeoutWith\n     * @owner Observable\n     */\n    function timeoutWith(due, withObservable, scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return timeoutWith_1.timeoutWith(due, withObservable, scheduler)(this);\n    }\n    exports.timeoutWith = timeoutWith;\n});\n\ndefine('rxjs/add/operator/timeoutWith',[\"require\", \"exports\", \"../../Observable\", \"../../operator/timeoutWith\"], function (require, exports, Observable_1, timeoutWith_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;\n});\n\ndefine('rxjs/operator/timestamp',[\"require\", \"exports\", \"../scheduler/async\", \"../operators/timestamp\"], function (require, exports, async_1, timestamp_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param scheduler\n     * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}\n     * @method timestamp\n     * @owner Observable\n     */\n    function timestamp(scheduler) {\n        if (scheduler === void 0) { scheduler = async_1.async; }\n        return timestamp_1.timestamp(scheduler)(this);\n    }\n    exports.timestamp = timestamp;\n});\n\ndefine('rxjs/add/operator/timestamp',[\"require\", \"exports\", \"../../Observable\", \"../../operator/timestamp\"], function (require, exports, Observable_1, timestamp_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.timestamp = timestamp_1.timestamp;\n});\n\ndefine('rxjs/operator/toArray',[\"require\", \"exports\", \"../operators/toArray\"], function (require, exports, toArray_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Collects all source emissions and emits them as an array when the source completes.\n     *\n     * <span class=\"informal\">Get all values inside an array when the source completes</span>\n     *\n     * <img src=\"./img/toArray.png\" width=\"100%\">\n     *\n     * `toArray` will wait until the source Observable completes\n     * before emitting the array containing all emissions.\n     * When the source Observable errors no array will be emitted.\n     *\n     * @example <caption>Create array from input</caption>\n     * const input = Rx.Observable.interval(100).take(4);\n     *\n     * input.toArray()\n     *   .subscribe(arr => console.log(arr)); // [0,1,2,3]\n     *\n     * @see {@link buffer}\n     *\n     * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}\n     * @method toArray\n     * @owner Observable\n     */\n    function toArray() {\n        return toArray_1.toArray()(this);\n    }\n    exports.toArray = toArray;\n});\n\ndefine('rxjs/add/operator/toArray',[\"require\", \"exports\", \"../../Observable\", \"../../operator/toArray\"], function (require, exports, Observable_1, toArray_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.toArray = toArray_1.toArray;\n});\n\n// HACK: does nothing, because `toPromise` now lives on the `Observable` itself.\n// leaving this module here to prevent breakage.\n;\ndefine(\"rxjs/add/operator/toPromise\", function(){});\n\ndefine('rxjs/operator/window',[\"require\", \"exports\", \"../operators/window\"], function (require, exports, window_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable whenever\n     * `windowBoundaries` emits.\n     *\n     * <span class=\"informal\">It's like {@link buffer}, but emits a nested Observable\n     * instead of an array.</span>\n     *\n     * <img src=\"./img/window.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits connected, non-overlapping\n     * windows. It emits the current window and opens a new one whenever the\n     * Observable `windowBoundaries` emits an item. Because each window is an\n     * Observable, the output is a higher-order Observable.\n     *\n     * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var interval = Rx.Observable.interval(1000);\n     * var result = clicks.window(interval)\n     *   .map(win => win.take(2)) // each window has at most 2 emissions\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link windowWhen}\n     * @see {@link buffer}\n     *\n     * @param {Observable<any>} windowBoundaries An Observable that completes the\n     * previous window and starts a new window.\n     * @return {Observable<Observable<T>>} An Observable of windows, which are\n     * Observables emitting values of the source Observable.\n     * @method window\n     * @owner Observable\n     */\n    function window(windowBoundaries) {\n        return window_1.window(windowBoundaries)(this);\n    }\n    exports.window = window;\n});\n\ndefine('rxjs/add/operator/window',[\"require\", \"exports\", \"../../Observable\", \"../../operator/window\"], function (require, exports, Observable_1, window_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.window = window_1.window;\n});\n\ndefine('rxjs/operator/windowCount',[\"require\", \"exports\", \"../operators/windowCount\"], function (require, exports, windowCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable with each\n     * nested Observable emitting at most `windowSize` values.\n     *\n     * <span class=\"informal\">It's like {@link bufferCount}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowCount.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits windows every `startWindowEvery`\n     * items, each containing no more than `windowSize` items. When the source\n     * Observable completes or encounters an error, the output Observable emits\n     * the current window and propagates the notification from the source\n     * Observable. If `startWindowEvery` is not provided, then new windows are\n     * started immediately at the start of the source and when each window completes\n     * with size `windowSize`.\n     *\n     * @example <caption>Ignore every 3rd click event, starting from the first one</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.windowCount(3)\n     *   .map(win => win.skip(1)) // skip first of every 3 clicks\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @example <caption>Ignore every 3rd click event, starting from the third one</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks.windowCount(2, 3)\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link windowWhen}\n     * @see {@link bufferCount}\n     *\n     * @param {number} windowSize The maximum number of values emitted by each\n     * window.\n     * @param {number} [startWindowEvery] Interval at which to start a new window.\n     * For example if `startWindowEvery` is `2`, then a new window will be started\n     * on every other value from the source. A new window is started at the\n     * beginning of the source by default.\n     * @return {Observable<Observable<T>>} An Observable of windows, which in turn\n     * are Observable of values.\n     * @method windowCount\n     * @owner Observable\n     */\n    function windowCount(windowSize, startWindowEvery) {\n        if (startWindowEvery === void 0) { startWindowEvery = 0; }\n        return windowCount_1.windowCount(windowSize, startWindowEvery)(this);\n    }\n    exports.windowCount = windowCount;\n});\n\ndefine('rxjs/add/operator/windowCount',[\"require\", \"exports\", \"../../Observable\", \"../../operator/windowCount\"], function (require, exports, Observable_1, windowCount_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.windowCount = windowCount_1.windowCount;\n});\n\ndefine('rxjs/operator/windowTime',[\"require\", \"exports\", \"../scheduler/async\", \"../util/isNumeric\", \"../util/isScheduler\", \"../operators/windowTime\"], function (require, exports, async_1, isNumeric_1, isScheduler_1, windowTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    function windowTime(windowTimeSpan) {\n        var scheduler = async_1.async;\n        var windowCreationInterval = null;\n        var maxWindowSize = Number.POSITIVE_INFINITY;\n        if (isScheduler_1.isScheduler(arguments[3])) {\n            scheduler = arguments[3];\n        }\n        if (isScheduler_1.isScheduler(arguments[2])) {\n            scheduler = arguments[2];\n        }\n        else if (isNumeric_1.isNumeric(arguments[2])) {\n            maxWindowSize = arguments[2];\n        }\n        if (isScheduler_1.isScheduler(arguments[1])) {\n            scheduler = arguments[1];\n        }\n        else if (isNumeric_1.isNumeric(arguments[1])) {\n            windowCreationInterval = arguments[1];\n        }\n        return windowTime_1.windowTime(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler)(this);\n    }\n    exports.windowTime = windowTime;\n});\n\ndefine('rxjs/add/operator/windowTime',[\"require\", \"exports\", \"../../Observable\", \"../../operator/windowTime\"], function (require, exports, Observable_1, windowTime_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.windowTime = windowTime_1.windowTime;\n});\n\ndefine('rxjs/operator/windowToggle',[\"require\", \"exports\", \"../operators/windowToggle\"], function (require, exports, windowToggle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable starting from\n     * an emission from `openings` and ending when the output of `closingSelector`\n     * emits.\n     *\n     * <span class=\"informal\">It's like {@link bufferToggle}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowToggle.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits windows that contain those items\n     * emitted by the source Observable between the time when the `openings`\n     * Observable emits an item and when the Observable returned by\n     * `closingSelector` emits an item.\n     *\n     * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var openings = Rx.Observable.interval(1000);\n     * var result = clicks.windowToggle(openings, i =>\n     *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n     * ).mergeAll();\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowWhen}\n     * @see {@link bufferToggle}\n     *\n     * @param {Observable<O>} openings An observable of notifications to start new\n     * windows.\n     * @param {function(value: O): Observable} closingSelector A function that takes\n     * the value emitted by the `openings` observable and returns an Observable,\n     * which, when it emits (either `next` or `complete`), signals that the\n     * associated window should complete.\n     * @return {Observable<Observable<T>>} An observable of windows, which in turn\n     * are Observables.\n     * @method windowToggle\n     * @owner Observable\n     */\n    function windowToggle(openings, closingSelector) {\n        return windowToggle_1.windowToggle(openings, closingSelector)(this);\n    }\n    exports.windowToggle = windowToggle;\n});\n\ndefine('rxjs/add/operator/windowToggle',[\"require\", \"exports\", \"../../Observable\", \"../../operator/windowToggle\"], function (require, exports, Observable_1, windowToggle_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;\n});\n\ndefine('rxjs/operator/windowWhen',[\"require\", \"exports\", \"../operators/windowWhen\"], function (require, exports, windowWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * Branch out the source Observable values as a nested Observable using a\n     * factory function of closing Observables to determine when to start a new\n     * window.\n     *\n     * <span class=\"informal\">It's like {@link bufferWhen}, but emits a nested\n     * Observable instead of an array.</span>\n     *\n     * <img src=\"./img/windowWhen.png\" width=\"100%\">\n     *\n     * Returns an Observable that emits windows of items it collects from the source\n     * Observable. The output Observable emits connected, non-overlapping windows.\n     * It emits the current window and opens a new one whenever the Observable\n     * produced by the specified `closingSelector` function emits an item. The first\n     * window is opened immediately when subscribing to the output Observable.\n     *\n     * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var result = clicks\n     *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))\n     *   .map(win => win.take(2)) // each window has at most 2 emissions\n     *   .mergeAll(); // flatten the Observable-of-Observables\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link window}\n     * @see {@link windowCount}\n     * @see {@link windowTime}\n     * @see {@link windowToggle}\n     * @see {@link bufferWhen}\n     *\n     * @param {function(): Observable} closingSelector A function that takes no\n     * arguments and returns an Observable that signals (on either `next` or\n     * `complete`) when to close the previous window and start a new one.\n     * @return {Observable<Observable<T>>} An observable of windows, which in turn\n     * are Observables.\n     * @method windowWhen\n     * @owner Observable\n     */\n    function windowWhen(closingSelector) {\n        return windowWhen_1.windowWhen(closingSelector)(this);\n    }\n    exports.windowWhen = windowWhen;\n});\n\ndefine('rxjs/add/operator/windowWhen',[\"require\", \"exports\", \"../../Observable\", \"../../operator/windowWhen\"], function (require, exports, Observable_1, windowWhen_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;\n});\n\ndefine('rxjs/operator/withLatestFrom',[\"require\", \"exports\", \"../operators/withLatestFrom\"], function (require, exports, withLatestFrom_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * Combines the source Observable with other Observables to create an Observable\n     * whose values are calculated from the latest values of each, only when the\n     * source emits.\n     *\n     * <span class=\"informal\">Whenever the source Observable emits a value, it\n     * computes a formula using that value plus the latest values from other input\n     * Observables, then emits the output of that formula.</span>\n     *\n     * <img src=\"./img/withLatestFrom.png\" width=\"100%\">\n     *\n     * `withLatestFrom` combines each value from the source Observable (the\n     * instance) with the latest values from the other input Observables only when\n     * the source emits a value, optionally using a `project` function to determine\n     * the value to be emitted on the output Observable. All input Observables must\n     * emit at least one value before the output Observable will emit a value.\n     *\n     * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>\n     * var clicks = Rx.Observable.fromEvent(document, 'click');\n     * var timer = Rx.Observable.interval(1000);\n     * var result = clicks.withLatestFrom(timer);\n     * result.subscribe(x => console.log(x));\n     *\n     * @see {@link combineLatest}\n     *\n     * @param {ObservableInput} other An input Observable to combine with the source\n     * Observable. More than one input Observables may be given as argument.\n     * @param {Function} [project] Projection function for combining values\n     * together. Receives all values in order of the Observables passed, where the\n     * first parameter is a value from the source Observable. (e.g.\n     * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not\n     * passed, arrays will be emitted on the output Observable.\n     * @return {Observable} An Observable of projected values from the most recent\n     * values from each input Observable, or an array of the most recent values from\n     * each input Observable.\n     * @method withLatestFrom\n     * @owner Observable\n     */\n    function withLatestFrom() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return withLatestFrom_1.withLatestFrom.apply(void 0, args)(this);\n    }\n    exports.withLatestFrom = withLatestFrom;\n});\n\ndefine('rxjs/add/operator/withLatestFrom',[\"require\", \"exports\", \"../../Observable\", \"../../operator/withLatestFrom\"], function (require, exports, Observable_1, withLatestFrom_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;\n});\n\ndefine('rxjs/operator/zip',[\"require\", \"exports\", \"../operators/zip\"], function (require, exports, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /* tslint:enable:max-line-length */\n    /**\n     * @param observables\n     * @return {Observable<R>}\n     * @method zip\n     * @owner Observable\n     */\n    function zipProto() {\n        var observables = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            observables[_i] = arguments[_i];\n        }\n        return zip_1.zip.apply(void 0, observables)(this);\n    }\n    exports.zipProto = zipProto;\n});\n\ndefine('rxjs/add/operator/zip',[\"require\", \"exports\", \"../../Observable\", \"../../operator/zip\"], function (require, exports, Observable_1, zip_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.zip = zip_1.zipProto;\n});\n\ndefine('rxjs/operator/zipAll',[\"require\", \"exports\", \"../operators/zipAll\"], function (require, exports, zipAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    /**\n     * @param project\n     * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}\n     * @method zipAll\n     * @owner Observable\n     */\n    function zipAll(project) {\n        return zipAll_1.zipAll(project)(this);\n    }\n    exports.zipAll = zipAll;\n});\n\ndefine('rxjs/add/operator/zipAll',[\"require\", \"exports\", \"../../Observable\", \"../../operator/zipAll\"], function (require, exports, Observable_1, zipAll_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    Observable_1.Observable.prototype.zipAll = zipAll_1.zipAll;\n});\n\ndefine('rxjs/Rx',[\"require\", \"exports\", \"./Subject\", \"./Observable\", \"./Subscription\", \"./Subscriber\", \"./AsyncSubject\", \"./ReplaySubject\", \"./BehaviorSubject\", \"./observable/ConnectableObservable\", \"./Notification\", \"./util/EmptyError\", \"./util/ArgumentOutOfRangeError\", \"./util/ObjectUnsubscribedError\", \"./util/TimeoutError\", \"./util/UnsubscriptionError\", \"./operator/timeInterval\", \"./operators/timestamp\", \"./testing/TestScheduler\", \"./scheduler/VirtualTimeScheduler\", \"./observable/dom/AjaxObservable\", \"./util/pipe\", \"./scheduler/asap\", \"./scheduler/async\", \"./scheduler/queue\", \"./scheduler/animationFrame\", \"./symbol/rxSubscriber\", \"./symbol/iterator\", \"./symbol/observable\", \"./operators\", \"./add/observable/bindCallback\", \"./add/observable/bindNodeCallback\", \"./add/observable/combineLatest\", \"./add/observable/concat\", \"./add/observable/defer\", \"./add/observable/empty\", \"./add/observable/forkJoin\", \"./add/observable/from\", \"./add/observable/fromEvent\", \"./add/observable/fromEventPattern\", \"./add/observable/fromPromise\", \"./add/observable/generate\", \"./add/observable/if\", \"./add/observable/interval\", \"./add/observable/merge\", \"./add/observable/race\", \"./add/observable/never\", \"./add/observable/of\", \"./add/observable/onErrorResumeNext\", \"./add/observable/pairs\", \"./add/observable/range\", \"./add/observable/using\", \"./add/observable/throw\", \"./add/observable/timer\", \"./add/observable/zip\", \"./add/observable/dom/ajax\", \"./add/observable/dom/webSocket\", \"./add/operator/buffer\", \"./add/operator/bufferCount\", \"./add/operator/bufferTime\", \"./add/operator/bufferToggle\", \"./add/operator/bufferWhen\", \"./add/operator/catch\", \"./add/operator/combineAll\", \"./add/operator/combineLatest\", \"./add/operator/concat\", \"./add/operator/concatAll\", \"./add/operator/concatMap\", \"./add/operator/concatMapTo\", \"./add/operator/count\", \"./add/operator/dematerialize\", \"./add/operator/debounce\", \"./add/operator/debounceTime\", \"./add/operator/defaultIfEmpty\", \"./add/operator/delay\", \"./add/operator/delayWhen\", \"./add/operator/distinct\", \"./add/operator/distinctUntilChanged\", \"./add/operator/distinctUntilKeyChanged\", \"./add/operator/do\", \"./add/operator/exhaust\", \"./add/operator/exhaustMap\", \"./add/operator/expand\", \"./add/operator/elementAt\", \"./add/operator/filter\", \"./add/operator/finally\", \"./add/operator/find\", \"./add/operator/findIndex\", \"./add/operator/first\", \"./add/operator/groupBy\", \"./add/operator/ignoreElements\", \"./add/operator/isEmpty\", \"./add/operator/audit\", \"./add/operator/auditTime\", \"./add/operator/last\", \"./add/operator/let\", \"./add/operator/every\", \"./add/operator/map\", \"./add/operator/mapTo\", \"./add/operator/materialize\", \"./add/operator/max\", \"./add/operator/merge\", \"./add/operator/mergeAll\", \"./add/operator/mergeMap\", \"./add/operator/mergeMapTo\", \"./add/operator/mergeScan\", \"./add/operator/min\", \"./add/operator/multicast\", \"./add/operator/observeOn\", \"./add/operator/onErrorResumeNext\", \"./add/operator/pairwise\", \"./add/operator/partition\", \"./add/operator/pluck\", \"./add/operator/publish\", \"./add/operator/publishBehavior\", \"./add/operator/publishReplay\", \"./add/operator/publishLast\", \"./add/operator/race\", \"./add/operator/reduce\", \"./add/operator/repeat\", \"./add/operator/repeatWhen\", \"./add/operator/retry\", \"./add/operator/retryWhen\", \"./add/operator/sample\", \"./add/operator/sampleTime\", \"./add/operator/scan\", \"./add/operator/sequenceEqual\", \"./add/operator/share\", \"./add/operator/shareReplay\", \"./add/operator/single\", \"./add/operator/skip\", \"./add/operator/skipLast\", \"./add/operator/skipUntil\", \"./add/operator/skipWhile\", \"./add/operator/startWith\", \"./add/operator/subscribeOn\", \"./add/operator/switch\", \"./add/operator/switchMap\", \"./add/operator/switchMapTo\", \"./add/operator/take\", \"./add/operator/takeLast\", \"./add/operator/takeUntil\", \"./add/operator/takeWhile\", \"./add/operator/throttle\", \"./add/operator/throttleTime\", \"./add/operator/timeInterval\", \"./add/operator/timeout\", \"./add/operator/timeoutWith\", \"./add/operator/timestamp\", \"./add/operator/toArray\", \"./add/operator/toPromise\", \"./add/operator/window\", \"./add/operator/windowCount\", \"./add/operator/windowTime\", \"./add/operator/windowToggle\", \"./add/operator/windowWhen\", \"./add/operator/withLatestFrom\", \"./add/operator/zip\", \"./add/operator/zipAll\"], function (require, exports, Subject_1, Observable_1, Subscription_1, Subscriber_1, AsyncSubject_1, ReplaySubject_1, BehaviorSubject_1, ConnectableObservable_1, Notification_1, EmptyError_1, ArgumentOutOfRangeError_1, ObjectUnsubscribedError_1, TimeoutError_1, UnsubscriptionError_1, timeInterval_1, timestamp_1, TestScheduler_1, VirtualTimeScheduler_1, AjaxObservable_1, pipe_1, asap_1, async_1, queue_1, animationFrame_1, rxSubscriber_1, iterator_1, observable_1, _operators) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Subject = Subject_1.Subject;\n    exports.AnonymousSubject = Subject_1.AnonymousSubject;\n    exports.Observable = Observable_1.Observable;\n    exports.Subscription = Subscription_1.Subscription;\n    exports.Subscriber = Subscriber_1.Subscriber;\n    exports.AsyncSubject = AsyncSubject_1.AsyncSubject;\n    exports.ReplaySubject = ReplaySubject_1.ReplaySubject;\n    exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;\n    exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;\n    exports.Notification = Notification_1.Notification;\n    exports.EmptyError = EmptyError_1.EmptyError;\n    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;\n    exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;\n    exports.TimeoutError = TimeoutError_1.TimeoutError;\n    exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;\n    exports.TimeInterval = timeInterval_1.TimeInterval;\n    exports.Timestamp = timestamp_1.Timestamp;\n    exports.TestScheduler = TestScheduler_1.TestScheduler;\n    exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;\n    exports.AjaxResponse = AjaxObservable_1.AjaxResponse;\n    exports.AjaxError = AjaxObservable_1.AjaxError;\n    exports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;\n    exports.pipe = pipe_1.pipe;\n    exports.operators = _operators;\n    /* tslint:enable:no-unused-variable */\n    /**\n     * @typedef {Object} Rx.Scheduler\n     * @property {Scheduler} queue Schedules on a queue in the current event frame\n     * (trampoline scheduler). Use this for iteration operations.\n     * @property {Scheduler} asap Schedules on the micro task queue, which uses the\n     * fastest transport mechanism available, either Node.js' `process.nextTick()`\n     * or Web Worker MessageChannel or setTimeout or others. Use this for\n     * asynchronous conversions.\n     * @property {Scheduler} async Schedules work with `setInterval`. Use this for\n     * time-based operations.\n     * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.\n     * Use this for synchronizing with the platform's painting\n     */\n    var Scheduler = {\n        asap: asap_1.asap,\n        queue: queue_1.queue,\n        animationFrame: animationFrame_1.animationFrame,\n        async: async_1.async\n    };\n    exports.Scheduler = Scheduler;\n    /**\n     * @typedef {Object} Rx.Symbol\n     * @property {Symbol|string} rxSubscriber A symbol to use as a property name to\n     * retrieve an \"Rx safe\" Observer from an object. \"Rx safety\" can be defined as\n     * an object that has all of the traits of an Rx Subscriber, including the\n     * ability to add and remove subscriptions to the subscription chain and\n     * guarantees involving event triggering (can't \"next\" after unsubscription,\n     * etc).\n     * @property {Symbol|string} observable A symbol to use as a property name to\n     * retrieve an Observable as defined by the [ECMAScript \"Observable\" spec](https://github.com/zenparsing/es-observable).\n     * @property {Symbol|string} iterator The ES6 symbol to use as a property name\n     * to retrieve an iterator from an object.\n     */\n    var Symbol = {\n        rxSubscriber: rxSubscriber_1.rxSubscriber,\n        observable: observable_1.observable,\n        iterator: iterator_1.iterator\n    };\n    exports.Symbol = Symbol;\n});\n\n"]}